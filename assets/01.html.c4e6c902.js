import{e as s}from"./app.0374563d.js";import{_ as n}from"./plugin-vue_export-helper.21dcd24c.js";const a={},e=s(`<h1 id="rust-quiz-1" tabindex="-1"><a class="header-anchor" href="#rust-quiz-1" aria-hidden="true">#</a> Rust Quiz#1</h1><h2 id="\u9898\u76EE" tabindex="-1"><a class="header-anchor" href="#\u9898\u76EE" aria-hidden="true">#</a> \u9898\u76EE</h2><p>\u4E0B\u9762\u7684 1 \u8F93\u51FA\u662F\u4EC0\u4E48\uFF1F</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token macro property">macro_rules!</span> m <span class="token punctuation">{</span>
    <span class="token punctuation">(</span>$<span class="token punctuation">(</span> <span class="token variable">$s</span><span class="token punctuation">:</span><span class="token fragment-specifier punctuation">stmt</span> <span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        $<span class="token punctuation">(</span>
            <span class="token punctuation">{</span> <span class="token macro property">stringify!</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token punctuation">}</span>
        <span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token operator">*</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token macro property">print!</span><span class="token punctuation">(</span>
        <span class="token string">&quot;{}{}{}&quot;</span><span class="token punctuation">,</span>
        <span class="token macro property">m!</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">||</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token macro property">m!</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span><span class="token keyword">return</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token macro property">m!</span> <span class="token punctuation">{</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span> <span class="token operator">||</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><ol><li>The program exhibits undefined behavior</li><li>The program does not compile</li><li>The program is guaranteed to output: [ ]</li></ol><h2 id="\u89E3\u7B54" tabindex="-1"><a class="header-anchor" href="#\u89E3\u7B54" aria-hidden="true">#</a> \u89E3\u7B54</h2><p>122</p><p>\u8FD9\u4E2A\u95EE\u9898\u56F4\u7ED5\u7740 Rust \u7684\u8BED\u6CD5\u8FB9\u754C\u8BBE\u8BA1\u3002</p><blockquote><p>This question revolves around where the Rust grammar places statement boundaries.</p></blockquote><p>\u5B8F\u7684\u8F93\u5165\u89C4\u5219\u662F <code>$( $s:stmt )*</code>, \u5B83\u80FD\u591F\u5339\u914D\u5230 0 \u6216\u591A\u4E2A Rust \u8BED\u53E5\u3002\u8BE5\u89C4\u5219\u5185\u90E8\u7684 <code>$s: stmt</code> \u662F\u4E00\u4E2A\u7247\u6BB5\u5206\u7C7B\u7B26\uFF0C\u5B83\u80FD\u591F\u5339\u914D\u5230\u4E00\u4E2A\u7B26\u5408 Rust \u8BED\u6CD5\u89C4\u8303\u7684\u8868\u8FBE\u5F0F\u3002\u88AB\u5339\u914D\u5230\u7684\u8BED\u53E5\u53EF\u4EE5\u5728\u5C55\u5F00\u540E\u7684\u4EE3\u7801\u4E2D\u4F5C\u4E3A <code>$s</code> \u3002\u800C\u5916\u90E8\u7684 <code>$(...)*</code> \u90E8\u5206\u8868\u793A\u4E00\u4E2A\u91CD\u590D\uFF0C\u5B83\u53EF\u4EE5\u91CD\u590D\u5339\u914D 0 \u6216\u591A\u6B21\u5185\u5BB9\u3002</p><blockquote><p>The input rule of the macro m! is $($s:stmt)* which matches zero or more Rust statements. The $(...)* part of the rule is a repetition which matches the contents of the repetition zero or more times, and the $s:stmt is a fragment specifier that matches a Rust statement (stmt) conforming to the rules of the Rust grammar. The matched statements are available within the expanded code as the fragment variable $s.</p></blockquote><p>\u8BED\u53E5\u662F\u51FD\u6570\u4F53\u4E2D\u5141\u8BB8\u7684\u6700\u9AD8\u7EA7\u522B\u7684\u8BED\u6CD5\u5355\u4F4D\u3002\u4E0B\u9762\u6240\u6709\u7684\u5185\u5BB9\u90FD\u662F\u8BED\u53E5\u7684\u4F8B\u5B50\u3002</p><blockquote><p>A statement is the top-level unit of syntax permitted within a function body. All of the following are examples of statements.</p></blockquote><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// Items are statements.</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">S</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token keyword">u64</span> <span class="token punctuation">}</span>

<span class="token comment">// Let-bindings are statements.</span>
<span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">S</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>

<span class="token comment">// Expressions are statements.</span>
s<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">1</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>\u51FD\u6570\u4F53\u7684\u8BED\u6CD5\u8981\u6C42\u67D0\u4E9B\u7C7B\u578B\u7684\u8BED\u53E5\u540E\u9762\u6709\u4E00\u4E2A\u5206\u53F7\uFF0C\u4F46\u5BF9\u4E8E\u5B8F\u7684\u8BED\u6CD5\u800C\u8A00\uFF0C\u5206\u53F7\u5E76\u4E0D\u662F\u8BED\u53E5\u7684\u4E00\u90E8\u5206\u3002</p><blockquote><p>The grammar of function bodies requires that some types of statements are followed by a semicolon, but the semicolon is not part of the statement for the purpose of macro syntax.</p></blockquote><p>m! \u5C06\u4F1A\u5C55\u5F00\u4E3A 0 \u6216\u591A\u4E2A\u7531 <code>&lt;&lt;</code> \u5206\u5272\u7684 <code>{ stringify!($s); 1 }</code>\u3002<code>$(...)&lt;&lt;*</code> \u90E8\u5206\u8868\u793A\u91CD\u590D\u8BED\u53E5\u4E4B\u95F4\u4F7F\u7528 <code>&lt;&lt;</code> \u4F5C\u4E3A\u5206\u9694\u7B26</p><blockquote><p>The macro m! expands to zero or more copies of <code>{ stringify!($s); 1 }</code> separated by the <code>&lt;&lt;</code> token. The <code>$(...)&lt;&lt;*</code> part of the rule is a repetition using <code>&lt;&lt;</code> as the separator.</p></blockquote><p>\u5728\u5B8F\u4E2D\u4F7F\u7528 <code>&lt;&lt;</code> \u4F5C\u4E3A\u5206\u9694\u7B26\u975E\u5E38\u4E0D\u5E38\u89C1\u3002\u6700\u5E38\u7528\u7684\u5206\u9694\u7B26\u662F\u9017\u53F7\uFF0C<code>$(...),*</code>\uFF0C\u5176\u4ED6\u7684\u5355\u4E00\u7B26\u53F7\u4E5F\u662F\u5141\u8BB8\u7684\u3002\u91CD\u8981\u7684\u662F\uFF0C<code>macro_rules!</code> \u628A\u6240\u6709\u7684 Rust \u5185\u7F6E\u64CD\u4F5C\u7B26\u90FD\u5F53\u6210\u5355 token</p><blockquote><p>Using <code>&lt;&lt;</code> as a separator in a repetition in a macro is highly unusual. The most commmonly used separator is the comma, written as <code>$(...),*</code>, but any other single token is allowed here. Crucially, macro_rules! treats all built-in Rust operators as single tokens, even those that consist of multiple characters like &lt;&lt;.</p></blockquote><p>The <code>{ stringify!($s); 1 }</code> is an expression whose value is always 1. The value of <code>stringify!($s)</code> is discarded, so this is equivalent to the expression <code>{ 1 }</code>. The reason for having <code>stringify!($s)</code> in there is to control the number of times the repetition is repeated, which is determined by which fragment variables are used within the repetition. Writing a repetition without using any fragment variables inside of it would not be legal.</p><p>Suppose we call this macro with three of the statements shown above as input.</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token macro property">m!</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token type-definition class-name">S</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token keyword">u64</span> <span class="token punctuation">}</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">S</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
    s<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>The macro expands to:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token punctuation">{</span> <span class="token macro property">stringify!</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token type-definition class-name">S</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token keyword">u64</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token punctuation">}</span>
    <span class="token operator">&lt;&lt;</span> <span class="token punctuation">{</span> <span class="token macro property">stringify!</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">S</span> <span class="token punctuation">{</span> x<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token punctuation">}</span>
    <span class="token operator">&lt;&lt;</span> <span class="token punctuation">{</span> <span class="token macro property">stringify!</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Each of the stringifys expands to a string literal: 2</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token punctuation">{</span> <span class="token string">&quot;struct S { x: u64 }&quot;</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token punctuation">}</span>
    <span class="token operator">&lt;&lt;</span> <span class="token punctuation">{</span> <span class="token string">&quot;let mut s = S { x: 1 }&quot;</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token punctuation">}</span>
    <span class="token operator">&lt;&lt;</span> <span class="token punctuation">{</span> <span class="token string">&quot;s.x + 1&quot;</span><span class="token punctuation">;</span> <span class="token number">1</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>The values of the string literals are not used. In this case the expression is equivalent to <code>{ 1 } &lt;&lt; { 1 } &lt;&lt; { 1 }</code>, which is equivalent to <code>1 &lt;&lt; 1 &lt;&lt; 1</code>. The <code>&lt;&lt;</code> operator is left-associative; the numeric value of this expression is 4.</p><p>Altogether, the relevant behavior of this macro is that it evaluates to <code>1 &lt;&lt; 1 &lt;&lt; 1 &lt;&lt; ...</code> where the number of ones is equal to the number of Rust statements in the input of the macro. In closed form, the numeric value is <code>1 &lt;&lt; (n - 1)</code> where n is the number of statements, except in the case that n is zero where the macro expands to nothing and we get a syntax error at the call site.</p><p>It remains to determine how many statements are in the three invocations of m! in the quiz code.</p><ol><li><code>return || true</code></li></ol><p>This is a return-expression that would return the closure <code>|| true</code>. It is equivalent to return <code>(|| true)</code>. It is parsed as a single statement so the m! invocation evaluates to</p><ol start="2"><li><code>(return) || true</code></li></ol><p>This is a logical-OR expression. The <code>||</code> is a binary operator, where the left-hand side is the expression <code>(return)</code> (of diverging type <code>!</code>) and the right-hand side is the expression <code>true</code>. This expression is a single statement so m! again evaluates to 1.</p><ol start="3"><li><code>{return} || true</code></li></ol><p>This one is two statements! A block-statement <code>{return}</code> followed by a closure expression <code>|| true</code>.</p><p>The Rust grammar distinguishes between expressions that require a semicolon in order to stand alone as a statement, and expressions that can be statements even without a semicolon. Consider two examples:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token comment">// No trailing semicolon required.</span>
<span class="token keyword">for</span> t <span class="token keyword">in</span> vec <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span>

<span class="token comment">// Trailing semicolon required.</span>
<span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">skip_whitespace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>The list of expression types that stand alone without a semicolon is defined here in libsyntax. The distinction informs a few different early bail-out cases where the parser decides to finish parsing the current expression.</p><p>Relevant to our case is that block expressions <code>{ /* ... */ }</code> terminate an expression if doing so would be syntactically sensible. The parser does not eagerly consume binary operators after a block expression. Thus one might write:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;static</span> <span class="token operator">&amp;</span><span class="token lifetime-annotation symbol">&#39;static</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
    <span class="token comment">// Block expression.</span>
    <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;What a silly function.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Reference to reference to true.</span>
    <span class="token operator">&amp;&amp;</span><span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>In order to parse a block followed by a binary operator, we would need to make it syntactically insensible for the parser to terminate an expression at the close curly brace. This would usually be done by wrapping in parentheses.</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token boolean">true</span> <span class="token punctuation">}</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Anyhow, the output of the program is 112.</p><p>You have answered 2 of 33 questions correctly.</p>`,45);function t(p,o){return e}var r=n(a,[["render",t]]);export{r as default};
