"use strict";(self.webpackChunktrdthg_github_io=self.webpackChunktrdthg_github_io||[]).push([[5643],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,p=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),k=s(n),d=l,c=k["".concat(p,".").concat(d)]||k[d]||m[d]||i;return n?a.createElement(c,o(o({ref:t},u),{},{components:n})):a.createElement(c,o({ref:t},u))}));function d(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,o=new Array(i);o[0]=k;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r.mdxType="string"==typeof e?e:l,o[1]=r;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},687:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>s});var a=n(7462),l=(n(7294),n(3905));const i={},o="Rust Quiz",r={unversionedId:"rust/rust_quiz",id:"rust/rust_quiz",title:"Rust Quiz",description:"1 statement boundry",source:"@site/docs/rust/rust_quiz.md",sourceDirName:"rust",slug:"/rust/rust_quiz",permalink:"/docs/rust/rust_quiz",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Channel \u6e90\u7801\u5256\u6790",permalink:"/docs/rust/rs_channel"},next:{title:"Wasm \u5b9e\u73b0\u751f\u547d\u6e38\u620f",permalink:"/docs/rust/wasm"}},p={},s=[{value:"#1 <code>statement boundry</code>",id:"1-statement-boundry",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a",level:3},{value:"\u89e3\u7b54",id:"\u89e3\u7b54",level:3},{value:"#2 <code>impl BitAnd</code>",id:"2-impl-bitand",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-1",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-1",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3",level:3},{value:"#3 <code>const initializer</code>",id:"3-const-initializer",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-2",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-2",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-1",level:3},{value:"#4 <code>..</code>",id:"4-",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-3",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-3",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-2",level:3},{value:"#5 <code>T or &amp;T</code>",id:"5-t-or-t",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-4",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-4",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-3",level:3},{value:"#6 <code>size of ()</code>",id:"6-size-of-",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-5",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-5",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-4",level:3},{value:"#7 <code>match</code>",id:"7-match",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-6",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-6",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-5",level:3},{value:"#8 <code>= = &gt;</code>",id:"8---",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-7",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-7",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-6",level:3},{value:"#9 <code>$tt:tt</code>",id:"9-tttt",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-8",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-8",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-7",level:3},{value:"#10 <code>Trait::f</code>",id:"10-traitf",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-9",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-9",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-8",level:3},{value:"#11 <code>early &amp; late bound</code>",id:"11-early--late-bound",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-10",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-10",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-9",level:3},{value:"#12 <code>let S { x, .. } = S</code>",id:"12-let-s--x----s",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-11",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-11",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-10",level:3},{value:"#13 <code>eq</code>",id:"13-eq",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-12",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-12",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-11",level:3},{value:"#14 <code>trait scope</code>",id:"14-trait-scope",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-13",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-13",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-12",level:3},{value:"#15 <code>type inference</code>",id:"15-type-inference",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-14",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-14",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-13",level:3},{value:"#16 <code>--i</code>",id:"16---i",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-15",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-15",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-14",level:3},{value:"#17 <code>-- - --</code>",id:"17--------",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-16",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-16",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-15",level:3},{value:"#18 <code>f() and f()</code>",id:"18-f-and-f",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-17",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-17",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-16",level:3},{value:"#19 <code>move or drop</code>",id:"19-move-or-drop",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-18",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-18",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-17",level:3},{value:"#20 <code>return and return</code>",id:"20-return-and-return",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-19",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-19",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-18",level:3},{value:"#21 <code>return &amp; break</code>",id:"21-return--break",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-20",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-20",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-19",level:3},{value:"#22 <code>- is a token</code>",id:"22---is-a-token",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-21",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-21",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-20",level:3},{value:"#23 <code>method lookup order</code>",id:"23-method-lookup-order",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-22",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-22",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-21",level:3},{value:"#24 <code>Hygiene</code>",id:"24-hygiene",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-23",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-23",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-22",level:3},{value:"#25 <code>drop</code>",id:"25-drop",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-24",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-24",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-23",level:3},{value:"#26 <code>lazy map</code>",id:"26-lazy-map",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-25",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-25",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-24",level:3},{value:"#27 <code>dyn Trait</code>",id:"27-dyn-trait",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-26",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-26",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-25",level:3},{value:"#28 <code>_guard &amp; _</code>",id:"28-_guard--_",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-27",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-27",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-26",level:3},{value:"#29 <code>(T) &amp; (T,)</code>",id:"29-t--t",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-28",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-28",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-27",level:3},{value:"#30 <code>clone</code>",id:"30-clone",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-29",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-29",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-28",level:3},{value:"#31 <code>method lookup order</code>",id:"31-method-lookup-order",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-30",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-30",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-29",level:3},{value:"#32 <code>march arm &amp; if guard</code>",id:"32-march-arm--if-guard",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-31",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-31",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-30",level:3},{value:"#33 <code>Range&#39;s method</code>",id:"33-ranges-method",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-32",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-32",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-31",level:3},{value:"#34 <code>size of fn</code>",id:"34-size-of-fn",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-33",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-33",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-32",level:3},{value:"#35 <code>Hygiene 2</code>",id:"35-hygiene-2",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-34",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-34",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-33",level:3},{value:"\uff0336 <code>move &amp; Fn</code>",id:"36-move--fn",level:2},{value:"\u9898\u76ee",id:"\u9898\u76ee-35",level:3},{value:"\u63d0\u793a",id:"\u63d0\u793a-35",level:3},{value:"\u9898\u89e3",id:"\u9898\u89e3-34",level:3}],u={toc:s};function m(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"rust-quiz"},"Rust Quiz"),(0,l.kt)("h2",{id:"1-statement-boundry"},"#1 ",(0,l.kt)("inlineCode",{parentName:"h2"},"statement boundry")),(0,l.kt)("h3",{id:"\u9898\u76ee"},"\u9898\u76ee"),(0,l.kt)("p",null,"\u4e0b\u9762\u7684 1 \u8f93\u51fa\u662f\u4ec0\u4e48\uff1f"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'macro_rules! m {\n    ($( $s:stmt )*) => {\n        $(\n            { stringify!($s); 1 }\n        )<<*\n    };\n}\n\nfn main() {\n    print!(\n        "{}{}{}",\n        m! { return || true },\n        m! { (return) || true },\n        m! { {return} || true },\n    );\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u5b8f\u7684\u8f93\u51fa\u4e2d\u7684\u8868\u8fbe\u5f0f\u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"1 << (n - 1)")," \u6548\u679c\u76f8\u540c\uff0c\u5176\u4e2d n \u662f\u5b8f\u8f93\u5165\u4e2d\u5305\u542b\u7684 Rust \u8bed\u53e5\u7684\u6570\u91cf\u3002"),(0,l.kt)("h3",{id:"\u89e3\u7b54"},"\u89e3\u7b54"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a122"),(0,l.kt)("p",null,"\u8fd9\u4e2a\u95ee\u9898\u56f4\u7ed5\u7740 Rust \u7684\u8bed\u6cd5\u8fb9\u754c\u8bbe\u8ba1\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This question revolves around where the Rust grammar places statement\nboundaries.")),(0,l.kt)("p",null,"\u5b8f\u7684\u8f93\u5165\u89c4\u5219\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"$( $s:stmt )*"),", \u5b83\u80fd\u591f\u5339\u914d\u5230 0 \u6216\u591a\u4e2a Rust \u8bed\u53e5\u3002"),(0,l.kt)("p",null,"\u8be5\u89c4\u5219\u5185\u90e8\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"$s: stmt")," \u662f\u4e00\u4e2a\u7247\u6bb5\u5206\u7c7b\u7b26\uff0c\u5b83\u80fd\u591f\u5339\u914d\u5230\u4e00\u4e2a\u7b26\u5408 Rust \u8bed\u6cd5\u89c4\u8303\u7684\u8868\u8fbe\u5f0f\u3002\u88ab\u5339\u914d\u5230\u7684\u8bed\u53e5\u53ef\u4ee5\u5728\u5c55\u5f00\u540e\u7684\u4ee3\u7801\u4e2d\u4f5c\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"$s")," \u3002"),(0,l.kt)("p",null,"\u800c\u5916\u90e8\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"$(...)*")," \u90e8\u5206\u8868\u793a\u4e00\u4e2a\u91cd\u590d\uff0c\u5b83\u53ef\u4ee5\u91cd\u590d\u5339\u914d 0 \u6216\u591a\u6b21\u5185\u5bb9\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The input rule of the macro m! is $($s:stmt)",(0,l.kt)("em",{parentName:"p"},"which matches zero or more Rust\nstatements. The $(...)")," part of the rule is a repetition which matches the\ncontents of the repetition zero or more times, and the $s:stmt is a fragment\nspecifier that matches a Rust statement (stmt) conforming to the rules of the\nRust grammar. The matched statements are available within the expanded code as\nthe fragment variable $s.")),(0,l.kt)("p",null,"\u8bed\u53e5\u662f\u51fd\u6570\u4f53\u4e2d\u5141\u8bb8\u7684\u6700\u9ad8\u7ea7\u522b\u7684\u8bed\u6cd5\u5355\u4f4d\u3002\u4e0b\u9762\u6240\u6709\u7684\u5185\u5bb9\u90fd\u662f\u8bed\u53e5\u7684\u4f8b\u5b50\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"A statement is the top-level unit of syntax permitted within a function body.\nAll of the following are examples of statements.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"// Items are statements.\nstruct S { x: u64 }\n\n// Let-bindings are statements.\nlet mut s = S { x: 1 }\n\n// Expressions are statements.\ns.x + 1\n")),(0,l.kt)("p",null,"\u51fd\u6570\u4f53\u7684\u8bed\u6cd5\u8981\u6c42\u67d0\u4e9b\u7c7b\u578b\u7684\u8bed\u53e5\u540e\u9762\u6709\u4e00\u4e2a\u5206\u53f7\uff0c\u4f46\u5bf9\u4e8e\u5b8f\u7684\u8bed\u6cd5\u800c\u8a00\uff0c\u5206\u53f7\u5e76\u4e0d\u662f\u8bed\u53e5\u7684\u4e00\u90e8\u5206\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The grammar of function bodies requires that some types of statements are followed by a semicolon, but the semicolon is not part of the statement for the purpose of macro syntax.")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"m!")," \u5c06\u4f1a\u5c55\u5f00\u6210 0 \u6216\u591a\u4e2a\u7531 ",(0,l.kt)("inlineCode",{parentName:"p"},"<<")," \u5206\u5272\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"{ stringify!($s); 1 }"),"\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"$(...)<<*")," \u90e8\u5206\u8868\u793a\u91cd\u590d\u8bed\u53e5\u4e4b\u95f4\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"<<")," \u4f5c\u4e3a\u5206\u9694\u7b26\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The macro m! expands to zero or more copies of ",(0,l.kt)("inlineCode",{parentName:"p"},"{ stringify!($s); 1 }")," separated by the ",(0,l.kt)("inlineCode",{parentName:"p"},"<<")," token. The ",(0,l.kt)("inlineCode",{parentName:"p"},"$(...)<<*")," part of the rule is a repetition using ",(0,l.kt)("inlineCode",{parentName:"p"},"<<")," as the separator.")),(0,l.kt)("p",null,"\u5728\u5b8f\u4e2d\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"<<")," \u4f5c\u4e3a\u5206\u9694\u7b26\u975e\u5e38\u4e0d\u5e38\u89c1\u3002\u6700\u5e38\u7528\u7684\u5206\u9694\u7b26\u662f\u9017\u53f7\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"$(...),*"),"\uff0c\u5176\u4ed6\u7684\u5355\u4e00\u7b26\u53f7\u4e5f\u662f\u5141\u8bb8\u7684\u3002\u91cd\u8981\u7684\u662f\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"macro_rules!")," \u628a\u6240\u6709\u7684 Rust \u5185\u7f6e\u64cd\u4f5c\u7b26\u90fd\u5f53\u6210\u5355 token"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Using ",(0,l.kt)("inlineCode",{parentName:"p"},"<<")," as a separator in a repetition in a macro is highly unusual. The most commmonly used separator is the comma, written as ",(0,l.kt)("inlineCode",{parentName:"p"},"$(...),*"),", but any other single token is allowed here. Crucially, macro_rules! treats all built-in Rust operators as single tokens, even those that consist of multiple characters like ",(0,l.kt)("inlineCode",{parentName:"p"},"<<"),".")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"{ stringify!($s); 1 }")," \u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u5b83\u7684\u8fd4\u56de\u503c\u6c38\u8fdc\u662f 1\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"stringify!($s)")," \u88ab\u4e22\u5f03\u4e86\uff0c\u6240\u4ee5\u5b83\u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"{ 1 }")," \u7684\u6548\u679c\u662f\u76f8\u540c\u7684\u3002\u8fd9\u91cc\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"stringify!($s)")," \u662f\u4e3a\u4e86\u63a7\u5236\u91cd\u590d\u7684\u6b21\u6570\uff0c\u89c4\u5219\u4e2d\u5b9a\u4e49\u7684\u6807\u5fd7\u7b26"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"{ stringify!($s); 1 }")," is an expression whose value is always 1. The value of ",(0,l.kt)("inlineCode",{parentName:"p"},"stringify!($s)")," is discarded, so this is equivalent to the expression ",(0,l.kt)("inlineCode",{parentName:"p"},"{ 1 }"),". The reason for having ",(0,l.kt)("inlineCode",{parentName:"p"},"stringify!($s)")," in there is to control the number of times the repetition is repeated, which is determined by which fragment variables are used within the repetition. Writing a repetition without using any fragment variables inside of it would not be legal.")),(0,l.kt)("p",null,"\u5047\u8bbe\u6211\u4eec\u8c03\u7528\u5b8f\u65f6\u4f20\u5165\u4e09\u6761\u8bed\u53e5\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Suppose we call this macro with three of the statements shown above as input.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"m! {\n    struct S { x: u64 }\n    let mut s = S { x: 1 }\n    s.x + 1\n}\n")),(0,l.kt)("p",null,"\u8fd9\u4e2a\u5b8f\u4f1a\u88ab\u5c55\u5f00\u4e3a\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The macro expands to:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"{ stringify!(struct S { x: u64 }); 1 }\n    << { stringify!(let mut s = S { x: 1 }); 1 }\n    << { stringify!(s.x + 1); 1 }\n")),(0,l.kt)("p",null,"\u6bcf\u4e2a stringifys \u90fd\u4f1a\u88ab\u8f6c\u4e3a\u5b57\u7b26\u4e32\u5b57\u9762\u91cf\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Each of the stringifys expands to a string literal:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'{ "struct S { x: u64 }"; 1 }\n    << { "let mut s = S { x: 1 }"; 1 }\n    << { "s.x + 1"; 1 }\n')),(0,l.kt)("p",null,"\u5b57\u7b26\u4e32\u5b57\u9762\u91cf\u7684\u503c\u6ca1\u6709\u88ab\u4f7f\u7528\u3002\u6240\u4ee5\u8fd9\u4e2a\u7ed3\u679c\u7b49\u4ef7\u4e8e ",(0,l.kt)("inlineCode",{parentName:"p"},"{ 1 } << { 1 } << { 1 }"),"\uff0c\u4e5f\u7b49\u4ef7\u4e8e ",(0,l.kt)("inlineCode",{parentName:"p"},"1 << 1 << 1"),"\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"<<")," \u64cd\u4f5c\u7b26\u5c31\u662f\u5de6\u79fb\uff1b\u7ed3\u679c\u662f 4\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The values of the string literals are not used. In this case the expression is equivalent to ",(0,l.kt)("inlineCode",{parentName:"p"},"{ 1 } << { 1 } << { 1 }"),", which is equivalent to ",(0,l.kt)("inlineCode",{parentName:"p"},"1 << 1 << 1"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"<<")," operator is left-associative; the numeric value of this expression is 4.")),(0,l.kt)("p",null,"\u603b\u7684\u6765\u8bf4\uff0cRust \u8bed\u53e5\u6709\u591a\u5c11\uff0c1 \u5c31\u91cd\u590d\u591a\u5c11\u6b21\u3002\u6240\u4ee5\u8fd9\u4e2a\u5b8f\u5c31\u76f8\u5f53\u4e8e ",(0,l.kt)("inlineCode",{parentName:"p"},"1 << (n - 1)"),"\u3002\u5f53 n \u4e3a 0 \u65f6\uff0c\u8bed\u53e5\u65e0\u6cd5\u5c55\u5f00\uff0c\u4f1a\u7f16\u8bd1\u5931\u8d25\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Altogether, the relevant behavior of this macro is that it evaluates to ",(0,l.kt)("inlineCode",{parentName:"p"},"1 << 1 << 1 << ...")," where the number of ones is equal to the number of Rust statements in the input of the macro. In closed form, the numeric value is ",(0,l.kt)("inlineCode",{parentName:"p"},"1 << (n - 1)")," where n is the number of statements, except in the case that n is zero where the macro expands to nothing and we get a syntax error at the call site.")),(0,l.kt)("p",null,"\u5269\u4e0b\u7684\u5c31\u662f\u5224\u65ad\u4e00\u4e0b\u8fd9 3 \u6b21\u8c03\u7528\u5206\u522b\u4f20\u5165\u4e86\u591a\u5c11\u4e2a Rust \u8bed\u53e5\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"It remains to determine how many statements are in the three invocations of m! in the quiz code.")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"return || true"))),(0,l.kt)("p",null,"\u8fd9\u662f\u4e00\u6761 return \u8bed\u53e5\uff0c\u4ed6\u8fd4\u56de\u7684 y \u662f\u4e00\u4e2a\u95ed\u5305 ",(0,l.kt)("inlineCode",{parentName:"p"},"|| true"),"\u3002\u7b49\u4ef7\u4e8e ",(0,l.kt)("inlineCode",{parentName:"p"},"(|| true)"),"\u3002\u6240\u4ee5\u4ed6\u4f1a\u88ab\u89e3\u6790\u4e3a\u4e00\u6761\u8bed\u53e5\uff0c\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"m!")," \u7684\u7ed3\u679c\u662f 1\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This is a return-expression that would return the closure ",(0,l.kt)("inlineCode",{parentName:"p"},"|| true"),". It is\nequivalent to return ",(0,l.kt)("inlineCode",{parentName:"p"},"(|| true)"),". It is parsed as a single statement so the m! invocation evaluates to 1")),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"(return) || true"))),(0,l.kt)("p",null,"\u8fd9\u662f\u4e00\u6761\u903b\u8f91\u6216\u8bed\u53e5\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"||")," \u662f\u4e00\u4e2a\u4e8c\u5143\u8fd0\u7b97\u7b26\uff0c\u5de6\u4fa7\u662f\u4e00\u4e2a ",(0,l.kt)("inlineCode",{parentName:"p"},"(return)")," \u8bed\u53e5 (\u6216\u8005\u8bf4 ",(0,l.kt)("inlineCode",{parentName:"p"},"!")," \u7c7b\u578b)\uff0c\u53f3\u4fa7\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),"\u3002\u6240\u4ee5 ",(0,l.kt)("inlineCode",{parentName:"p"},"(return) || true")," \u662f\u4e00\u4e2a\u8bed\u53e5\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"m!")," \u7684\u503c\u4ecd\u7136\u4e3a 1\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This is a logical-OR expression. The ",(0,l.kt)("inlineCode",{parentName:"p"},"||")," is a binary operator, where the left-hand side is the expression ",(0,l.kt)("inlineCode",{parentName:"p"},"(return)")," (of diverging type ",(0,l.kt)("inlineCode",{parentName:"p"},"!"),") and the right-hand side is the expression ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),". This expression is a single statement so m! again evaluates to 1.")),(0,l.kt)("ol",{start:3},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"{return} || true"))),(0,l.kt)("p",null,"\u8fd9\u6761\u662f\u4e24\u4e2a\u8bed\u53e5\uff01\u4e00\u4e2a\u5757\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"return"),"\uff0c\u540e\u9762\u53c8\u8ddf\u4e00\u4e2a\u95ed\u5305 ",(0,l.kt)("inlineCode",{parentName:"p"},"|| true"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This one is two statements! A block-statement ",(0,l.kt)("inlineCode",{parentName:"p"},"{return}")," followed by a closure expression ",(0,l.kt)("inlineCode",{parentName:"p"},"|| true"),".")),(0,l.kt)("p",null,"Rust \u7684\u8bed\u6cd5\u533a\u5206\u4e86\u9700\u8981\u5206\u53f7\u7684\u8868\u8fbe\u5f0f (\u4f5c\u4e3a\u5355\u4e2a\u8868\u8fbe\u5f0f) \u548c\u65e0\u9700\u5206\u53f7\u7684\u4e00\u7ec4\u8868\u8fbe\u5f0f\u3002\u770b\u770b\u4e0b\u9762\u7684\u4e24\u4e2a\u4f8b\u5b50\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The Rust grammar distinguishes between expressions that require a semicolon in order to stand alone as a statement, and expressions that can be statements even without a semicolon. Consider two examples:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"// \u7ed3\u5c3e\u4e0d\u9700\u8981\u5206\u53f7\u3002\nfor t in vec {\n    /* ... */\n}\n\n// \u7ed3\u5c3e\u9700\u8981\u5206\u53f7\u3002\nself.skip_whitespace()?;\n")),(0,l.kt)("p",null,"\u4e0d\u9700\u8981\u5206\u53f7\u7684\u8868\u8fbe\u5f0f\u90fd\u5b9a\u4e49\u5728 libsyntex \u91cc\u3002The distinction informs a few different early bail-out cases where the parser decides to finish parsing the current expression.(\u80fd\u529b\u6709\u9650\uff0c\u4e0d\u4f1a\u7ffb\u8bd1)"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The list of expression types that stand alone without a semicolon is defined here in libsyntax. The distinction informs a few different early bail-out cases where the parser decides to finish parsing the current expression.")),(0,l.kt)("p",null,"\u5757\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"{ /* ... */ }")," \u7ec8\u6b62\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u548c\u672c\u9898\u7684\u60c5\u51b5\u76f8\u540c\u3002\u5982\u679c\u8fd9\u6837\u505a\u5728\u8bed\u6cd5\u4e0a\u662f\u5408\u7406\u7684\uff0c\u90a3\u5c31\u610f\u5473\u7740\u89e3\u6790\u5668\u5728\u5757\u8868\u8fbe\u5f0f\u4e4b\u540e\u4e0d\u4f1a\u7acb\u5373\u6d88\u8017\u4e8c\u5143\u8fd0\u7b97\u7b26\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u8fd9\u6837\u5199\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Relevant to our case is that block expressions ",(0,l.kt)("inlineCode",{parentName:"p"},"{ /* ... */ }")," terminate an expression if doing so would be syntactically sensible. The parser does not eagerly consume binary operators after a block expression. Thus one might write:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"fn f() -> &'static &'static bool {\n    // \u5757\u8868\u8fbe\u5f0f\u3002\n    {\n        println!(\"What a silly function.\");\n    }\n\n    // true \u7684\u5f15\u7528\u7684\u5f15\u7528\u3002\n    &&true\n}\n")),(0,l.kt)("p",null,"\u4e3a\u4e86\u6b63\u786e\u89e3\u6790\u8fd9\u79cd\u60c5\u51b5\uff08\u5757\u8868\u8fbe\u5f0f\u540e\u9762\u7d27\u8ddf\u4e00\u4e2a\u4e8c\u5143\u8fd0\u7b97\u7b26\uff09\uff0c\u89e3\u6790\u5668\u9700\u8981\u5728\u8868\u8fbe\u5f0f\u7684\u672b\u5c3e\u53ca\u65f6\u7ec8\u6b62\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In order to parse a block followed by a binary operator, we would need to make it syntactically insensible for the parser to terminate an expression at the close curly brace. This would usually be done by wrapping in parentheses.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"fn f() -> bool {\n    ({ true } && true)\n}\n")),(0,l.kt)("p",null,"\u603b\u4e4b\uff0c\u8be5\u7a0b\u5e8f\u7684\u8f93\u51fa\u662f 112\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Anyhow, the output of the program is 112.")),(0,l.kt)("h2",{id:"2-impl-bitand"},"#2 ",(0,l.kt)("inlineCode",{parentName:"h2"},"impl BitAnd")),(0,l.kt)("h3",{id:"\u9898\u76ee-1"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'struct S(i32);\n\nimpl std::ops::BitAnd<S> for () {\n    type Output = ();\n\n    fn bitand(self, rhs: S) {\n        print!("{}", rhs.0);\n    }\n}\n\nfn main() {\n    let f = || ( () & S(1) );\n    let g = || { () & S(2) };\n    let h = || ( {} & S(3) );\n    let i = || { {} & S(4) };\n    f();\n    g();\n    h();\n    i();\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-1"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u5176\u4e2d\u4e00\u4e2a\u95ed\u5305\u548c\u53e6\u5916\u4e09\u4e2a\u4e0d\u540c\u3002"),(0,l.kt)("h3",{id:"\u9898\u89e3"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a123"),(0,l.kt)("p",null,"f\uff0cg \u548c h \u90fd\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"impl Fn()"),"\u3002\u95ed\u5305\u7684 body \u90fd\u4f1a\u88ab\u89e3\u6790\u4e3a\u5bf9\u4e0a\u9762\u7531 BitAnd Trait \u5b9a\u4e49\u7684 bitwise-AND \u64cd\u4f5c\u7b26\u7684\u8c03\u7528\u3002\u5f53\u95ed\u5305\u88ab\u8c03\u7528\u65f6\uff0cbitwise-AND \u4f1a\u6253\u5370\u51fa\u53f3\u4fa7 S \u7684\u5185\u5bb9\uff0c\u95ed\u5305\u5219\u8fd4\u56de ",(0,l.kt)("inlineCode",{parentName:"p"},"()"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The closures f, g, and h are all of type impl Fn(). The closure bodies are parsed as an invocation of the user-defined bitwise-AND operator defined above by the BitAnd trait impl. When the closures are invoked, the bitwise-AND implementation prints the content of the S from the right-hand side and evaluates to ().")),(0,l.kt)("p",null,"\u95ed\u5305 i \u5219\u4e0d\u75db\u3002\u4f7f\u7528 rustfmt \u683c\u5f0f\u5316\u4ee3\u7801\u4f1a\u8ba9\u4ed6\u66f4\u6e05\u6670\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The closure i is different. Formatting the code with rustfmt makes it clearer how i is parsed.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"let i = || {\n    {}\n    &S(4)\n};\n")),(0,l.kt)("p",null,"\u95ed\u5305\u4f53\u7531\u4e00\u4e2a\u7a7a\u7684\u5757\u72b6\u8bed\u53e5 {} \u548c\u540e\u9762\u7684\u5bf9 S(4) \u7684\u5f15\u7528\u7ec4\u6210\uff0c\u800c\u4e0d\u662f\u4e00\u4e2a bitwise-AND \u64cd\u4f5c\u3002i \u7684\u7c7b\u578b\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"impl Fn() -> &'static S"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The closure body consists of an empty block-statement {} followed by a reference to S(4), not a bitwise-AND. The type of i is impl Fn() -> &'static S.")),(0,l.kt)("p",null,"f \u5bf9\u8fd9\u79cd\u60c5\u51b5\u7684\u89e3\u6790\u662f\u7531 libsyntax \u4e2d\u7684\u4ee3\u7801\u7ba1\u7406\u7684\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The parsing of this case is governed by this code in libsyntax.")),(0,l.kt)("h2",{id:"3-const-initializer"},"#3 ",(0,l.kt)("inlineCode",{parentName:"h2"},"const initializer")),(0,l.kt)("h3",{id:"\u9898\u76ee-2"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'struct S {\n    x: i32,\n}\n\nconst S: S = S { x: 2 };\n\nfn main() {\n    let v = &mut S;\n    v.x += 1;\n    S.x += 1;\n    print!("{}{}", v.x, S.x);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-2"},"\u63d0\u793a"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"const")," \u548c \u4e0d\u53ef\u53d8\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"static")," \u6709\u4ec0\u4e48\u533a\u522b\uff1f"),(0,l.kt)("h3",{id:"\u9898\u89e3-1"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a32"),(0,l.kt)("p",null,"const \u7684\u8bed\u4e49\u662f\uff0c\u4efb\u4f55\u5728\u8868\u8fbe\u5f0f\u4f4d\u7f6e\u4e0a\u4ee5\u540d\u79f0\u63d0\u53ca\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"const")," \u90fd\u4f1a\u88ab const initializer \u7684\u503c\u6240\u66ff\u4ee3\u3002\u4e0a\u9762\u7684\u4ee3\u7801\u5176\u5b9e\u7b49\u540c\u4e8e\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The semantics of const is that any mention of the const by name in expression position is substituted with the value of the const initializer. In this quiz code the behavior is equivalent to:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'struct S {\n    x: i32,\n}\n\nfn main() {\n    let v = &mut S { x: 2 };\n    v.x += 1;\n    S { x: 2 }.x += 1;\n    print!("{}{}", v.x, S { x: 2 }.x);\n}\n')),(0,l.kt)("p",null,"\u8fd9\u91cc\u6211\u53ea\u662f\u7b80\u5355\u5730\u628a\u6bcf\u4e00\u4e2a\u63d0\u5230 S \u7684\u5730\u65b9\u90fd\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"const S")," \u7684\u503c\u6765\u4ee3\u66ff\uff0c\u5373 ",(0,l.kt)("inlineCode",{parentName:"p"},"S { x: 2 }"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"I have simply substituted every mention of S in expresson position with the value of const S which is S { x: 2 }.")),(0,l.kt)("p",null,"main \u7684\u7b2c\u4e00\u884c\u7b49\u540c\u4e8e\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The first line of main is equivalent to:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"let mut _tmp0 = S { x: 2 };\nlet v = &mut _tmp0;\n")),(0,l.kt)("p",null,"main \u7684\u7b2c\u4e8c\u884c\u6539\u53d8\u4e86 v \u6307\u5411\u7684 x\uff0c\u5728 v \u5269\u4f59\u7684\u751f\u547d\u671f\u5185\uff0cx \u4ecd\u7136\u53ef\u4ee5\u901a\u8fc7 v \u8bbf\u95ee\uff0c\u56e0\u6b64\u6253\u5370\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u662f 3\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The second line of main mutates the value pointed to by v. The same value remains accessible through v for the rest of the lifetime of v, which is why the first character printed is 3.")),(0,l.kt)("p",null,"main \u7684\u7b2c\u4e09\u884c\u6539\u53d8\u4e86\u4e00\u4e2a\u4e34\u65f6\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u5728\u5206\u53f7\u7ed3\u5c3e\u5c31\u7acb\u5373\u8d85\u51fa\u4e86\u4f5c\u7528\u57df\u3002\u6253\u5370\u7684\u7b2c\u4e8c\u4e2a\u5b57\u7b26\u6765\u81ea\u4e00\u4e2a\u5168\u65b0\u7684",(0,l.kt)("inlineCode",{parentName:"p"},"S { x: 2 }"),"\uff0c\u6240\u4ee5\u7b2c\u4e8c\u4e2a\u6253\u5370\u7684\u662f 2\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The third line of main mutates a temporary that immediately goes out of scope at the semicolon. The second character printed is coming from a brand new S { x: 2 }, so 2 is printed.")),(0,l.kt)("p",null,"\u8fd9\u6bb5\u4ee3\u7801\u4e2d\u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\uff0c\u662f Rust \u4e2d\u5173\u4e8e\u547d\u540d\u7a7a\u95f4\u548c\u540d\u5b57\u89e3\u6790\u7684\u6982\u5ff5\u3002\u4efb\u4f55\u6307\u4ee3\u7c7b\u578b\u7684\u540d\u5b57\u90fd\u5728\u7c7b\u578b\u547d\u540d\u7a7a\u95f4\uff0c\u4efb\u4f55\u6307\u4ee3\u503c\u7684\u540d\u5b57\u90fd\u5728\u503c\u547d\u540d\u7a7a\u95f4\u3002"),(0,l.kt)("p",null,"\u8fd9\u662f\u4e24\u7ec4\u4e0d\u540c\u7684\u540d\u5b57\uff0c\u800c\u8bed\u8a00\u7684\u7ed3\u6784\u4f7f\u6211\u4eec\u603b\u662f\u53ef\u4ee5\u77e5\u9053\u5728\u54ea\u4e2a\u547d\u540d\u7a7a\u95f4\u4e2d\u67e5\u627e\u4e00\u4e2a\u540d\u5b57\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"One additional wrinkle in this code is the concept of namespaces and name resolution in Rust. Any name that refers to a type lives in the type namespace, and any name that refers to a value lives in the value namespace. These are two separate sets of names, and the language is structured such that we can always tell which namespace to look up a name in.")),(0,l.kt)("p",null,"\u5728\u4ee3\u7801\u7684\u4e0a\u4e0b\u6587\u4e2d\uff0c\u7ed3\u6784\u4f53 S \u7684\u540d\u79f0\u662f\u7c7b\u578b\u540d\u79f0\u7a7a\u95f4\u7684\u4e00\u90e8\u5206\uff0c\u800c\u5e38\u91cf S \u7684\u540d\u79f0\u662f\u503c\u540d\u79f0\u7a7a\u95f4\u7684\u4e00\u90e8\u5206\u3002\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u6211\u4eec\u53ef\u4ee5\uff0c\u5728\u540c\u4e00\u65f6\u95f4\u770b\u5230\u4e24\u4e2a\u76f8\u540c\u540d\u79f0\u7684\u4e0d\u540c\u4e8b\u7269\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In the context of the quiz code, the name of the struct S is part of the type namespace and the name of the const S is part of the value namespace. That is how we can have seemingly two different things with the same name in scope at the same time.")),(0,l.kt)("h2",{id:"4-"},"#4 ",(0,l.kt)("inlineCode",{parentName:"h2"},"..")),(0,l.kt)("h3",{id:"\u9898\u76ee-3"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn main() {\n    let (.., x, y) = (0, 1, ..);\n    print!("{}", b"066"[y][x]);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-3"},"\u63d0\u793a"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"..")," \u5728\u8868\u8fbe\u4e2d\u548c\u6a21\u5f0f\u5339\u914d\u4e2d\u542b\u4e49\u4e0d\u540c\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},".. means one thing in an expression and something else in a pattern.")),(0,l.kt)("h3",{id:"\u9898\u89e3-2"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a54"),(0,l.kt)("p",null,"\u8fd9\u4e2a\u95ee\u9898\u5c55\u793a\u4e86 ",(0,l.kt)("inlineCode",{parentName:"p"},".."),"\u4e0d\u540c\u542b\u4e49"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This question demonstrates two different meanings of ...")),(0,l.kt)("p",null,"\u5728\u8868\u8fbe\u5f0f\u7684\u4e00\u4fa7 (\u53f3\u4fa7), ",(0,l.kt)("inlineCode",{parentName:"p"},"..")," \u662f\u6784\u9020\u95f0 ",(0,l.kt)("inlineCode",{parentName:"p"},"Range")," \u7c7b\u578b\u7684\u8bed\u6cd5\uff0c\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"(0, 1, ..)")," \u662f\u4e00\u4e2a\u62e5\u6709\u4e09\u4e2a\u5143\u7d20\u7684\u5143\u7ec4\uff0c\u5176\u4e2d\u7684\u7b2c\u4e09\u4e2a\u62e5\u6709 RangeFull \u7c7b\u578b\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In expression position, .. is the syntax for constructing various types of ranges. Here the expression (0, 1, ..) is a tuple with three elements, the third one having type RangeFull.")),(0,l.kt)("p",null,"\u5728\u6a21\u5f0f\u7684\u4e00\u4fa7\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"..")," \u88ab\u7528\u6765\u8868\u793a\u4efb\u4f55\u6570\u91cf\u7684\u5143\u7d20\u3002\u6240\u4ee5\u6a21\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"(.., x, y)")," \u4f1a\u5339\u914d\u5230\u4e00\u4e2a\u62e5\u6709\u4e24\u4e2a\u6216\u8005\u66f4\u591a\u5143\u7d20\u7684\u5143\u7ec4\uff0c\u5e76\u628a\u5012\u6570\u7b2c 2 \u4e2a\u5143\u7d20\u7ed1\u5b9a\u5230 x \u4e0a\uff0c\u6700\u540e\u4e00\u4e2a\u6570\u7ed1\u5b9a\u5230 y \u4e0a\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'On the other hand in a pattern, .. is used to mean "any number of elements". So the pattern (.., x, y) matches a tuple with 2 or more elements, binding the second-last one to x and the last one to y.')),(0,l.kt)("p",null,"\u6240\u4ee5\u5728\u9762\u7684\u7b2c 1 \u884c\uff0cx \u7684\u503c\u4e3a 1\uff0cy \u7684\u503c\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"(..)"),"\u3002\u56e0\u6b64\u6253\u5370\u51fa\u6765\u7684\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},'b"066[..][1]"'),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'Coming out of the first line of main, we have x = 1 and y = (..). Thus the value printed is going to be b"066"',"[..][1]",".")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},'b"066"')," \u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u4ed6\u662f\u4e00\u4e2a Byte \u5f62\u5f0f\u7684\u5b57\u7b26\u4e32\u5b57\u9762\u91cf\uff0c\u5b83\u7684\u7c7b\u578b\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"&'static [u8; 3]"),", \u62e5\u6709\u4e09\u4e2a ASCII \u5b57\u7b26 ",(0,l.kt)("inlineCode",{parentName:"p"},"b'0'"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"b'6'"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"b'6'"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'The expression b"066" is a byte-string literal of type &\'static ',"[u8; 3]"," containing the three ASCII bytes b'0', b'6', b'6'.")),(0,l.kt)("p",null,"\u5f53\u6211\u4eec\u7528 RangeFull \u5bf9\u5b57\u8282\u4e32\u8fdb\u5207\u7247\u65f6\uff0c\u6211\u4eec\u5f97\u5230\u4e00\u4e2a\u957f\u5ea6\u4e3a 3 \u7684\u52a8\u6001\u5927\u5c0f\u7684\u5207\u7247 ","[u8]","\uff0c\u63a5\u4e0b\u6765\u6211\u4eec\u8bbf\u95ee\u5207\u7247\u5728 1 \u5904\u7684\u5143\u7d20\uff0c\u5373\u7c7b\u578b\u4e3a u8 \u7684\u5b57\u8282 ",(0,l.kt)("inlineCode",{parentName:"p"},"b'6'"),"\u3002\u5f53\u6253\u5370\u65f6\uff0c\u6211\u4eec\u770b\u5230\u7684\u662f ASCII \u6570\u5b57 6 \u7684\u5341\u8fdb\u5236\u8868\u793a\uff0c\u4e5f\u5c31\u662f\u6570\u5b57 54\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"When we slice the byte-string with RangeFull we get a dynamically sized slice ","[u8]"," of length 3. Next we access element 1 of the slice, which is the byte b'6' of type u8. When printed, we see the decimal representation of the byte value of the ASCII digit 6, which is the number 54.")),(0,l.kt)("h2",{id:"5-t-or-t"},"#5 ",(0,l.kt)("inlineCode",{parentName:"h2"},"T or &T")),(0,l.kt)("h3",{id:"\u9898\u76ee-4"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'trait Trait {\n    fn p(self);\n}\n\nimpl<T> Trait for fn(T) {\n    fn p(self) {\n        print!("1");\n    }\n}\n\nimpl<T> Trait for fn(&T) {\n    fn p(self) {\n        print!("2");\n    }\n}\n\nfn f(_: u8) {}\nfn g(_: &u8) {}\n\nfn main() {\n    let a: fn(_) = f;\n    let b: fn(_) = g;\n    let c: fn(&_) = g;\n    a.p();\n    b.p();\n    c.p();\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-4"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u5982\u679c\u4f60\u719f\u6089\u9ad8\u7ea7\u751f\u547d\u5468\u671f\u7ed1\u5b9a\u7684\u8bed\u6cd5\uff0c\u53ef\u4ee5\u5c1d\u8bd5\u5c06 impl \u7b7e\u540d\u4e2d\u7684\u6240\u6709\u7c7b\u578b\u548c main \u4e2d\u7684\u7c7b\u578b\u89e3\u6784\u4e3a\u5b8c\u5168\u663e\u5f0f\u7684\u5f62\u5f0f\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If you are familiar with higher-rank trait bound syntax, try desugaring all the types in the impl signatures and types in main into their fully explicit form.")),(0,l.kt)("h3",{id:"\u9898\u89e3-3"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a112"),(0,l.kt)("p",null,"\u7b2c\u4e00\u4e2a impl \u9002\u7528\u4e8e ",(0,l.kt)("inlineCode",{parentName:"p"},"fn(T)")," \u7c7b\u578b\u7684\u51fd\u6570\u6307\u9488\uff0c\u5176\u4e2d T \u662f\u4efb\u4f55\u5355\u4e00\u7684\u5177\u4f53\u7c7b\u578b\u3002\u7b2c\u4e8c\u4e2a impl \u9002\u7528\u4e8e\u66f4\u9ad8\u7b49\u7ea7\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"for<'a> fn(&'a T)")," \u7c7b\u578b\u7684\u51fd\u6570\u6307\u9488\uff0c\u5176\u4e2d T \u7c7b\u578b\u7684\u751f\u547d\u5468\u671f\u8d85\u8fc7 ",(0,l.kt)("inlineCode",{parentName:"p"},"'a"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The first impl applies to function pointers of type fn(T) where T is any single concrete type. The second impl applies to function pointers of higher-ranked type for<'a> fn(&'a T) for some concrete type T that outlives 'a.")),(0,l.kt)("p",null,"\u5728 main \u4e2d\uff0c\u7f16\u8bd1\u5668\u4f1a\u81ea\u52a8\u4f7f\u7528\u7c7b\u578b\u63a8\u5bfc\uff0c\u7528\u67d0\u79cd\u5177\u4f53\u7684\u7c7b\u578b\u6765\u66ff\u4ee3\u6240\u6709\u51fa\u73b0\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"_"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Inside of main, the compiler is going to use type inference to substitute all occurrences of _ in a type by some concrete type.")),(0,l.kt)("p",null,"\u5bf9\u4e8e\u95ed\u5305 a\uff0c\u6211\u4eec\u63a8\u65ad ",(0,l.kt)("inlineCode",{parentName:"p"},"_ = u8"),"\uff0c\u95ed\u5305\u7c7b\u578b\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"fn(u8)"),"\uff0c\u63a5\u53d7\u4e00\u4e2a ",(0,l.kt)("inlineCode",{parentName:"p"},"u8")," \u7c7b\u578b\u7684\u53c2\u6570\u5e76\u8fd4\u56de ",(0,l.kt)("inlineCode",{parentName:"p"},"()"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"For the closure a we infer _ = u8, yielding the closure type fn(u8) taking an argument of type u8 and returning ().")),(0,l.kt)("p",null,"\u5bf9\u4e8e b\uff0c\u6211\u4eec\u63a8\u65ad ",(0,l.kt)("inlineCode",{parentName:"p"},"_ = &'x u8"),", \u4e3a\u4e00\u4e9b\u5177\u4f53\u7684\u751f\u547d\u5468\u671f ",(0,l.kt)("inlineCode",{parentName:"p"},"'x"),"\uff0c\u6700\u7ec8\u5c06\u88ab\u9001\u5165\u501f\u7528\u68c0\u67e5\u5668\u3002b \u7684\u7c7b\u578b\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"fn(&'x u8)"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"For b we infer _ = &'x u8 for some concrete lifetime 'x that will ultimately feed into the borrow checker. The type of b is fn(&'x u8).")),(0,l.kt)("p",null,"\u6700\u540e\uff0c\u5bf9\u4e8e c\uff0c\u6211\u4eec\u63a8\u65ad ",(0,l.kt)("inlineCode",{parentName:"p"},"_ = u8"),"\uff0c\u4ea7\u751f\u66f4\u9ad8\u7b49\u7ea7\u7684\u95ed\u5305\u7c7b\u578b ",(0,l.kt)("inlineCode",{parentName:"p"},"<'a> fn(&'a u8)"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"And finally for c we infer _ = u8, yielding the higher-ranked closure type for<'a> fn(&'a u8).")),(0,l.kt)("p",null,"\u4ee5\u6b64\u4e3a\u6846\u67b6\uff0c\u53ef\u4ee5\u770b\u51fa\uff0c\u5728 main \u7ed3\u5c3e\u51fa\u4f1a\u6253\u5370 112\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Framed in this way, it follows that the trait method calls at the end of main print 112.")),(0,l.kt)("h2",{id:"6-size-of-"},"#6 ",(0,l.kt)("inlineCode",{parentName:"h2"},"size of ()")),(0,l.kt)("h3",{id:"\u9898\u76ee-5"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'use std::mem;\n\nfn main() {\n    let a;\n    let a = a = true;\n    print!("{}", mem::size_of_val(&a));\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-5"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u6709\u4e24\u4e2a\u540d\u4e3a a \u7684\u53d8\u91cf\uff0c\u5b83\u4eec\u5404\u81ea\u7684\u7c7b\u578b\u662f\u4ec0\u4e48\uff1f"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"There are two variables named a. What is the type of each one?")),(0,l.kt)("h3",{id:"\u9898\u89e3-4"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a0"),(0,l.kt)("p",null,'\u8fd9\u91cc\u6709\u4e24\u4e2a\u540d\u4e3a a e \u7684\u53d8\u91cf\uff0c\u7b2c\u4e8c\u4e2a\u4f1a "\u906e\u853d" \u7b2c\u4e00\u4e2a\uff0c\u8fd9\u6bb5\u7a0b\u5e8f\u7b49\u4ef7\u4e8e\uff1a'),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"There are two variables named a, one shadowing the other. The program is equivalent to:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'let a;\nlet b = a = true;\nprint!("{}", mem::size_of_val(&b));\n')),(0,l.kt)("p",null,"\u66f4\u8fdb\u4e00\u6b65\uff0c\u4e3a b \u8d4b\u7684\u503c\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"a = true"),";"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Further, the value being assigned to b is the expression a = true.")),(0,l.kt)("p",null,"\u5728 Rust \u91cc\uff0c\u8d4b\u503c\u8868\u8fbe\u5f0f\u7684\u8fd4\u56de\u503c\u59cb\u7ec8\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"()"),"\u3002\u5728\u7b80\u5316\u4e00\u4e0b\u4ee3\u7801\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In Rust, assignment expressions always have the value (). Simplified some more, the quiz code is equivalent to:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'let a = true;\nlet b = ();\nprint!("{}", mem::size_of_val(&b));\n')),(0,l.kt)("p",null,"\u5173\u4e8e\u5b83\u7684\u884c\u4e3a\u89c4\u8303\uff0c\u8bf7\u53c2\u8003 size_of_val \u7684\u6587\u6863\uff0c\u4f46\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5b83\u88ab\u5b9e\u4f8b\u5316\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"T = ()"),"\uff0c\u6211\u4eec\u6700\u7ec8\u4f1a\u6253\u5370\u51fa ",(0,l.kt)("inlineCode",{parentName:"p"},"size_of::<()>()")," \u7684\u503c\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Refer to the documentation of size_of_val for a specification of its behavior, but in this case it is being instantiated with T = () and we end up printing the value of size_of::<()>().")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"()")," \u662f\u96f6\u5927\u5c0f\u7c7b\u578b\u6216 ZST \u7684\u4e00\u4e2a\u4f8b\u5b50\uff0c\u5728\u8fd0\u884c\u65f6\u7531\u96f6\u5b57\u8282\u7684\u6570\u636e\u8868\u793a\uff0c\u6240\u4ee5\u7a0b\u5e8f\u4f1a\u6253\u5370\u51fa 0\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"() is one example of a zero-sized type or ZST and is represented by zero bytes of data at runtime, so the program prints 0.")),(0,l.kt)("h2",{id:"7-match"},"#7 ",(0,l.kt)("inlineCode",{parentName:"h2"},"match")),(0,l.kt)("h3",{id:"\u9898\u76ee-6"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'#[repr(u8)]\nenum Enum {\n    First,\n    Second,\n}\n\nimpl Enum {\n    fn p(self) {\n        match self {\n            First => print!("1"),\n            Second => print!("2"),\n        }\n    }\n}\n\nfn main() {\n    Enum::p(unsafe {\n        std::mem::transmute(1u8)\n    });\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-6"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"Enum::p")," \u65f6\u4f20\u5165\u7684\u53c2\u6570\u4e00\u5b9a\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"Enum::Second"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The argument of the call to Enum::p is guaranteed to be Enum::Second.")),(0,l.kt)("h3",{id:"\u9898\u89e3-5"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a1"),(0,l.kt)("p",null,"\u5c55\u5f00\u9690\u85cf\u7684\u6761\u4ef6\uff0c\u8fd9\u6bb5 Enum \u7684\u5b9a\u4e49\u5176\u5b9e\u7b49\u540c\u4e8e\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Filling in the implicit discriminants, the definition of Enum is equivalent to:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"#[repr(u8)]\nenum Enum {\n    First = 0u8,\n    Second = 1u8,\n}\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"unsafe transmute")," \u53ea\u662f\u8f6c\u79fb\u4f60\u7684\u6ce8\u610f\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"#[repr(u8)]")," \u4f1a\u786e\u4fdd\u6211\u4eec\u7684\u7c7b\u578b\u548c u8 \u6709\u76f8\u540c\u7684\u5185\u5b58\u5e03\u5c40\uff0c\u800c ",(0,l.kt)("inlineCode",{parentName:"p"},"Enum::Second")," \u7684\u5224\u522b\u4f1a\u786e\u4fdd ",(0,l.kt)("inlineCode",{parentName:"p"},"Enum::Second")," \u548c 1u8 \u7684\u5e03\u5c40\u76f8\u540c\u3002\u56e0\u6b64\u8fd9\u91cc\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"transmute")," \u7684\u5b9a\u4e49\u660e\u786e\uff0c\u7b49\u4ef7\u4e8e ",(0,l.kt)("inlineCode",{parentName:"p"},"Enum::Second"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The unsafe transmute is a red herring. The attribute #","[repr(u8)]"," guarantees that our type has the same representation as u8, and the discriminant on Enum::Second guarantees that Enum::Second has the same representation as 1u8. The transmute is well-defined and evaluates to Enum::Second.")),(0,l.kt)("p",null,"\u5982\u679c\u65b9\u6cd5 p \u7684\u5b9a\u65f6\u662f\u8fd9\u6837\u7684\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If the method p had been written as:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'match self {\n    Enum::First => print!("1"),\n    Enum::Second => print!("2"),\n}\n')),(0,l.kt)("p",null,"\u8fd9\u4e2a\u7a0b\u5e8f\u4f1a\u6253\u5370 2\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"then this program would print 2.")),(0,l.kt)("p",null,"\u4f46\u662f\uff0c\u6a21\u5f0f\u5339\u914d\u91cc\u7684\u4e24\u4e2a\u5206\u652f\u90fd\u662f\u901a\u914d\u7b26\uff0c\u80fd\u591f\u5339\u914d\u5230\u4efb\u4f55\u503c\uff0c\u5e76\u628a\u5b83\u7ed1\u5b9a\u5230 First \u6216\u8005 Second \u4e0a\u3002\u6a21\u5f0f\u6309\u987a\u5e8f\u5339\u914d\uff0c\u6240\u4ee5\u8fd9\u91cc\u603b\u662f\u4f1a\u5339\u914d\u5230 First \u5206\u652f\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"However, as written, both arms of the match expression are wildcard matches that successfully match any value and bind a variable with the name First or Second. Match arms are applied in order so the wildcard match in the first arm is always the one matched.")),(0,l.kt)("p",null,"\u7f16\u8bd1\u5668\u4f1a\u7ed9\u6211\u4eec\u4e24\u6761\u8b66\u544a\u3002\u7b2c\u4e00\u4e2a\u662f\u5b83\u63cf\u8ff0\u4e86\u5339\u914d\u7684\u8fc7\u7a0b\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The compiler helps us out with not one but two relevant warnings. First it describes exactly how this match is parsed and why that is probably silly.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'warning: unreachable pattern\n  --\x3e questions/007.rs:11:13\n   |\n10 |             First => print!("1"),\n   |             ----- matches any value\n11 |             Second => print!("2"),\n   |             ^^^^^^ unreachable pattern\n')),(0,l.kt)("p",null,"\u7b2c\u4e8c\u4e2a\u662f\u7f16\u8bd1\u5668\u610f\u8bc6\u5230\u4e86\u7a0b\u5e8f\u5458\u53ef\u80fd\u5199\u9519\u4e86\u4ee3\u7801\uff0c\u5e76\u7ed9\u51fa\u4e86\u53ef\u80fd\u6b63\u786e\u7684\u63d0\u793a\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Second, it recognizes what the programmer has done wrong and what they probably meant to write instead.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'warning[E0170]: pattern binding `First` is named the same as one of the variants of the type `Enum`\n  --\x3e questions/007.rs:10:13\n   |\n10 |             First => print!("1"),\n   |             ^^^^^ help: to match on the variant, qualify the path: `Enum::First`\n')),(0,l.kt)("p",null,"\u5728\u6a21\u5f0f\u4e2d\u76f4\u63a5\u5199\u9650\u5b9a\u8def\u5f84\u7684\u65b9\u6cd5\u662f\u628a\u679a\u4e3e\u7684\u53d8\u4f53\u4e5f\u5f15\u5165\u4f5c\u7528\u57df\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"An alternative to writing qualified paths in the pattern is to bring the variants into scope.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'use Enum::*;\n\nmatch self {\n    First => print!("1"),\n    Second => print!("2"),\n}\n')),(0,l.kt)("p",null,"\u901a\u8fc7",(0,l.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/prelude/index.html"},"\u6807\u51c6\u5e93\u7684 prelude"),"\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u6a21\u5f0f\u5339\u914d\u4e2d\u76f4\u63a5\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"OK")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"Some")," (\u800c\u4e0d\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"Result::OK")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"Option::Some"),")\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Having variants brought into scope by the standard library prelude is what allows us to write Ok and Some in match arms, rather than the qualified paths Result::Ok and Option::Some.")),(0,l.kt)("h2",{id:"8---"},"#8 ",(0,l.kt)("inlineCode",{parentName:"h2"},"= = >")),(0,l.kt)("h3",{id:"\u9898\u76ee-7"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'macro_rules! m {\n    (==>) => { print!("1"); };\n    (= = >) => { print!("2"); };\n    (== >) => { print!("3"); };\n    (= =>) => { print!("4"); };\n}\n\nfn main() {\n    m!(==>);\n    m!(= = >);\n    m!(== >);\n    m!(= =>);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-7"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u6839\u636e ",(0,l.kt)("inlineCode",{parentName:"p"},"macro_rules!")," \u7684\u89c4\u5219\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"==")," \u662f\u4e00\u4e2a token\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"=>")," \u4e5f\u662f\u4e00\u4e2a token\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"According to macro_rules!, == is one token and => is one token.")),(0,l.kt)("h3",{id:"\u9898\u89e3-6"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a1214"),(0,l.kt)("p",null,"\u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"macro_rules!")," \u7684\u8f93\u5165\u6a21\u5f0f\u4e2d\uff0c\u76f8\u90bb\u7684\u6807\u70b9\u7b26\u53f7\u6839\u636e\u5b83\u4eec\u7684\u7528\u6cd5\u4e0d\u540c\uff0c\u4f1a\u88ab\u5212\u5206\u4e3a\u51e0\u7ec4\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Adjacent punctuation characters in the input pattern of a macro_rules! macro are grouped according to how those characters are used by native Rust tokens.")),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://docs.rs/syn/0.15.22/syn/token/index.html#structs"},"\u8fd9\u91cc"),"\u5217\u51fa\u4e86 Rust \u4e2d\u7684\u5355\u5b57\u7b26\u548c\u591a\u5b57\u7b26 token \u5217\u8868"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This page contains a list of the single-character and multi-character punctuation tokens involved in the Rust grammar.")),(0,l.kt)("p",null,"\u5217\u8868\u4e2d\u7684\u6709\u4e00\u4e2a\u4f8b\u5b50\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"<<=")," \u662f\u4e00\u4e2a token\uff0cRust \u8bed\u6cd5\u628a\u5b83\u4f5c\u4e3a\u5de6\u79fb\u8d4b\u503c\u3002\u56e0\u6b64\u5305\u542b ",(0,l.kt)("inlineCode",{parentName:"p"},"<<=")," \u7684\u4e00\u4e2a ",(0,l.kt)("inlineCode",{parentName:"p"},"macro_rules!")," \u8f93\u5165\uff0c\u53ea\u6709\u9047\u5230 ",(0,l.kt)("inlineCode",{parentName:"p"},"<<=")," \u4e14\u4e2d\u95f4\u6ca1\u6709\u7a7a\u683c\u65f6\u624d\u4f1a\u5339\u914d\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"As one example from that list, ",(0,l.kt)("inlineCode",{parentName:"p"},"<<=")," is a single token because the Rust grammar uses that sequence of characters to mean left shift assignment. Thus a macro_rules! input rule containing ",(0,l.kt)("inlineCode",{parentName:"p"},"<<=")," would only match if all three characters ",(0,l.kt)("inlineCode",{parentName:"p"},"<<=")," are written consecutively without spaces in the invocation.")),(0,l.kt)("p",null,"\u4f46\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"=<<")," \u5728 Rust \u8bed\u6cd5\u4e2d\u4e0d\u662f\u4e00\u4e2a native token\u3002macro_rules\uff01\u7684\u89e3\u6790\u5668\u4f1a\u6839\u636e\u8d2a\u5fc3\u5c06\u5176\u5206\u89e3\u4e3a Rust \u6807\u8bb0\u3002 ",(0,l.kt)("inlineCode",{parentName:"p"},"=<")," \u4e5f\u4e0d\u662f\u4e00\u4e2a native token\uff0c\u6240\u4ee5\u9996\u5148\u6211\u4eec\u9700\u8981\u5339\u914d\u4e00\u4e2a ",(0,l.kt)("inlineCode",{parentName:"p"},"=")," \u672c\u8eab\u3002\u7136\u540e\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"<<")," \u662f\u4e00\u4e2a native token\u3002\u5728\u5b8f\u89c4\u5219\u4e2d\u5199 ",(0,l.kt)("inlineCode",{parentName:"p"},"=<<")," \u7684\u884c\u4e3a\u4e0e\u5199 ",(0,l.kt)("inlineCode",{parentName:"p"},"= <<")," \u7684\u884c\u4e3a\u5b8c\u5168\u76f8\u540c\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"But for example ",(0,l.kt)("inlineCode",{parentName:"p"},"=<<")," is not a native token in the Rust grammar. The parser of macro_rules! will decompose this into Rust tokens according to a greedy process. ",(0,l.kt)("inlineCode",{parentName:"p"},"=<")," is also not a native token, so first we would need to match a ",(0,l.kt)("inlineCode",{parentName:"p"},"=")," by itself. Then ",(0,l.kt)("inlineCode",{parentName:"p"},"<<")," is a native token. Writing ",(0,l.kt)("inlineCode",{parentName:"p"},"=<<")," in a macro rule behaves exactly the same as writing ",(0,l.kt)("inlineCode",{parentName:"p"},"= <<"),".")),(0,l.kt)("p",null,"\u73b0\u5728\u8ba9\u6211\u4eec\u4ee5\u540c\u6837\u7684\u65b9\u5f0f\u5206\u89e3\u4ee3\u7801\u4e2d\u7684\u89c4\u5219\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Now let's decompose the rules in the quiz code the same way.")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"==>")," \u5206\u89e3\u4e3a ",(0,l.kt)("inlineCode",{parentName:"li"},"== >"),"\u3002"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"= = >")," \u5df2\u7ecf\u88ab\u5206\u89e3\u4e86\u3002"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"== >")," \u5df2\u7ecf\u88ab\u5206\u89e3\u4e86\u3002"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"= =>")," \u5df2\u7ecf\u88ab\u5206\u89e3\u4e86\u3002")),(0,l.kt)("p",null,"\u5728\u6211\u4eec\u7684\u5b8f\u91cc\uff0c\u7b2c\u4e00\u6761\u89c4\u5219\u52a0\u4e0d\u52a0\u7a7a\u683c\u662f\u4e00\u6837\u7684\u3002\u7b2c\u4e09\u6761\u89c4\u5219\u662f\u4e0d\u53ef\u8fbe\u7684\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Our macro is the same as if we had written the first rule with a space. The third rule is unreachable.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'macro_rules! m {\n    (== >) => { print!("1"); };\n    (= = >) => { print!("2"); };\n    (== >) => { print!("3"); };\n    (= =>) => { print!("4"); };\n}\n')),(0,l.kt)("p",null,"\u5728 main \u4e2d\uff0c\u7b2c\u4e00\u884c\u548c\u7b2c\u4e09\u884c\u90fd\u7b26\u5408\u7b2c\u4e00\u6761\u5b8f\u89c4\u5219\u3002\u7b2c\u4e8c\u884c\u5339\u914d\u7b2c\u4e8c\u6761\u89c4\u5219\uff0c\u7b2c\u56db\u884c\u5339\u914d\u7b2c\u56db\u6761\u89c4\u5219\u3002\u8f93\u51fa\u7ed3\u679c\u662f 1214\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Within main, the first and third lines both match the first macro rule. The second line matches the second rule and the fourth line matches the fourth rule. The output is 1214.")),(0,l.kt)("p",null,"\u8fc7\u7a0b\u5b8f\u4f7f\u7528\u66f4\u7075\u6d3b\u3001\u66f4\u5f3a\u5927\u7684\u5b8f API\uff0c\u5e76\u4e14\u603b\u662f\u80fd\u591f\u533a\u5206\u76f8\u540c\u5b57\u7b26\u7684\u4e0d\u540c\u95f4\u9694\uff0c\u4f8b\u5982 ",(0,l.kt)("inlineCode",{parentName:"p"},"== >")," \u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"==>"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Procedural macros use a more flexible and powerful macro API and can always distinguish between different spacings of the same characters, such as == > vs ==>.")),(0,l.kt)("h2",{id:"9-tttt"},"#9 ",(0,l.kt)("inlineCode",{parentName:"h2"},"$tt:tt")),(0,l.kt)("h3",{id:"\u9898\u76ee-8"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'macro_rules! m {\n    (1) => { print!("1") };\n    ($tt:tt) => { print!("2") };\n}\n\nmacro_rules! e {\n    ($e:expr) => { m!($e) };\n}\n\nmacro_rules! t {\n    ($tt:tt) => { e!($tt); m!($tt); };\n}\n\nfn main() {\n    t!(1);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-8"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u4e00\u65e6\u88ab\u5339\u914d\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"$:expr"),"\uff0c\u5339\u914d\u5230\u7684\u8868\u8fbe\u5f0f\u5c31\u53d8\u6210\u4e86\u4e00\u4e2a\u4e0d\u900f\u660e\u7684\u6807\u8bb0\u6811\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Upon being matched as a $:expr, the matched expression becomes a single opaque token tree.")),(0,l.kt)("h3",{id:"\u9898\u89e3-7"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a21"),(0,l.kt)("p",null,"\u8fd9\u4e2a\u95ee\u9898\u6d89\u53ca\u5230\u5b8f\u5339\u914d\u5668\u5728\u5339\u914d\u5b8f\u7684\u5143\u53d8\u91cf\u65f6\u7684\u884c\u4e3a\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This question involves the behavior of macro matchers as regards matching macro metavariables.")),(0,l.kt)("p",null,"\u4ece\u4ee3\u7801\u7684\u6700\u540e\u4e00\u884c\u770b\u8d77\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"t!(1)")," \u4f1a\u5339\u914d\u5230 ",(0,l.kt)("inlineCode",{parentName:"p"},"t!")," \u7684\u7b2c\u4e00\u6761\u89c4\u5219\uff0c\u7136\u540e\u5c55\u5f00\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"e!(1); m!(1);")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Starting from the bottom of the quiz code, the invocation t!(1) matches the first rule of t! and expands to e!(1); m!(1);.")),(0,l.kt)("p",null,"\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"e!(1)")," \u4f1a\u5339\u914d ",(0,l.kt)("inlineCode",{parentName:"p"},"e!")," \u7684\u7b2c\u4e00\u6761\u89c4\u5219\u3002\u4f5c\u4e3a\u8fd9\u4e2a\u5339\u914d\u7684\u4e00\u90e8\u5206\uff0c\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"1")," \u4f1a\u88ab\u6253\u5305\u6210\u4e00\u4e2a\u4e0d\u900f\u660e\u7684\u8868\u8fbe\u5f0f token\uff0c\u79f0\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"$e"),"\u3002\u5728\u63a5\u4e0b\u6765\u7684\u4efb\u4f55\u65f6\u5019\uff0c\u4efb\u4f55 ",(0,l.kt)("inlineCode",{parentName:"p"},"macro_rules\uff01"),"\u5b8f\u90fd\u4e0d\u53ef\u80fd\u67e5\u770b ",(0,l.kt)("inlineCode",{parentName:"p"},"$e")," \u7684\u5185\u90e8\uff0c\u552f\u4e00\u53ef\u4ee5\u77e5\u9053\u7684\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"$e")," \u662f\u67d0\u4e2a\u8868\u8fbe\u5f0f\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The invocation e!(1) matches the first rule of e!. As part of this match, the expression 1 is packaged into an opaque expression token called $e. At no subsequent point will it be possible for any macro_rules! macro to look inside of $e. All that can be known is that $e is some expression.")),(0,l.kt)("p",null,"\u5728\u4efb\u4f55\u60c5\u51b5\u4e0b\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"e!(1)")," \u90fd\u4f1a\u6269\u5c55\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"m!($e)"),"\uff0c\u5176\u4e2d ",(0,l.kt)("inlineCode",{parentName:"p"},"$e")," \u662f\u4e00\u4e2a\u5305\u542b ",(0,l.kt)("inlineCode",{parentName:"p"},"1")," \u7684\u4e0d\u900f\u660e\u8868\u8fbe\u5f0f\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"m!($e)")," \u5e76\u4e0d\u7b26\u5408 ",(0,l.kt)("inlineCode",{parentName:"p"},"m!")," \u7684\u7b2c\u4e00\u6761\u89c4\u5219\uff0c\u56e0\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"$e")," \u662f\u4e0d\u900f\u660e\u7684\u3002\u6240\u4ee5\u5b83\u5339\u914d\u4e86 ",(0,l.kt)("inlineCode",{parentName:"p"},"m!")," \u7684\u7b2c\u4e8c\u6761\u89c4\u5219\uff0c\u5e76\u6253\u5370\u51fa 2\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In any case, e!(1) expands to m!($e) where $e is an opaque expression containing 1. That m!($e) does not match the first rule of m! because $e is opaque. Instead it matches the second rule of m! and prints 2.")),(0,l.kt)("p",null,"\u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"e!(1)")," \u4e4b\u540e\u6709\u4e00\u4e2a\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"m!(1)")," \u7684\u8c03\u7528\uff0c\u6765\u81ea ",(0,l.kt)("inlineCode",{parentName:"p"},"t!")," \u7684\u5c55\u5f00\u3002\u8fd9\u4e2a\u8c03\u7528\u786e\u5b9e\u7b26\u5408 ",(0,l.kt)("inlineCode",{parentName:"p"},"m!")," \u7684\u7b2c\u4e00\u6761\u89c4\u5219\uff0c\u5e76\u6253\u5370\u51fa 1\u3002\u6240\u4ee5\u8fd9\u4e2a\u7a0b\u5e8f\u7684\u8f93\u51fa\u662f 21\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"After e!(1) there is an invocation m!(1) coming from the expansion of t!. That one does match the first rule of m! and prints 1. The output of this program is 21.")),(0,l.kt)("p",null,"\u5927\u591a\u6570\u7247\u6bb5\u5206\u7c7b\u7b26\u90fd\u6709\u8fd9\u79cd\u53d8\u4e3a\u4e0d\u900f\u660e token \u7684\u884c\u4e3a\uff0c\u4f46\u6709\u4e9b\u6ca1\u6709\u3002\u4e00\u65e6\u5339\u914d\u5230\u5c31\u53d8\u4e3a\u4e0d\u900f\u660e token \u7684\u7247\u6bb5\u5206\u7c7b\u7b26\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Most fragment specifiers have this behavior of becoming opaque token boxes, but some do not. Specifiers that are opaque once matched:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"$:block\n$:expr\n$:item\n$:literal\n$:meta\n$:pat\n$:path\n$:stmt\n$:ty\n")),(0,l.kt)("p",null,"\u5269\u4e0b\u7684\u7247\u6bb5\u5206\u7c7b\u7b26\u5339\u914d\u6210\u529f\u540e\u4e0d\u4f1a\u53d8\u4e3a\u4e0d\u900f\u660e\u7684\uff0c\u53ef\u4ee5\u88ab\u540e\u7eed\u7684\u89c4\u5219\u68c0\u67e5\u5230\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The rest of the specifiers do not become opaque and can be inspected by subsequent rules:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"$:ident\n$:lifetime\n$:tt\n")),(0,l.kt)("p",null,"\u6bd4\u5982\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"For example:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"macro_rules! m {\n    ('a) => {};\n}\n\nmacro_rules! l {\n    ($l:lifetime) => {\n        // $l is not opaque.\n        m!($l);\n    }\n}\n\nl!('a);\n")),(0,l.kt)("h2",{id:"10-traitf"},"#10 ",(0,l.kt)("inlineCode",{parentName:"h2"},"Trait::f")),(0,l.kt)("h3",{id:"\u9898\u76ee-9"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'trait Trait {\n    fn f(&self);\n}\n\nimpl<\'a> dyn Trait + \'a {\n    fn f(&self) {\n        print!("1");\n    }\n}\n\nimpl Trait for bool {\n    fn f(&self) {\n        print!("2");\n    }\n}\n\nfn main() {\n    Trait::f(&true);\n    Trait::f(&true as &dyn Trait);\n    <_ as Trait>::f(&true);\n    <_ as Trait>::f(&true as &dyn Trait);\n    <bool as Trait>::f(&true);\n    <dyn Trait as Trait>::f(&true as &dyn Trait);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-9"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u8fd9\u5e76\u4e0d\u80fd\u5e2e\u52a9\u4f60\u89e3\u51b3\u95ee\u9898\uff0c\u4f46\u53ef\u80fd\u4f1a\u8ba9\u4f60\u597d\u53d7\u4e9b\uff1a\u4f5c\u8005\u4e5f\u88ab\u8fd9\u4e2a\u95ee\u9898\u96be\u4f4f\u4e86\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This won't help you answer the question but may help feel better: the quiz author was also stumped by this one.")),(0,l.kt)("h3",{id:"\u9898\u89e3-8"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a222222"),(0,l.kt)("p",null,"\u8fd9\u9053\u9898\u91cc\u6709\u4e00\u4e2a Trait \u65b9\u6cd5 ",(0,l.kt)("inlineCode",{parentName:"p"},"Trait::f"),"\uff0c\u540c\u65f6\u8fd8\u6709\u7279\u5f81\u5bf9\u8c61 ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Trait")," \u7684 f \u65b9\u6cd5\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This question contains a trait method ",(0,l.kt)("inlineCode",{parentName:"p"},"Trait::f")," as well as an inherent method f on the trait object type dyn Trait.")),(0,l.kt)("p",null,"\u636e\u6211\u6240\u77e5\uff0c\u9274\u4e8e\u8fd9\u4e9b\u540d\u5b57\u4f1a\u76f8\u4e92\u906e\u853d\uff0c\u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Trait")," \u5b9e\u73b0\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," \u65b9\u6cd5\u5b9e\u9645\u4e0a\u662f\u65e0\u6cd5\u8c03\u7528\u7684\u3002\u76ee\u524d\uff0cRust \u4e2d\u6ca1\u6709\u4efb\u4f55\u8bed\u6cd5\u53ef\u4ee5\u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Trait")," \u4e0a\u8c03\u7528\u5b83\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"As far as I know, given that these names shadow each other, the inherent method is literally uncallable. There is currently no syntax in Rust for calling the inherent f on dyn Trait.")),(0,l.kt)("p",null,"\u5982\u679c trait \u65b9\u6cd5\u7684\u540d\u5b57\u53ef\u4ee5\u4ee5\u4e0d\u540c\u7684\u65b9\u5f0f\u547d\u540d\uff0c\u5e76\u4e14\u53ea\u6709 ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Trait")," \u7684\u65b9\u6cd5\u88ab\u79f0\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),"\uff0c\u90a3\u4e48 main \u7684\u524d\u4e24\u884c\u5c31\u4f1a\u6210\u529f\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Trait")," \u7684\u65b9\u6cd5\u3002\u7136\u800c\uff0c\u7531\u4e8e\u5199\u7684\u662f\u88ab\u906e\u853d\u7684\u540d\u5b57\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u6b67\u4e49\uff0c\u6700\u540e\u8c03\u7528\u7684\u662f Trait \u7684\u65b9\u6cd5\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If the trait method were named something different and only the inherent method were called f, then the first two lines of main would successfully call the inherent method. However, as written with shadowed names, they disambiguate to the trait method.")),(0,l.kt)("p",null,"\u8fd8\u6709\u4e00\u79cd\u53ef\u4ee5\u5c1d\u8bd5\u7684\u8bed\u6cd5\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"One additional syntax to try would be:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"<dyn Trait>::f(&true);\n<dyn Trait>::f(&true as &dyn Trait);\n")),(0,l.kt)("p",null,"\u5982\u679c\u7279\u5f81\u65b9\u6cd5\u7684\u547d\u540d\u4e0d\u540c\uff0c\u8fd9\u4e24\u4e2a\u8c03\u7528\u90fd\u4f1a\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Trait")," \u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," \u65b9\u6cd5\u3002\u5982\u679c ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Trait")," \u7684\u65b9\u6cd5\u88ab\u547d\u540d\u4e3a\u4e0d\u540c\u7684\u4e1c\u897f\uff0c\u8fd9\u4e24\u4e2a\u65b9\u6cd5\u90fd\u4f1a\u8c03\u7528 Trait \u65b9\u6cd5\u3002\u4f46\u662f\u5982\u679c ",(0,l.kt)("inlineCode",{parentName:"p"},"Trait")," \u65b9\u6cd5\u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Trait")," \u65b9\u6cd5\u90fd\u53eb\u4f5c f\uff0c\u90a3\u4e48\u7f16\u8bd1\u5668\u4f1a\u62a5\u544a\u4e00\u4e2a\u6b67\u4e49\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If the trait method were named something different, both of these would call the inherent method. If the inherent method were named something different, both of these would call the trait method. But if the trait method and the inherent method are both f then the compiler reports an ambiguity.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"error[E0034]: multiple applicable items in scope\n  --\x3e questions/010.rs:18:5\n   |\n18 |     <dyn Trait>::f(&true);\n   |     ^^^^^^^^^^^^^^ multiple `f` found\n   |\nnote: candidate #1 is defined in an impl for the type `dyn Trait`\n  --\x3e questions/010.rs:6:5\n   |\n6  |     fn f(&self) {\n   |     ^^^^^^^^^^^\nnote: candidate #2 is defined in the trait `Trait`\n  --\x3e questions/010.rs:2:5\n   |\n2  |     fn f(&self);\n   |     ^^^^^^^^^^^^\n   = help: to disambiguate the method call, write `Trait::f(...)` instead\n")),(0,l.kt)("p",null,"\u4e5f\u8bb8\u6709\u4e00\u5929\uff0c\u5728\u4e00\u4e2a\u88ab\u7279\u5f81\u65b9\u6cd5\u6240\u906e\u853d\u7684\u7279\u5f81\u5bf9\u8c61\u4e0a\u8c03\u7528\u5b83\u7684\u65b9\u6cd5\u53ef\u80fd\u6d88\u9664\u6b67\u4e49\u3002\u4f46\u662f\u73b0\u5728\uff0c\u4ee3\u7801\u53ea\u80fd\u6253\u5370\u51fa 222222\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Maybe some day it will be possible to disambiguate a call to an inherent method on a trait object shadowed by a trait method. For now, the quiz code prints 222222.")),(0,l.kt)("h2",{id:"11-early--late-bound"},"#11 ",(0,l.kt)("inlineCode",{parentName:"h2"},"early & late bound")),(0,l.kt)("h3",{id:"\u9898\u76ee-10"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"fn f<'a>() {}\nfn g<'a: 'a>() {}\n\nfn main() {\n    let pf = f::<'static> as fn();\n    let pg = g::<'static> as fn();\n    print!(\"{}\", pf == pg);\n}\n")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-10"},"\u63d0\u793a"),(0,l.kt)("p",null,"f \u548c g \u7684\u5199\u6cd5\u662f\u4e0d\u80fd\u4e92\u6362\u7684\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The way that f and g are written is not interchangeable.")),(0,l.kt)("h3",{id:"\u9898\u89e3-9"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("p",null,"\u6bd4\u8f83\u51fd\u6570\u6307\u9488\u662f\u4e00\u4e2a\u574f\u4e3b\u610f\u3002\u5728\u4f18\u5316\u540e\u7684\u6784\u5efa\u4e2d\uff0c\u5f88\u5bb9\u6613\u51fa\u73b0\u65e0\u610f\u4e49\u7684\u884c\u4e3a\u3002\u5173\u4e8e\u8fd9\u79cd\u884c\u4e3a\u7684\u4e00\u4e2a\u4ee4\u4eba\u77a0\u76ee\u7ed3\u820c\u7684\u4f8b\u5b50\uff0c\u8bf7\u770b ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/rust/issues/54685"},"rust-lang/rust#54685"),"\uff0c\u5176\u4e2d x == y \u540c\u65f6\u4e3a\u771f\uff0c\u53c8\u4e0d\u4e3a\u771f\u3002(\u8bd1\u8005\u6ce8\uff1a\u8be5\u95ee\u9898\u5df2\u4fee\u590d)"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Function pointer comparison is generally a Bad Idea. It is easily possible to get nonsensical behavior in optimized builds. For a jaw-dropping example of such behavior, check out rust-lang/rust#54685 in which x == y is both true and not true at the same time.")),(0,l.kt)("p",null,"\u90a3\u5c31\u662f\u8bf4\uff0c\u8fd9\u6bb5\u4ee3\u7801\u7f16\u8bd1\u5931\u8d25\u3002\u4e0b\u9762\u662f\u7f16\u8bd1\u7684\u8f93\u51fa\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"That said, the quiz code in this question fails to compile. Here is the compiler output:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n --\x3e questions/011.rs:5:18\n  |\n5 |     let pf = f::<'static> as fn();\n  |                  ^^^^^^^\n  |\nnote: the late bound lifetime parameter is introduced here\n --\x3e questions/011.rs:1:18\n  |\n1 | fn f<'a>() {}\n  |      ^^\n")),(0,l.kt)("p",null,"\u6cdb\u578b\u53c2\u6570\u53ef\u4ee5\u662f\u65e9\u7ed1\u5b9a\u4e5f\u53ef\u4ee5\u662f\u665a\u7ed1\u5b9a\u3002\u76ee\u524d (\u4ee5\u53ca\u53ef\u4ee5\u9047\u89c1\u7684\u672a\u6765) \u7c7b\u578b\u53c2\u6570\u90fd\u662f\u65e9\u7ed1\u5b9a\uff0c\u4f46\u662f\u751f\u547d\u5468\u671f\u53c2\u6570\u4e24\u8005\u90fd\u6709\u53ef\u80fd\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Generic parameters can be either early bound or late bound. Currently (and for the foreseeable future) type parameters are always early bound, but lifetime parameters can be either early or late bound.")),(0,l.kt)("p",null,"\u65e9\u7ed1\u5b9a\u662f\u5728\u7f16\u8bd1\u5668\u5728\u5355\u6001\u5316\u8fc7\u7a0b\u4e2d\u51b3\u5b9a\u7684\u3002\u56e0\u4e3a\u7c7b\u578b\u53c2\u6570\u603b\u662f\u65e9\u7ed1\u5b9a\uff0c\u4f60\u4e0d\u80fd\u62e5\u6709\u4e00\u4e2a\u6cdb\u578b\u672a\u6307\u5b9a\u7684\u503c\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Early bound parameters are determined by the compiler during monomorphization. Since type parameters are always early bound, you cannot have a value whose type has an unresolved type parameter. For example:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"fn m<T>() {}\n\nfn main() {\n    let m1 = m::<u8>; // ok\n    let m2 = m; // error: cannot infer type for `T`\n}\n")),(0,l.kt)("p",null,"\u4f46\u662f\uff0c\u5bf9\u4e8e\u751f\u547d\u5468\u671f\u662f\u5408\u6cd5\u7684\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"However, this is often allowed for lifetime parameters:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"fn m<'a>(_: &'a ()) {}\n\nfn main() {\n    let m1 = m; // \u5373\u4f7f\u6ca1\u6709\u63d0\u4f9b 'a \u4e5f\u53ef\u4ee5\n}\n")),(0,l.kt)("p",null,"\u56e0\u4e3a 'a \u7684\u5177\u4f53\u53d6\u503c\u53d6\u51b3\u4e0e\u5b83\u5982\u4f55\u88ab\u8c03\u7528\uff0c\u7528\u6237\u53ef\u4ee5\u7701\u7565\u751f\u547d\u5468\u671f\u53c2\u6570\uff0c\u4ed6\u4f1a\u5728\u8c03\u7528\u662f\u51b3\u5b9a\u3002\u751f\u547d\u5468\u671f\u751a\u81f3\u53ef\u4ee5\u5728\u6bcf\u6b21\u8c03\u7528\u65f6\u90fd\u4e0d\u4e00\u6837\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Since the actual choice of lifetime 'a depends on how it is called, we are allowed to omit the lifetime parameter and it will be determined at the call site. The lifetime can even be different for each time it gets called.")),(0,l.kt)("p",null,"\u9274\u4e8e\u6b64\uff0c\u6211\u4eec\u4e0d\u80fd\u5728\u8c03\u7528\u524d\u6307\u5b9a\u51fd\u6570\u4e0a\u7684\u751f\u547d\u5468\u671f\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"For this reason, we cannot specify the lifetime on this function until it is called:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\nlet m2 = m::<'static>;\n")),(0,l.kt)("p",null,"\u6211\u4eec\u751a\u81f3\u4e0d\u80fd\u8ba9\u501f\u7528\u68c0\u67e5\u5668\u63d0\u524d\u81ea\u52a8\u63a8\u65ad\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"We may not even ask the borrow checker to infer it too soon:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\nlet m3 = m::<'_>;\n")),(0,l.kt)("p",null,'\u665a\u7ed1\u5b9a\u53c2\u6570\u7684\u6982\u5ff5\u4e0e Rust \u4e2d\u7684\u53e6\u4e00\u4e2a\u7279\u6027 "\u9ad8\u9636\u751f\u547d\u5468\u671f" \u6709\u4e9b\u91cd\u590d\u3002\u8fd9\u662f\u4e00\u79cd\u7528\u4e8e\u8868\u8fbe\u7279\u5f81\u53c2\u6570\u7684\u8fb9\u754c\u662f\u665a\u7ed1\u5b9a\u7684\u673a\u5236\u3002\u76ee\u524d\u8fd9\u53ea\u9650\u4e8e\u751f\u547d\u5468\u671f\u53c2\u6570\uff0c\u4f46\u5728\u5176\u4ed6\u8bed\u8a00\uff08\u5982 Haskell\uff09\u4e2d\u4e5f\u5b58\u5728\u540c\u6837\u7684\u60f3\u6cd5\uff0c\u7528\u4e8e\u7c7b\u578b\u53c2\u6570\uff0c\u8fd9\u5c31\u662f "\u9ad8\u7ea7" \u4e00\u8bcd\u7684\u7531\u6765\u3002'),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'The idea of late bound parameters overlaps considerably with a feature of Rust called "higher ranked trait bounds" (HRTB). This is a mechanism for expressing that bounds on a trait\'s parameters are late bound. Currently this is limited to lifetime parameters, but the same idea exists in other languages (such as Haskell) for type parameters, which is where the term "higher ranked" comes from.')),(0,l.kt)("p",null,"\u8868\u8fbe HRTB \u7684\u8bed\u6cd5\u9700\u8981\u4f7f\u7528 for \u5173\u952e\u5b57\u3002\u4e3a\u4e86\u8868\u8fbe\u4e0a\u9762 m1 \u7684\u7c7b\u578b\uff0c\u4f60\u53ef\u4ee5\u8fd9\u4e48\u5199\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The syntax to express a HRTB for lifetimes uses the for keyword. To express the type of m1 above, we could have written:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"let m1: impl for<'r> Fn(&'r ()) = m;\n")),(0,l.kt)("p",null,'\u4f60\u53ef\u4ee5\u628a\u5b83\u770b\u6210\uff1a"\u8fd9\u91cc\u6709\u4e00\u4e2a\u751f\u547d\u5468\u671f\u53c2\u6570\uff0c\u4f46\u662f\u76ee\u524d\u6211\u4eec\u4e0d\u9700\u8981\u77e5\u9053\u5b83\u5177\u4f53\u662f\u4ec0\u4e48".'),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'You can think of this as meaning: "There is a lifetime but we don\'t need to know what it is just yet".')),(0,l.kt)("p",null,"\u665a\u7ed1\u5b9a\u7684\u751f\u547d\u5468\u671f\u662f\u65e0\u9650\u5236\u7684\uff1b\u6ca1\u6709\u660e\u786e\u7684\u8bed\u6cd5\u6765\u8868\u8fbe\u4e00\u4e2a\u665a\u7ed1\u5b9a\u7684\u751f\u547d\u5468\u671f\u5fc5\u987b\u8d85\u8fc7\u5176\u4ed6\u7684\u751f\u547d\u5468\u671f\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Late bound lifetimes are always unbounded; there is no syntax for expressing a late bound lifetime that must outlive some other lifetime.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"error: lifetime bounds cannot be used in this context\n --\x3e src/main.rs:5:20\n  |\n5 |     let _: for<'b: 'a> fn(&'b ());\n  |                    ^^\n")),(0,l.kt)("p",null,"\u6570\u636e\u7c7b\u578b\u4e0a\u7684\u751f\u547d\u5468\u671f\u603b\u662f\u65e9\u7ed1\u5b9a\uff0c\u9664\u975e\u5f00\u53d1\u8005\u660e\u786e\u4f7f\u7528 HRBT \u7684\u8bed\u6cd5\u3002\u5728\u51fd\u6570\u4e0a\uff0c\u751f\u547d\u5468\u671f\u9ed8\u8ba4\u662f\u665a\u7ed1\u5b9a\uff0c\u5728\u4e0b\u5217\u60c5\u51b5\u4e0b\u53ef\u4ee5\u662f\u65e9\u7ed1\u5b9a\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Lifetimes on data types are always early bound except when the developer has explicitly used the HRTB for syntax. On functions, lifetimes are late bound by default but can be early bound if:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u751f\u547d\u5468\u671f\u5728\u51fd\u6570\u7b7e\u540d\u4e4b\u5916\u58f0\u660e\uff0c\u4f8b\u5982\uff0c\u5728\u4e00\u4e2a\u7ed3\u6784\u4f53\u7684\u65b9\u6cd5\u4e2d;\u6216\u8005"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"The lifetime is declared outside the function signature, e.g. in an associated method of a struct it could be from the struct itself; or"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u751f\u547d\u5468\u671f\u53c2\u6570\u88ab\u5176\u4ed6\u4e00\u4e9b\u66f4\u957f\u7684\u751f\u547d\u5468\u671f\u6240\u7ea6\u675f\u3002\u6b63\u5982\u6211\u4eec\u6240\u770b\u5230\u7684\uff0c\u8fd9\u79cd\u7ea6\u675f\u5728 HRTB \u4e2d\u662f\u65e0\u6cd5\u8868\u8fbe\u7684\uff0c\u56e0\u4e3a HRTB \u4f1a\u6d89\u53ca\u5230\u751f\u547d\u5468\u671f\u7684\u665a\u7ed1\u5b9a\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"The lifetime parameter is bounded below by some other lifetime that it must outlive. As we've seen, this constraint is not expressible in the HRTB that would be involved in late binding the lifetime.")))),(0,l.kt)("p",null,"\u6839\u636e\u8fd9\u4e9b\u89c4\u5219\uff0c\u7b7e\u540d ",(0,l.kt)("inlineCode",{parentName:"p"},"fn f<'a>()")," \u6709\u4e00\u4e2a\u665a\u671f\u7ed1\u5b9a\u7684\u751f\u547d\u5468\u671f\u53c2\u6570\uff0c\u800c\u7b7e\u540d ",(0,l.kt)("inlineCode",{parentName:"p"},"fn g<'a: 'a>()")," \u6709\u4e00\u4e2a\u65e9\u7ed1\u5b9a\u7684\u751f\u547d\u5468\u671f\u53c2\u6570 -- \u5c3d\u7ba1\u8fd9\u91cc\u7684\u7ea6\u675f\u662f\u65e0\u6548\u7684\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"By these rules, the signature fn f<'a>() has a late bound lifetime parameter while the signature fn g<'a: 'a>() has an early bound lifetime parameter \u2014 even though the constraint here is ineffectual.")),(0,l.kt)("p",null,"\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u8fd9\u4e9b\u533a\u522b\u662f\u7f16\u8bd1\u5668\u5185\u90e8\u7684\u672f\u8bed\uff0cRust \u7a0b\u5e8f\u5458\u5728\u65e5\u5e38\u7f16\u5199\u4ee3\u7801\u65f6\u5e76\u4e0d\u9700\u8981\u4e86\u89e3\u6216\u601d\u8003\u8fd9\u4e9b\u672f\u8bed\u3002\u53ea\u6709\u5728\u5c11\u6570\u8fb9\u7f18\u60c5\u51b5\u4e0b\uff0c\u7c7b\u578b\u7cfb\u7edf\u7684\u8fd9\u4e2a\u65b9\u9762\u5728\u8bed\u8a00\u4e2d\u662f\u53ef\u4ee5\u89c2\u5bdf\u5230\u7684\uff0c\u6bd4\u5982\u5728\u8fd9\u9053 Quiz \u7684\u4ee3\u7801\u4e2d\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Ordinarily these distinctions are compiler-internal terminology that Rust programmers are not intended to know about or think about in everyday code. There are only a few edge cases where this aspect of the type system becomes observable in the surface language, such as in the original quiz code.")),(0,l.kt)("h2",{id:"12-let-s--x----s"},"#12 ",(0,l.kt)("inlineCode",{parentName:"h2"},"let S { x, .. } = S")),(0,l.kt)("h3",{id:"\u9898\u76ee-11"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'struct D(u8);\n\nimpl Drop for D {\n    fn drop(&mut self) {\n        print!("{}", self.0);\n    }\n}\n\nstruct S {\n    d: D,\n    x: u8,\n}\n\nfn main() {\n    let S { x, .. } = S {\n        d: D(1),\n        x: 2,\n    };\n    print!("{}", x);\n\n    let S { ref x, .. } = S {\n        d: D(3),\n        x: 4,\n    };\n    print!("{}", x);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-11"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u6a21\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"S { ref x, .. }")," \u4ece S \u7c7b\u578b\u7684\u503c\u7684\u6240\u6709\u8005\u90a3\u91cc\u501f\u7528\u4e86\u4e00\u4e2a x \u6210\u5458\uff0c\u5e76\u7ed1\u5b9a\u5230\u4e86\u53d8\u91cf x \u4e0a\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The pattern ",(0,l.kt)("inlineCode",{parentName:"p"},"S { ref x, .. }")," borrows a binding x from the owner of a value of type S.")),(0,l.kt)("h3",{id:"\u9898\u89e3-10"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a1243"),(0,l.kt)("p",null,"\u6a21\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"S { ref x, .. }")," \u4ece S \u7c7b\u578b\u7684\u503c\u7684\u6240\u6709\u8005\u90a3\u91cc\u501f\u7528\u4e00\u4e2a\u7ed1\u5b9a\u7684 x\u3002\u8fd9\u4e2a\u95ee\u9898\u6d89\u53ca\u5230 drop \u89e6\u53d1\u7684\u4f4d\u7f6e\u3002D \u5728\u54ea\u91cc\u88ab drop\uff1f"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This question involves drop-placement. Where does D get dropped?")),(0,l.kt)("p",null,'\u5728\u7b2c\u4e00\u4e2a let-binding \u4e2d\uff0c\u6211\u4eec\u5c06\u4e00\u4e2a S \u7c7b\u578b\u7684\u503c\u89e3\u6784\u4e3a\u5b83\u7684 u8 \u7c7b\u578b\u7684\u5b57\u6bb5 x \u4ee5\u53ca\u4ee3\u8868 "S \u7684\u5176\u4f59\u90e8\u5206" \u7684 ',(0,l.kt)("inlineCode",{parentName:"p"},".."),"\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"..")," \u4f1a\u7acb\u5373\u88ab drop\uff0c\u56e0\u4e3a\u5b83\u4e0d\u518d\u6709\u6240\u6709\u8005\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'In the first let-binding, we destructure a value of type S into its field x of type u8 as well as .. which represents "the rest of S". The part that is the rest of S is dropped immediately at that point because it no longer has an owner.')),(0,l.kt)("p",null,"\u5728\u7b2c\u4e8c\u4e2a let-binding \u4e2d\uff0c\u6211\u4eec\u4ece S \u7c7b\u578b\u7684\u503c\u7684\u6240\u6709\u8005\u90a3\u91cc\u501f\u7528\u4e00\u4e2a\u5b57\u6bb5 x\u3002\u5728\u5b57\u6bb5 x \u88ab\u501f\u7528\u671f\u95f4\uff0c\u6574\u4e2a S \u7c7b\u578b\u7684\u503c\u5c06\u4fdd\u6301\u5728\u4f5c\u7528\u57df\u5185\uff0c\u5e76\u5728 main \u7684\u95ed\u5408\u5927\u62ec\u53f7\u5904\u9000\u51fa\u4f5c\u7528\u57df\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In the second let-binding, we borrow a field x from the owner of a value of type S. The whole value of type S remains in scope during the time that its field x is borrowed, and goes out of scope at the close curly brace of main.")),(0,l.kt)("p",null,"\u6700\u540e\u7684\u8f93\u51fa\u662f 1243\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The output is 1243.")),(0,l.kt)("h2",{id:"13-eq"},"#13 ",(0,l.kt)("inlineCode",{parentName:"h2"},"eq")),(0,l.kt)("h3",{id:"\u9898\u76ee-12"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'struct S;\n\nfn main() {\n    let [x, y] = &mut [S, S];\n    let eq = x as *mut S == y as *mut S;\n    print!("{}", eq as u8);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-12"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u4e24\u4e2a\u53ef\u53d8\u5f15\u7528\u6307\u5411\u540c\u4e00\u4e2a\u5185\u5b58\u4f4d\u7f6e\u53ef\u4ee5\u5417\uff1f\u4f1a\u51fa\u4ec0\u4e48\u95ee\u9898\u5462\uff1f"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Is it okay for two mutable references to point to the same memory location? What could go wrong?")),(0,l.kt)("h3",{id:"\u9898\u89e3-11"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a1"),(0,l.kt)("p",null,"\u5728\u8fd9\u6bb5\u4ee3\u7801\u4e2d\uff0cS \u662f\u4e00\u4e2a\u96f6\u5927\u5c0f\u7c7b\u578b\u3002\u96f6\u5927\u5c0f\u7c7b\u578b\u662f\u7f16\u8bd1\u65f6\u7684\u6982\u5ff5\uff0c\u5728\u7f16\u8bd1\u8fc7\u7a0b\u4e2d\u4f1a\u6d88\u5931\uff0c\u5728\u8fd0\u884c\u65f6\u4f1a\u4ee5\u96f6\u5b57\u8282\u8868\u793a\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In this code, S is a zero sized type or ZST. Zero sized types are compile-time concepts that disappear during compilation and have a runtime representation of zero bytes.")),(0,l.kt)("p",null,"main \u7684\u7b2c\u4e00\u884c\u521b\u5efa\u4e86\u4e00\u4e2a\u7c7b\u578b\u4e3a ","[S; 2]"," \u7684\u672c\u5730\u503c\u3002\u8ba9\u6211\u4eec\u628a\u8fd9\u4e2a\u4e34\u65f6\u503c\u79f0\u4e3a tmp\u3002let-binding \u5728 tmp \u4e2d\u7ed1\u5b9a\u4e86\u4e24\u4e2a\u5f15\u7528\uff0cx \u6307\u7684\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"&mut tmp[0]"),"\uff0cy \u6307\u7684\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"&mut tmp[1]"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The first line of main creates a local value of type ","[S; 2]",". Let's refer to that temporary as tmp. The let-binding binds two references into tmp, x referring to &mut tmp","[0]"," and y referring to &mut tmp","[1]",".")),(0,l.kt)("p",null,"\u5728 main \u7684\u7b2c\u4e8c\u884c\uff0c\u6211\u4eec\u60f3\u77e5\u9053\u4f5c\u4e3a\u6307\u9488\u7684 x \u548c y \u662f\u5426\u6709\u76f8\u540c\u7684\u503c\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"On the second line of main we want to know whether x and y as pointers have the same value.")),(0,l.kt)("p",null,"\u6570\u7ec4\u7c7b\u578b ",(0,l.kt)("inlineCode",{parentName:"p"},"[S; 2]")," \u672c\u8eab\u5c31\u662f\u4e00\u4e2a\u96f6\u5927\u5c0f\u7684\u7c7b\u578b\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u6253\u5370 ",(0,l.kt)("inlineCode",{parentName:"p"},"std::mem::size_of::<[S; 2]>()")," \u7684\u503c\u6765\u786e\u8ba4\u8fd9\u70b9\u3002\u4e8b\u5b9e\u4e0a\uff0c\u6570\u7ec4\u7684\u7b2c\u4e00\u4e2a\u548c\u7b2c\u4e8c\u4e2a\u5143\u7d20\u6709\u76f8\u540c\u7684\u5185\u5b58\u5730\u5740\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The array type ",(0,l.kt)("inlineCode",{parentName:"p"},"[S; 2]")," is itself a zero sized type. You can confirm this by printing the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"std::mem::size_of::<[S; 2]>()"),". Indeed the first and second element of the array have the same memory address.")),(0,l.kt)("p",null,"\u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u5bf9\u540c\u4e00\u5185\u5b58\u4f4d\u7f6e\u6709\u591a\u4e2a\u53ef\u53d8\u5f15\u7528\u662f\u4e0d\u5b89\u5168\u7684\uff0c\u4f46\u662f\u5728\u5bf9\u96f6\u5927\u5c0f\u7c7b\u578b\u7684\u53ef\u53d8\u5f15\u7528\u7684\u60c5\u51b5\u4e0b\uff0c\u89e3\u5f15\u7528\u662f\u4e0d\u53ef\u884c\u7684\uff0c\u6240\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u6ca1\u6709\u8fdd\u53cd\u4efb\u4f55\u5185\u5b58\u5b89\u5168\u4fdd\u8bc1\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Ordinarily having multiple mutable references to the same memory location would not be safe, but in the case of mutable references to zero sized types, dereferencing is a no-op so there is no way to violate any memory safety guarantees this way.")),(0,l.kt)("h2",{id:"14-trait-scope"},"#14 ",(0,l.kt)("inlineCode",{parentName:"h2"},"trait scope")),(0,l.kt)("h3",{id:"\u9898\u76ee-13"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'trait Trait: Sized {\n    fn is_reference(self) -> bool;\n}\n\nimpl<\'a, T> Trait for &\'a T {\n    fn is_reference(self) -> bool {\n        true\n    }\n}\n\nfn main() {\n    match 0.is_reference() {\n        true => print!("1"),\n        false => print!("0"),\n    }\n\n    match \'?\'.is_reference() {\n        true => print!("1"),\n        false => {\n            impl Trait for char {\n                fn is_reference(self) -> bool {\n                    false\n                }\n            }\n            print!("0")\n        }\n    }\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-13"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u5728\u8fd9\u4e2a ",(0,l.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/28552082/6086311"},"Stack Overflow")," \u7684\u7b54\u6848\u4e2d\u6d89\u53ca\u5230 trait \u65b9\u6cd5\u7684\u81ea\u52a8\u5f15\u7528\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Trait method auto-ref is covered in this Stack Overflow answer.")),(0,l.kt)("h3",{id:"\u9898\u89e3-12"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a10"),(0,l.kt)("p",null,"\u7a0b\u5e8f\u4e2d\u6240\u6709\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"Trait impls")," \u90fd\u662f\u5728\u4f5c\u7528\u57df\u5185\u7684\uff0c\u6240\u4ee5\u5728\u4e00\u4e2a\u4ee3\u7801\u5757\u5185\u7f16\u5199\u7684\u5bf9 char \u7684 Trait impl \u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u3002\u7279\u522b\u662f\uff0c\u8fd9\u4e2a impl \u5728\u6574\u4e2a\u7a0b\u5e8f\u4e2d\u90fd\u662f\u53ef\u89c1\u7684\uff0c\u800c\u4e0d\u4ec5\u4ec5\u662f\u5728\u5305\u542b\u8be5 impl \u7684\u4ee3\u7801\u5757\u4e2d\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Trait impls anywhere in a program are always in scope, so there is no significance to the impl Trait for char being written inside of a block of code. In particular, that impl is visible throughout the whole program, not just within the block containing the impl.")),(0,l.kt)("p",null,"\u8fd9\u4e2a\u95ee\u9898\u4e0e trait \u65b9\u6cd5\u81ea\u52a8\u5f15\u7528\u7684\u884c\u4e3a\u6709\u5173\uff0c\u8fd9\u4e2a\u95ee\u9898\u5728 ",(0,l.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/28552082/6086311"},"Stack Overflow")," \u7684\u7b54\u6848\u4e2d\u6709\u6240\u6d89\u53ca\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This question relates to the behavior of trait method auto-ref which is covered in this Stack Overflow answer.")),(0,l.kt)("p",null,"\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"0.is_reference()")," \u7684\u8c03\u7528\u89c2\u5bdf\u5230\u6ca1\u6709\u4e00\u4e2a\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u7684\u4e3a\u6574\u6570\u7c7b\u578b\u7684 Trait \u7684\u5b9e\u73b0\u3002\u6240\u4ee5\u65b9\u6cd5\u89e3\u6790\u81ea\u52a8\u63d2\u5165\u4e86\u4e00\u4e2a\u5f15\u7528\uff0c\u5373 ",(0,l.kt)("inlineCode",{parentName:"p"},"(&0).is_reference()"),"\u3002\u8fd9\u4e00\u6b21\u7684\u8c03\u7528\u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"&'a, T> Trait")," \u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"impl<'a, T>")," \u5339\u914d\uff0c\u5e76\u6253\u5370\u51fa 1\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The call to ",(0,l.kt)("inlineCode",{parentName:"p"},"0.is_reference()")," observes that there is no implementation of Trait for an integer type that we could call directly. Method resolution inserts an auto-ref, effectively evaluating ",(0,l.kt)("inlineCode",{parentName:"p"},"(&0).is_reference()"),". This time the call matches impl<'a, T> Trait for &'a T and prints 1.")),(0,l.kt)("p",null,"\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"'?'.is_reference()")," \u7684\u8c03\u7528\u53cd\u800c\u627e\u5230\u4e86 ",(0,l.kt)("inlineCode",{parentName:"p"},"char")," \u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"implated Trait"),"\uff0c\u6253\u5370\u51fa 0\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The call to ",(0,l.kt)("inlineCode",{parentName:"p"},"'?'.is_reference()")," instead finds impl Trait for char, printing 0.")),(0,l.kt)("h2",{id:"15-type-inference"},"#15 ",(0,l.kt)("inlineCode",{parentName:"h2"},"type inference")),(0,l.kt)("h3",{id:"\u9898\u76ee-14"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'trait Trait {\n    fn f(&self);\n}\n\nimpl Trait for u32 {\n    fn f(&self) {\n        print!("1");\n    }\n}\n\nimpl<\'a> Trait for &\'a i32 {\n    fn f(&self) {\n        print!("2");\n    }\n}\n\nfn main() {\n    let x = &0;\n    x.f();\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-14"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u7c7b\u578b\u63a8\u65ad\u4f1a\u63a8\u65ad\u51fa x \u662f\u4ec0\u4e48\u7c7b\u578b\uff1f"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"What type would type inference infer for x?")),(0,l.kt)("h3",{id:"\u9898\u89e3-13"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a1"),(0,l.kt)("p",null,"\u5728\u7c7b\u578b\u63a8\u65ad\u8fc7\u7a0b\u4e2d\uff0c\u53d8\u91cf x \u7684\u7c7b\u578b\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"&{integer}"),"\uff0c\u662f\u5bf9\u67d0\u4e2a\u5c1a\u672a\u786e\u5b9a\u7684\u6574\u6570\u7c7b\u578b\u7684\u5f15\u7528\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"During type inference the variable x has type &{integer}, a reference to some as yet undetermined integer type.")),(0,l.kt)("p",null,"\u5982\u679c\u6211\u4eec\u60f3\u89e3\u51b3 trait \u65b9\u6cd5\u7684\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"Trait::f(x)"),"\uff0c\u6211\u4eec\u53d1\u73b0\u5b83\u7684\u53c2\u6570 x \u5fc5\u987b\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"&Self")," \u7c7b\u578b\uff0c\u5373\u5b9e\u73b0\u4e86 Trait \u7684\u67d0\u4e2a Self \u7c7b\u578b\u3002\u6211\u4eec\u53d1\u73b0\u63a8\u65ad ",(0,l.kt)("inlineCode",{parentName:"p"},"0: u32")," \u65e2\u6ee1\u8db3\u4e86 u32 \u662f\u4e00\u4e2a\u6574\u6570\u7684\u7ea6\u675f\uff0c\u4e5f\u6ee1\u8db3\u4e86 u32 \u5b9e\u73b0\u4e86 Trait\uff0c\u6240\u4ee5\u8fd9\u4e2a\u65b9\u6cd5\u8c03\u7528\u6700\u7ec8\u8c03\u7528\u4e86 ",(0,l.kt)("inlineCode",{parentName:"p"},"<u32 as Trait>::f(x)")," \u5e76\u6253\u5370\u51fa 1\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If we want to resolve the trait method call ",(0,l.kt)("inlineCode",{parentName:"p"},"Trait::f(x)"),", we find that its argument x must be of type ",(0,l.kt)("inlineCode",{parentName:"p"},"&Self")," for some type Self that implements Trait. We find that inferring 0: u32 satisfies both the constraint that u32 is an integer as well as u32 implements Trait, so the method call ends up calling ",(0,l.kt)("inlineCode",{parentName:"p"},"<u32 as Trait>::f(x)")," and prints 1.")),(0,l.kt)("p",null,"\u5728\u8fd9\u4e2a ",(0,l.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/28552082/6086311"},"Stack Overflow")," \u7684\u7b54\u6848\u4e2d\u8be6\u7ec6\u4ecb\u7ecd\u4e86 Trait \u65b9\u6cd5\u7684\u89e3\u6790\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Trait method resolution is covered in more detail in this ",(0,l.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/28552082/6086311"},"Stack Overflow")," answer.")),(0,l.kt)("h2",{id:"16---i"},"#16 ",(0,l.kt)("inlineCode",{parentName:"h2"},"--i")),(0,l.kt)("h3",{id:"\u9898\u76ee-15"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn main() {\n    let mut x = 4;\n    --x;\n    print!("{}{}", --x, --x);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-15"},"\u63d0\u793a"),(0,l.kt)("p",null,"Rust \u6240\u652f\u6301\u7684\u8fd0\u7b97\u7b26\u96c6\u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"std::ops")," \u4e2d\u6709\u76f8\u5173\u6587\u6863\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The set of operators supported by Rust is documented in ",(0,l.kt)("inlineCode",{parentName:"p"},"std::ops"),".")),(0,l.kt)("h3",{id:"\u9898\u89e3-14"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a44"),(0,l.kt)("p",null,"\u4e0e C \u6216 Java \u4e0d\u540c\uff0cRust \u4e2d\u6ca1\u6709\u81ea\u589e\u81ea\u51cf\u8fd0\u7b97\u7b26\u3002Rust \u8bed\u8a00\u8bbe\u8ba1\u7684 FAQ\uff08\u7f51\u4e0a\u5df2\u7ecf\u6ca1\u6709\u4e86\uff09\u66fe\u7ecf\u6d89\u53ca\u8fc7\u539f\u56e0\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Unlike C or Java, there is no unary increment or decrement operator in Rust. The Rust language design FAQ (no longer available online) used to touch on the reason:")),(0,l.kt)("p",null,"\u4e3a\u4ec0\u4e48 Rust \u6ca1\u6709\u81ea\u589e\u548c\u81ea\u51cf\u8fd0\u7b97\u7b26\uff1f"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Why doesn't Rust have increment and decrement operators?")),(0,l.kt)("p",null,"Preincrement \u548c Postincrement\uff08\u4ee5\u53ca\u4e0e\u4e4b\u5bf9\u5e94\u7684 Decrement\uff09\uff0c\u867d\u7136\u65b9\u4fbf\uff0c\u4f46\u4e5f\u76f8\u5f53\u590d\u6742\u3002\u5b83\u4eec\u9700\u8981\u5bf9\u8ba1\u7b97\u987a\u5e8f\u8db3\u591f\u4e86\u89e3\uff0c\u5e76\u7ecf\u5e38\u5bfc\u81f4 C \u548c C++ \u4e2d\u4e00\u4e9b\u5fae\u5999\u7684\u9519\u8bef\u548c\u672a\u5b9a\u4e49\u7684\u884c\u4e3a\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Preincrement and postincrement (and the decrement equivalents), while convenient, are also fairly complex. They require knowledge of evaluation order, and often lead to subtle bugs and undefined behavior in C and C++. x = x + 1 or x += 1 is only slightly longer, but unambiguous.")),(0,l.kt)("p",null,"\u5728\u6ca1\u6709\u81ea\u51cf\u8fd0\u7b97\u7b26\u7684\u60c5\u51b5\u4e0b\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"--x")," \u88ab\u89e3\u6790\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"-(-x)"),"\u3002\u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"x = 4")," \u7684\u60c5\u51b5\u4e0b\uff0c\u8fd9\u5c06\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"-(-4)"),"\uff0c\u4e5f\u5c31\u662f 4\u3002\u8be5\u7a0b\u5e8f\u7b49\u540c\u4e8e\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In the absense of a decrement operator, --x is parsed as -(-x). In the case of x = 4 this would be -(-4) which is 4. The program is equivalent to:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn main() {\n    let mut x = 4;\n    4;\n    print!("{}{}", 4, 4);\n}\n')),(0,l.kt)("h2",{id:"17--------"},"#17 ",(0,l.kt)("inlineCode",{parentName:"h2"},"-- - --")),(0,l.kt)("h3",{id:"\u9898\u76ee-16"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn main() {\n    let mut a = 5;\n    let mut b = 3;\n    print!("{}", a-- - --b);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-16"},"\u63d0\u793a"),(0,l.kt)("p",null,"Rust \u652f\u6301\u7684\u64cd\u4f5c\u7b26\u90fd\u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"std\uff1a\uff1aops"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The set of operators supported by Rust is documented in ",(0,l.kt)("inlineCode",{parentName:"p"},"std::ops"),".")),(0,l.kt)("h3",{id:"\u9898\u89e3-15"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a2"),(0,l.kt)("p",null,"\u4e0d\u50cf C \u6216\u8005 Java\uff0cRust \u6ca1\u6709\u81ea\u589e\u548c\u81ea\u51cf\u8fd0\u7b97\u7b26\u3002Rust \u8bed\u8a00\u8bbe\u8ba1\u7684 FAQ\uff08\u7f51\u4e0a\u5df2\u7ecf\u6ca1\u6709\u4e86\uff09\u66fe\u7ecf\u63a2\u8ba8\u8fc7\u8fd9\u4e2a\u539f\u56e0\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Unlike C or Java, there is no unary increment or decrement operator in Rust. The Rust language design FAQ (no longer available online) used to touch on the reason:")),(0,l.kt)("p",null,"\u4e3a\u4ec0\u4e48 Rust \u6ca1\u6709\u81ea\u589e\u548c\u81ea\u51cf\u8fd0\u7b97\u7b26\uff1f"),(0,l.kt)("p",null,"Preincrement (",(0,l.kt)("inlineCode",{parentName:"p"},"++i"),") \u548c Postincrement (",(0,l.kt)("inlineCode",{parentName:"p"},"--i"),")\uff08\u4ee5\u53ca\u4e0e\u4e4b\u5bf9\u5e94\u7684 Decrement\uff09\uff0c\u867d\u7136\u65b9\u4fbf\uff0c\u4f46\u4e5f\u76f8\u5f53\u590d\u6742\u3002\u7528\u6237\u9700\u8981\u77e5\u9053\u6c42\u503c\u987a\u5e8f\uff0c\u8fd9\u7ecf\u5e38\u5bfc\u81f4\u4e00\u4e9b C \u548c C++ \u4e2d\u5fae\u5999\u7684\u9519\u8bef\u548c\u672a\u5b9a\u4e49\u7684\u884c\u4e3a\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Why doesn't Rust have increment and decrement operators?\nPreincrement and postincrement (and the decrement equivalents), while convenient, are also fairly complex. They require knowledge of evaluation order, and often lead to subtle bugs and undefined behavior in C and C++. x = x + 1 or x += 1 is only slightly longer, but unambiguous.")),(0,l.kt)("p",null,"\u5728\u6ca1\u6709\u81ea\u51cf\u8fd0\u7b97\u7b26 (\u5305\u62ec ",(0,l.kt)("inlineCode",{parentName:"p"},"i--")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"--i"),") \u7684\u60c5\u51b5\u4e0b\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"a-- --b")," \u4f1a\u88ab\u89e3\u6790\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"a-(-(-(-b))))"),"\u3002\u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"a=5")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"b=3")," \u7684\u60c5\u51b5\u4e0b\uff0c\u8fd9\u4e2a\u8868\u8fbe\u5f0f\u7684\u503c\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"5-3"),"\uff0c\u4e5f\u5c31\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"2"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In the absense of postfix and prefix decrement operators, a-- - --b is parsed as a - (-(-(-(-b)))). In the case of a = 5 and b = 3 the value of this expression is 5 - 3 which is 2.")),(0,l.kt)("h2",{id:"18-f-and-f"},"#18 ",(0,l.kt)("inlineCode",{parentName:"h2"},"f() and f()")),(0,l.kt)("h3",{id:"\u9898\u76ee-17"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'struct S {\n    f: fn(),\n}\n\nimpl S {\n    fn f(&self) {\n        print!("1");\n    }\n}\n\nfn main() {\n    let print2 = || print!("2");\n    S { f: print2 }.f();\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-17"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},".f()")," \u53ef\u4ee5\u89e3\u6790\u4e3a\u5b57\u6bb5 f \u6216\u56fa\u6709\u7684\u65b9\u6cd5 f\uff0c\u4f60\u5982\u4f55\u5199\u51fa\u5bf9\u53e6\u4e00\u4e2a\u7684\u8c03\u7528\uff1f"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The call .f() resolves to either the field f or the inherent method f. How would you write a call to the other one?")),(0,l.kt)("h3",{id:"\u9898\u89e3-16"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a1"),(0,l.kt)("p",null,"\u4e00\u4e2a\u770b\u8d77\u6765\u50cf ",(0,l.kt)("inlineCode",{parentName:"p"},".f()"),"\u7684\u8c03\u7528\u603b\u4f1a\u89e3\u6790\u5230\u4e00\u4e2a\u65b9\u6cd5\uff0c\u5728\u8fd9\u91cc\u662f\u56fa\u6709\u7684\u65b9\u6cd5 ",(0,l.kt)("inlineCode",{parentName:"p"},"S::f"),"\u3002\u5982\u679c\u4f5c\u7528\u57df\u5185\u6ca1\u6709\u65b9\u6cd5 f\uff0c\u90a3\u4e48\u5373\u4f7f\u5b57\u6bb5 f \u5b58\u5728\u5e76\u5305\u542b\u4e00\u4e2a\u51fd\u6570\u6307\u9488\uff0c\u8fd9\u6837\u7684\u8c03\u7528\u4e5f\u4e0d\u80fd\u7f16\u8bd1\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"A call that looks like .f() always resolves to a method, in this case the inherent method ",(0,l.kt)("inlineCode",{parentName:"p"},"S::f"),". If there were no method f in scope, a call like this would fail to compile even if a field f exists and contains a function pointer.")),(0,l.kt)("p",null,"\u4e3a\u4e86\u8c03\u7528\u5b58\u50a8\u5728\u5b57\u6bb5 f \u4e2d\u7684\u51fd\u6570\u6307\u9488\uff0c\u6211\u4eec\u9700\u8981\u5728\u5b57\u6bb5\u5468\u56f4\u5199\u4e0a\u5706\u62ec\u53f7\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"To call the function pointer stored in field f, we would need to write parentheses around the field access:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn main() {\n    let print2 = || print!("2");\n    (S { f: print2 }.f)();\n}\n')),(0,l.kt)("h2",{id:"19-move-or-drop"},"#19 ",(0,l.kt)("inlineCode",{parentName:"h2"},"move or drop")),(0,l.kt)("h3",{id:"\u9898\u76ee-18"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'struct S;\n\nimpl Drop for S {\n    fn drop(&mut self) {\n        print!("1");\n    }\n}\n\nfn main() {\n    let s = S;\n    let _ = s;\n    print!("2");\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-18"},"\u63d0\u793a"),(0,l.kt)("p",null,"s \u6240\u6709\u6743\u79fb\u52a8\u4e86\u5417\uff1f"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Does s get moved?")),(0,l.kt)("h3",{id:"\u9898\u89e3-17"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a21"),(0,l.kt)("p",null,"\u76f8\u5173\u7684\u4e00\u884c\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"let _ = s"),"\u3002\u5982\u679c\u8fd9\u4e00\u884c\u6ca1\u6709\u79fb\u52a8 s\uff0c\u90a3\u4e48 s \u5c06\u7ee7\u7eed\u5b58\u5728\uff0c\u76f4\u5230\u5927\u62ec\u53f7\u7ed3\u5c3e\uff0c\u7a0b\u5e8f\u5c06\u6253\u5370 21\u3002\u4f46\u662f\u5982\u679c\u8fd9\u4e00\u884c\u79fb\u52a8\u4e86 s\uff0c\u800c\u6ca1\u6709\u7ed1\u5b9a\u5b83\uff0c\u90a3\u4e48\u88ab\u79fb\u52a8\u7684 S \u7c7b\u578b\u7684\u503c\u5c06\u88ab\u7acb\u5373 drop\uff0c\u7a0b\u5e8f\u5c06\u6253\u5370 12\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The relevant line is let _ = s. If this line does not move s then s will continue to live until the close curly brace and the program would print 21. But if this line does move s, without binding it, then the moved value of type S would be dropped immediately and the program would print 12.")),(0,l.kt)("p",null,"\u4e8b\u5b9e\u4e0a\uff0cs \u5e76\u6ca1\u6709\u88ab\u79fb\u52a8\uff0c\u8f93\u51fa\u7ed3\u679c\u662f 21\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In fact s does not get moved and the output is 21.")),(0,l.kt)("h2",{id:"20-return-and-return"},"#20 ",(0,l.kt)("inlineCode",{parentName:"h2"},"return and return")),(0,l.kt)("h3",{id:"\u9898\u76ee-19"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn return1() {\n    if (return { print!("1") }) {\n    }\n}\n\nfn return2() {\n    if return { print!("2") } {\n    }\n}\n\nfn break1() {\n    loop {\n        if (break { print!("1") }) {\n        }\n    }\n}\n\nfn break2() {\n    loop {\n        if break { print!("2") } {\n        }\n    }\n}\n\nfn main() {\n    return1();\n    return2();\n    break1();\n    break2();\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-19"},"\u63d0\u793a"),(0,l.kt)("p",null,"Rust \u4e2d\u6d89\u53ca break \u7684\u8bed\u6cd5\u4e0e\u6d89\u53ca return \u7684\u8bed\u6cd5\u4e0d\u540c\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The Rust grammar involving break is different from the grammar involving return.")),(0,l.kt)("h3",{id:"\u9898\u89e3-18"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a121"),(0,l.kt)("p",null,"\u8ba9\u6211\u4eec\u4ee5\u6b64\u7814\u7a76\u8fd9\u4e9b\u51fd\u6570\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Let's work through the functions one at a time.")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"fn return1")),(0,l.kt)("p",{parentName:"li"},"  if \u8bed\u53e5\u7684\uff0c\u6761\u4ef6\u3002\u88ab\u89e3\u6790\u4e3a\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u8fd9\u4e2a\u8868\u8fbe\u5f0f\u4f1a\u8fd4\u56de ",(0,l.kt)("inlineCode",{parentName:"p"},'{ print!("1") }')," \u5373 ().\u8fd9\u4e2a\u503c\u9700\u8981\u5728\u8fd4\u56de\u524d\u88ab\u8ba1\u7b97\uff0c\u6240\u4ee5\u6700\u7ec8\u6253\u5370 1."),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},'The condition of the if-statement is parsed as a return-expression that returns the value { print!("1") } of type (). The value needs to be evaluated prior to being returned so this function prints 1.'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"fn return2")),(0,l.kt)("p",{parentName:"li"}," \u8fd9\u4e2a\u51fd\u6570\u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"return1")," \u4e00\u6837\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"return")," \u5173\u952e\u5b57\u4f1a\u7acb\u5373\u6d88\u8017\u6389\u8fd4\u56de\u503c\uff0c\u5373\u4f7f\u8fd4\u56de\u503c\u88ab\u5927\u62ec\u53f7\u5305\u88f9\uff0e\u751a\u81f3\u662f\u5728 if \u8bed\u53e5\u7684\u6761\u4ef6\u4e2d\uff0c\u5927\u62ec\u53f7 (\u4f8b\u5982\u7ed3\u6784\u4f53) \u901a\u5e38\u4e5f\u4e0d\u4f1a\u88ab\u63a5\u53d7\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"This function is parsed the same as return1. The return keyword eagerly consumes a trailing return value, even if the return value begins with a curly brace, and even in the condition of an if-statement where curly braces such as in a struct literal would ordinarly not be accepted. This function prints 2."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"fn break1")),(0,l.kt)("p",{parentName:"li"},"  if \u8bed\u53e5\u7684\u6761\u4ef6\u662f\u662f\u4e2a break-with-value \u8868\u8fbe\u5f0f\uff0c\u5b83\u4f1a\u7ed3\u675f\u6574\u4e2a\u5faa\u73af\uff0c\u5e76\u8fd4\u56de ",(0,l.kt)("inlineCode",{parentName:"p"},'{ print!("1") }'),", \u5373 ()\uff0c\u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"return1")," \u7c7b\u4f3c\uff0c\u4e3a\u4e86\u5728\u6253\u7834\u5faa\u73af\u65f6\u8fd4\u56de\u503c\uff0c\u8fd9\u4e2a\u503c\u9700\u8981\u88ab\u8ba1\u7b97\uff0c\u6240\u4ee5\u6700\u7ec8\u6253\u5370 1\uff1b"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},'The condition of the if-statement is a break-with-value expression that breaks out of the enclosing loop with the value { print!("1") } of type (). Similar to return1, in order to break with this value the value needs to be evaluated and this function prints 1.'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"fn break2")),(0,l.kt)("p",{parentName:"li"},"  \u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u770b\u5230 break \u548c return \u8bed\u6cd5\u7684\u533a\u522b\u3002\u4e0d\u50cf return\uff0cif \u6761\u4ef6\u91cc\u7684 break \u5173\u952e\u5b57\u4e0d\u4f1a\u7acb\u5373\u89e3\u6790\u51fa\u540e\u9762\u5927\u62ec\u53f7\u7684\u503c\u3002\u8fd9\u6bb5\u4ee3\u7801\u4f1a\u88ab\u89e3\u6790\u4e3a\uff1a"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"Here we observe a difference between the grammar of break and the grammar of return. Unlike return, the break keyword in the condition of this if-statement does not eagerly parse a value that begins with a curly brace. This code is parsed as:")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'loop {\n    if break {\n        print!("2")\n    }\n    {}\n}\n')),(0,l.kt)("p",{parentName:"li"},"  \u6211\u4eec\u5728\u6267\u884c print \u524d\u6253\u7834\u4e86\u5faa\u73af\uff0c\u6240\u4ee5\u8fd9\u4e2a\u51fd\u6570\u4e0d\u4f1a\u6267\u884c print."),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"We break out of the loop before executing the print, so this function does not print anything.")),(0,l.kt)("p",{parentName:"li"},"  \u6211\u76f8\u4fe1 return \u548c break \u4e0d\u540c\u7684\u539f\u56e0\u662f\uff0creturn \u5728 Rust 1.0 \u4ee5\u53ca\u4e4b\u524d\u663e\u7136\u90fd\u662f\u652f\u6301\u7684\uff0c\u4f46\u662f break-with-value \u662f\u5728 Rust 1.19 \u624d\u88ab\u5f15\u5165\u4e4b\u540e\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"break2")," \u4e2d\u7684\u4ee3\u7801\u4e00\u76f4\u90fd\u662f\u5408\u6cd5\u7684 Rust \u4ee3\u7801\uff0c\u6240\u4ee5\u5728\u5b9e\u73b0 break-with-value \u8fd9\u4e2a\u8bed\u8a00\u7279\u6027\u65f6\u4e5f\u8003\u8651\u5230\u4e0d\u80fd\u6539\u53d8\u5b83\u7684\u884c\u4e3a\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"I believe the reason for the difference between return and break is that returning a value was obviously supported at Rust 1.0 and well before, but break-with-value was introduced fairly late, in Rust 1.19. The code in break2 was perfectly legal Rust code prior to Rust 1.19 so we cannot change its behavior when implementing the break-with-value language feature.")),(0,l.kt)("p",{parentName:"li"},"  \u672a\u6765\u7684\u7248\u672c\u6709\u53ef\u80fd\u5bf9\u8fd9\u4e24\u79cd\u8bed\u6cd5\u8fdb\u884c\u8c03\u6574\uff0c\u4f7f\u4e4b\u76f8\u4e92\u4e00\u81f4\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"It is possible that a future Edition would adjust the two grammars to align with each other.")))),(0,l.kt)("p",null,"main \u7684\u8f93\u51fa\u4e3a 121\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The output from main is 121.")),(0,l.kt)("h2",{id:"21-return--break"},"#21 ",(0,l.kt)("inlineCode",{parentName:"h2"},"return & break")),(0,l.kt)("h3",{id:"\u9898\u76ee-20"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'trait Trait {\n    fn f(&self);\n}\n\nimpl<F: FnOnce() -> bool> Trait for F {\n    fn f(&self) {\n        print!("1");\n    }\n}\n\nimpl Trait for () {\n    fn f(&self) {\n        print!("2");\n    }\n}\n\nfn main() {\n    let x = || { (return) || true; };\n    x().f();\n\n    let x = loop { (break) || true; };\n    x.f();\n\n    let x = || { return (|| true); };\n    x().f();\n\n    let x = loop { break (|| true); };\n    x.f();\n\n    let x = || { return || true; };\n    x().f();\n\n    let x = loop { break || true; };\n    x.f();\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-20"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u5728\u672c\u9898\u4e2d\uff0cbreak \u548c return \u5173\u952e\u5b57\u7684\u8bed\u6cd5\u662f\u4e00\u6837\u7684\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The break and return keywords have the same grammar in this question.")),(0,l.kt)("h3",{id:"\u9898\u89e3-19"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a221111"),(0,l.kt)("p",null,"\u6211\u4eec\u60f3\u77e5\u9053 ",(0,l.kt)("inlineCode",{parentName:"p"},"return || true;")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"break || true;")," \u7684\u6bcf\u4e00\u4e2a\u53ef\u80fd\u7684\u62ec\u53f7\u662f\u5426\u8bc4\u4f30\u4e3a\u95ed\u5305 ",(0,l.kt)("inlineCode",{parentName:"p"},"|| true")," \u6216\u5355\u4f4d\u503c ()\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"We want to know whether each possible parenthesization of return || true; and break || true; evaluates to the closure || true or to the unit value ().")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"let x = || { (return) || true; };")),(0,l.kt)("p",{parentName:"li"},"  \u5728\u8fd9\u4e00\u884c\uff0cx \u662f\u4e00\u4e2a\u8fd4\u56de () \u7684\u95ed\u5305\u3002\u7b49\u4ef7\u4e8e ",(0,l.kt)("inlineCode",{parentName:"p"},"let x = || {}"),".\u5f53\u6211\u4eec\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"x().f()")," \u65f6\uff0c\u65b9\u6cd5 f \u4f1a\u88ab\u89e3\u6790\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"impl Trait for ()"),", \u5e76\u6253\u5370 2."),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"On this line, x is a closure that returns (). It is equivalent to let x = || {}. When we call x().f(), the method f resolves to impl Trait for () which prints 2.")),(0,l.kt)("p",{parentName:"li"},"  \u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"(treturn)")," \u7684\u7c7b\u578b\u662f\u539f\u59cb\u7684 never \u7c7b\u578b\uff0c\u901a\u5e38\u5199\u6210 ",(0,l.kt)("inlineCode",{parentName:"p"},"\uff01"),"\u3002\u8ba1\u7b97 ",(0,l.kt)("inlineCode",{parentName:"p"},"! || true")," \u662f\u5408\u6cd5\u7684\uff0c\u56e0\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"!")," \u53ef\u4ee5\u8f6c\u4e3a\u4efb\u4f55\u7c7b\u578b\uff0c\u5728\u8fd9\u91cc\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"bool"),"\u3002\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"! || true")," \u662f\u4e00\u4e2a\u903b\u8f91\u6216\uff0c\u5de6\u4fa7\u548c\u53f3\u4fa7\u90fd\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"bool"),"\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"The type of the expression (return) is the primitive never type, usually written as !. It is legal to compute ! || true because ! can fill in for any type, in this case bool. The expression ! || true is a logical-OR with bool on both the left-hand side and right-hand side.")),(0,l.kt)("p",{parentName:"li"},"  ",(0,l.kt)("inlineCode",{parentName:"p"},"!")," \u53ef\u4ee5\u8f6c\u4e3a\u4efb\u4f55\u7c7b\u578b\u7684\u884c\u4e3a\u5141\u8bb8\u6211\u4eec\u5199\u51fa\u5982\u4e0b\u4ee3\u7801\uff1a"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"The behavior of ! of filling in for any type is what allows us to write:")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"fn f() -> bool {\n    unimplemented!()\n}\n")),(0,l.kt)("p",{parentName:"li"},"  \u5176\u4e2d ",(0,l.kt)("inlineCode",{parentName:"p"},"unimplemented!()")," \u7684\u7c7b\u578b\uff0c\u56e0\u4e3a\u5b83\u5728\u6ca1\u6709\u6c42\u503c\u7684\u60c5\u51b5\u4e0b\u76f4\u63a5 panic\uff0c\u5b83\u7684\u8fd4\u56de\u503c\u7c7b\u578b\u4e5f\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"\uff01"),"\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"in which the type of unimplemented!(), since it panics without evaluating to any value, is also !."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"let x = loop { (break) || true; };")),(0,l.kt)("p",{parentName:"li"},"  \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"(return)")," \u7c7b\u4f3c\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"(break)")," \u7684\u7c7b\u578b\u4e5f\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"!"),". \u8fd9\u884c\u4ee3\u7801\u4f1a\u6253\u7834\u5faa\u73af\uff0c\u5e76\u8fd4\u56de ",(0,l.kt)("inlineCode",{parentName:"p"},"()"),", \u6240\u4ee5 ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," \u7684\u7c7b\u578b\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"()"),".\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"x.f()")," \u4f1a\u6253\u5370 2."),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"Similar to (return), the type of (break) is the never type !. This code breaks out of the loop with the implicit value (), so x is of type (). Calling x.f() will print 2."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"let x = || { return (|| true); };")),(0,l.kt)("p",{parentName:"li"},"  \u5728\u8fd9\u4e00\u884c\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"x")," \u662f\u4e00\u4e2a\u95ed\u5305\uff0c\u5b83\u8fd4\u56de\u4e00\u4e2a\u8fd4\u56de true \u7684\u95ed\u5305\u3002\u4f60\u53ef\u4ee5\u5199 ",(0,l.kt)("inlineCode",{parentName:"p"},"x()()"),"\uff0c\u5b83\u7684\u503c\u4f1a\u662f true\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"On this line x is a closure that returns a closure that returns true. You could write x()() and that would be true.")),(0,l.kt)("p",{parentName:"li"},"  Quiz \u4ee3\u7801\u8c03\u7528\u4e86 ",(0,l.kt)("inlineCode",{parentName:"p"},"x().f()"),", \u8fd9\u4f1a\u89e3\u6790\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"impl<F> Trait for F where F: FnOnce() -> bool"),". \u6700\u7ec8\u6253\u5370 1."),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"The quiz code calls ",(0,l.kt)("inlineCode",{parentName:"p"},"x().f()")," which resolves to ",(0,l.kt)("inlineCode",{parentName:"p"},"impl<F> Trait for F where F: FnOnce() -> bool"),". That trait impl prints 1."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"let x = loop { break (|| true); };")),(0,l.kt)("p",{parentName:"li"},"  \u8fd9\u662f\u4e00\u4e2a\u5305\u542b ",(0,l.kt)("inlineCode",{parentName:"p"},"break-with-value")," \u8868\u8fbe\u5f0f\u7684\u5faa\u73af\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"break")," \u7684\u53c2\u6570\u53d8\u6210\u4e86\u5faa\u73af\u7684\u8fd4\u56de\u503c\u3002\u8fd9\u6bb5\u4ee3\u7801\u7b49\u540c\u4e8e ",(0,l.kt)("inlineCode",{parentName:"p"},"let x = || true"),"\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"This is a loop containing a break-with-value expression. The argument of the break becomes the value of the enclosing loop. This code is equivalent to let ",(0,l.kt)("inlineCode",{parentName:"p"},"x = || true"),".")),(0,l.kt)("p",{parentName:"li"},"  \u5f53\u6211\u4eec\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"x.f()")," \u65f6\uff0c\u5b83\u4f7f\u7528\u4e86 FnOnce \u7684 Trait \u5b9e\u73b0\uff0c\u6253\u5370\u51fa 1\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"When we call ",(0,l.kt)("inlineCode",{parentName:"p"},"x.f()")," it uses the FnOnce impl of Trait which prints 1."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"let x = || { return || true; };")),(0,l.kt)("p",{parentName:"li"},"  \u73b0\u5728\u6211\u4eec\u6765\u5230\u4e86\u8fd9\u4e2a\u95ee\u7b54\u95ee\u9898\u7684\u6838\u5fc3\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"return || true")," \u7684\u89e3\u6790\u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"(return) || true")," \u76f8\u540c\uff0c\u8fd8\u662f\u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"return (|| true)")," \u76f8\u540c\uff1f"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"Now we arrive at the meat of this quiz question. Is ",(0,l.kt)("inlineCode",{parentName:"p"},"return || true")," parsed the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"(return) || true")," or as ",(0,l.kt)("inlineCode",{parentName:"p"},"return (|| true)"),"?")),(0,l.kt)("p",{parentName:"li"},"  \u7ed3\u679c\u662f\u540e\u8005\uff0c\u6240\u4ee5 x \u662f\u4e00\u4e2a\u8fd4\u56de true \u7684\u95ed\u5305\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"x().f()")," \u6253\u5370 1\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"It turns out to be the latter, so x is a closure that returns a closure that returns true. ",(0,l.kt)("inlineCode",{parentName:"p"},"x().f()")," prints 1."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"let x = loop { break || true; };")),(0,l.kt)("p",{parentName:"li"},"  \u8fd9\u4e2a\u4e5f\u662f\u7c7b\u4f3c\u7684\u95ee\u9898\uff0c\u8fd9\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"(break) || true")," \u8fd8\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"break (|| true)"),"\uff1f"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"Similar question here, is this ",(0,l.kt)("inlineCode",{parentName:"p"},"(break) || true")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"break (|| true)"),"?")),(0,l.kt)("p",{parentName:"li"},"  ",(0,l.kt)("inlineCode",{parentName:"p"},"break-with-value")," \u8bed\u8a00\u529f\u80fd\u662f\u5728 1.0 \u4e4b\u540e\u7684\u4e24\u5e74\u540e (Rust 1.19) \u52a0\u5165\u7684\u3002\u5728 break-with-value \u4e4b\u524d\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"break || true")," \u662f\u5b8c\u5168\u5408\u6cd5\u7684 Rust \u4ee3\u7801\uff0c\u89e3\u6790\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"(break) || true"),"\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"The break-with-value language feature was added to Rust more than two years after 1.0, in Rust 1.19. Prior to break-with-value, ",(0,l.kt)("inlineCode",{parentName:"p"},"break || true")," was perfectly legal Rust code that parsed as ",(0,l.kt)("inlineCode",{parentName:"p"},"(break) || true"),".")),(0,l.kt)("p",{parentName:"li"},"  \u5728 Rust 1.19 \u4e2d\uff0c\u8fd9\u6bb5\u4ee3\u7801\u7684\u884c\u4e3a\u88ab\u8bed\u8a00\u65e0\u610f\u4e2d\u6253\u7834\u4e86\uff0c\u73b0\u5728\u5b83\u88ab\u89e3\u6790\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"break (|| true)"),"\uff0c\u6253\u5370\u51fa\u6765\u7684\u503c\u662f 1\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"In Rust 1.19 the behavior of this code was unintentionally broken by the language such that now it parses as ",(0,l.kt)("inlineCode",{parentName:"p"},"break (|| true)")," and the printed value is 1.")),(0,l.kt)("p",{parentName:"li"},"  \u5982\u679c\u6211\u4eec\u5728 Rust 1.19 \u7684\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u6ce8\u610f\u5230\u8fd9\u79cd\u610f\u4e49\u4e0a\u7684\u53d8\u5316\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u8c03\u6574\u89e3\u6790\u4ee5\u4fdd\u7559\u73b0\u6709\u4ee3\u7801\u7684\u610f\u4e49\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u6837\u505a\u4f1a\u5bfc\u81f4\u8bed\u6cd5\u5728 return \u548c break \u4e4b\u95f4\u6709\u4e0d\u540c\u7684\u8868\u73b0\uff0c\u9664\u4e86\u5386\u53f2\u7684\u610f\u5916\uff0c\u6ca1\u6709\u4efb\u4f55\u5408\u7406\u7684\u7406\u7531\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"If we had noticed this change in meaning during the development of Rust 1.19, we may have adjusted the parsing to preserve the meaning of existing code. Unfortunately doing so would result in a grammar that behaves differently between return and break for no justifiable reason other than an accident of history.")),(0,l.kt)("p",{parentName:"li"},"  \u6216\u8005\uff0c\u6211\u4eec\u4e5f\u6709\u53ef\u80fd\u8ba4\u4e3a\u8fd9\u662f\u4e00\u4e2a\u6c38\u8fdc\u4e0d\u4f1a\u51fa\u73b0\u5728\u771f\u5b9e\u4ee3\u7801\u4e2d\u7684\u8bed\u6cd5\u8fb9\u7f18\u6848\u4f8b\uff0c\u7528 Crater \u6765\u9a8c\u8bc1\u8fd9\u4e00\u5047\u8bbe\uff0c\u5e76\u6709\u610f\u6253\u7834\u8fd9\u4e00\u884c\u4e3a\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"Or it is possible we would have ruled this an edge case of syntax that would never appear in real code, used Crater to validate that hypothesis, and broken the behavior intentionally.")))),(0,l.kt)("p",null,"main \u7684\u5b8c\u6574\u8f93\u51fa\u662f 221111."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The total output from main is 221111.")),(0,l.kt)("h2",{id:"22---is-a-token"},"#22 ",(0,l.kt)("inlineCode",{parentName:"h2"},"- is a token")),(0,l.kt)("h3",{id:"\u9898\u76ee-21"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'macro_rules! m {\n    ($a:tt) => { print!("1") };\n    ($a:tt $b:tt) => { print!("2") };\n    ($a:tt $b:tt $c:tt) => { print!("3") };\n    ($a:tt $b:tt $c:tt $d:tt) => { print!("4") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt) => { print!("5") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt) => { print!("6") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt $g:tt) => { print!("7") };\n}\n\nfn main() {\n    m!(-1);\n    m!(-1.);\n    m!(-1.0);\n    m!(-1.0e1);\n    m!(-1.0e-1);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-21"},"\u63d0\u793a"),(0,l.kt)("p",null,'macro \u4f1a\u8ba1\u7b97\u8f93\u5165\u7684 "token" \u7684\u6570\u91cf\u3002'),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'The macro is counting how many "tokens" are in its input.')),(0,l.kt)("h3",{id:"\u9898\u89e3-20"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a22222"),(0,l.kt)("p",null,"\u6240\u6709\u7684 m\uff01\u8c03\u7528\u90fd\u4f20\u9012\u4e86\u4e24\u4e2a\u6807\u8bb0\u4f5c\u4e3a\u8f93\u5165\uff1a\u4e00\u4e2a\u51cf\u53f7\uff0c\u7136\u540e\u662f\u4e00\u4e2a\u6574\u6570\u6216\u6d6e\u70b9\u5b57\u6837\u7684\u6807\u8bb0\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"All five invocations of m! pass two tokens as input: a minus sign followed by an integer or floating point literal token.")),(0,l.kt)("p",null,"\u6d6e\u70b9\u5b57\u9762\u7b26\u53f7 ",(0,l.kt)("inlineCode",{parentName:"p"},"1."),"\u3001",(0,l.kt)("inlineCode",{parentName:"p"},"1.0"),"\u3001",(0,l.kt)("inlineCode",{parentName:"p"},"1.0e1"),"\u3001",(0,l.kt)("inlineCode",{parentName:"p"},"1.0e-1")," \u90fd\u662f\u5355\u4e00\u7684\u539f\u5b50\u7b26\u53f7\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The floating point literals 1., 1.0, 1.0e1, 1.0e-1 are each a single atomic token.")),(0,l.kt)("p",null,"Rust \u7f16\u8bd1\u5668\u5185\u7f6e\u7684\u89e3\u6790\u5668\u603b\u662f\u5c06\u8d1f\u53f7\u4f5c\u4e3a\u4e00\u4e2a\u5355\u72ec\u7684\u6807\u8bb0\uff0c\u4e0e\u6570\u5b57\u8fdb\u884c\u533a\u5206\u3002\u7136\u800c\uff0c\u5728\u8fc7\u7a0b\u5b8f\u4e2d\uff0c\u7528\u6237\u5b9a\u4e49\u7684\u89e3\u6790\u5668\u53ef\u4ee5\u901a\u8fc7\u5411 ",(0,l.kt)("inlineCode",{parentName:"p"},"proc_macro::Literal")," \u7684\u6784\u9020\u5668\u4e4b\u4e00\u4f20\u9012\u4e00\u4e2a\u8d1f\u7684\u6574\u6570\u6216\u8d1f\u7684\u6d6e\u70b9\u6570\u6765\u6784\u9020\u4e00\u4e2a\u8d1f\u6570\u4f5c\u4e3a\u5355\u4e2a\u6807\u8bb0\u3002\u5982\u679c\u8fd9\u6837\u7684\u8d1f\u6570\u6700\u7ec8\u51fa\u73b0\u5728\u968f\u540e\u7684\u8fc7\u7a0b\u5b8f\u8c03\u7528\u7684\u8f93\u5165\u4e2d\uff0c\u5219\u7531\u7f16\u8bd1\u5668\u51b3\u5b9a\u662f\u91cd\u5199\u6210\u4e00\u5bf9\u6807\u8bb0\u8fd8\u662f\u5c06\u5176\u4f5c\u4e3a\u4e00\u4e2a\u6807\u8bb0\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The parser built into the Rust compiler always parses a negative sign as a separate token from the numeric literal that is being negating. However, it is possible for a user-defined parser within a procedural macro to construct a negative number as a single token by passing a negative integer or negative floating point value to one of the constructors of ",(0,l.kt)("inlineCode",{parentName:"p"},"proc_macro::Literal"),". If such a negative literal ends up in the input of a subsequent procedural macro invocation, it is up to the compiler whether to rewrite into a pair of tokens or keep them as one.")),(0,l.kt)("p",null,"\u7f16\u8bd1\u5668\u7684\u89e3\u6790\u5668\u7684\u884c\u4e3a\u5728\u8bed\u8a00\u8868\u9762\u4e5f\u662f\u53ef\u4ee5\u89c2\u5bdf\u5230\u7684\uff0c\u4e0d\u4ec5\u4ec5\u662f\u5728\u5b8f\u4e2d\u3002\u4f8b\u5982\uff0c\u4e0b\u9762\u7684\u4ee3\u7801\u6253\u5370\u51fa -81\uff0c\u56e0\u4e3a\u8868\u8fbe\u5f0f\u88ab\u89e3\u6790\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"-(3i32.pow(4))")," \u800c\u4e0d\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"(-3i32).pow(4)"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The behavior of the compiler's parser is observable in the surface language as well, not only in macros. For example the following code prints -81 because the expression is parsed as -(3i32.pow(4)) rather than (-3i32).pow(4).")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn main() {\n    let n = -3i32.pow(4);\n    println!("{}", n);\n}\n')),(0,l.kt)("h2",{id:"23-method-lookup-order"},"#23 ",(0,l.kt)("inlineCode",{parentName:"h2"},"method lookup order")),(0,l.kt)("h3",{id:"\u9898\u76ee-22"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'trait Trait {\n    fn f(&self);\n    fn g(&self);\n}\n\nstruct S;\n\nimpl S {\n    fn f(&self) {\n        print!("1");\n    }\n\n    fn g(&mut self) {\n        print!("1");\n    }\n}\n\nimpl Trait for S {\n    fn f(&self) {\n        print!("2");\n    }\n\n    fn g(&self) {\n        print!("2");\n    }\n}\n\nfn main() {\n    S.f();\n    S.g();\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-22"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u6211\u4e0d\u80fd\u5e2e\u52a9\u4f60\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\u8fd9\u662f\u7531\u8bed\u8a00\u672c\u8eab\u505a\u51fa\u7684\u4e00\u4e2a\u76f8\u5f53\u968f\u610f\u7684\u9009\u62e9\u3002\u8bd5\u8bd5\u6240\u6709\u7684\u53ef\u80fd\u5427\uff01"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"I can't help you with this one. This is a pretty arbitrary choice made by the language. Try all the possibilities!")),(0,l.kt)("h3",{id:"\u9898\u89e3-21"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a12"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"S.f()")," \u4f1a\u8c03\u7528\u56fa\u6709\u65b9\u6cd5 f\u3002\u5982\u679c\u4e00\u4e2a\u56fa\u6709\u65b9\u6cd5\u548c\u4e00\u4e2a Trait \u65b9\u6cd5\u540c\u540d\uff0c\u5e76\u4e14\u8fd4\u56de\u503c\u76f8\u540c\uff0c\u666e\u901a\u7684\u65b9\u6cd5\u8c03\u7528\u603b\u662f\u4f1a\u9009\u62e9\u56fa\u6709\u65b9\u6cd5\u3002\u8c03\u7528\u8fd9\u5fc5\u987b\u5199 ",(0,l.kt)("inlineCode",{parentName:"p"},"Trait::f(&s)")," \u6216\u8005 ",(0,l.kt)("inlineCode",{parentName:"p"},"<S as Trait>::f(&s)")," \u53bb\u8c03\u7528 Trait \u65b9\u6cd5\u3002 "),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("inlineCode",{parentName:"p"},"S.f()")," calls the inherent method f. If an inherent method and a trait method have the same name and receiver type, plain method call syntax will always prefer the inherent method. The caller would need to write ",(0,l.kt)("inlineCode",{parentName:"p"},"Trait::f(&S)")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"<S as Trait>::f(&S)")," in order to call the trait method.")),(0,l.kt)("p",null,"\u5bf9\u4e8e\u5b8f\u7684\u4f5c\u8005\u6765\u8bf4\uff0c\u610f\u8bc6\u5230\u8fd9\u4e00\u70b9\u5f88\u91cd\u8981\u3002\u5b8f\u751f\u6210\u7684\u4ee3\u7801\u901a\u5e38\u4e0d\u5e94\u8be5\u4f7f\u7528\u666e\u901a\u7684\u65b9\u6cd5\u8c03\u7528\u8bed\u6cd5\u6765\u8c03\u7528\u7528\u6237\u5b9a\u4e49\u7684\u7c7b\u578b\u4e0a\u7684\u7279\u5f81\u65b9\u6cd5\u3002\u8fd9\u4e9b\u8c03\u7528\u53ef\u80fd\u4f1a\u88ab\u4e0e\u7279\u8d28\u65b9\u6cd5\u540c\u540d\u7684\u56fa\u6709\u65b9\u6cd5\u65e0\u610f\u4e2d\u52ab\u6301\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"It is important for macro authors to be aware of this. Macro-generated code typically should not use method call syntax to invoke trait methods on types defined by the user. Those calls could get unintentially hijacked by inherent methods having the same name as the trait method.")),(0,l.kt)("p",null,"\u53e6\u4e00\u65b9\u9762\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"S.g()")," \u8c03\u7528\u7279\u8d28\u65b9\u6cd5 ",(0,l.kt)("inlineCode",{parentName:"p"},"g"),"\u3002\u5728\u65b9\u6cd5\u89e3\u6790\u8fc7\u7a0b\u4e2d\uff0c\u5982\u679c ",(0,l.kt)("inlineCode",{parentName:"p"},"&")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"\uff06mut")," \u90fd\u53ef\u4ee5\u8c03\u7528\uff0c\u81ea\u52a8\u5f15\u7528\u603b\u662f\u503e\u5411\u4e8e\u5c06\u67d0\u6837\u4e1c\u897f\u53d8\u6210 ",(0,l.kt)("inlineCode",{parentName:"p"},"&"),"\uff0c\u800c\u4e0d\u662f\u5c06\u5176\u53d8\u6210 ",(0,l.kt)("inlineCode",{parentName:"p"},"&mut"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"On the other hand, S.g() calls the trait method g. Auto-ref during method resolution always prefers making something into & over making it into &mut where either one would work.")),(0,l.kt)("p",null,"\u8bf7\u53c2\u9605 ",(0,l.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/28552082/6086311"},"Stack Overflow")," \u7684\u7b54\u6848\uff0c\u4e86\u89e3\u65b9\u6cd5\u89e3\u6790\u8fc7\u7a0b\u4e2d\u81ea\u52a8\u5f15\u7528\u7684\u66f4\u8be6\u7ec6\u89e3\u91ca\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"See this Stack Overflow answer for a more detailed explanation of auto-ref during method resolution.")),(0,l.kt)("h2",{id:"24-hygiene"},"#24 ",(0,l.kt)("inlineCode",{parentName:"h2"},"Hygiene")),(0,l.kt)("h3",{id:"\u9898\u76ee-23"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn main() {\n    let x: u8 = 1;\n    const K: u8 = 2;\n\n    macro_rules! m {\n        () => {\n            print!("{}{}", x, K);\n        };\n    }\n\n    {\n        let x: u8 = 3;\n        const K: u8 = 4;\n\n        m!();\n    }\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-23"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u5b8f\u7684\u536b\u751f\u6027\u53ea\u662f\u7528\u4e8e\u5c40\u90e8\u53d8\u91cf\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Hygiene in macro_rules! only applies to local variables.")),(0,l.kt)("h3",{id:"\u9898\u89e3-22"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a14"),(0,l.kt)("p",null,'\u8fd9\u4e2a\u7a0b\u5e8f\u6253\u5370\u51fa 14\uff0c\u56e0\u4e3a\u5b8f\u7684 "\u536b\u751f\u6027"(Hygiene) \u53ea\u9002\u7528\u4e8e\u5c40\u90e8\u53d8\u91cf\u3002'),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This program prints 14 because hygiene in macro_rules! only applies to local variables.")),(0,l.kt)("p",null,"\u4f60\u53ef\u4ee5\u628a Hygiene \u60f3\u8c61\u6210\uff1a\u7ed9\u6bcf\u6b21\u63d0\u5230\u7684\u5c40\u90e8\u53d8\u91cf\u7684\u540d\u5b57\u5206\u914d\u4e00\u79cd\u989c\u8272\uff0c\u5141\u8bb8\u5728\u8303\u56f4\u5185\u6709\u591a\u4e2a\u53ef\u533a\u5206\u7684\u5c40\u90e8\u53d8\u91cf\u540c\u65f6\u5177\u6709\u76f8\u540c\u7684\u540d\u5b57\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"You can imagine hygiene as a way of assigning a color to each mention of the name of a local variable, allowing for there to be multiple distinguishable local variables in scope simultaneously with the same name.")),(0,l.kt)("p",null,"\u5728 main \u7684\u9876\u7aef\uff0c\u5047\u8bbe\u6211\u4eec\u8ba4\u4e3a\u5c40\u90e8\u53d8\u91cf x \u7684\u540d\u5b57\u662f\u7d2b\u8272\u7684 x\uff0c\u5e38\u91cf K \u7684\u540d\u5b57\u53ea\u662f\u666e\u901a\u7684 K\uff0c\u56e0\u4e3a\u5e38\u91cf\u88ab\u8ba4\u4e3a\u662f\u9879 (Item) \u800c\u4e0d\u662f\u5c40\u90e8\u53d8\u91cf\uff08\u4f60\u53ef\u4ee5\u628a\u9879\u653e\u5728\u51fd\u6570\u4f53\u4e4b\u5916\uff1b\u4f46\u662f\u4e0d\u80fd\u628a\u5c40\u90e8\u53d8\u91cf\u653e\u5728\u51fd\u6570\u4f53\u4e4b\u5916\uff09\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"At the top of main, suppose we consider the name of the local variable x to be a purple x. The name of the constant K is just plain K, as constants are considered items rather than local variables (you can place items outside of a function body; you cannot place local variables outside of a function body).")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"let   x: u8 = 1; // x \u4e3a\u7d2b\u8272\nconst K: u8 = 2; // K \u4e3a\u65e0\u8272\n")),(0,l.kt)("p",null,"\u6211\u4eec\u7ee7\u7eed\u5f80\u4e0b\u770b\uff0c\u5728 macro m! \u7684\u58f0\u660e\u4e2d\uff0c\u6709\u4e24\u4e2a\u88ab\u7528\u5230\u7684\u6807\u8bc6\u7b26\u3002\u56e0\u4e3a\u4f5c\u7528\u57df\u5185\u6709\u4e00\u4e2a\u53d8\u91cf x\uff0c\u6240\u4ee5\u5728 m! \u5185\u4f7f\u7528\u7684\u6807\u8bc6\u7b26 x \u7684\u989c\u8272\u4e0e\u5c40\u90e8\u53d8\u91cf x \u76f8\u540c\u3002\u5728\u4f5c\u7528\u57df\u5185\u6ca1\u6709\u5c40\u90e8\u53d8\u91cf K\uff0c\u6240\u4ee5\u5728\u5b8f\u7684\u58f0\u660e\u4e2d\u7684 K \u88ab\u5206\u914d\u4e86\u4e00\u4e9b\u65b0\u7684\u989c\u8272\uff0c\u4f8b\u5982\u6a59\u8272\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Continuing down the body of main, within the declaration of the macro m! there are identifiers x and K being used. Since there is a local variable x in scope, the use of the identifier x within the macro body picks up the same color as the local variable x. There is no local variable K in scope so the K within the declaration of the macro is assigned some new color, say orange.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'macro_rules! m {\n    () => {\n        print!("{}{}", x, K); // x \u4e3a\u7d2b\u8272\uff0cK \u4e3a\u6a59\u8272\n    };\n}\n')),(0,l.kt)("p",null,"\u63a5\u4e0b\u6765\u6211\u4eec\u8fdb\u5165\u4e00\u4e2a\u65b0\u7684\u4f5c\u7528\u57df\uff08\u7528\u5927\u62ec\u53f7\u5212\u5b9a\uff09\uff0c\u5305\u542b\u53e6\u4e00\u4e2a x \u548c K\u3002\u6bcf\u4e00\u4e2a\u65b0\u7684\u5c40\u90e8\u53d8\u91cf\u603b\u662f\u4f1a\u5f15\u5165\u4e00\u4e2a\u65b0\u7684\u989c\u8272\uff0c\u6240\u4ee5\u6211\u4eec\u628a\u8fd9\u4e2a x \u53eb\u505a\u84dd\u8272\u3002const \u4f9d\u7136\u4e0d\u662f\u4e00\u4e2a\u5c40\u90e8\u53d8\u91cf\uff0c\u6240\u4ee5\u6ca1\u6709\u7ed9 K \u5206\u914d\u989c\u8272\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Next we enter a new scope (delimited by curly braces) containing another x and K. Every new local variable always introduces a new color so let's call this x blue. The const again is not a local variable so no color is assigned to K.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"{\n    let   x: u8 = 3; // x \u4e3a\u84dd\u8272\n    const K: u8 = 4; // K \u4e3a\u65e0\u8272\n\n    m!();\n}\n")),(0,l.kt)("p",null,"\u5f53 ",(0,l.kt)("inlineCode",{parentName:"p"},"m!()")," \u5c55\u5f00\u65f6\uff0c\u5c55\u5f00\u7684\u4ee3\u7801\u5305\u542b\u4e00\u4e2a\u7d2b\u8272\u7684 x \u548c\u4e00\u4e2a\u6a59\u8272\u7684 K\u3002\u7d2b\u8272\u7684 x \u53ef\u4ee5\u548c\u84dd\u8272\u7684 x \u533a\u5206\u5f00\u6765\uff0c\u6240\u4ee5\u7d2b\u8272\u7684 x \u7684\u503c\u88ab\u6253\u5370\u51fa\u6765\uff0c\u662f 1\u3002\u81f3\u4e8e K\uff0c\u4e00\u4e2a\u4e0d\u536b\u751f\u7684\uff08\u672a\u7740\u8272\u7684\uff09K \u88ab\u5141\u8bb8\u50cf\u4efb\u4f55\u989c\u8272\u4e00\u6837\u3002\u7b2c\u4e8c\u4e2a K \u4f1a\u906e\u853d\u7b2c\u4e00\u4e2a K\u3002\u5f53 m! \u5bfb\u627e\u4e00\u4e2a\u6a59\u8272\u7684 K \u65f6\uff0c\u4f1a\u8bc6\u522b\u5230\u7b2c\u4e8c\u4e2a K\uff0c\u7b2c\u4e8c\u4e2a K \u7684\u503c\u88ab\u6253\u5370\u51fa\u6765\uff0c\u5373 4\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"When m!() expands, the expanded code refers to a purple x and an orange K. The purple x is distinguishable from the blue x -- the value of the purple x is printed which is 1. As for the K, an unhygienic (uncolored) K is allowed to act like any color. The second K is shadowing the first one. It gets picked up when looking for an orange K and its value is printed, which is 4.")),(0,l.kt)("p",null,"\u6240\u4ee5\u8f93\u51fa\u662f 14\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"So the output of the quiz code is 14.")),(0,l.kt)("h2",{id:"25-drop"},"#25 ",(0,l.kt)("inlineCode",{parentName:"h2"},"drop")),(0,l.kt)("h3",{id:"\u9898\u76ee-24"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'use std::fmt::{self, Display};\n\nstruct S;\n\nimpl Display for S {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str("1")\n    }\n}\n\nimpl Drop for S {\n    fn drop(&mut self) {\n        print!("2");\n    }\n}\n\nfn f() -> S {\n    S\n}\n\nfn main() {\n    let S = f(); \n    print!("{}", S);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-24"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u5f04\u6e05\u695a\u54ea\u4e9b\u503c\u88ab\u54ea\u4e9b\u53d8\u91cf\u6240\u62e5\u6709\u3002\u5f53\u4e00\u4e2a\u503c\u4e0d\u518d\u6709\u6240\u6709\u8005\u65f6\uff0c\u5b83\u5c31\u88ab drop \u4e86\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Figure out what values are owned by which variables where. A value is dropped when it no longer has an owner.")),(0,l.kt)("h3",{id:"\u9898\u89e3-23"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a212"),(0,l.kt)("p",null,"\u7a0b\u5e8f\u6253\u5370 212\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This program prints 212.")),(0,l.kt)("p",null,"\u5728\u51fd\u6570 f \u5185\uff0c\u6ca1\u6709 S \u4f1a\u88ab drop\u3002f \u51fd\u6570\u5185\u4ea7\u751f\u4e00\u4e2a S\uff0c\u7136\u540e\u628a\u5b83\u7684\u6240\u6709\u6743\u8fd4\u56de\u7ed9 f \u7684\u8c03\u7528\u8005\uff1b\u8c03\u7528\u8005\u4f1a\u51b3\u5b9a\u4ec0\u4e48\u65f6\u5019 drop \u6389\u4ed6\u62ff\u5230\u7684 S\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"No value of type S gets dropped within the body of function f. The function f conjures an S and returns ownership of it to the caller of f; the caller determines when to drop the S of which it received ownership.")),(0,l.kt)("p",null,"\u5728 main \u7684\u7b2c\u4e00\u884c\uff0c\u6211\u4eec\u8c03\u7528\u4e86 f(),\u4f46\u662f\u5e76\u6ca1\u6709\u628a\u5b83\u7ed1\u5b9a\u5230\u67d0\u4e00\u4e2a\u53d8\u91cf\u4e0a\u3002\u6240\u4ee5 f() \u8fd4\u56de\u7684 S \u4f1a\u88ab\u7acb\u5373 drop\uff0c\u6253\u5370\u4e86 2\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"let S = f()")," \u4e2d\u7684 S \u662f\u4e00\u4e2a\u5355\u5143\u7ed3\u6784\u4f53\u7684\u6a21\u5f0f\u5339\u914d (\u4e0d\u662f\u4e00\u4e2a\u53d8\u91cf)\uff0c\u5b83\u80fd\u591f\u901a\u8fc7\u89e3\u6784\u5339\u914d\u5230 S \u7ed3\u6784\u4f53\u91cc\u7684\u5b57\u6bb5\uff0c\u4f46\u662f\u8fd9\u91cc\u5e76\u6ca1\u6709\u5c06\u5339\u914d\u5230\u7684\u5b57\u6bb5\u7ed1\u5b9a\u5230\u67d0\u4e00\u53d8\u91cf\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"On the first line of main, we call f() and perform an infallible match that binds no new variables. As no variables are declared on this line, there is no variable that could be the owner of the S returned by f() so that S is dropped at that point, printing 2. The S in let S = f() is a unit struct pattern (not a variable name) that matches a value of type S via destructuring but does not bind the value to any variable.")),(0,l.kt)("p",null,"main \u7684\u7b2c\u4e8c\u884c\u4ea7\u751f\u4e00\u4e2a\u65b0\u7684 S\uff0c\u5e76\u6253\u5370\uff0c\u6700\u540e\u5728\u5206\u53f7\u5904 drop \u5b83\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The second line of main conjures a new S, prints it, and drops it at the semicolon.")),(0,l.kt)("h2",{id:"26-lazy-map"},"#26 ",(0,l.kt)("inlineCode",{parentName:"h2"},"lazy map")),(0,l.kt)("h3",{id:"\u9898\u76ee-25"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn main() {\n    let input = vec![1, 2, 3];\n\n    let parity = input\n        .iter()\n        .map(|x| {\n            print!("{}", x);\n            x % 2\n        });\n\n    for p in parity {\n        print!("{}", p);\n    }\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-25"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u8bf7\u67e5\u9605 ",(0,l.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/iter/trait.Iterator.html"},"Iterator")," Trait \u7684\u6587\u6863"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Refer to the documentation of the Iterator trait.")),(0,l.kt)("h3",{id:"\u9898\u89e3-24"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a112031"),(0,l.kt)("p",null,"\u6b63\u5982 ",(0,l.kt)("inlineCode",{parentName:"p"},"Iterator::map")," \u65b9\u6cd5\u7684\u6587\u6863\u4e2d\u6240\u63cf\u8ff0\u7684\uff0cmap \u64cd\u4f5c\u662f\u60f0\u6027\u6267\u884c\u7684\u3002\u4f5c\u4e3a\u53c2\u6570\u63d0\u4f9b\u7ed9 map \u7684\u95ed\u5305\u53ea\u6709\u5728\u503c\u4ece\u7ed3\u679c\u8fed\u4ee3\u5668\u4e2d\u88ab\u6d88\u8017\u65f6\u624d\u4f1a\u88ab\u8c03\u7528\u3002\u95ed\u5305\u5e76\u4e0d\u4f1a\u7acb\u5373\u5e94\u7528\u4e8e\u6574\u4e2a\u8f93\u5165\u6d41\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"As described in the documentation of the Iterator::map method, the map operation is performed lazily. The closure provided as an argument to map is only invoked as values are consumed from the resulting iterator. The closure is not applied eagerly to the entire input stream up front.")),(0,l.kt)("p",null,"\u5728\u8fd9\u6bb5\u4ee3\u7801\u4e2d\uff0cfor \u5faa\u73af\u662f\u9a71\u52a8\u8fed\u4ee3\u7684\u56e0\u7d20\u3002\u5bf9\u4e8e\u4ece\u5947\u5076\u6027\u8fed\u4ee3\u5668\u4e2d\u6d88\u8017\u7684\u6bcf\u4e2a\u5143\u7d20\uff0c\u6211\u4eec\u7684\u95ed\u5305\u90fd\u9700\u8981\u88ab\u6267\u884c\u4e00\u6b21\u3002\u56e0\u6b64\uff0c\u8f93\u51fa\u5c06\u5728\u7531\u95ed\u5305\u6253\u5370\u7684\u6570\u5b57\u548c\u7531\u5faa\u73af\u4f53\u6253\u5370\u7684\u6570\u5b57\u4e4b\u95f4\u4ea4\u66ff\u8fdb\u884c\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In this code, the for loop is what drives the iteration. For each element consumed from the parity iterator, our closure needs to be evaluated one time. Thus the output will alternate between numbers printed by the closure and numbers printed by the loop body.")),(0,l.kt)("h2",{id:"27-dyn-trait"},"#27 ",(0,l.kt)("inlineCode",{parentName:"h2"},"dyn Trait")),(0,l.kt)("h3",{id:"\u9898\u76ee-26"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'trait Base {\n    fn method(&self) {\n        print!("1");\n    }\n}\n\ntrait Derived: Base {\n    fn method(&self) {\n        print!("2");\n    }\n}\n\nstruct BothTraits;\nimpl Base for BothTraits {}\nimpl Derived for BothTraits {}\n\nfn dynamic_dispatch(x: &dyn Base) {\n    x.method();\n}\n\nfn static_dispatch<T: Base>(x: T) {\n    x.method();\n}\n\nfn main() {\n    dynamic_dispatch(&BothTraits);\n    static_dispatch(BothTraits);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-26"},"\u63d0\u793a"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"Base::method")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"Derived::method")," \u78b0\u5de7\u6709\u76f8\u540c\u7684\u540d\u5b57\uff0c\u4f46\u662f\u662f\u6beb\u4e0d\u76f8\u5173\u7684\u4e24\u4e2a\u65b9\u6cd5\u3002\u4e0d\u4f1a\u4e92\u76f8\u8986\u76d6\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Base::method and ",(0,l.kt)("inlineCode",{parentName:"p"},"Derived::method")," happen to have the same name but are otherwise unrelated methods. One does not override the other.")),(0,l.kt)("h3",{id:"\u9898\u89e3-25"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a11"),(0,l.kt)("p",null,"\u8fd9\u4e24\u4e2a Trait\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"Base")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"Derived")," \u5404\u81ea\u5b9a\u4e49\u4e86\u4e00\u4e2a\u540d\u4e3a method \u7684 Trait \u65b9\u6cd5\u3002\u8fd9\u4e24\u4e2a\u65b9\u6cd5\u53ea\u662f\u78b0\u5de7\u62e5\u6709\u76f8\u540c\u7684\u540d\u79f0\uff0c\u4f46\u5728\u5176\u4ed6\u65b9\u9762\u5e76\u4e0d\u76f8\u5173\uff0c\u5982\u4e0b\u6587\u6240\u89e3\u91ca\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The two traits Base and Derived each define a trait method called method. These methods happen to have the same name but are otherwise unrelated methods as explained below.")),(0,l.kt)("p",null,"\u4e24\u4e2a Trait \u90fd\u4e3a method \u63d0\u4f9b\u4e86\u4e00\u4e2a\u9ed8\u8ba4\u7684\u5b9e\u73b0\u3002\u5982\u679c\u67d0\u4e2a\u5177\u4f53\u5b9e\u73b0\u6ca1\u6709\u5b9a\u4e49\u65b9\u6cd5\uff0c\u90a3\u4e48\u9ed8\u8ba4\u7684\u5b9e\u73b0\u5728\u6982\u5ff5\u4e0a\u4f1a\u88ab\u590d\u5236\u5230\u5177\u4f53\u7684\u5b9e\u73b0\u4e2d\u3002"),(0,l.kt)("p",null,"\u9ed8\u8ba4\u5b9e\u73b0\u5728\u6982\u5ff5\u4e0a\u88ab\u590d\u5236\u5230\u6bcf\u4e2a\u6ca1\u6709\u660e\u786e\u5b9a\u4e49\u76f8\u540c\u65b9\u6cd5\u7684 trait impl \u4e2d\u3002\u4f8b\u5982\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cBothTraits \u7684 impl Base \u6ca1\u6709\u63d0\u4f9b\u81ea\u5df1\u7684 Base::method \u7684\u5b9e\u73b0\uff0c\u8fd9\u610f\u5473\u7740 BothTraits \u7684 Base \u7684\u5b9e\u73b0\u5c06\u4f7f\u7528\u8be5 trait \u5b9a\u4e49\u7684\u9ed8\u8ba4\u884c\u4e3a\uff0c\u5373 print!"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Both traits provide a default implementation of their trait method. Default implementations are conceptually copied into each trait impl that does not explicitly define the same method. In this case for example impl Base for BothTraits does not provide its own implementation of ",(0,l.kt)("inlineCode",{parentName:"p"},"Base::method"),', which means the implementation of Base for BothTraits will use the default behavior defined by the trait i.e. print!("1").')),(0,l.kt)("p",null,"\u6b64\u5916\uff0cDerived \u5c06 Base \u4f5c\u4e3a\u4e00\u4e2a supertrait\uff0c\u8fd9\u610f\u5473\u7740\u6bcf\u4e2a\u5b9e\u73b0 Derived \u7684\u7c7b\u578b\u4e5f\u90fd\u9700\u8981\u5b9e\u73b0 Base\u3002\u8fd9\u4e24\u4e2a trait \u65b9\u6cd5\u5c3d\u7ba1\u540d\u5b57\u76f8\u540c\uff0c\u4f46\u5374\u6ca1\u6709\u5173\u7cfb -- \u56e0\u6b64\u4efb\u4f55\u5b9e\u73b0 Derived \u7684\u7c7b\u578b\u90fd\u4f1a\u6709 Derived::method \u548c Base::method \u7684\u5b9e\u73b0\uff0c\u800c\u4e14\u8fd9\u4e24\u4e2a\u65b9\u6cd5\u53ef\u4ee5\u81ea\u7531\u5730\u6709\u4e0d\u540c\u7684\u884c\u4e3a\u3002Supertraits \u4e0d\u662f\u7ee7\u627f\uff01Supertraits \u662f\u4e00\u79cd\u7279\u5f81\u7ea6\u675f\uff0c\u5982\u679c\u8981\u5b9e\u73b0 Derived\uff0c\u90a3\u4e48 Base \u4e5f\u5fc5\u987b\u88ab\u5b9e\u73b0\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Additionally, Derived has Base as a supertrait which means that every type that implements Derived is also required to implement Base. The two trait methods are unrelated despite having the same name -- thus any type that implements Derived will have an implementation of Derived::method as well as an implementation of ",(0,l.kt)("inlineCode",{parentName:"p"},"Base::method")," and the two are free to have different behavior. Supertraits are not inheritance! Supertraits are a constraint that if some trait is implemented, some other trait must also be implemented.")),(0,l.kt)("p",null,"\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u4ece main \u8c03\u7528\u7684\u4e24\u4e2a\u65b9\u6cd5\u7684\u5177\u4f53\u8fc7\u7a0b\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Let's consider what happens in each of the two methods called from main.")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"dynamic_dispatch(&BothTraits)")),(0,l.kt)("p",{parentName:"li"},"  \u53c2\u6570 x \u662f\u4e00\u4e2a\u5bf9\u7279\u5f81\u5bf9\u8c61 ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Base"),' \u7684\u5f15\u7528\u3002\u7279\u5f81\u5bf9\u8c61\u662f\u7531\u7f16\u8bd1\u5668\u751f\u6210\u7684\u4e00\u4e2a "\u5c0f\u57ab\u7247"\uff0c\u5b83\u5177\u6709\u548c Trait \u76f8\u540c\u7684\u540d\u79f0 (\u5982\u4e0b\u6240\u793a)\uff0c\u53ef\u4ee5\u901a\u8fc7\u5c06\u6240\u6709\u7279\u8d28\u65b9\u6cd5\u7684\u8c03\u7528\uff0c\u8f6c\u53d1\u5230\u539f\u59cb\u7c7b\u578b\u7684\u7279\u8d28\u65b9\u6cd5\u3002\u8f6c\u53d1\u662f\u901a\u8fc7\u8bfb\u53d6\u7279\u5f81\u5bf9\u8c61\u91cc\u5305\u542b\u7684\u51fd\u6570\u6307\u9488\u8868\u6765\u5b8c\u6210\u7684\u3002'),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"The argument x is a reference to the trait object type dyn Base. A trait object is a little shim generated by the compiler that implements the trait with the same name by forwarding all trait method calls to trait methods of whatever type the trait object was created from. The forwarding is done by reading from a table of function pointers contained within the trait object.")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"// Generated by the compiler.\n//\n// This is an implementation of the trait `Base` for the\n// trait object type `dyn Base`, which you can think of as\n// a struct containing function pointers.\nimpl Base for (dyn Base) {\n    fn method(&self) {\n        /*\n        Some automatically generated implementation detail\n        that ends up calling the right type's impl of the\n        trait method Base::method.\n        */\n    }\n}\n")),(0,l.kt)("p",{parentName:"li"},"  \u5728 quiz \u4ee3\u7801\u91cc\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"x.method()")," \u5b9e\u9645\u4e0a\u662f\u8c03\u7528\u7531\u7f16\u8bd1\u5668\u81ea\u52a8\u751f\u6210\u7684\u65b9\u6cd5\uff0c\u5b83\u7684\u540d\u5b57\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"<dyn Base as Base>::method"),"\u3002\u7531\u4e8e x \u662f\u901a\u8fc7\u5c06 ",(0,l.kt)("inlineCode",{parentName:"p"},"BothTraits")," \u8f6c\u6362\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Base")," \u5f97\u5230\u7684\uff0c\u81ea\u52a8\u751f\u6210\u7684\u5b9e\u73b0\u5c06\u8f6c\u53d1\u5230 ",(0,l.kt)("inlineCode",{parentName:"p"},"<BothTraits as Base>::method"),"\uff0c\u6700\u540e\u6253\u5370\u51fa 1\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"In the quiz code, ",(0,l.kt)("inlineCode",{parentName:"p"},"x.method()")," is a call to this automatically generated method whose fully qualified name is ",(0,l.kt)("inlineCode",{parentName:"p"},"<dyn Base as Base>::method"),". Since x was obtained by converting a BothTraits to dyn Base, the automatically generated implementation detail will wind up forwarding to ",(0,l.kt)("inlineCode",{parentName:"p"},"<BothTraits as Base>::method")," which prints 1.")),(0,l.kt)("p",{parentName:"li"},"  \u5e0c\u671b\u4ece\u8fd9\u4e00\u5207\u53ef\u4ee5\u770b\u51fa\uff0c\u8fd9\u91cc\u6ca1\u6709\u4efb\u4f55\u4e1c\u897f\u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"BothTraits")," \u5b9a\u4e49\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"Derived::method")," \u6709\u5173\u3002\u7279\u522b\u8981\u6ce8\u610f\u7684\u662f\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"x.method()")," \u4e0d\u53ef\u80fd\u662f\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"Derived::method")," \u7684\u8c03\u7528\uff0c\u56e0\u4e3a x \u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Base")," \u7c7b\u578b\uff0c\u800c ",(0,l.kt)("inlineCode",{parentName:"p"},"dyn Base")," \u5e76\u6ca1\u6709 ",(0,l.kt)("inlineCode",{parentName:"p"},"Derived")," \u7684\u5b9e\u73b0\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"Hopefully it's clear from all of this that nothing here has anything to do with the unrelated trait method Derived::method defined by BothTraits. Especially notice that ",(0,l.kt)("inlineCode",{parentName:"p"},"x.method()")," cannot be a call to Derived::method because x is of type dyn Base and there is no implementation of Derived for dyn Base."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"static_dispatch(BothTraits)"),(0,l.kt)("p",{parentName:"li"},"  \u5728\u7f16\u8bd1\u65f6\u6211\u4eec\u77e5\u9053 ",(0,l.kt)("inlineCode",{parentName:"p"},"x.method()")," \u662f\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"<T as Base>::method")," \u7684\u8c03\u7528\u3002Rust \u4e2d\u5bf9\u6cdb\u578b\u51fd\u6570\u7684\u7c7b\u578b\u63a8\u65ad\u662f\u72ec\u7acb\u4e8e\u6cdb\u578b\u51fd\u6570\u7684\u4efb\u4f55\u5177\u4f53\u5b9e\u4f8b\u800c\u53d1\u751f\u7684\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5728\u6211\u4eec\u77e5\u9053 T \u53ef\u80fd\u662f\u4ec0\u4e48\u4e4b\u524d\uff0c\u53ea\u77e5\u9053\u5b83\u5b9e\u73b0\u4e86 Base \u8fd9\u4e00\u4e8b\u5b9e\u3002\u56e0\u6b64\uff0c\u5177\u4f53\u7c7b\u578b T \u4e0a\u7684\u4efb\u4f55\u56fa\u6709\u65b9\u6cd5\u6216\u4efb\u4f55\u5176\u4ed6\u7279\u5f81\u65b9\u6cd5\u90fd\u4e0d\u53ef\u80fd\u5f71\u54cd ",(0,l.kt)("inlineCode",{parentName:"p"},"x.method()")," \u7684\u8c03\u7528\u3002\u5728\u51b3\u5b9a T \u7684\u65f6\u5019\uff0c\u5df2\u7ecf\u786e\u5b9a ",(0,l.kt)("inlineCode",{parentName:"p"},"x.method()")," \u4f1a\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"<T as Base>::method"),"\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"At compile time we know that ",(0,l.kt)("inlineCode",{parentName:"p"},"x.method()")," is a call to ",(0,l.kt)("inlineCode",{parentName:"p"},"<T as Base>::method"),". Type inference within generic functions in Rust happens independently of any concrete instantiation of the generic function i.e. before we know what T may be, other than the fact that it implements Base. Thus no inherent method on the concrete type T or any other trait method may affect what method ",(0,l.kt)("inlineCode",{parentName:"p"},"x.method()")," is calling. By the time that T is decided, it has already been determined that ",(0,l.kt)("inlineCode",{parentName:"p"},"x.method()")," is calling ",(0,l.kt)("inlineCode",{parentName:"p"},"<T as Base>::method"),".")),(0,l.kt)("p",{parentName:"li"},"  \u6cdb\u578b\u51fd\u6570\u5728\u5b9e\u4f8b\u5316\u65f6\uff0cT \u7b49\u4e8e BothTraits\uff0c\u6240\u4ee5\u8fd9\u5c06\u4f1a\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"<BothTraits as Base>::method"),"\uff0c\u6253\u5370\u51fa 1\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"The generic function is instantiated with T equal to BothTraits so this is going to call ",(0,l.kt)("inlineCode",{parentName:"p"},"<BothTraits as Base>::method")," which prints 1.")))),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If you are familiar with C++, the behavior of this code in Rust is different from the behavior of superficially analogous C++ code. In C++ the output would be 22 as seen in the following implementation. This highlights the difference between Rust's traits and supertraits vs C++'s inheritance.")),(0,l.kt)("p",null,"\u5982\u679c\u4f60\u719f\u6089 C++\uff0c\u8fd9\u6bb5\u4ee3\u7801\u5728 Rust \u4e2d\u7684\u884c\u4e3a\u4e0e\u8868\u9762\u4e0a\u7c7b\u4f3c\u7684 C++\u4ee3\u7801\u7684\u884c\u4e3a\u662f\u4e0d\u540c\u7684\u3002\u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"C++")," \u4e2d\uff0c\u8f93\u51fa\u5c06\u662f 22\uff0c\u6b63\u5982\u5728\u4e0b\u9762\u7684\u5b9e\u73b0\u4e2d\u770b\u5230\u7684\u90a3\u6837\u3002\u8fd9\u7a81\u51fa\u4e86 Rust \u7684 traits \u548c supertraits \u4e0e C++ \u7684\u7ee7\u627f\u4e4b\u95f4\u7684\u533a\u522b\u3002"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nstruct Base {\n    virtual void method() const {\n        std::cout << "1";\n    }\n};\n\nstruct Derived: Base {\n    void method() const {\n        std::cout << "2";\n    }\n};\n\nvoid dynamic_dispatch(const Base &x) {\n    x.method();\n}\n\ntemplate <typename T>\nvoid static_dispatch(const T x) {\n    x.method();\n}\n\nint main() {\n    dynamic_dispatch(Derived{});\n    static_dispatch(Derived{});\n}\n')),(0,l.kt)("h2",{id:"28-_guard--_"},"#28 ",(0,l.kt)("inlineCode",{parentName:"h2"},"_guard & _")),(0,l.kt)("h3",{id:"\u9898\u76ee-27"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'struct Guard;\n\nimpl Drop for Guard {\n    fn drop(&mut self) {\n        print!("1");\n    }\n}\n\nfn main() {\n    let _guard = Guard;\n    print!("3");\n    let _ = Guard;\n    print!("2");\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-27"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u5f53\u4e00\u4e2a\u503c\u4e0d\u518d\u6709\u6240\u6709\u8005\u65f6\uff0c\u5b83\u5c31\u88ab drop \u4e86\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"A value is dropped when it no longer has an owner.")),(0,l.kt)("h3",{id:"\u9898\u89e3-26"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a3121"),(0,l.kt)("p",null,"\u8be5\u7a0b\u5e8f\u6253\u5370\u51fa 3121\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"let _guard = Guard")," \u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"Drop")," \u5728 main \u7684\u672b\u5c3e\u8fd0\u884c\uff0c\u4f46\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"let _ = Guard")," \u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"Drop")," \u5374\u7acb\u5373\u8fd0\u884c\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The program prints 3121. That is, the Drop impl for let ",(0,l.kt)("em",{parentName:"p"},"guard = Guard runs at the end of main but the Drop impl for let ")," = Guard runs right away.")),(0,l.kt)("p",null,"\u4e00\u822c\u6765\u8bf4\uff0c\u5f53\u4e00\u4e2a\u503c\u4e0d\u518d\u6709\u6240\u6709\u8005\u65f6\uff0c\u5b83\u5c31\u4f1a\u88ab\u653e\u5f03\u3002\u53d8\u91cf ",(0,l.kt)("inlineCode",{parentName:"p"},"_guard")," \u62e5\u6709 Guard \u7c7b\u578b\u7684\u7b2c\u4e00\u4e2a\u503c\uff0c\u5e76\u4e14\u5728 main \u7ed3\u675f\u524d\u4e00\u76f4\u5904\u4e8e\u4f5c\u7528\u57df\u4e2d\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"_")," \u4e0d\u662f\u4e00\u4e2a\u53d8\u91cf\uff0c\u800c\u662f\u4e00\u4e2a\u901a\u914d\u7b26\u6a21\u5f0f\uff0c\u5b83\u6ca1\u6709\u7ed1\u5b9a\u4efb\u4f55\u4e1c\u897f\uff1b\u56e0\u4e3a\u8fd9\u4e00\u884c\u6ca1\u6709\u7ed1\u5b9a\u4efb\u4f55\u53d8\u91cf\uff0c\u6240\u4ee5\u6ca1\u6709\u53d8\u91cf\u6210\u4e3a Guard \u7c7b\u578b\u7684\u7b2c\u4e8c\u4e2a\u503c\u7684\u6240\u6709\u8005\uff0c\u8be5\u503c\u5728\u540c\u4e00\u884c\u88ab\u4e22\u5f03\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In general, a value is dropped when it no longer has an owner. The variable ",(0,l.kt)("em",{parentName:"p"},"guard owns the first value of type Guard and remains in scope until the end of main. The ")," is not a variable but a wildcard pattern that binds nothing; since no variables are bound on this line, there is no variable to be the owner of the second value of type Guard and that value is dropped on the same line.")),(0,l.kt)("p",null,"\u4e0b\u5212\u7ebf\u6a21\u5f0f\u4e0e\u5e26\u4e0b\u5212\u7ebf\u7684\u53d8\u91cf\u4e4b\u95f4\u7684\u533a\u522b\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u5f88\u91cd\u8981\uff0c\u7279\u522b\u662f\u5f53\u5728 unsafe \u4ee3\u7801\u4e2d\u4f7f\u7528\u9501\u65f6\uff0c"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This distinction between the underscore pattern vs variables with a leading underscore is incredibly important to remember when working with lock guards in unsafe code.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"use std::sync::Mutex;\n\nstatic MUTEX: Mutex<()> = Mutex::new(());\n\n/// MUTEX must be held when accessing this value.\nstatic mut VALUE: usize = 0;\n\nfn main() {\n    let _guard = MUTEX.lock().unwrap();\n    unsafe {\n        VALUE += 1;\n    }\n}\n")),(0,l.kt)("p",null,"\u5982\u679c\u8fd9\u6bb5\u4ee3\u7801\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"let _ = MUTEX.lock().unwrap()"),"\uff0c\u5219\u4f1a\u7acb\u5373\u91ca\u653e\u4e92\u65a5\u9501\uff0c\u65e0\u6cd5\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"VALUE")," \u7684\u8bbf\u95ee\u8fdb\u884c\u9650\u5236\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If this code were to use ",(0,l.kt)("inlineCode",{parentName:"p"},"let _ = MUTEX.lock().unwrap()")," then the mutex guard would be dropped immediately, releasing the mutex and failing to guard the access of VALUE.")),(0,l.kt)("h2",{id:"29-t--t"},"#29 ",(0,l.kt)("inlineCode",{parentName:"h2"},"(T) & (T,)")),(0,l.kt)("h3",{id:"\u9898\u76ee-28"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'trait Trait {\n    fn p(&self);\n}\n\nimpl Trait for (u32) {\n    fn p(&self) { print!("1"); }\n}\n\nimpl Trait for (i32,) {\n    fn p(&self) { print!("2"); }\n}\n\nimpl Trait for (u32, u32) {\n    fn p(&self) { print!("3"); }\n}\n\nimpl Trait for (i32, i32,) {\n    fn p(&self) { print!("4"); }\n}\n\nfn main() {\n    (0).p();\n    (0,).p();\n    (0, 0).p();\n    (0, 0,).p();\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-28"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u62ec\u53f7\u5185\u7684\u503c\u4e0e\u53ea\u6709\u4e00\u4e2a\u5143\u7d20\u7684\u5143\u7ec4\u7684\u7c7b\u578b\u4e0d\u4e00\u6837\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"A value in parentheses does not have the same type as a 1-tuple.")),(0,l.kt)("h3",{id:"\u9898\u89e3-27"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a1244"),(0,l.kt)("p",null,"\u5728\u5355\u5143\u7d20\u5143\u7ec4\u7684\u60c5\u51b5\u4e0b\uff0c\u5c3e\u90e8\u7684\u9017\u53f7\u662f\u5fc5\u987b\u7684\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5c06\u5176\u4e0e\u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"(0)")," \u533a\u5206\u5f00\u6765 (",(0,l.kt)("inlineCode",{parentName:"p"},"(0)")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," \u76f8\u540c)\u3002\u7136\u800c\uff0c\u5bf9\u4e8e\u66f4\u5927\u7684\u5143\u7ec4\uff0c\u5b83\u662f\u5b8c\u5168\u53ef\u9009\u7684\uff1a",(0,l.kt)("inlineCode",{parentName:"p"},"(i32)")," \u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"(i32,)")," \u662f\u4e0d\u540c\u7684\u7c7b\u578b\uff0c\u4f46\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"(i32, i32)")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"(i32, i32, )")," \u662f\u76f8\u540c\u7684\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The trailing comma is required in the case of a 1-tuple, (0,), because it disambiguates it from (0) which is identical to 0. However, for larger tuples, it is entirely optional: (i32) is a distinct type from (i32,), but (i32, i32) and (i32, i32,) are the same.")),(0,l.kt)("p",null,"\u4e00\u4e2a\u6574\u5f62 0 \u53ef\u4ee5\u88ab\u63a8\u65ad\u4e3a\u4efb\u4f55\u6574\u6570\u7c7b\u578b\uff0c\u4f46\u5982\u679c\u6ca1\u6709\u8db3\u591f\u7684\u7c7b\u578b\u4fe1\u606f\uff0c\u5219\u9ed8\u8ba4\u63a8\u65ad\u4e3a i32\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"(0)")," \u88ab\u63a8\u65ad\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"u32"),"\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"(0,)")," \u88ab\u63a8\u65ad\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"(i32,)"),"\uff0c\u56e0\u4e3a\u5b83\u4eec\u5206\u522b\u5177\u6709\u552f\u4e00\u7684 Trait \u5b9e\u73b0\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"An integral literal 0 can be inferred to be any integer type, but defaults to i32 if insufficient type information is available. (0) is inferred to be a u32 and (0,) is inferred to be a (i32,) because those are respectively the only integral and 1-tuple types with an implementation for Trait.")),(0,l.kt)("p",null,"\u7531\u4e8e ",(0,l.kt)("inlineCode",{parentName:"p"},"(0, 0)")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"(0, 0,)")," \u5177\u6709\u76f8\u540c\u7684\u7c7b\u578b\uff0c\u5b83\u4eec\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"p")," \u65b9\u6cd5\u7684\u8f93\u51fa\u4e5f\u662f\u76f8\u540c\u7684\uff0c\u4f46\u662f Rust \u9700\u8981\u5728 Trait \u7684\u4e24\u79cd\u53ef\u80fd\u7684\u5b9e\u73b0\u4e2d\u8fdb\u884c\u9009\u62e9\uff0c\u5373 ",(0,l.kt)("inlineCode",{parentName:"p"},"(u32, u32)")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"(i32, i32)"),"\u3002\u7531\u4e8e ",(0,l.kt)("inlineCode",{parentName:"p"},"i32")," \u662f\u9ed8\u8ba4\u7684\u6574\u5f62\u7c7b\u578b\uff0c\u6240\u4ee5\u5728\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e0b\u90fd\u4f1a\u9009\u62e9 ",(0,l.kt)("inlineCode",{parentName:"p"},"(i32, i32)"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Since (0, 0) and (0, 0,) have the same type, the output of their p methods must be the same, but Rust needs to somehow choose between the two possible implementations of Trait, namely (u32, u32) and (i32, i32). Since i32 is the default integral type, (i32, i32) is chosen in both cases.")),(0,l.kt)("h2",{id:"30-clone"},"#30 ",(0,l.kt)("inlineCode",{parentName:"h2"},"clone")),(0,l.kt)("h3",{id:"\u9898\u76ee-29"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'use std::rc::Rc;\n\nstruct A;\n\nfn p<X>(x: X) {\n    match std::mem::size_of::<X>() {\n        0 => print!("0"),\n        _ => print!("1"),\n    }\n}\n\nfn main() {\n    let a = &A;\n    p(a);\n    p(a.clone());\n    \n    let b = &();\n    p(b);\n    p(b.clone());\n    \n    let c = Rc::new(());\n    p(Rc::clone(&c));\n    p(c.clone());\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-29"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u4e0d\u53ef\u53d8\u7684\u6307\u9488 ",(0,l.kt)("inlineCode",{parentName:"p"},"&T")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"Rc<T>")," \u5b9e\u73b0\u4e86 ",(0,l.kt)("inlineCode",{parentName:"p"},"Clone"),"\uff0c\u5373\u4f7f ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," \u5e76\u6ca1\u6709\u5b9e\u73b0\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Immutable pointers ",(0,l.kt)("inlineCode",{parentName:"p"},"&T")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"Rc<T>")," implement Clone even if T doesn't.")),(0,l.kt)("h3",{id:"\u9898\u89e3-28"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a111011"),(0,l.kt)("p",null,"\u8fd9\u91cc\u51fa\u73b0\u7684\u4e24\u4e2a\u975e\u5f15\u7528\u7c7b\u578b\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"()")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"A")," \u90fd\u662f\u96f6\u5927\u5c0f\u7c7b\u578b (ZST)\u3002\u5982\u679c\u4f60\u5411\u51fd\u6570 ",(0,l.kt)("inlineCode",{parentName:"p"},"p<X>")," \u4f20\u4e00\u4e2a ",(0,l.kt)("inlineCode",{parentName:"p"},"X = ()")," \u6216\u8005 ",(0,l.kt)("inlineCode",{parentName:"p"},"X = A"),"\uff0c\u90a3\u4e48\u4f1a\u6253\u5370 0\u3002\u5982\u679c\u4f20\u7684\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"X = \uff06()")," \u6216\u8005 ",(0,l.kt)("inlineCode",{parentName:"p"},"X = &A"),"\uff0c\u65e0\u8bba\u6307\u9488\u6709\u591a\u5927\uff0c\u603b\u4f1a\u6253\u5370 1\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Both of our non-reference types, ",(0,l.kt)("inlineCode",{parentName:"p"},"()")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"A"),", are zero-sized types (ZST). The function ",(0,l.kt)("inlineCode",{parentName:"p"},"p<X>")," will print 0 if it is passed a value of type ",(0,l.kt)("inlineCode",{parentName:"p"},"X = ()")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"X = A"),", and it will print 1 if passed a reference ",(0,l.kt)("inlineCode",{parentName:"p"},"X = &()")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"X = &A")," regardless of exactly how big pointers happen to be.")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"p(a)")," \u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"X = &A")," \u8c03\u7528 p\uff0c\u56e0\u4e3a\u53c2\u6570 a \u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"&A")," \u7c7b\u578b\u7684\uff1b\u6253\u5370\u51fa 1\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"p(a) invokes p with X = &A because the argument a is of type ",(0,l.kt)("inlineCode",{parentName:"p"},"&A"),"; this prints 1.")),(0,l.kt)("p",null,"\u5728\u4e0b\u4e00\u884c ",(0,l.kt)("inlineCode",{parentName:"p"},"p(a.clone())"),"\uff0c\u5982\u679c A \u5b9e\u73b0\u4e86 Clone\uff0c\u90a3\u4e48 ",(0,l.kt)("inlineCode",{parentName:"p"},"a.clone()")," \u4f1a\u8c03\u7528\u5bf9\u5e94\u7684\u5b9e\u73b0\u3002\u4f46\u662f\u5b83\u6ca1\u6709\uff0c\u7f16\u8bd1\u5668\u53d1\u73b0 ",(0,l.kt)("inlineCode",{parentName:"p"},"&T")," \u5b9e\u73b0\u4e86 Clone\uff0c\u6240\u4ee5\u8fd9\u91cc\u4f1a\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"&A")," \u5b9e\u73b0\u7684 Clone\uff0c\u5b83\u4f1a\u901a\u8fc7\u7b80\u5355\u5730\u91cd\u590d\u5f15\u7528\uff0c\u5c06\u4e00\u4e2a ",(0,l.kt)("inlineCode",{parentName:"p"},"&&A")," \u8f6c\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"&A"),"\u3002\u5bf9 p \u7684\u8c03\u7528\u4e2d\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"X = &A"),"\uff0c\u4e5f\u4f1a\u6253\u5370 1\u3002\u5728\u5b9e\u8df5\u4e2d\uff0c\u5f53\u5305\u542b\u5f15\u7528\u7684\u7ed3\u6784\u60f3\u8981\u6d3e\u751f\u51fa Clone \u65f6\uff0cClone \u5bf9\u5f15\u7528\u7684\u5f71\u54cd\u662f\u975e\u5e38\u6709\u7528\u7684\uff0c\u4f46\u6b63\u5982\u8fd9\u91cc\u6240\u770b\u5230\u7684\uff0c\u5b83\u6709\u65f6\u4f1a\u610f\u5916\u5730\u542f\u52a8\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"On the next line, if A implemented Clone then a.clone() would be a call to that impl. But since it doesn't, the compiler finds another applicable impl which is the implementation of Clone for references &T -- so concretely the clone call is calling the impl of Clone for &A which turns a &&A into a &A by simply duplicating the reference. We get another call to p with X = &A printing 1. The impl of Clone for references is useful in practice when a struct containing a reference wants to derive Clone, but as seen here it can sometimes kick in unexpectedly.")),(0,l.kt)("p",null,"\u7c7b\u578b ",(0,l.kt)("inlineCode",{parentName:"p"},"()")," \u786e\u5b9e\u5b9e\u73b0\u4e86 Clone\uff0c\u6240\u4ee5 ",(0,l.kt)("inlineCode",{parentName:"p"},"b.clone()")," \u8c03\u7528\u4e86\u8be5\u5b9e\u73b0\uff0c\u4ea7\u751f\u4e86 ",(0,l.kt)("inlineCode",{parentName:"p"},"()"),"\u3002\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"&()"),"\u7684 Clone \u5b9e\u73b0\u4e5f\u9002\u7528\u4e8e A \u7684\u60c5\u51b5\uff0c\u4f46\u662f\u7f16\u8bd1\u5668\u66f4\u559c\u6b22\u8c03\u7528 trait impl for ()\uff0c\u5c06 ",(0,l.kt)("inlineCode",{parentName:"p"},"&()")," \u8f6c\u6362\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"()")," \uff0c\u800c\u4e0d\u662f trait impl for &()\uff0c\u5c06 ",(0,l.kt)("inlineCode",{parentName:"p"},"&&()")," \u8f6c\u6362\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"&()"),"\uff0c\u56e0\u4e3a\u524d\u8005\u5bf9 trait solver \u63d2\u5165\u7684\u9690\u5f0f\u5f15\u7528\u6216\u53d6\u6d88\u5f15\u7528\u7684\u8981\u6c42\u66f4\u5c11\u3002\u5728\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"b.clone()")," \u7684\u8c03\u7528\u4e2d\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"b")," \u7684\u7c7b\u578b\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"&()"),"\uff0c\u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"impl Clone for ()")," \u7684\u53c2\u6570\u5b8c\u5168\u5339\u914d\uff0c\u800c\u4e3a\u4e86\u62ff\u5230 ",(0,l.kt)("inlineCode",{parentName:"p"},"&&()")," \u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9 ",(0,l.kt)("inlineCode",{parentName:"p"},"impl Clone for &()"),"\uff0c\u7279\u5f81\u6c42\u89e3\u5668\u8fd8\u9700\u8981\u63d2\u5165\u989d\u5916\u7684\u9690\u5f0f\u5f15\u7528\u5c42 -- \u6709\u6548\u5730\u8ba1\u7b97 ",(0,l.kt)("inlineCode",{parentName:"p"},"(&b).clone()"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The type () does implement Clone so b.clone() invokes that impl and produces (). The implementation of Clone for &() would also be applicable as happened in the case of A, but the compiler prefers calling the trait impl for () which converts &() to () over the trait impl for &() which converts &&() to &() because the former is the one that requires fewer implicit references or dereferences inserted by the trait solver. In the call to b.clone(), b is of type &() which exactly matches the argument of the impl Clone for (), while in order to obtain a &&() to pass as argument to the impl Clone for &() the trait solver would need to insert an additional layer of referencing implicitly -- effectively computing (&b).clone().")),(0,l.kt)("p",null,"\u6211\u4eec\u5728\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"p(b)")," \u65f6\u5b9e\u9645\u4f20\u5165\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"X = \uff06()"),"\uff0c\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"p(b.clone())")," \u65f6\u5219\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"X = ()"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"What we get is p(b) calling p with X = &() and p(b.clone()) calling p with X = (). Together these print 10.")),(0,l.kt)("p",null,"\u6700\u540e\u662f Rc\uff0c\u4e24\u6b21\u5bf9 b \u7684\u8c03\u7528\u90fd\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"X = Rc<()>"),"\uff0c\u5927\u5c0f\u4e0d\u4e3a\u96f6\u3002\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"Rc::clone(&c)")," \u800c\u4e0d\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"c.clone()")," \u6765\u514b\u9686\u4e00\u4e2a Rc \u88ab\u8ba4\u4e3a\u662f\u4e60\u60ef\u6027\u7684\uff0c\u56e0\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"Rc::clone()")," \u4f7f\u4eba\u660e\u663e\u611f\u89c9\u5230\u8fd9\u662f\u4e00\u4e2a\u5f15\u7528\u8ba1\u6570\u7684\u589e\u52a0\uff0c\u800c\u4e0d\u662f\u514b\u9686\u5e95\u5c42\u6570\u636e\uff0c\u4f46\u6700\u7ec8\u4e24\u8005\u6307\u7684\u662f\u540c\u4e00\u4e2a\u51fd\u6570\u3002\u8981\u5728 Rc \u5185\u90e8\u8c03\u7528\u4e00\u4e2a\u503c\u7684\u514b\u9686\uff0c\u4f60\u9700\u8981\u5148\u5bf9\u5b83\u89e3\u5f15\u7528\uff1a",(0,l.kt)("inlineCode",{parentName:"p"},"(*c).clone()"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Finally in the Rc case, both calls to p are with ",(0,l.kt)("inlineCode",{parentName:"p"},"X = Rc<()>")," which is non-zero sized. It is considered idiomatic to clone a Rc using ",(0,l.kt)("inlineCode",{parentName:"p"},"Rc::clone(&c)")," instead of ",(0,l.kt)("inlineCode",{parentName:"p"},"c.clone()")," because it makes it apparent that this is a reference count bump rather than cloning underlying data, but ultimately both refer to the same function. To call the clone method of a value inside a Rc, you would need to dereference it first: ",(0,l.kt)("inlineCode",{parentName:"p"},"(*c).clone()"),".")),(0,l.kt)("h2",{id:"31-method-lookup-order"},"#31 ",(0,l.kt)("inlineCode",{parentName:"h2"},"method lookup order")),(0,l.kt)("h3",{id:"\u9898\u76ee-30"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'trait Or {\n    fn f(self);\n}\n\nstruct T;\n\nimpl Or for &T {\n    fn f(self) {\n        print!("1");\n    }\n}\n\nimpl Or for &&&&T {\n    fn f(self) {\n        print!("2");\n    }\n}\n\nfn main() {\n    let t = T;\n    let wt = &T;\n    let wwt = &&T;\n    let wwwt = &&&T;\n    let wwwwt = &&&&T;\n    let wwwwwt = &&&&&T;\n    t.f();\n    wt.f();\n    wwt.f();\n    wwwt.f();\n    wwwwt.f();\n    wwwwwt.f();\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-30"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u5728\u65b9\u6cd5\u67e5\u627e\u8fc7\u7a0b\u4e2d\uff0cRust \u4f1a\u81ea\u52a8\u89e3\u5f15\u7528\uff0c\u5e76\u4ee5\u660e\u786e\u7684\u987a\u5e8f\u501f\u7528\u63a5\u6536\u5668\uff0c\u76f4\u5230\u627e\u5230\u7b2c\u4e00\u4e2a\u6709\u5408\u9002\u7b7e\u540d\u7684\u51fd\u6570\u3002\u8fd9\u4e2a\u987a\u5e8f\u662f\u4ec0\u4e48\u5462\uff1f"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"During a method lookup, Rust automatically derefences and borrows the receiver in a well-defined order until it finds the first function with a suitable signature. What is that order?")),(0,l.kt)("h3",{id:"\u9898\u89e3-29"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a111222"),(0,l.kt)("p",null,"\u8fd9\u7bc7 ",(0,l.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/expressions/method-call-expr.html"},"\u5f15\u7528")," \u63cf\u8ff0\u4e86 Rust \u7684\u65b9\u6cd5\u67e5\u627e\u987a\u5e8f\u3002\u76f8\u5173\u7684\u6bb5\u843d\u5982\u4e0b\uff1a "),(0,l.kt)("p",null,"\u83b7\u5f97 ","[\u5019\u9009\u63a5\u6536\u65b9\u7c7b\u578b]"," \u7684\u65b9\u6cd5\u662f\uff1a\u53cd\u590d\u89e3\u5f15\u7528\u63a5\u53d7\u8005\u8868\u8fbe\u5f0f\u7684\u7c7b\u578b\uff0c\u5c06\u9047\u5230\u7684\u6bcf\u4e2a\u7c7b\u578b\u6dfb\u52a0\u5230\u5217\u8868\u4e2d\uff0c\u6700\u540e\u5c1d\u8bd5\u5728\u6700\u540e\u8fdb\u884c\u975e\u5927\u5c0f\u80c1\u8feb\uff0c\u5982\u679c\u6210\u529f\uff0c\u5219\u6dfb\u52a0\u7ed3\u679c\u7c7b\u578b\u3002\u7136\u540e\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5019\u9009\u7684T\uff0c\u5c06 ",(0,l.kt)("inlineCode",{parentName:"p"},"&T")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"&mut T")," \u6dfb\u52a0\u5230\u7d27\u8ddf ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," \u7684\u5217\u8868\u4e2d\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The ",(0,l.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/expressions/method-call-expr.html"},"Reference")," describes Rust's method lookup order. The relevant paragraph is:")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Obtain ","[the candidate receiver type]"," by repeatedly dereferencing the receiver expression's type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, and adding the result type if that is successful. Then, for each candidate T, add &T and &mut T to the list immediately after T.")),(0,l.kt)("p",null,"\u628a\u8fd9\u4e9b\u89c4\u5219\u6dfb\u52a0\u5230\u6240\u7ed9\u7684\u4f8b\u5b50\u91cc\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Applying these rules to the given examples, we have:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"t.f()"),": \u6211\u4eec\u8bd5\u56fe\u627e\u5230\u4e00\u4e2a\u5b9a\u4e49\u5728\u7c7b\u578b ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," \u4e0a\u7684\u51fd\u6570 f\uff0c\u4f46\u662f\u6ca1\u6709\u3002\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u641c\u7d22\u7c7b\u578b ",(0,l.kt)("inlineCode",{parentName:"p"},"&T"),"\uff0c\u5e76\u627e\u5230 ",(0,l.kt)("inlineCode",{parentName:"p"},"Or")," \u7279\u5f81\u7684\u7b2c\u4e00\u4e2a\u5b9e\u73b0\uff0c\u7136\u540e\u6211\u4eec\u5c31\u5b8c\u6210\u4e86\u3002\u5728\u8c03\u7528\u65f6\uff0c\u627e\u5230\u7684\u8c03\u7528\u4f1a\u6253\u5370\u51fa 1\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"t.f(): We try to find a function f defined on the type T, but there is none. Next, we search the type &T, and find the first implemenation of the Or trait, and we are done. Upon invocation, the resolved call prints 1."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"wt.f()"),": \u6211\u4eec\u641c\u7d22\u4e00\u4e2a\u5b9a\u4e49\u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"&T")," \u4e0a\u7684\u51fd\u6570 f\uff0c\u7acb\u523b\u5c31\u6210\u529f\u4e86\u3002\u8c03\u7528\u540e\uff0c\u8be5\u51fd\u6570\u6253\u5370\u51fa 1\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"We search for a function f defined on &T, which immediately succeeds. Upon invocation, the function prints 1."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"wwt.f()"),": \u641c\u7d22\u987a\u5e8f\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"&&T -> &&&T -> &mut &&T -> &T"),"\uff0c\u7ed3\u679c\u6253\u5370 1\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"The search order is ",(0,l.kt)("inlineCode",{parentName:"p"},"&&T -> &&&T -> &mut &&T -> &T"),", and we're done. Upon invocation, the function prints 1."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"wwwt.f()"),": ",(0,l.kt)("inlineCode",{parentName:"p"},"&&&T -> &&&&T")," \u8fd9\u4e2a\u6253\u5370 2\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("inlineCode",{parentName:"p"},"&&&T -> &&&&T"),". This prints 2."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"wwwwt.f()"),": ",(0,l.kt)("inlineCode",{parentName:"p"},"&&&&T")," \u8fd9\u4e2a\u6253\u5370 2\u3002 "),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("inlineCode",{parentName:"p"},"&&&&T"),". This prints 2."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"wwwwwt.f()"),": ",(0,l.kt)("inlineCode",{parentName:"p"},"&&&&&T -> &&&&&&T -> &mut &&&&&T -> &&&&T")," \u8fd9\u4e2a\u6253\u5370 2\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("inlineCode",{parentName:"p"},"&&&&&T -> &&&&&&T -> &mut &&&&&T -> &&&&T"),". This prints 2.")))),(0,l.kt)("h2",{id:"32-march-arm--if-guard"},"#32 ",(0,l.kt)("inlineCode",{parentName:"h2"},"march arm & if guard")),(0,l.kt)("h3",{id:"\u9898\u76ee-31"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn check(x: i32) -> bool {\n    print!("{}", x);\n    false\n}\n\nfn main() {\n    match (1, 2) {\n        (x, _) | (_, x) if check(x) => {\n            print!("3")\n        }\n        _ => print!("4"),\n    }\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-31"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u65e0\u8bba\u54ea\u79cd\u65b9\u5f0f\uff0c\u5728\u4e0d\u540c\u7684\u60c5\u51b5\u4e0b\u90fd\u4f1a\u4ee4\u4eba\u56f0\u60d1\uff1b\u6ca1\u6709\u4e00\u4e2a\u660e\u786e\u7684\u6b63\u786e\u884c\u4e3a\uff0c\u63d0\u793a\u53ef\u4ee5\u5e2e\u52a9\u8bc6\u522b\u3002\u731c\u6d4b\u4e24\u8005\u90fd\u662f\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Either way would be confusing in different situations; there isn't a clear right behavior that a hint could help identify. Guess both. :/")),(0,l.kt)("h3",{id:"\u9898\u89e3-30"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a124"),(0,l.kt)("p",null,"\u8fd9\u4e2a\u95ee\u9898\u8986\u76d6\u4e86 match \u5206\u652f\u548c guards \u7684\u884c\u4e3a\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This question covers two behaviors of match arms and guards.")),(0,l.kt)("p",null,"\u9996\u5148\uff0c\u5305\u542b ",(0,l.kt)("inlineCode",{parentName:"p"},"|")," \u7684\u5339\u914d\u81c2\u4e0a\u7684 if guard \u662f\u9002\u7528\u4e8e\u5339\u914d\u81c2\u4e2d\u7684\u6240\u6709\u5907\u9009\u65b9\u6848\uff0c\u8fd8\u662f\u53ea\u9002\u7528\u4e8e\u5b83\u76f8\u90bb\u7684\u65b9\u6848\u3002\u5728\u6d4b\u9a8c\u4ee3\u7801\u4e2d\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"check(x)")," \u662f\u540c\u65f6\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"(x, _)")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"(_, x)")," \u6267\u884c\uff0c\u8fd8\u662f\u53ea\u8986\u76d6\u4e86 ",(0,l.kt)("inlineCode",{parentName:"p"},"(_, x)"),"\uff1f\u6211\u4eec\u5e0c\u671b\u53ea\u6709\u5728\u524d\u8005\u7684\u60c5\u51b5\u4e0b\uff0c1 \u624d\u4f1a\u88ab\u6253\u5370\u51fa\u6765\u3002\u4e8b\u5b9e\u4e0a\uff0c1 \u786e\u5b9e\u88ab\u6253\u5370\u51fa\u6765\u4e86\u3002\u4e00\u4e2a\u5339\u914d\u81c2\u6700\u591a\u53ea\u80fd\u6709\u4e00\u4e2a if guard\uff0c\u800c\u4e14\u8fd9\u4e2a guard \u9002\u7528\u4e8e\u5339\u914d\u81c2\u4e2d\u6240\u6709\u7684\u7531 ",(0,l.kt)("inlineCode",{parentName:"p"},"|")," \u5206\u9694\u7684\u5907\u9009\u65b9\u6848\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"First, whether an if guard on a match-arm containing ",(0,l.kt)("inlineCode",{parentName:"p"},"|")," applies to all alternatives in the match-arm or just to the one it is adjacent to. In the quiz code, does ",(0,l.kt)("inlineCode",{parentName:"p"},"check(x)")," execute at all for ",(0,l.kt)("inlineCode",{parentName:"p"},"(x, _)")," or does it only cover the ",(0,l.kt)("inlineCode",{parentName:"p"},"(_, x)")," case? We would expect 1 would get printed if and only if the former is the case. In fact 1 does get printed. A match-arm gets to have at most one if guard and that guard applies to all the ",(0,l.kt)("inlineCode",{parentName:"p"},"|"),"-separated alternatives in the arm.")),(0,l.kt)("p",null,'\u5176\u6b21\uff0c\u8fd9\u4e2a\u95ee\u9898\u8fd8\u5305\u62ec\u5339\u914d\u81c2\u7684\u4e00\u79cd "\u56de\u6eaf" \u884c\u4e3a\u3002\u5f53 ',(0,l.kt)("inlineCode",{parentName:"p"},"check(x)")," \u5728 ",(0,l.kt)("inlineCode",{parentName:"p"},"(x, _)")," \u4e0a\u8fd4\u56de false \u65f6\uff0c\u6574\u4e2a\u5339\u914d\u81c2\u662f\u5728\u8fd9\u91cc\u5339\u914d\u5931\u8d25\uff0c\u8fd8\u662f Rust \u7ee7\u7eed\u524d\u8fdb\u5230 ",(0,l.kt)("inlineCode",{parentName:"p"},"(_, x)")," \u5e76\u7b2c\u4e8c\u6b21\u6267\u884c guard\uff1f\u6211\u4eec\u671f\u671b\u5f53\u4e14\u4ec5\u5f53\u540e\u4e00\u79cd\u60c5\u51b5\u51fa\u73b0\u65f6 2 \u4f1a\u88ab\u6253\u5370\u51fa\u6765\u3002\u4e8b\u5b9e\u4e0a\uff0c2 \u786e\u5b9e\u88ab\u6253\u5370\u51fa\u6765\u4e86\uff1bif guard \u88ab\u8fd0\u884c\u4e86\u591a\u6b21\uff0c\u5728\u5339\u914d\u81c2\u4e2d\u7684\u6bcf\u4e00\u4e2a ",(0,l.kt)("inlineCode",{parentName:"p"},"|")," \u5206\u9694\u7684\u9009\u9879\u4e2d\u90fd\u6709\u4e00\u6b21\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},'But second, this question also covers a kind of "backtracking" behavior of match-arms. After ',(0,l.kt)("inlineCode",{parentName:"p"},"check(x)")," returns false on ",(0,l.kt)("inlineCode",{parentName:"p"},"(x, _)"),", does the whole match-arm fail to match at that point or does Rust move on to ",(0,l.kt)("inlineCode",{parentName:"p"},"(_, x)")," and execute the guard a second time? We would expect 2 to be printed if and only if the latter is the case. In fact 2 does get printed; the guard is being run multiple times, once per ",(0,l.kt)("inlineCode",{parentName:"p"},"|"),"-separated alternative in the match-arm.")),(0,l.kt)("h2",{id:"33-ranges-method"},"#33 ",(0,l.kt)("inlineCode",{parentName:"h2"},"Range's method")),(0,l.kt)("h3",{id:"\u9898\u76ee-32"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'use std::ops::RangeFull;\n\ntrait Trait {\n    fn method(&self) -> fn();\n}\n\nimpl Trait for RangeFull {\n    fn method(&self) -> fn() {\n        print!("1");\n        || print!("3")\n    }\n}\n\nimpl<F: FnOnce() -> T, T> Trait for F {\n    fn method(&self) -> fn() {\n        print!("2");\n        || print!("4")\n    }\n}\n\nfn main() {\n    (|| .. .method())();\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-32"},"\u63d0\u793a"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"||")," \u662f\u4e00\u4e2a\u95ed\u5305\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"..")," \u662f range \u7684\u8bed\u6cd5\uff0c\u901a\u5e38\u4f1a\u5728\u5207\u7247\u4e2d\u770b\u5230\uff0c\u4f8b\u5982 ",(0,l.kt)("inlineCode",{parentName:"p"},"&s[1..4]")," \u6216\u8005 ",(0,l.kt)("inlineCode",{parentName:"p"},"&s[..s.len() - 1]"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("inlineCode",{parentName:"p"},"||")," is a closure introducer. ",(0,l.kt)("inlineCode",{parentName:"p"},"..")," is range syntax, normally seen in slicing operations like ",(0,l.kt)("inlineCode",{parentName:"p"},"&s[1..4]")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"&s[..s.len() - 1]"),".")),(0,l.kt)("h3",{id:"\u9898\u89e3-31"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a24"),(0,l.kt)("p",null,"\u4e24\u4e2a\u5408\u7406\u7684\u53ef\u80fd\u662f 1 \u6216 24\uff0c\u53d6\u51b3\u4e8e\u5982\u4f55\u533a\u5206 ",(0,l.kt)("inlineCode",{parentName:"p"},"|| .. .method()")," \u7684\u4f18\u5148\u7ea7\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The two rational possibilities are 1 or 24, depending on how the precedence of ",(0,l.kt)("inlineCode",{parentName:"p"},"|| .. .method()")," is disambiguated.")),(0,l.kt)("p",null,"\u5982 ",(0,l.kt)("inlineCode",{parentName:"p"},"|| ((..).method())"),"\uff0c\u8fd9\u662f\u4e00\u4e2a\u95ed\u5305\uff0c\u5176\u4e3b\u4f53\u8c03\u7528\u4e86\u6211\u4eec\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"RangeFull")," \u7684\u5b9e\u73b0\u7684 Trait \u65b9\u6cd5\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cmain \u4f1a\u6253\u5370 1\u3002\u5b83\u4e0d\u4f1a\u6253\u5370 13\uff0c\u56e0\u4e3a\u4ece ",(0,l.kt)("inlineCode",{parentName:"p"},"(..).method()")," \u8fd4\u56de\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"fn()")," \u4ece\u672a\u88ab main \u8c03\u7528\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"As ",(0,l.kt)("inlineCode",{parentName:"p"},"|| ((..).method())"),", which is a closure whose body invokes our impl of Trait on ",(0,l.kt)("inlineCode",{parentName:"p"},"RangeFull"),". In this case main would print 1. It would not print 13 because the ",(0,l.kt)("inlineCode",{parentName:"p"},"fn()")," returned from ",(0,l.kt)("inlineCode",{parentName:"p"},"(..).method()")," is never invoked by main.")),(0,l.kt)("p",null,"\u5982 ",(0,l.kt)("inlineCode",{parentName:"p"},"(|| ..).method()"),"\uff0c\u5b83\u662f\u6211\u4eec\u5bf9 ",(0,l.kt)("inlineCode",{parentName:"p"},"FnOnce()->T")," \u5b9e\u73b0\u7684 Trait \u7684\u8c03\u7528\uff0c\u5176\u4e2d ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," \u88ab\u63a8\u65ad\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"RangeFull"),"\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cmain \u4f1a\u6253\u5370 24\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"As ",(0,l.kt)("inlineCode",{parentName:"p"},"(|| ..).method()"),", which is an invocation of our impl of Trait on ",(0,l.kt)("inlineCode",{parentName:"p"},"FnOnce() -> T")," where T is inferred to be ",(0,l.kt)("inlineCode",{parentName:"p"},"RangeFull"),". In this case main would print 24.")),(0,l.kt)("p",null,"\u540e\u8005\u624d\u662f\u6b63\u786e\u7684\u7b54\u6848\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The latter of those is the correct answer.")),(0,l.kt)("p",null,"\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u663e\u5f0f\u7684\u62ec\u53f7\u6765\u5b9e\u73b0\u524d\u8005\u7684\u884c\u4e3a\uff0c\u5982\u4e0a\u6587\u4e2d\u6240\u793a\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"We can achieve the former behavior by explicitly parenthesizing as shown in the bullet above.")),(0,l.kt)("p",null,"\u53ea\u6709\u90e8\u5206\u62ec\u53f7\u5982 ",(0,l.kt)("inlineCode",{parentName:"p"},"|| (.. .method())")," \u662f\u4e0d\u591f\u7684\u3002\u8fd9\u4f1a\u5bfc\u81f4\u4e00\u4e2a\u89e3\u6790\u9519\u8bef\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Partially parenthesizing as ",(0,l.kt)("inlineCode",{parentName:"p"},"|| (.. .method())")," is not sufficient. This results in a parse error.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"error: expected one of `)` or `,`, found `.`\n  --\x3e src/main.rs:22:13\n   |\n22 |     (|| (.. .method()))();\n   |            -^ expected one of `)` or `,`\n   |            |\n   |            help: missing `,`\n")),(0,l.kt)("p",null,"\u6b63\u786e\u5904\u7406\u50cf ",(0,l.kt)("inlineCode",{parentName:"p"},"|| .. .method()")," \u8fd9\u6837\u76f8\u5f53\u6a21\u7cca\u7684\u8868\u8fbe\u5f0f\u5bf9 Rust tooling \u6765\u8bf4\u662f\u4e00\u4e2a\u6311\u6218\uff0c\u4ece Rustfmt (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/rustfmt/issues/4808"},"rust-lang/rustfmt#4808"),") \u548c Syn (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/dtolnay/syn/issues/1019"},"dtolnay/syn#1019"),") \u7684\u76f8\u5173\u9519\u8bef\u4e2d\u53ef\u4ee5\u770b\u51fa\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Correctly handling a quite ambiguous expression like || .. .method() is a challenge for tooling, as seen by the associated bugs in Rustfmt (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/rustfmt/issues/4808"},"rust-lang/rustfmt#4808"),") and Syn (",(0,l.kt)("a",{parentName:"p",href:"https://github.com/dtolnay/syn/issues/1019"},"dtolnay/syn#1019"),").")),(0,l.kt)("h2",{id:"34-size-of-fn"},"#34 ",(0,l.kt)("inlineCode",{parentName:"h2"},"size of fn")),(0,l.kt)("h3",{id:"\u9898\u76ee-33"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn d<T>(_f: T) {\n    match std::mem::size_of::<T>() {\n        0 => print!("0"),\n        1 => print!("1"),\n        _ => print!("2"),\n    }\n}\n\nfn a<T>(f: fn(T)) {\n    d(f);\n}\n\nfn main() {\n    a(a::<u8>);\n    d(a::<u8>);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-33"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u7528\u4efb\u4f55\u5176\u4ed6\u6574\u6570\u7c7b\u578b\u4ee3\u66ff u8\uff0c\u7b54\u6848\u90fd\u662f\u4e00\u6837\u7684\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The answer would be the same with any other integer type in place of u8.")),(0,l.kt)("h3",{id:"\u9898\u89e3-32"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a20"),(0,l.kt)("p",null,"\u8868\u8fbe\u5f0f ",(0,l.kt)("inlineCode",{parentName:"p"},"a::<u8>")," \u7684\u7c7b\u578b\u662f\u4e00\u4e2a\u96f6\u5927\u5c0f\u7c7b\u578b\uff08ZST\uff09\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The expression ",(0,l.kt)("inlineCode",{parentName:"p"},"a::<u8>"),"'s type is a zero-sized type (ZST).")),(0,l.kt)("p",null,"Rust \u56f4\u7ed5\u51fd\u6570\u7c7b\u578b\u7684\u4f5c\u51fa\u7684\u9009\u62e9\u548c\u5177\u4f53\u5b9e\u73b0\u4e0e\u51e0\u4e4e\u6240\u6709\u5176\u4ed6\u8bed\u8a00\u90fd\u4e0d\u540c\uff0c\u4f46\u5b83\u662f Rust \u8bb8\u591a\u96f6\u5f00\u9500\u62bd\u8c61\u7684\u91cd\u8981\u4fc3\u6210\u56e0\u7d20\u3002\u5728 Rust \u4e2d\uff0c\u6bcf\u4e2a\u51fd\u6570\uff08\u6216\u6cdb\u578b\u51fd\u6570\u7684\u6bcf\u4e2a\u4e0d\u540c\u5b9e\u4f8b\uff09\u90fd\u6709\u81ea\u5df1\u7684\u72ec\u7279\u7c7b\u578b\u3002\u7279\u522b\u662f\uff0c\u5373\u4f7f\u662f\u5177\u6709\u76f8\u540c\u51fd\u6570\u7b7e\u540d\u7684\u4e24\u4e2a\u51fd\u6570\u4e5f\u4f1a\u6709\u4e0d\u540c\u7684\u7c7b\u578b\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Rust's implementation choices around function types are different from nearly all other languages, but are an important enabler of many of Rust's zero-overhead abstractions. In Rust, every function (or every distinct instantiation of a generic function) has its own unique type. In particular, even two functions with the same function signature would have different types.")),(0,l.kt)("p",null,"\u6bcf\u4e2a\u51fd\u6570\u90fd\u6709\u4e00\u4e2a\u72ec\u7279\u7684\u7c7b\u578b\uff0c\u8fd9\u79cd\u7279\u6027\u5141\u8bb8\u7c7b\u578b\u672c\u8eab\u643a\u5e26\u5c06\u88ab\u8c03\u7528\u7684\u51fd\u6570\u7684\u4fe1\u606f\uff0c\u4e0d\u9700\u8981\u4efb\u4f55\u8fd0\u884c\u65f6\u72b6\u6001\uff0c\u5982\u6307\u9488\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Having a unique type for each function allows the type itself to carry the information of what function will be called, not needing any runtime state such as a pointer.")),(0,l.kt)("p",null,"\u4e3a\u4e86\u7406\u89e3\u8fd9\u79cd\u4f18\u5316\u65b9\u6cd5\u7684\u4f18\u52bf\uff0c\u8003\u8651 ",(0,l.kt)("inlineCode",{parentName:"p"},"Iterator::map")," \u548c\u4e24\u4e2a\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"iter.map(f)")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"iter.map(g)"),"\uff0c\u5176\u4e2d ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"g")," \u662f\u5177\u6709\u76f8\u540c\u7b7e\u540d\u7684\u4e0d\u540c\u51fd\u6570\u3002\u56e0\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"g")," \u6709\u4e0d\u540c\u7684\u7c7b\u578b\uff0c\u8fd9\u4e24\u4e2a map \u8c03\u7528\u4f1a\u4ea7\u751f\u4e24\u4e2a\u4e0d\u540c\u7684\u6cdb\u578b\u51fd\u6570\u7684\u5355\u6001\u5b9e\u4f8b\uff0c\u5176\u4e2d\u4e00\u4e2a\u9759\u6001\u5730\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"f"),"\uff0c\u53e6\u4e00\u4e2a\u9759\u6001\u5730\u8c03\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"g"),"\uff0c\u5c31\u50cf\u4f60\u76f4\u63a5\u4e3a\u6bcf\u4e2a\u51fd\u6570\u5199\u4e86\u4e00\u4e2a\u7279\u6b8a\u7684 map \u5b9e\u73b0\uff0c\u800c\u6ca1\u6709 map \u63d0\u4f9b\u7684\u62bd\u8c61\u3002\u56e0\u6b64\uff0c\u6cdb\u578b map \u662f\u4e00\u4e2a\u96f6\u6210\u672c\u7684\u62bd\u8c61\u3002\u4f20\u7edf\u4e0a\uff0c\u5728\u5176\u4ed6\u8bed\u8a00\u5982 C++ \u6216 Go \u4e2d\uff0cf \u548c g \u4f1a\u88ab\u4f5c\u4e3a\u4e00\u4e2a\u51fd\u6570\u6307\u9488\u4f20\u9012\u7ed9 map\uff0c\u5e76\u4e14\u53ea\u6709\u4e00\u4e2a map \u7684\u5b9e\u4f8b\uff0c\u5305\u542b\u4e00\u4e2a\u6267\u884c\u51fd\u6570\u8c03\u7528\u7684\u52a8\u6001\u5206\u53d1\uff0c\u8fd9\u901a\u5e38\u4f1a\u6bd4\u9759\u6001\u8c03\u7528\u51fd\u6570\u66f4\u6162\u3002\u8fd9\u79cd\u6027\u80fd\u7f3a\u9677\u4f7f\u5f97\u8fd9\u4e9b\u8bed\u8a00\u4e2d\u7684 map \u4e0d\u662f\u4e00\u4e2a\u96f6\u6210\u672c\u7684\u62bd\u8c61\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"To understand the optimization advantages of this approach, consider ",(0,l.kt)("inlineCode",{parentName:"p"},"Iterator::map")," and the two calls ",(0,l.kt)("inlineCode",{parentName:"p"},"iter.map(f)")," and iter.map(g) where f and g are different functions with the same signature. Because f and g have distinct types, the two map calls would produce two different monomorphic instantiations of the generic map function, one of which statically calls f and the other statically calls g, as if you had directly written a special-purpose map implementation specific to each function without the abstraction provided by map. The generic map is thus a zero-overhead abstraction. Traditionally in other languages such as C++ or Go, in this situation f and g would be passed to map as a function pointer and there would be just one instantiation of map, containing a dynamic dispatch to execute the function call, which is usually going to be slower than statically calling the right function. This performance penalty makes map in those languages not a zero-overhead abstraction.")),(0,l.kt)("p",null,"\u76ee\u524d\u5728 Rust \u4e2d\uff0c\u6ca1\u6709\u8bed\u6cd5\u6765\u8868\u8fbe\u7279\u5b9a\u7684\u51fd\u6570\u7c7b\u578b\uff0c\u6240\u4ee5\u5b83\u4eec\u603b\u662f\u4f5c\u4e3a\u4e00\u4e2a\u901a\u7528\u7684\u7c7b\u578b\u53c2\u6570\u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"FnOnce"),"\u3001",(0,l.kt)("inlineCode",{parentName:"p"},"Fn")," \u6216 ",(0,l.kt)("inlineCode",{parentName:"p"},"FnMut")," \u7ed1\u5b9a\u4f20\u9012\u3002\u5728\u9519\u8bef\u4fe1\u606f\u4e2d\uff0c\u4f60\u53ef\u80fd\u4f1a\u770b\u5230\u51fd\u6570\u7c7b\u578b\u4ee5 ",(0,l.kt)("inlineCode",{parentName:"p"},"fn(T) -> U {fn_name}")," \u7684\u5f62\u5f0f\u51fa\u73b0\uff0c\u4f46\u4f60\u4e0d\u80fd\u5728\u4ee3\u7801\u4e2d\u4f7f\u7528\u8fd9\u79cd\u8bed\u6cd5\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Currently in Rust there is no syntax to express the type of a specific function, so they are always passed as a generic type parameter with a FnOnce, Fn or FnMut bound. In error messages you might see function types appear in the form fn(T) -> U {fn_name}, but you can't use this syntax in code.")),(0,l.kt)("p",null,"\u53e6\u4e00\u65b9\u9762\uff0c\u4e00\u4e2a\u51fd\u6570\u6307\u9488\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"fn(T) -> U"),'\uff0c\u5728\u8fd0\u884c\u65f6\u662f\u6307\u9488\u5927\u5c0f\u3002\u51fd\u6570\u7c7b\u578b\u53ef\u4ee5\u88ab\u80c1\u8feb\u4e3a\u51fd\u6570\u6307\u9488\uff0c\u8fd9\u4e00\u70b9\u5728\u4f60\u9700\u8981\u5c06 "\u9009\u62e9\u8c03\u7528\u90a3\u4e2a\u51fd\u6570" \u63a8\u8fdf\u5230\u8fd0\u884c\u65f6\u5f88\u6709\u7528\u3002'),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"On the other hand, a function pointer, fn(T) -> U, is pointer-sized at runtime. Function types can be coerced into function pointers, which can be useful in case you need to defer the choice of function to call until runtime.")),(0,l.kt)("p",null,"\u5728\u6d4b\u9a8c\u4ee3\u7801\u4e2d\uff0cmain \u4e2d\u7684\u7b2c\u4e00\u4e2a\u8c03\u7528\u5728\u8c03\u7528 d \u4e4b\u524d\u5c06 ",(0,l.kt)("inlineCode",{parentName:"p"},"a::<u8>")," \u4ece\u4e00\u4e2a\u51fd\u6570\u80c1\u8feb\u4e3a\u4e00\u4e2a\u51fd\u6570\u6307\u9488",(0,l.kt)("inlineCode",{parentName:"p"},"(fn(fn(u8)) {a::<u8>}")," \u5230 ",(0,l.kt)("inlineCode",{parentName:"p"},"fn(fn(u8)))"),"\uff0c\u56e0\u6b64\u5728\u4e00\u4e2a\u5177\u6709 64 \u4f4d\u51fd\u6570\u6307\u9488\u7684\u7cfb\u7edf\u4e2d\uff0c\u5b83\u7684\u5927\u5c0f\u4e3a 8\u3002main \u4e2d\u7684\u7b2c\u4e8c\u4e2a\u8c03\u7528\u4e0d\u6d89\u53ca\u51fd\u6570\u6307\u9488\uff1bd \u88ab\u76f4\u63a5\u8c03\u7528\uff0cT \u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"a::<u8>")," \u7684\u4e0d\u53ef\u8868\u8fbe\u7684\u7c7b\u578b\uff0c\u5b83\u7684\u5927\u5c0f\u4e3a\u96f6\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"In the quiz code, the first call in main coerces ",(0,l.kt)("inlineCode",{parentName:"p"},"a::<u8>")," from a function to a function pointer ",(0,l.kt)("inlineCode",{parentName:"p"},"(fn(fn(u8)) {a::<u8>}")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"fn(fn(u8)))")," prior to calling d, so its size would be 8 on a system with 64-bit function pointers. The second call in main does not involve function pointers; d is directly called with T being the inexpressible type of ",(0,l.kt)("inlineCode",{parentName:"p"},"a::<u8>"),", which is zero-sized.")),(0,l.kt)("h2",{id:"35-hygiene-2"},"#35 ",(0,l.kt)("inlineCode",{parentName:"h2"},"Hygiene 2")),(0,l.kt)("h3",{id:"\u9898\u76ee-34"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'macro_rules! x {\n    ($n:expr) => {\n        let a = X($n);\n    };\n}\n\nstruct X(u64);\n\nimpl Drop for X {\n    fn drop(&mut self) {\n        print!("{}", self.0);\n    }\n}\n\nfn main() {\n    let a = X(1);\n    x!(2);\n    print!("{}", a.0);\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-34"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u6709\u4e00\u4e9b\u7a0b\u5e8f\uff0ccargo expand \u4ea7\u751f\u7684\u5c55\u5f00\u540e\u7684\u4ee3\u7801\u53ef\u4ee5\u7f16\u8bd1\uff0c\u4f46\u5176\u884c\u4e3a\u4e0e\u539f\u59cb\u4ee3\u6027\u7801\u7684\u539f\u59cb\u5b8f\u536b\u751f\u4e0d\u540c\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"There are some programs for which cargo expand produces expanded code that compiles, but behaves differently than the original code with the original macro hygiene.")),(0,l.kt)("h3",{id:"\u9898\u89e3-33"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a121"),(0,l.kt)("p",null,"\u6839\u636e\u4f60\u5bf9 macro \u5c55\u5f00\u7684\u5047\u8bbe\uff0c\u672c\u9898\u6709\u4e24\u6761\u770b\u4f3c\u5408\u7406\u7684\u9519\u8bef\u7b54\u6848\uff1a"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"There are two reasonable paths to an incorrect answer on this question, based on your assumptions around how this macro gets expanded:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"1. let a = X(2);\n2. { let a = X(2); }\n")),(0,l.kt)("p",null,"\u5982\u679c\u7b2c\u4e00\u79cd\u5c55\u5f00\u65b9\u5f0f\u662f\u6b63\u786e\u7684\uff0c\u8fd9\u4e2a\u5b8f\u4f1a\u5f15\u5165\u4e00\u4e2a\u65b0\u7684\u7ed1\u5b9a\uff0ca\uff0c\u5b83\u5c06\u906e\u853d main \u4e2d\u5df2\u7ecf\u76f4\u63a5\u5206\u914d\u7684 a\u3002\u56e0\u6b64\uff0cmain \u4e2d\u7684 print \u8bed\u53e5\u5c06\u9996\u5148\u6267\u884c\uff0c\u6253\u5370 2\uff0c\u7136\u540e\u53d8\u91cf\u5c06\u6309\u5f15\u5165\u7684\u987a\u5e8f\u5012\u5e8f drop\uff0c\u5148\u6253\u5370 2\uff0c\u518d\u6253\u5370 1\uff0c\u6700\u540e\u8f93\u51fa 221\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If the first expansion were right, the macro would introduce a new binding, a, which shadows the a already directly assigned in main. So the print statement in main would execute first, printing 2, then the variables would drop in reverse order of introduction, printing 2 then 1, with a final output of 221.")),(0,l.kt)("p",null,"\u5982\u679c\u7b2c\u4e8c\u79cd\u5c55\u5f00\u65b9\u5f0f\u662f\u6b63\u786e\u7684\uff0c\u8fd9\u4e2a\u5b8f\u4f1a\u5728\u4e00\u4e2a\u5d4c\u5957\u7684\u4f5c\u7528\u57df\u4e2d\u5f15\u5165 a\uff0c\u53ea\u5728\u8fd9\u4e2a\u4f5c\u7528\u57df\u4e2d\u906e\u853d\u5df2\u7ecf\u5b58\u5728\u7684 a\uff0c\u800c\u4e0d\u662f\u5728\u5b83\u4e4b\u5916\u3002\u7531\u4e8e\u65b0\u7684 a \u7684\u4f5c\u7528\u57df\u5728\u6253\u5370\u8bed\u53e5\u4e4b\u524d\u5c31\u7ed3\u675f\u4e86\uff0c\u6240\u4ee5\u5f53\u5b83\u8d85\u51fa\u4f5c\u7528\u57df\u65f6\uff0c\u5b83\u7684 Drop impl \u5c06\u662f\u7b2c\u4e00\u4e2a\u6267\u884c\u7684\u6253\u5370\uff0c\u6253\u5370 2\u3002\u63a5\u4e0b\u6765\uff0cmain \u4e2d\u7684\u6253\u5370\u5c06\u6253\u5370 1\uff0c\u4e5f\u5c31\u662f\u7b2c\u4e00\u4e2a a \u7684\u503c\uff0c\u6700\u540e\uff0c\u5f53\u8fd9\u4e2a\u503c\u5728 main \u7ed3\u675f\u65f6\uff0c\u518d\u6253\u5370 1\uff0c\u6700\u7ec8\u8f93\u51fa 211\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If the second expansion were right, the macro would introduce a in a nested scope, shadowing the already existing a only inside of that scope and not beyond it. Since the new a's scope ends before the print statement, its Drop impl when going out of scope would be the first print to execute, printing 2. Next the print in main would print 1 which is the value of the first a, and finally 1 again when that value drops at the end of main, with final output 211.")),(0,l.kt)("p",null,"\u5982\u679c\u4f60\u8bfb\u8fc7\u5173\u4e8e\u5b8f\u536b\u751f\u6027\u7684\u6587\u7ae0\uff0c\u90a3\u4e48\u4f60\u53ef\u80fd\u5df2\u7ecf\u731c\u5230\u5b83\u7684\u5b9e\u73b0\u65b9\u5f0f\u4e0e\u7b2c\u4e8c\u4e2a\u9009\u9879\u7c7b\u4f3c\u3002\u91cd\u8981\u7684\u662f\uff0c\u5b8f\u7684\u5185\u90e8\u7ed3\u6784\u4e0d\u4f1a\u4e0e\u8c03\u7528\u5730\u70b9\u8303\u56f4\u5185\u7684\u53d8\u91cf\u53d1\u751f\u51b2\u7a81\uff0c\u800c\u4e14 Rust \u5b8f\u5728\u9632\u6b62\u610f\u5916\u7684\u540d\u79f0\u51b2\u7a81\u65b9\u9762\u505a\u5f97\u5f88\u597d\u3002\u7136\u800c\uff0c\u8fd9\u5e76\u4e0d\u662f\u536b\u751f\u6027\u7684\u5b9e\u73b0\u65b9\u5f0f\uff1b\u5728\u5b8f\u6269\u5c55\u5468\u56f4\u5f15\u5165\u4eba\u4e3a\u7684\u4f5c\u7528\u57df\u4f1a\u4f7f\u5b83\u4eec\u7684\u4f5c\u7528\u66f4\u52a0\u6709\u9650\uff0c\u800c\u4e14\u4e0d\u4f1a\u89e3\u51b3\u5f88\u591a\u5176\u4ed6\u7684\u536b\u751f\u6027\u95ee\u9898\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If you've read about macro hygiene then you might have guessed it would be implemented something like this second option. It's important that internals of a macro don't interfere coincidentally with variables in scope at the call site, and Rust macros mostly do a good job of preventing unintended name collisions. However, this is not how hygiene is implemented; introducing artificial scopes around macro expansions would make them more limited in their usefulness, and wouldn't solve a lot of other hygiene problems.")),(0,l.kt)("p",null,"\u4f60\u53ef\u4ee5\u628a lazily calcalute \u60f3\u8c61\u6210\u7ed9\u6bcf\u4e2a\u63d0\u5230\u7684\u5c40\u90e8\u53d8\u91cf\u7684\u540d\u5b57\u5206\u914d\u4e00\u4e2a\u989c\u8272\uff0c\u5141\u8bb8\u5728\u4f5c\u7528\u57df\u5185\u6709\u591a\u4e2a\u53ef\u533a\u5206\u7684\u5c40\u90e8\u53d8\u91cf\u540c\u65f6\u62e5\u6709\u76f8\u540c\u7684\u6587\u672c\u540d\u79f0\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"You can instead imagine hygiene as a way of assigning a color to each mention of the name of a local variable, allowing for there to be multiple distinguishable local variables in scope simultaneously with the same textual name.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn main() {\n    let a = X(1);\n    let a = X(2);\n    print!("{}", a.0);\n}\n')),(0,l.kt)("p",null,"\u6240\u4ee5\u6253\u5370\u51fa\u6765\u7684\u662f main \u7684\u6807\u8bc6\u7b26 a \u7684\u503c\uff0c\u4e5f\u5c31\u662f 1\uff0c\u7136\u540e\u4e24\u4e2a\u503c\u6309\u7167\u5f15\u5165\u7684\u76f8\u53cd\u987a\u5e8f\u4e22\u6389\uff0c\u5148\u6253\u5370 2 \u518d\u6253\u5370 1\uff0c\u7a0b\u5e8f\u7684\u8f93\u51fa\u662f 121\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"So what's printed is the value of main's identifier a which is 1, then the two values are dropped in reverse order of introduction printing 2 then 1, and the output of the program is 121.")),(0,l.kt)("h2",{id:"36-move--fn"},"\uff0336 ",(0,l.kt)("inlineCode",{parentName:"h2"},"move & Fn")),(0,l.kt)("h3",{id:"\u9898\u76ee-35"},"\u9898\u76ee"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'fn call(mut f: impl FnMut() + Copy) {\n    f();\n}\n\nfn g(mut f: impl FnMut() + Copy) {\n    f();\n    call(f);\n    f();\n    call(f);\n}\n\nfn main() {\n    let mut i = 0i32;\n    g(move || {\n        i += 1;\n        print!("{}", i);\n    });\n}\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"),(0,l.kt)("li",{parentName:"ol"},"\u7f16\u8bd1\u5931\u8d25"),(0,l.kt)("li",{parentName:"ol"},"\u7a0b\u5e8f\u786e\u5b9a\u4f1a\u8f93\u51fa\uff1a","[ ]")),(0,l.kt)("h3",{id:"\u63d0\u793a-35"},"\u63d0\u793a"),(0,l.kt)("p",null,"\u53d8\u91cf ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," \u88ab\u7f16\u8bd1\u5668\u751f\u6210\u7684\u95ed\u5305\u5bf9\u8c61\u6240\u6355\u83b7\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The variable ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," is captured by value in the compiler-generated closure object.")),(0,l.kt)("h3",{id:"\u9898\u89e3-34"},"\u9898\u89e3"),(0,l.kt)("p",null,"\u7b54\u6848\uff1a1223"),(0,l.kt)("p",null,"\u4f20\u5165 g \u7684\u5bf9\u8c61\u662f\u4e00\u4e2a ",(0,l.kt)("inlineCode",{parentName:"p"},"FnMut")," \u95ed\u5305\uff0c\u5b83\u6355\u83b7\u4e86\u4e00\u4e2a\u6574\u6570\u3002\u5b9e\u9645\u4e0a\uff0c\u5b83\u662f\u4e00\u4e2a\u4e0d\u53ef\u547d\u540d\u7684\u7ed3\u6784\u4f53\uff0c\u5305\u542b\u4e00\u4e2a\u7c7b\u578b\u4e3a i32 \u7684\u5b57\u6bb5\uff0c\u5e76\u6709\u4e00\u4e2a\u51fd\u6570\u8c03\u7528\u64cd\u4f5c\u7b26\uff0c\u8be5\u64cd\u4f5c\u7b26\u63a5\u6536 ",(0,l.kt)("inlineCode",{parentName:"p"},"&mut self"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The object passed into g is a FnMut closure which captures an integer by value. Effectively it's an unnameable struct containing a single field whose type is i32, with a function call operator that takes &mut self:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},'#[derive(Copy, Clone)]\npub struct UnnameableClosure {\n    i: i32,\n}\n\nimpl UnnameableClosure {\n    pub fn unnameable_call_operator(&mut self) {\n        self.i += 1;\n        print!("{}", self.i);\n    }\n}\n\nlet mut i = 0i32;\ng(UnnameableClosure { i });\n')),(0,l.kt)("p",null,"g \u91cc\u9762\u7684 4 \u4e2a\u8c03\u7528\u7684\u884c\u4e3a\u5982\u4e0b\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The behavior of the 4 calls inside g is as follows:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"f()")," \u8fd0\u884c\u95ed\u5305\uff0c\u5176\u901a\u8fc7\u503c\u6355\u83b7\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," \u7684\u503c\u53d8\u4e3a 1\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"f() runs the closure and its by-value captured value of i becomes 1."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"call(f)")," \u5236\u9020\u4e00\u4e2a ",(0,l.kt)("inlineCode",{parentName:"p"},"f")," \u7684\u526f\u672c\uff0c\u4f5c\u4e3a call \u7684\u53c2\u6570\u3002\u8fd9\u4e2a\u526f\u672c\u88ab\u6267\u884c\uff0c\u5b83\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," \u53d8\u6210\u4e86 2\uff0c\u4f46\u662f\u539f\u59cb\u95ed\u5305\u4ecd\u7136\u4fdd\u6301\u7740\u5b83\u6355\u83b7\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"i")," \u7684\u503c\u4e3a 1\u3002",(0,l.kt)("inlineCode",{parentName:"p"},"f")," \u7684\u526f\u672c\u5728\u8c03\u7528\u4e3b\u4f53\u7684\u672b\u5c3e\u8d85\u51fa\u4e86\u4f5c\u7528\u57df\u88ab drop\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"call(f) makes a copy of f to become the argument of call. The copy gets executed and its i becomes 2, but the original closure still holds a value of 1 for its captured i. The copy of the closure gets dropped as it goes out of scope at the end of the body of call."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"f()")," \u7b2c\u4e8c\u6b21\u8fd0\u884c\u539f\u59cb\u95ed\u5305\uff0c\u5176 i \u53d8\u4e3a 2\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"f() runs the original closure a second time and its i becomes 2."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"call(f)")," \u7b2c\u4e8c\u6b21\u590d\u5236 f \u5e76\u6267\u884c\u526f\u672c\uff0c\u5b83\u7684 i \u53d8\u6210\u4e86 3\u3002"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"call(f) copies f a second time and executes the copy, its i becomes 3.")))),(0,l.kt)("p",null,"\u4ece Rust 1.26 \u5f00\u59cb\uff0c\u5982\u679c\u95ed\u5305\u7684\u6240\u6709\u6355\u83b7\u90fd\u5b9e\u73b0\u4e86 Clone\uff0c\u5219\u95ed\u5305\u81ea\u52a8\u5b9e\u73b0\u4e86 Clone\uff1b\u5982\u679c\u6240\u6709\u6355\u83b7\u90fd\u5b9e\u73b0\u4e86 Copy\uff0c\u5219\u95ed\u5305\u81ea\u52a8\u5b9e\u73b0\u4e86 Copy\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Since Rust 1.26, closures automatically implement Clone if all their captures implement Clone, and Copy if all the captures implement Copy.")),(0,l.kt)("p",null,"\u5982\u679c quiz \u4ee3\u7801\u4e2d\u7701\u7565\u4e86 move \u5173\u952e\u5b57\uff0c\u7f16\u8bd1\u5668\u751f\u6210\u7684\u95ed\u5305\u5c06\u901a\u8fc7\u53ef\u53d8\u5f15\u7528\u800c\u4e0d\u662f\u901a\u8fc7\u503c\u6355\u83b7 i\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If the move keyword were omitted from the quiz code, the compiler-generated closure would capture i by mutable reference instead of by value:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-rs"},"pub struct UnnameableClosure<'a> {\n    i: &'a mut i32,\n}\n")),(0,l.kt)("p",null,"\u5e76\u4e14\u4e0d\u518d\u6709 Copy impl\uff0c\u56e0\u4e3a\u5c06\u4e00\u4e2a\u53ef\u53d8\u5f15\u7528\u590d\u5236\u6210\u591a\u4e2a\u526f\u672c\u662f\u4e0d\u6b63\u786e\u7684\uff08aliasing xor mutation\uff1b\u8fd9\u662f\u501f\u7528\u68c0\u67e5\u5668\u7684\u91cd\u70b9\uff09\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"and there would no longer be a Copy impl, because it's incorrect to duplicate a mutable reference into multiple copies (aliasing xor mutation; this is the point of the borrow checker).")),(0,l.kt)("p",null,"\u5bf9\u4e8e Rust \u7684\u521d\u5b66\u8005\u6765\u8bf4\uff0c\u4e00\u4e2a\u7ecf\u5e38\u51fa\u73b0\u7684\u56f0\u60d1\u662f move, non-move \u95ed\u5305\u4e0e Fn\u3001FnMut \u548c FnOnce \u95ed\u5305\u4e4b\u95f4\u7684\u5173\u7cfb\u3002\u8fd9\u662f\u4e24\u4e2a\u51e0\u4e4e\u5b8c\u5168\u4e0d\u540c\u7684\u4e1c\u897f\u3002\u6b63\u5982\u4e0a\u9762\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"UnnameableClosure")," \u4f2a\u4ee3\u7801\u6240\u793a\uff0cmove \u4e0e non-move \u662f\u6307\u7f16\u8bd1\u5668\u751f\u6210\u7684\u95ed\u5305\u7ed3\u6784\u7684\u5b57\u6bb5\u662f\u5426\u4e0e\u539f\u59cb\u88ab\u6355\u83b7\u53d8\u91cf\u7684\u7c7b\u578b\u76f8\u540c\uff0c\u6216\u8005\u662f\u5bf9\u539f\u59cb\u6355\u83b7\u53d8\u91cf\u7c7b\u578b\u7684\u5f15\u7528\uff08\u4f8b\u5982\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"i32")," \u4e0e ",(0,l.kt)("inlineCode",{parentName:"p"},"&mut i32"),"\uff09\u3002\u76f8\u6bd4\u4e4b\u4e0b\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"Fn")," vs ",(0,l.kt)("inlineCode",{parentName:"p"},"FnMut")," vs ",(0,l.kt)("inlineCode",{parentName:"p"},"FnOnce")," \u662f\u5173\u4e8e\u7f16\u8bd1\u5668\u751f\u6210\u7684\u95ed\u5305\u7ed3\u6784\u7684\u8c03\u7528\u65b9\u6cd5\u662f\u5426\u6709\u4e00\u4e2a\u63a5\u6536\u5668\uff0c\u8be5\u63a5\u6536\u5668\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"&self")," vs ",(0,l.kt)("inlineCode",{parentName:"p"},"&mut self")," vs ",(0,l.kt)("inlineCode",{parentName:"p"},"self"),"\u3002"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"One recurring source of confusion for Rust beginners is the relationship between move and non-move closures vs Fn and FnMut and FnOnce closures. These are two nearly-orthogonal things. As illustrated in the UnnameableClosure pseudocode above, move vs non-move is about whether the fields of the compiler-generated closure struct have the same type as the original captured variable's type, vs are references to the original captured variable's type (i32 vs &mut i32, for example). In contrast, Fn vs FnMut vs FnOnce is about whether the call method of the compiler-generated closure struct has a receiver which is &self vs &mut self vs self.")))}m.isMDXComponent=!0}}]);