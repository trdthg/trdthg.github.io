"use strict";(self.webpackChunktrdthg_github_io=self.webpackChunktrdthg_github_io||[]).push([[9063],{3905:(e,a,n)=>{n.d(a,{Zo:()=>m,kt:()=>k});var t=n(7294);function l(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){l(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function s(e,a){if(null==e)return{};var n,t,l=function(e,a){if(null==e)return{};var n,t,l={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(l[n]=e[n]);return l}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var o=t.createContext({}),p=function(e){var a=t.useContext(o),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},m=function(e){var a=p(e.components);return t.createElement(o.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},h=t.forwardRef((function(e,a){var n=e.components,l=e.mdxType,r=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),h=p(n),k=l,u=h["".concat(o,".").concat(k)]||h[k]||c[k]||r;return n?t.createElement(u,i(i({ref:a},m),{},{components:n})):t.createElement(u,i({ref:a},m))}));function k(e,a){var n=arguments,l=a&&a.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var o in a)hasOwnProperty.call(a,o)&&(s[o]=a[o]);s.originalType=e,s.mdxType="string"==typeof e?e:l,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}h.displayName="MDXCreateElement"},984:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>o,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var t=n(7462),l=(n(7294),n(3905));const r={},i="Haskell \u5b66\u4e60",s={unversionedId:"magic/haskell",id:"magic/haskell",title:"Haskell \u5b66\u4e60",description:"\u2b50\ufe0fLearn You a Haskell for Great Good!",source:"@site/docs/magic/haskell.md",sourceDirName:"magic",slug:"/magic/haskell",permalink:"/docs/magic/haskell",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\u6587\u4ef6\u7cfb\u7edf",permalink:"/docs/magic/fd"},next:{title:"IO \u591a\u8def\u590d\u7528",permalink:"/docs/magic/linuxIO"}},o={},p=[{value:"0. \u7279\u6027",id:"0-\u7279\u6027",level:2},{value:"1. \u5f00\u59cb",id:"1-\u5f00\u59cb",level:2},{value:"1.1 \u57fa\u672c\u51fd\u6570",id:"11-\u57fa\u672c\u51fd\u6570",level:3},{value:"1.2 \u5217\u8868",id:"12-\u5217\u8868",level:3},{value:"1.3 \u751f\u6210\u5f0f",id:"13-\u751f\u6210\u5f0f",level:3},{value:"1.4 \u5143\u7ec4",id:"14-\u5143\u7ec4",level:3},{value:"1.5 \u91cd\u8981",id:"15-\u91cd\u8981",level:3},{value:"2. \u7c7b\u578b\u7cfb\u7edf",id:"2-\u7c7b\u578b\u7cfb\u7edf",level:2},{value:"2.1 \u67e5\u770b\u7c7b\u578b",id:"21-\u67e5\u770b\u7c7b\u578b",level:3},{value:"2.2 Typeclasses 101",id:"22-typeclasses-101",level:3},{value:"2.2.1 Eq",id:"221-eq",level:4},{value:"2.2.2 Ord",id:"222-ord",level:4},{value:"2.2.3 Show",id:"223-show",level:4},{value:"2.2.4 Read",id:"224-read",level:4},{value:"2.2.5 Enum",id:"225-enum",level:4},{value:"2.2.6 Bounded",id:"226-bounded",level:4},{value:"2.2.7 Num",id:"227-num",level:4},{value:"2.2.9 Integral &amp; Floating",id:"229-integral--floating",level:4},{value:"3. \u51fd\u6570\u8bed\u6cd5",id:"3-\u51fd\u6570\u8bed\u6cd5",level:2},{value:"3.1 Match \u8868\u8fbe\u5f0f",id:"31-match-\u8868\u8fbe\u5f0f",level:3},{value:"3.2 Guard",id:"32-guard",level:3},{value:"3.3 where",id:"33-where",level:3},{value:"3.4 Let it be",id:"34-let-it-be",level:3},{value:"3.5 Case Expression",id:"35-case-expression",level:3},{value:"4. \u9012\u5f52",id:"4-\u9012\u5f52",level:2},{value:"4.2 replicate",id:"42-replicate",level:3},{value:"4.3 take",id:"43-take",level:3},{value:"4.4 zip",id:"44-zip",level:3},{value:"4.5 quick sort",id:"45-quick-sort",level:3},{value:"5. \u9ad8\u9636\u51fd\u6570",id:"5-\u9ad8\u9636\u51fd\u6570",level:2},{value:"5.1 Curried functions",id:"51-curried-functions",level:3},{value:"5.2 \u4e00\u4e9b\u9ad8\u9636\u51fd\u6570",id:"52-\u4e00\u4e9b\u9ad8\u9636\u51fd\u6570",level:3},{value:"5.3 Map",id:"53-map",level:3},{value:"5.4 Filter",id:"54-filter",level:3},{value:"5.5 takeWhile",id:"55-takewhile",level:3},{value:"5.6 Chain",id:"56-chain",level:3},{value:"5.7 map (*) 0..",id:"57-map--0",level:3},{value:"5.8 Lambdas",id:"58-lambdas",level:3},{value:"5.9 Fold",id:"59-fold",level:3},{value:"5.10 $ \u8fd0\u7b97\u7b26",id:"510--\u8fd0\u7b97\u7b26",level:3},{value:"5.11 \u51fd\u6570\u7ec4\u5408",id:"511-\u51fd\u6570\u7ec4\u5408",level:3},{value:"6. \u6a21\u5757",id:"6-\u6a21\u5757",level:2},{value:"6.1 \u5bfc\u5165\u6a21\u5757",id:"61-\u5bfc\u5165\u6a21\u5757",level:3},{value:"6.2 Data.List",id:"62-datalist",level:3},{value:"6.4 Data.Map",id:"64-datamap",level:3},{value:"6.5 Data.Set",id:"65-dataset",level:3},{value:"7. \u81ea\u5b9a\u4e49\u7c7b\u578b",id:"7-\u81ea\u5b9a\u4e49\u7c7b\u578b",level:2},{value:"7.1 \u57fa\u672c\u7c7b\u578b\u5b9a\u4e49",id:"71-\u57fa\u672c\u7c7b\u578b\u5b9a\u4e49",level:3},{value:"7.2 record syntax \u5b9a\u4e49\u7c7b\u578b",id:"72-record-syntax-\u5b9a\u4e49\u7c7b\u578b",level:3},{value:"7.3 \u7c7b\u578b\u53c2\u6570",id:"73-\u7c7b\u578b\u53c2\u6570",level:3},{value:"7.3.1 Maybe",id:"731-maybe",level:4},{value:"7.3.2 Car",id:"732-car",level:4},{value:"7.3.3 Vector",id:"733-vector",level:4},{value:"7.4 \u6d3e\u751f\u5b9e\u4f8b",id:"74-\u6d3e\u751f\u5b9e\u4f8b",level:3},{value:"7.4.1 derive",id:"741-derive",level:4},{value:"7.4.2 \u5b9e\u73b0\u4e00\u4e9b Typeclasses",id:"742-\u5b9e\u73b0\u4e00\u4e9b-typeclasses",level:4},{value:"7.4.3 \u7c7b\u578b\u540c\u4e49\u8bcd",id:"743-\u7c7b\u578b\u540c\u4e49\u8bcd",level:4},{value:"7.4.4 Either",id:"744-either",level:4},{value:"7.4.5 \u9012\u5f52",id:"745-\u9012\u5f52",level:4},{value:"7.4.6 Typeclasses 102",id:"746-typeclasses-102",level:4},{value:"7.4.7 Functor \u548c Kinds",id:"747-functor-\u548c-kinds",level:4},{value:"8. IO",id:"8-io",level:2},{value:"8.1 cmd \u53c2\u6570",id:"81-cmd-\u53c2\u6570",level:3},{value:"8.2 \u8f93\u5165",id:"82-\u8f93\u5165",level:3},{value:"8.3. \u5faa\u73af",id:"83-\u5faa\u73af",level:3},{value:"8.4 map IO action",id:"84-map-io-action",level:3},{value:"8.6 todo list",id:"86-todo-list",level:3},{value:"8.7 Error Handle",id:"87-error-handle",level:3},{value:"9. Solve Some Problems",id:"9-solve-some-problems",level:2},{value:"9.1 \u8ba1\u7b97\u540e\u7f00\u8868\u8fbe\u5f0f",id:"91-\u8ba1\u7b97\u540e\u7f00\u8868\u8fbe\u5f0f",level:3},{value:"9.2 \u8ba1\u7b97\u6700\u77ed\u8def",id:"92-\u8ba1\u7b97\u6700\u77ed\u8def",level:3},{value:"10. Functors, Applicative Functors and Monoids",id:"10-functors-applicative-functors-and-monoids",level:2},{value:"10.1 Functor",id:"101-functor",level:3},{value:"10.2 Applicatives",id:"102-applicatives",level:3},{value:"10.3 Monads",id:"103-monads",level:3},{value:"10.4 \u603b\u7ed3",id:"104-\u603b\u7ed3",level:3}],m={toc:p};function c(e){let{components:a,...n}=e;return(0,l.kt)("wrapper",(0,t.Z)({},m,n,{components:a,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"haskell-\u5b66\u4e60"},"Haskell \u5b66\u4e60"),(0,l.kt)("p",null,"\u2b50\ufe0f",(0,l.kt)("a",{parentName:"p",href:"http://learnyouahaskell.com/chapters"},"Learn You a Haskell for Great Good!")),(0,l.kt)("h2",{id:"0-\u7279\u6027"},"0. \u7279\u6027"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"We usually use ' to either denote a strict  version of a function (one that isn't lazy) or a slightly modified  version of a function or a variable. Because ' is a valid character in functions, we can make a function like this.")),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"\u2018")," \u5728 haskell \u4e2d\u662f\u58f0\u660e\u7684\u5408\u6cd5\u5b57\u7b26\uff0c\u4e00\u822c\u4e2d\u52a0 ",(0,l.kt)("inlineCode",{parentName:"p"},"\u2019")," \u7684\u51fd\u6570\u4ee3\u8868\u4e00\u4e2a\u51fd\u6570\u7684\u4fee\u6539\u7248\u672c\u6216\u8005\u4e25\u683c\u7248\u672c"))),(0,l.kt)("h2",{id:"1-\u5f00\u59cb"},"1. \u5f00\u59cb"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Starting Out")),(0,l.kt)("h3",{id:"11-\u57fa\u672c\u51fd\u6570"},"1.1 \u57fa\u672c\u51fd\u6570"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u6700\u5c0f\u503c\uff1a",(0,l.kt)("inlineCode",{parentName:"li"},"min 1 3")),(0,l.kt)("li",{parentName:"ul"},"\u6700\u5927\u503c\uff1a",(0,l.kt)("inlineCode",{parentName:"li"},"max 1 3")),(0,l.kt)("li",{parentName:"ul"},"\u52a0\u4e00\uff1a",(0,l.kt)("inlineCode",{parentName:"li"},"succ 1"))),(0,l.kt)("h3",{id:"12-\u5217\u8868"},"1.2 \u5217\u8868"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u5408\u5e76\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"[1,2,3,4] ++ [9,10,11,12] "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u6839\u636e\u7d22\u5f15\u53d6\u503c\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},'"Steve Buscemi" !! 6'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u5f00\u5934\u63d2\u5165\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"'A':\" SMALL CAT\" ")),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"[1,2,3]"," is actually just syntactic sugar for 1:2:3:[]."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u53d6\u8868\u5934\uff1a",(0,l.kt)("inlineCode",{parentName:"p"},"head [1, 2, 3, 4, 5]"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u53d6\u8868\u5c3e\uff1a",(0,l.kt)("inlineCode",{parentName:"p"},"tail [1, 2, 3, 4, 5] "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u53d6\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff1a",(0,l.kt)("inlineCode",{parentName:"p"},"last [1, 2, 3, 4, 5]"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u53d6\u9664\u4e86\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"init [1, 2, 3, 4, 5]"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u957f\u5ea6\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"length [5,4,3,2,1] "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u662f\u5426\u4e3a\u7a7a\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"null [1,2,3] "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u53cd\u8f6c\u5217\u8868\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"reverse [5,4,3,2,1] "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u53d6\u524d n \u4e2a\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"take 3 [5,4,3,2,1] "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u4ece\u7b2c n \u4e2a\u5f00\u59cb\u5411\u540e\u53d6\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"drop 3 [8,4,2,1,5,6] "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u6700\u5927\u5143\u7d20\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"maximum [1,9,2,3,4] "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u6700\u5c0f\u5143\u7d20\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"minimum [8,4,2,1,5,6]"))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u52a0\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"sum [5,2,1,6,3,2,5,7] "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u4e58\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"product [6,2,1,2] "))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u662f\u5426\u5728\u5217\u8868\u4e2d\uff1a ",(0,l.kt)("inlineCode",{parentName:"p"},"4 "),"elem ",(0,l.kt)("inlineCode",{parentName:"p"},"[3,4,5,6]")))),(0,l.kt)("h3",{id:"13-\u751f\u6210\u5f0f"},"1.3 \u751f\u6210\u5f0f"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"\u5faa\u73af\u8ffd\u52a0\uff08append\uff09\uff1a ",(0,l.kt)("inlineCode",{parentName:"li"},"cycle [1,2,3]")),(0,l.kt)("li",{parentName:"ul"},"\u5faa\u73af\u751f\u6210\uff08extend\uff09\uff1a ",(0,l.kt)("inlineCode",{parentName:"li"},"repeat 5")),(0,l.kt)("li",{parentName:"ul"},"\u751f\u6210\u5f0f\uff1a ",(0,l.kt)("inlineCode",{parentName:"li"},'boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]'))),(0,l.kt)("h3",{id:"14-\u5143\u7ec4"},"1.4 \u5143\u7ec4"),(0,l.kt)("p",null,"\u7c7b\u578b\u968f\u610f\uff0c"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"fst\uff1a ",(0,l.kt)("inlineCode",{parentName:"li"},'fst ("Wow", False) ')),(0,l.kt)("li",{parentName:"ul"},"snd\uff1a ",(0,l.kt)("inlineCode",{parentName:"li"},'snd ("Wow", False)'))),(0,l.kt)("h3",{id:"15-\u91cd\u8981"},"1.5 \u91cd\u8981"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"zip",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]\n    [(5,"im"),(3,"a"),(2,"turtle")]\nzip [1..] ["apple", "orange", "cherry", "mango"]\n    [(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]\n')))),(0,l.kt)("h2",{id:"2-\u7c7b\u578b\u7cfb\u7edf"},"2. \u7c7b\u578b\u7cfb\u7edf"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Types and Typeclasses")),(0,l.kt)("h3",{id:"21-\u67e5\u770b\u7c7b\u578b"},"2.1 \u67e5\u770b\u7c7b\u578b"),(0,l.kt)("p",null,"ghci \u67e5\u770b"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'\uff1at (1, "qqq")\n')),(0,l.kt)("h3",{id:"22-typeclasses-101"},"2.2 Typeclasses 101"),(0,l.kt)("p",null,"\u6240\u6709\u7684 ",(0,l.kt)("inlineCode",{parentName:"p"},"== + - * / ")," \u90fd\u662f function"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t (==)\n(==) :: (Eq a) => a -> a -> Bool\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Everything before the => symbol is called a ",(0,l.kt)("em",{parentName:"p"},"class constraint"),". We can read the previous type declaration like this: the equality  function takes any two values that are of the same type and returns a Bool. The type of those two values must be a member of the Eq class (this was the class constraint).")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"=>")," \u4e4b\u524d\u7684\u88ab\u53eb\u505a\u7c7b\u578b\u7ea6\u675f")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Type variables")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t head\nhead :: [a] -> a\n")),(0,l.kt)("p",null,"a \u5c31\u662f\u7c7b\u578b\u53d8\u91cf\uff0c\u4f46\u662f\u7531\u4e8e a \u4e0d\u662f\u67d0\u4e00\u4e2a\u7279\u5b9a\u7684\u7c7b\u578b\uff0c\u6240\u4ee5\u6211\u4eec\u79f0 head \u591a\u6001\u51fd\u6570"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Functions that have type variables are called ",(0,l.kt)("strong",{parentName:"p"},"polymorphic functions"),".")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Typeclasses")," \u5c31\u662f\u7c7b\u578b\u7ea6\u675f"),(0,l.kt)("p",null,"\u4e0b\u9762\u4e3e\u51fa\u4e86\u4e00\u7cfb\u5217\u5e38\u7528\u7684 Typeclasses"),(0,l.kt)("h4",{id:"221-eq"},"2.2.1 Eq"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The Eq typeclass provides an interface for  testing for equality. Any type where it makes sense to test for equality between two values of that type should be a member of the Eq class. All standard Haskell types except for IO (the type for dealing with input and output) and functions are a part of the Eq typeclass.")),(0,l.kt)("p",null,"Eq \u63d0\u4f9b\u4e86\u4e00\u4e2a\u6bd4\u8f83\u7684\u63a5\u53e3\uff0c\u4efb\u4f55\u80fd\u591f\u6bd4\u8f83\u8be5\u7c7b\u578b\u7684\u4e24\u4e2a\u503c\u4e4b\u95f4\u76f8\u7b49\u6027\u7684\u90fd\u5e94\u8be5\u662f Eq \u7c7b\u7684\u6210\u5458"),(0,l.kt)("h4",{id:"222-ord"},"2.2.2 Ord"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"All the types we covered so far except for functions are part of Ord. Ord covers all the standard comparing functions such as >, <, >= and <=. The compare function takes two Ord members of the same type and returns an ordering. Ordering is a type that can be GT, LT or EQ, meaning ",(0,l.kt)("em",{parentName:"p"},"greater than"),", ",(0,l.kt)("em",{parentName:"p"},"lesser than")," and ",(0,l.kt)("em",{parentName:"p"},"equal"),", respectively.")),(0,l.kt)("p",null,"Ord \u5305\u542b\u4e86\u6240\u6709\u6807\u51c6\u7684\u6bd4\u8f83\u51fd\u6570\uff0c\u4f8b\u5982 > < >= <=, \u6bd4\u8f83\u51fd\u6570\u63a5\u53d7\u4e24\u4e2a\u7c7b\u578b\u76f8\u540c\u7684 Ord \u6210\u5458\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u6392\u5e8f\uff0c\u6392\u5e8f\u662f GT\uff0cLT\uff0cEQ\uff0c\u5206\u522b\u8868\u793a\u5927\u4e8e\uff0c\u5c0f\u4e8e\uff0c\u7b49\u4e8e"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> "Abrakadabra" < "Zebra"\nTrue\nghci> "Abrakadabra" `compare` "Zebra"\nLT\nghci> 5 >= 2\nTrue\nghci> 5 `compare` 3\nGT\n')),(0,l.kt)("h4",{id:"223-show"},"2.2.3 Show"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Members of Show can be presented as strings. All types covered so far except for functions are a part of Show. The most used function that deals with the Show typeclass is show. It takes a value whose type is a member of Show and presents it to us as a string.")),(0,l.kt)("p",null,"Show \u7684\u6210\u5458\u53ef\u4ee5\u88ab\u6253\u5370\u4e3a\u5b57\u7b26\u4e32\uff0c\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u9664\u4e86\u51fd\u6570\u4e4b\u5916\u7684\u6240\u6709\u7c7b\u578b\u90fd\u662f Show \u7684\u4e00\u90e8\u5206\u3002"),(0,l.kt)("p",null,"show \u51fd\u6570\u63a5\u53d7\u4e00\u4e2a\u7c7b\u578b\u4e3a Show \u6210\u5458\u7684\u503c\uff0c\u5e76\u5c06\u5176\u4f5c\u4e3a\u5b57\u7b26\u4e32\u5448\u73b0"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t read\nread :: (Read a) => String -> a\n")),(0,l.kt)("h4",{id:"224-read"},"2.2.4 Read"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Read is sort of the opposite typeclass of Show. The read function takes a string and returns a type which is a member of Read.")),(0,l.kt)("p",null,"read \u51fd\u6570\u63a5\u53d7\u4e00\u4e2a String\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a Read \u7684\u6210\u5458\u7684\u7c7b\u578b"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"\u95ee\u9898")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> read \"4\"\n    <interactive>:1:0:\n        Ambiguous type variable `a' in the constraint:\n            `Read a' arising from a use of `read' at <interactive>:1:0-7\n        Probable fix: add a type signature that fixes these type variable(s)\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"\u6307\u5b9a return \u7c7b\u578b")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> read "5" :: Int\n5\nghci> read "5" :: Float\n5.0\nghci> (read "5" :: Float) * 4\n20.0\nghci> read "[1,2,3,4]" :: [Int]\n[1,2,3,4]\nghci> read "(3, \'a\')" :: (Int, Char)\n(3, \'a\')\n')),(0,l.kt)("h4",{id:"225-enum"},"2.2.5 Enum"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Enum members are sequentially ordered types \u2014 they can be enumerated. The main advantage of the Enum typeclass is that we can use its types in list ranges. They also have  defined successors and predecesors, which you can get with the succ and pred functions. Types in this class: (), Bool, Char, Ordering, Int, Integer, Float and Double.")),(0,l.kt)("p",null,"\u679a\u4e3e\u7c7b\u578b\u662f\u6309\u7167\u987a\u5e8f\u6392\u5e8f\u7684\u7c7b\u578b\uff0c\u4ed6\u4eec\u53ef\u4ee5\u88ab\u679a\u4e3e\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u5217\u8868\u4e2d\u4f7f\u7528\u5b83\u7684\u6240\u6709\u7c7b\u578b\u3002"),(0,l.kt)("p",null,"\u4ed6\u4eec\u8fd8\u88ab\u5b9a\u4e49\u4e86\u524d\u9a71\u548c\u540e\u7ee7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5bf9\u5b83\u7684\u7c7b\u578b\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"succ")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"pred")," \u51fd\u6570"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> ['a'..'e']\n\"abcde\"\nghci> [LT .. GT]\n[LT,EQ,GT]\nghci> [3 .. 5]\n[3,4,5]\nghci> succ 'B'\n'C'\n")),(0,l.kt)("h4",{id:"226-bounded"},"2.2.6 Bounded"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Bounded members have an upper and a lower bound.")),(0,l.kt)("p",null,"Bounded \u7c7b\u578b\u6709\u4e0a\u754c\u548c\u4e0b\u754c"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> minBound :: Int\n-2147483648\nghci> maxBound :: Char\n'\\1114111'\nghci> maxBound :: Bool\nTrue\nghci> minBound :: Bool\nFalse\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"minBound and maxBound are interesting because they have a type of (Bounded a) => a. In a sense they are polymorphic constants.")),(0,l.kt)("p",null,"\u4ed6\u4eec\u662f\u591a\u6001\u6027\u5e38\u91cf\uff0c\u89c1\u4e0b\u6587"),(0,l.kt)("p",null,"\u5982\u679c\u5143\u7ec4\u7684\u5143\u7d20\u4e5f\u5728\u5143\u7ec4\u4e2d\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5143\u7ec4\u4e5f\u662f Bounded \u7684\u6210\u5458\u3002"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> maxBound :: (Bool, Int, Char)\n(True,2147483647,'\\1114111')\n")),(0,l.kt)("h4",{id:"227-num"},"2.2.7 Num"),(0,l.kt)("p",null,"Num \u4e5f\u662f\u4e00\u4e2a\u591a\u6001\u6027\u5e38\u91cf\uff0c\u4ed6\u80fd\u8868\u73b0\u7684\u5411\u4efb\u4f55 Num \u7c7b\u7684\u6210\u5458\uff08\u5305\u62ec Int, Integer, Float, Double\uff09"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t 20\n20 :: (Num t) => t\n\nghci> 20 :: Int\n20\nghci> 20 :: Integer\n20\nghci> 20 :: Float\n20.0\nghci> 20 :: Double\n20.0\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"(5 :: Int) * (6 :: Integer)")," will error\uff0c while ",(0,l.kt)("inlineCode",{parentName:"p"},"5 * (6 :: Integer)"),"  will work just fine"),(0,l.kt)("h4",{id:"229-integral--floating"},"2.2.9 Integral & Floating"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Integral "),"contains ",(0,l.kt)("inlineCode",{parentName:"li"}," Int")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"Integer")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"Floating")," contains ",(0,l.kt)("inlineCode",{parentName:"li"},"Float")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"Double"),".")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"fromIntegral"),"\u53ef\u4ee5\u5e2e\u6211\u4eec\u5b9e\u73b0\u7c7b\u578b\u8f6c\u6362"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- It has a type declaration of\nfromIntegral :: (Num b, Integral a) => a -> b\n-- so, you can use it as\nfromIntegral (length [1,2,3,4]) + 3.2\n")),(0,l.kt)("h2",{id:"3-\u51fd\u6570\u8bed\u6cd5"},"3. \u51fd\u6570\u8bed\u6cd5"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Syntax in Functions")),(0,l.kt)("h3",{id:"31-match-\u8868\u8fbe\u5f0f"},"3.1 Match \u8868\u8fbe\u5f0f"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Pattern marching")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u5728 ghci \u4e2d\u58f0\u660e\u7c7b\u578b\u9700\u8981\u4f7f\u7528\u591a\u884c\u5757\u4e2d"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},":{\nlucky :: Int -> String\nlucky a = show(a)\n:}\n\n:type lucky\nlucky :: Int -> String\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u5339\u914d\u5217\u8868\u957f\u5ea6"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'tell :: (Show a) => [a] -> String\ntell [] = "The list is empty"\ntell (x:[]) = "The list has one element: " ++ show x\ntell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y\ntell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u4e00\u4e2a length \u51fd\u6570\u7684\u5b9e\u73b0"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"length' :: (Num b) => [a] -> b\nlength' [] = 0\nlength' (_:xs) = 1 + length' xs\n")))),(0,l.kt)("h3",{id:"32-guard"},"3.2 Guard"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u6807\u51c6"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'bmiTell :: (RealFloat a) => a -> String\nbmiTell bmi\n   | bmi <= 18.5 = "You\'re underweight, you emo, you!"\n   | bmi <= 25.0 = "You\'re supposedly normal. Pffft, I bet you\'re ugly!"\n   | bmi <= 30.0 = "You\'re fat! Lose some weight, fatty!"\n   | otherwise   = "You\'re a whale, congratulations!"\n\nmyCompare :: (Ord a) => a -> a -> Ordering\na `myCompare` b\n    | a > b     = GT\n    | a == b    = EQ\n    | otherwise = LT\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"inline \u7248\uff08\u53ef\u8bfb\u6027\u5dee\uff09"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"max' :: (Ord a) => a -> a -> a\nmax' a b | a > b = a | otherwise = b\n")))),(0,l.kt)("h3",{id:"33-where"},"3.3 where"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u4f5c\u7528\u5728 guard \u4e0a"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'    bmiTell :: (RealFloat a) => a -> a -> String\n    bmiTell weight height\n        | bmi <= skinny = "You\'re underweight, you emo, you!"\n        | bmi <= normal = "You\'re supposedly normal. Pffft, I bet you\'re ugly!"\n        | bmi <= fat    = "You\'re fat! Lose some weight, fatty!"\n        | otherwise     = "You\'re a whale, congratulations!"\n        where bmi = weight / height ^ 2\n              skinny = 18.5\n              normal = 25.0\n              fat = 30.0\n')),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("em",{parentName:"p"},"where")," bindings aren't shared across function bodies of different  patterns. If you want several patterns of one function to access some  shared name, you have to define it globally.")),(0,l.kt)("p",{parentName:"li"},"where \u7684\u7ed1\u5b9a\u4e0d\u80fd\u5728\u51fd\u6570\u4f53\u91cc\u5171\u4eab\uff0c\u9664\u975e\u4ee5\u5168\u5c40\u65b9\u5f0f\u5b9a\u4e49")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u4f5c\u7528\u5728 pattern match \u4e0a"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'    initials :: String -> String -> String\n    initials firstname lastname = [f] ++ ". " ++ [l] ++ "."\n        where (f:_) = firstname\n              (l:_) = lastname\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u4f7f\u7528 where \u5b9a\u4e49 function"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"    calcBmis :: (RealFloat a) => [(a, a)] -> [a]\n    calcBmis xs = [bmi w h | (w, h) <- xs]\n        where bmi weight height = weight / height ^ 2\n")))),(0,l.kt)("h3",{id:"34-let-it-be"},"3.4 Let it be"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"}," ",(0,l.kt)("inlineCode",{parentName:"strong"},"let <bindings> in <expression> "))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"    cylinder :: (RealFloat a) => a -> a -> a\n    cylinder r h =\n        let sideArea = 2 * pi * r * h\n            topArea = pi * r ^2\n        in  sideArea + 2 * topArea\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The difference is that ",(0,l.kt)("em",{parentName:"p"},"let")," bindings are expressions themselves. ",(0,l.kt)("em",{parentName:"p"},"where")," bindings are just syntactic constructs.")),(0,l.kt)("p",null,"Let \u628a\u7ed1\u5b9a\u653e\u5728\u524d\u9762\uff0cwhere \u628a\u7ed1\u5b9a\u653e\u5728\u540e\u9762\uff0c\u4f46\u662f Let \u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0cWhere \u53ea\u662f\u4e2a\u8bed\u6cd5\u7ed3\u6784"),(0,l.kt)("h3",{id:"35-case-expression"},"3.5 Case Expression"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u793a\u4f8b 1"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'describeList :: [a] -> String\ndescribeList xs = "The list is " ++ case xs of [] -> "empty."\n                                               [x] -> "a singleton list."\n                                               xs -> "a longer list."\n'))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"\u793a\u4f8b 2"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'describeList :: [a] -> String\ndescribeList xs = "The list is " ++ what xs\n    where what [] = "empty."\n          what [x] = "a singleton list."\n          what xs = "a longer list."\n')))),(0,l.kt)("h2",{id:"4-\u9012\u5f52"},"4. \u9012\u5f52"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Recursion")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"### 4.1 maxium\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- \u7b2c\u4e00\u79cd\nmaximum' :: (Ord a) => [a] -> a\nmaximum' [] = error \"maximum of empty list\"\nmaximum' [x] = x\nmaximum' (x:xs)\n    | x > maxTail = x\n    | otherwise = maxTail\n    where maxTail = maximum' xs\n-- \u7b2c\u4e8c\u79cd\nmaximum' :: (Ord a) => [a] -> a\nmaximum' [] = error \"maximum of empty list\"\nmaximum' [x] = x\nmaximum' (x:xs) = max x (maximum' xs)\n")),(0,l.kt)("h3",{id:"42-replicate"},"4.2 replicate"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"replicate' :: (Num i, Ord i) => i -> a -> [a]\nreplicate' n x\n    | n <= 0    = []\n    | otherwise = x:replicate' (n-1) x\n")),(0,l.kt)("h3",{id:"43-take"},"4.3 take"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"take' :: (Num i, Ord i) => i -> [a] -> [a]\ntake' n _\n    | n <= 0   = []\ntake' _ []     = []\ntake' n (x:xs) = x : take' (n-1) xs\n")),(0,l.kt)("h3",{id:"44-zip"},"4.4 zip"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"elem' :: (Eq a) => a -> [a] -> Bool\nelem' a [] = False\nelem' a (x:xs)\n    | a == x    = True\n    | otherwise = a `elem'` xs\n")),(0,l.kt)("h3",{id:"45-quick-sort"},"4.5 quick sort"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"quicksort :: (Ord a) => [a] -> [a]\nquicksort [] = []\nquicksort (x:xs) =\n    let smallerSorted = quicksort [a | a <- xs, a <= x]\n        biggerSorted = quicksort [a | a <- xs, a > x]\n    in  smallerSorted ++ [x] ++ biggerSorted\nquicksort (x:xs) = quicksort [a | a <- xs, a <= x] ++ [x] ++ quicksort [a | a <- xs, a > x]\n")),(0,l.kt)("h2",{id:"5-\u9ad8\u9636\u51fd\u6570"},"5. \u9ad8\u9636\u51fd\u6570"),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Higher order functions")),(0,l.kt)("p",null,"\u80fd\u591f\u4ee5\u51fd\u6570\u4f5c\u4e3a\u53c2\u6570\uff0c\u6216\u8005\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570\u7684\u51fd\u6570\u90fd\u662f\u9ad8\u9636\u51fd\u6570\uff0c\u544a\u8beb\u51fd\u6570\u5c31\u662f Haskell \u7684\u4f53\u9a8c"),(0,l.kt)("h3",{id:"51-curried-functions"},"5.1 Curried functions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> max 4 5\n5\n-- max \u672c\u8eab\u53ef\u4ee5\u8fd9\u6837\u5199\nghci> (max 4) 5\n5\n")),(0,l.kt)("p",null,"\u8ba9\u6211\u4eec\u770b\u770b max \u7684\u7c7b\u578b"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"max :: (Ord a) => a -> a -> a.\n-- \u4e5f\u80fd\u5199\u4f5c\nmax :: (Ord a) => a -> (a -> a).\n")),(0,l.kt)("p",null,"\u6240\u4ee5 max \u8fd9\u4e2a\u51fd\u6570\u80fd\u591f\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570"),(0,l.kt)("p",null,"\u540c\u65f6"),(0,l.kt)("h3",{id:"52-\u4e00\u4e9b\u9ad8\u9636\u51fd\u6570"},"5.2 \u4e00\u4e9b\u9ad8\u9636\u51fd\u6570"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"applyTwice :: (a -> a) -> a -> a\napplyTwice f x = f (f x)\n\nghci> applyTwice (+3) 10\n16\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'zipWith\' :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWith\' _ [] _ = []\nzipWith\' _ _ [] = []\nzipWith\' f (x:xs) (y:ys) = f x y : zipWith\' f xs ys\n\nzipWith\' (++) ["aaa", "bbb"] ["ccc", "ddd"]\n["aaaccc","bbbddd"]\n')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"flip")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"flip' :: (a -> b -> c) -> b -> a -> c\nflip' f y x = f x y\n")),(0,l.kt)("h3",{id:"53-map"},"5.3 Map"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("inlineCode",{parentName:"p"},"map (+3) [1,5,3,1,6] "),"is the same as writing ",(0,l.kt)("inlineCode",{parentName:"p"},"[x+3 | x <- [1,5,3,1,6]]."))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"    map :: (a -> b) -> [a] -> [b]\n    map _ [] = []\n    map f (x:xs) = f x : map f xs\n")),(0,l.kt)("h3",{id:"54-filter"},"5.4 Filter"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"    filter :: (a -> Bool) -> [a] -> [a]\n    filter _ [] = []\n    filter p (x:xs)\n        | p x       = x : filter p xs\n        | otherwise = filter p xs\n")),(0,l.kt)("h3",{id:"55-takewhile"},"5.5 takeWhile"),(0,l.kt)("p",null,"take \u76f4\u5230\u9650\u5236\u6761\u4ef6\u5230"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"sum (takeWhile (<10000) (filter odd (map (^2) [1..])))\n\nsum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])\n")),(0,l.kt)("h3",{id:"56-chain"},"5.6 Chain"),(0,l.kt)("p",null,"\u751f\u6210 Collatz sequences"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"chain :: (Integral a) => a -> [a]\nchain 1 = [1]\nchain n\n    | even n =  n:chain (n `div` 2)\n    | odd n  =  n:chain (n*3 + 1)\n\n-- \u5c0f\u7ec3\u4e60\nnumLongChains :: Int\nnumLongChains = length (filter isLong (map chain [1..100]))\n    where isLong xs = length xs > 15\n")),(0,l.kt)("h3",{id:"57-map--0"},"5.7 map (*) ","[0..]"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If we map ",(0,l.kt)("inlineCode",{parentName:"p"},"*")," over the list ",(0,l.kt)("inlineCode",{parentName:"p"}," [0..]"),", we get back a list of functions that only take one parameter, so ",(0,l.kt)("inlineCode",{parentName:"p"},"(Num a) => [a -> a]"),". ",(0,l.kt)("inlineCode",{parentName:"p"},"map (*) [0..]")," produces a list like the one we'd get by writing ",(0,l.kt)("inlineCode",{parentName:"p"},"[(0*),(1*),(2*),(3*),(4*),(5*)..."))),(0,l.kt)("p",null,"\u5b9e\u4f8b\u4ee3\u7801"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> let listOfFuns = map (*) [0..]\nghci> (listOfFuns !! 4) 5\n20\n")),(0,l.kt)("h3",{id:"58-lambdas"},"5.8 Lambdas"),(0,l.kt)("p",null,"\u8bed\u6cd5\uff1a\u4e00\u822c\u4ee5\u5c0f\u62ec\u53f7\u9614\u8d77\u6765\uff0c\u4ee5 ",(0,l.kt)("inlineCode",{parentName:"p"},"\\")," \u5f00\u5934"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"numLongChains :: Int\nnumLongChains = length (filter (\\xs -> length xs > 15) (map chain [1..100]))\n")),(0,l.kt)("p",null,"\u4e00\u4e2a\u6bd4\u8f83\u597d\u7684\u7528\u53d1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"flip' :: (a -> b -> c) -> b -> a -> c\nflip' f = \\x y -> f y x\n")),(0,l.kt)("h3",{id:"59-fold"},"5.9 Fold"),(0,l.kt)("p",null,"\u6211\u4eec\u7528 ",(0,l.kt)("em",{parentName:"p"},"fold")," \u518d\u6b21\u5b9e\u73b0 ",(0,l.kt)("inlineCode",{parentName:"p"},"sum")," \u51fd\u6570"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"sum' :: (Num a) => [a] -> a\nsum' xs = foldl (\\acc x -> acc + x) 0 xs\nghci> sum' [3,5,2,1]\n11\n")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("strong",{parentName:"li"},"foldl")," \u63a5\u53d7 2 \u4e2a\u53c2\u6570\uff0c\u5206\u522b\u662f\u51fd\u6570\u548c\u4e00\u4e2a\u521d\u59cb\u503c (\u6216\u8005\u8bf4\u7d2f\u52a0\u5668), acc \u5f00\u59cb\u4e3a 0\uff0c\u4e4b\u540e\u4f9d\u6b21\u52a0 3, 5, 2, 1")),(0,l.kt)("p",null,"\u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u7d2f\u52a0\u5668\uff0c\u7b2c\u4e8c\u4e2a\u662f\u5f53\u524d\u7684\u503c"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- \u518d\u6b21\u5b9e\u73b0 elem\nelem' :: (Eq a) => a -> [a] -> Bool\nelem' x xs = foldl (\\acc el -> if el == x then True else acc) False xs\n")),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"foldr")," \u4e0e foldl \u76f8\u4f3c\uff0c\u4e0d\u8fc7\u662f\u4ece\u53f3\u4fa7\u5f00\u59cb\u904d\u5386\u5143\u7d20\uff0c\u5176\u4e2d\uff0cfoldr \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u5f53\u524d\u5143\u7d20\uff0c\u7b2c\u4e8c\u4e2a\u5143\u7d20\u662f acc \u7d2f\u52a0\u5668")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"\u4e24\u79cd map \u7684\u5b9e\u73b0")),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- foldr\nmap' :: (a -> b) -> [a] -> [b]\nmap' f xs = foldr (\\x acc -> f x : acc) [] xs\n-- foldl\nmap' f xs = foldl (\\acc x -> acc ++ [f x]) [] xs\n")),(0,l.kt)("p",{parentName:"li"},"\u5728\u4e0a\u9762\u7684\u6848\u4f8b\u4e2d\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"foldr")," \u5b9e\u73b0\u7684\u66f4\u597d\uff0c\u56e0\u4e3a ",(0,l.kt)("inlineCode",{parentName:"p"},":")," \u7684\u5f00\u9500\u6bd4 ",(0,l.kt)("inlineCode",{parentName:"p"},"++")," \u5c0f\u7684\u591a")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u8981\u6ce8\u610f\u7684\u662f foldr \u53ef\u4ee5\u4f5c\u7528\u5728\u65e0\u7ebf\u5217\u8868\u4e0a\uff0cfoldl \u4e0d\u80fd")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"foldl1")," \u548c ",(0,l.kt)("strong",{parentName:"p"},"foldr1")," \u4f7f\u7528\u7b2c\u4e00\u4e2a\u6216\u8005\u6700\u540e\u4e00\u4e2a\u4f5c\u4e3a\u521d\u503c\uff0c\u4e0d\u9700\u8981\u90a3\u4e2a\u53c2\u6570\u4e86"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- \u8fd9\u91cc\u662f\u4e00\u5806\u4f8b\u5b50\nmaximum' :: (Ord a) => [a] -> a\nmaximum' = foldr1 (\\x acc -> if x > acc then x else acc)\n\nreverse' :: [a] -> [a]\nreverse' = foldl (\\acc x -> x : acc) []\n\nproduct' :: (Num a) => [a] -> a\nproduct' = foldr1 (*)\n\nfilter' :: (a -> Bool) -> [a] -> [a]\nfilter' p = foldr (\\x acc -> if p x then x : acc else acc) []\n\nhead' :: [a] -> a\nhead' = foldr1 (\\x _ -> x)\n\nlast' :: [a] -> a\nlast' = foldl1 (\\_ x -> x)\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"scanl")," \u548c ",(0,l.kt)("strong",{parentName:"p"},"scanr")," \u548c fold \u7c7b\u4f3c\uff0c\u4e0d\u8fc7\u4f1a\u628a\u4e2d\u95f4\u7684\u72b6\u6001\u4fdd\u7559\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a\u5217\u8868"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> scanl (+) 0 [3,5,2,1]\n[0,3,8,10,11]\nghci> scanr (+) 0 [3,5,2,1]\n[11,8,3,1,0]\nghci> scanl1 (\\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]\n[3,4,5,5,7,9,9,9]\nghci> scanl (flip (:)) [] [3,2,1]\n[[],[3],[2,3],[1,2,3]]\n")))),(0,l.kt)("h3",{id:"510--\u8fd0\u7b97\u7b26"},"5.10 $ \u8fd0\u7b97\u7b26"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Whereas normal function application (putting a space between two things) has a really high precedence, the $ function has the lowest precedence. Function application with a space is left-associative (so f a b c is the same as ((f a) b) c)), function application with $ is right-associative.")),(0,l.kt)("p",null,"\u7a7a\u683c\u5177\u6709\u8f83\u9ad8\u7684\u4f18\u5148\u7ea7\uff0c\u4f46\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"$")," \u5177\u6709\u6700\u4f4e\u7684\u4f18\u5148\u7ea7"),(0,l.kt)("p",null,"\u4f7f\u7528\u7a7a\u683c\u5206\u5272\u7684\u662f\u5de6\u5173\u8054\u7684\uff0c\u800c\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"$")," \u5206\u5272\u7684\u662f\u53f3\u5173\u8054\u7684"),(0,l.kt)("p",null,"\u6709\u4ec0\u4e48\u7528\uff1f"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u5c11\u4e9b\u62ec\u53f7"),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"sum (map sqrt [1..130])")," \u53ef\u4ee5\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"sum $ map sqrt [1..130]")," \u4ee3\u66ff\uff0c",(0,l.kt)("inlineCode",{parentName:"p"},"sqrt 3 + 4 + 9"),"\u662f 13+ \u6839\u53f7 3\uff0c\u4f46\u662f ",(0,l.kt)("inlineCode",{parentName:"p"},"sqrt $ 3 + 4 + 9")," \u5c31\u6b63\u5e38"),(0,l.kt)("p",{parentName:"li"},"[]:"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"How about sum (filter (> 10) (map (",(0,l.kt)("em",{parentName:"p"},"2) ","[2..10]","))? Well, because $ is right-associative, f (g (z x)) is equal to f $ g $ z x. And so, we can rewrite sum (filter (> 10) (map ("),"2) ","[2..10]",")) as sum $ filter (> 10) $ map (*2) ","[2..10]","."))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u589e\u52a0\u7279\u6027"))),(0,l.kt)("p",null,"\u52a0\u4e86 ",(0,l.kt)("inlineCode",{parentName:"p"},"$")," \u610f\u5473\u7740\u53ef\u4ee5\u88ab\u5f53\u4f5c\u51fd\u6570\u6765\u5bf9\u5f85\uff0c\u6240\u4ee5\u4e0b\u9762\u7684\u5199\u6cd5\u662f\u53ef\u884c\u7684"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> map ($ 3) [(4+), (10*), (^2), sqrt]\n[7.0,30.0,9.0,1.7320508075688772]\n")),(0,l.kt)("h3",{id:"511-\u51fd\u6570\u7ec4\u5408"},"5.11 \u51fd\u6570\u7ec4\u5408"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},".")," \u662f\u4e00\u4e2a\u8fd0\u7b97\u7b26\uff0c\u4ed6\u7684\u5b9a\u4e49\u5982\u4e0b"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"(.) :: (b -> c) -> (a -> b) -> a -> c\nf . g = \\x -> f (g x)\n")),(0,l.kt)("p",null,"\u6709\u4e86\u8fd9\u4e2a\u540e\uff0c\u4e00\u4e9b\u5d4c\u5957\u7684\u51fd\u6570\u5c31\u80fd\u7b80\u5199\uff0c\u4f8b\u5982"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- before\nghci> map (\\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]\n[-5,-3,-6,-7,-3,-2,-19,-24]\n-- now\nghci> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]\n[-5,-3,-6,-7,-3,-2,-19,-24]\n")),(0,l.kt)("h2",{id:"6-\u6a21\u5757"},"6. \u6a21\u5757"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Modules")),(0,l.kt)("h3",{id:"61-\u5bfc\u5165\u6a21\u5757"},"6.1 \u5bfc\u5165\u6a21\u5757"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"\u5bfc\u5165")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- 1. \u5bfc\u5165\u4e00\u4e2a\u6a21\u5757\nghci> import Data.List\n-- 2. \u5bfc\u5165\u591a\u4e2a\u6a21\u5757\nghci> :m + Data.List Data.Map Data.Set\n-- 3. \u5bfc\u5165\u67d0\u4e9b\u51fd\u6570\nghci> import Data.List (nub, sort)\n-- 4. \u4e0d\u5bfc\u5165\u67d0\u4e9b\u6307\u5b9a\u7684\u51fd\u6570\nghci> import Data.List hiding (nub)\n")),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},"As")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- \u907f\u514d\u91cd\u540d\uff0c \u4f46\u662f\u4f7f\u7528\u65f6\u5fc5\u987b\u6307\u5b9a Data.Map.filter\nimport qualified Data.Map\n-- \u6362\u540d\uff0c \u53ef\u4ee5\u7528 M.filter\nimport qualified Data.Map as M\n")),(0,l.kt)("h3",{id:"62-datalist"},"6.2 Data.List"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"intersperse"),(0,l.kt)("p",{parentName:"li"},"\u5411 List \u4e2d\u586b\u5145\u5143\u7d20*, \u7c7b\u4f3c\u4e0e python \u4e2d\u7684 join"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> intersperse \'.\' "MONKEY"\n"M.O.N.K.E.Y"\nghci> intersperse 0 [1,2,3,4,5,6]\n[1,0,2,0,3,0,4,0,5,0,6]\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"intercalate"),(0,l.kt)("p",{parentName:"li"},"join \u540e\u8fdb\u884c concat\uff0c\u586b\u5145\u540e\u5408\u5e76\u8fd4\u56de\uff0c"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> intersperse \'.\' "MONKEY"\n"M.O.N.K.E.Y"\nghci> intersperse 0 [1,2,3,4,5,6]\n[1,0,2,0,3,0,4,0,5,0,6]\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"transpose"),(0,l.kt)("p",{parentName:"li"},"\u77e9\u9635\u8f6c\u7f6e"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> transpose [[1,2,3],[4,5,6],[7,8,9]]\n[[1,4,7],[2,5,8],[3,6,9]]\nghci> transpose ["hey","there","guys"]\n["htg","ehu","yey","rs","e"]\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"foldl' foldl1'"),(0,l.kt)("p",{parentName:"li"},"\u80fd\u591f\u7acb\u5373\u8fd0\u7b97\uff0c\u9632\u6b62\u5806\u6808\u6ea2\u51fa"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"foldl' and foldl1' are stricter versions of their respective lazy incarnations. When using lazy folds on really big lists, you might often get a stack overflow  error. The culprit for that is that due to the lazy nature of the folds, the accumulator value isn't actually updated as the folding happens.  What actually happens is that the accumulator kind of makes a promise  that it will compute its value when asked to actually produce the result (also called a thunk). That happens for every intermediate accumulator  and all those thunks overflow your stack. The strict folds aren't lazy  buggers and actually compute the intermediate values as they go along  instead of filling up your stack with thunks. So if you ever get stack  overflow errors when doing lazy folds, try switching to their strict  versions."))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"concat"),(0,l.kt)("p",{parentName:"li"},"\u548c\u5e76\u6240\u6709\u5143\u7d20\u5e76\u8fd4\u56de"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> concat ["foo","bar","car"]\n"foobarcar"\nghci> concat [[3,4,5],[2,3,4],[2,1,1]]\n[3,4,5,2,3,4,2,1,1]\n')),(0,l.kt)("p",{parentName:"li"},(0,l.kt)("strong",{parentName:"p"},"concatMap == concat map"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"and & or"),(0,l.kt)("p",{parentName:"li"},"\u9700\u8981\u914d\u5408 map \u4f7f\u7528"),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"and takes a list of boolean values and returns True only if all the values in the list are True.")),(0,l.kt)("p",{parentName:"li"},"\u5168\u4e3a\u771f\u8fd4\u56de True"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> and $ map (>4) [5,6,7,8]\nTrue\nghci> and $ map (==4) [4,4,4,3,4]\nFalse\n")),(0,l.kt)("blockquote",{parentName:"li"},(0,l.kt)("p",{parentName:"blockquote"},"or is like and, only it returns True if any of the boolean values in a list is True.")),(0,l.kt)("p",{parentName:"li"},"\u6709\u771f\u5c31\u8fd4\u56de True"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> or $ map (==4) [2,3,4,5,6,1]\nTrue\nghci> or $ map (>4) [1,2,3]\nFalse\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"all & any"),(0,l.kt)("p",{parentName:"li"},"and \u548c or \u7684\u66ff\u4ee3\u54c1"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> any (==4) [2,3,5,6,1,4]\nTrue\nghci> all (>4) [6,9,10]\nTrue\nghci> all (`elem` ['A'..'Z']) \"HEYGUYSwhatsup\"\nFalse\nghci> any (`elem` ['A'..'Z']) \"HEYGUYSwhatsup\"\nTrue\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"iterate"),(0,l.kt)("p",{parentName:"li"},"\u6839\u636e\u6bcf\u6b21\u7684\u7ed3\u679c\u751f\u6210\u4e0b\u4e00\u6b21\u7684\u503c"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'Prelude> take 10 (iterate (+10) 0)\n[0,10,20,30,40,50,60,70,80,90]\nPrelude> take 5 $ iterate (++ "haha") "haha"\n["haha","hahahaha","hahahahahaha","hahahahahahahaha","hahahahahahahahahaha"]\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"splitAt"),(0,l.kt)("p",{parentName:"li"},"\u5206\u5272\u751f\u6210\u5217\u8868"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> splitAt 3 "heyman"\n("hey","man")\nghci> splitAt 100 "heyman"\n("heyman","")\nghci> splitAt (-3) "heyman"\n("","heyman")\nghci> let (a,b) = splitAt 3 "foobar" in b ++ a\n"barfoo"\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"takeWhile & dropWhile"),(0,l.kt)("p",{parentName:"li"},"\u6839\u636e\u6761\u4ef6 take \u6216 drop"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]\n[6,5,4]\nghci> takeWhile (/=\' \') "This is a sentence"\n"This"\n\nghci> dropWhile (/=\' \') "This is a sentence"\n" is a sentence"\nghci> dropWhile (<3) [1,2,2,2,3,4,5,4,3,2,1]\n[3,4,5,4,3,2,1]\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"break & span"),(0,l.kt)("p",{parentName:"li"},"\u5c31\u662f\u628a takeWhile \u7684\u540e\u534a\u90e8\u5206\u4e5f\u8fd4\u56de\u4e86"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> break (==4) [1,2,3,4,5,6,7]\n([1,2,3],[4,5,6,7])\nghci> span (/=4) [1,2,3,4,5,6,7]\n([1,2,3],[4,5,6,7])\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"sort"),(0,l.kt)("p",{parentName:"li"},"\u6392\u5e8f\u5457"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> sort [8,5,3,2,1,6,4,2]\n[1,2,2,3,4,5,6,8]\nghci> sort "This will be sorted soon"\n"    Tbdeehiillnooorssstw"\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"group"),(0,l.kt)("p",{parentName:"li"},"\u5206\u7ec4\u4f46\u4e0d\u6392\u5e8f"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]\n[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"inits & tails"),(0,l.kt)("p",{parentName:"li"},"\u751f\u6210\u4e00\u4e2a\u524d\u7f00\u548c"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> inits "w00t"\n["","w","w0","w00","w00t"]\nghci> tails "w00t"\n["w00t","00t","0t","t",""]\nghci> let w = "w00t" in zip (inits w) (tails w)\n[("","w00t"),("w","00t"),("w0","0t"),("w00","t"),("w00t","")]\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"isInfixOf & isPrefixOf & isSuffixOf"),(0,l.kt)("p",{parentName:"li"},"\u662f\u5426\u662f sublist\uff0c\u662f\u5426\u5728\u5f00\u5934\uff0c\u662f\u5426\u5728\u7ed3\u5c3e"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> "cat" `isInfixOf` "im a cat burglar"\nTrue\nghci> "Cat" `isInfixOf` "im a cat burglar"\nFalse\nghci> "cats" `isInfixOf` "im a cat burglar"\nFalse\n\nghci> "hey" `isPrefixOf` "hey there!"\nTrue\nghci> "hey" `isPrefixOf` "oh hey there!"\nFalse\nghci> "there!" `isSuffixOf` "oh hey there!"\nTrue\nghci> "there!" `isSuffixOf` "oh hey there"\nFalse\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"elem & notElem & partition"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'\u5224\u65ad\u662f\u5426\u662f\uff0c\u5206\u4e3a\u4e24\u7ec4\n\n```haskell\nghci> partition (`elem` [\'A\'..\'Z\']) "BOBsidneyMORGANeddy"\n("BOBMORGAN","sidneyeddy")\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"\n17. find & findIndex & findIndices\n\n")),(0,l.kt)("p",null,"find \u8fd4\u56de\u7b2c\u4e00\u4e2a\u7b26\u5408\u7684\u5143\u7d20"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> find (>4) [1,2,3,4,5,6]\nJust 5\nghci> find (>9) [1,2,3,4,5,6]\nNothing\nghci> :t find\nfind :: (a -> Bool) -> [a] -> Maybe a\n\nghci> findIndex (==4) [5,3,2,1,6,4]\nJust 5\nghci> findIndex (==7) [5,3,2,1,6,4]\nNothing\nghci> findIndices (`elem` ['A'..'Z']) \"Where Are The Caps?\"\n[0,6,10,14]\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'\n18. elemIndex  & elemIndIces\n\n    \u8fd4\u56de\u5143\u7d20\u7684 index\n\n    ```haskell\n    ghci> :t elemIndex\n    elemIndex :: (Eq a) => a -> [a] -> Maybe Int\n    ghci> 4 `elemIndex` [1,2,3,4,5,6]\n    Just 3\n    ghci> 10 `elemIndex` [1,2,3,4,5,6]\n    Nothing\n\n    ghci> \' \' `elemIndices` "Where are the spaces?"\n    [5,9,13]\n    ```\n19. more zip\n\n    \u4e00\u76f4\u63d0\u4f9b\u5230 7\n\n    ```haskell\n    ghci> zipWith3 (\\x y z -> x + y + z) [1,2,3] [4,5,2,2] [2,2,3]\n    [7,9,8]\n    ghci> zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]\n    [(2,2,5,2),(3,2,5,2),(3,2,3,2)]\n    ```\n20. line & word\n\n    line \u5207\u51fa\u6ca1\u4e00\u884c\uff0cword \u5207\u51fa\u6bcf\u4e2a\u5355\u8bcd\n\n    ```haskell\n    ghci> lines "first line\\nsecond line\\nthird line"\n    ["first line","second line","third line"]\n    ghci> unlines ["first line", "second line", "third line"]\n    "first line\\nsecond line\\nthird line\\n"\n    ghci> words "hey these are the words in this sentence"\n    ["hey","these","are","the","words","in","this","sentence"]\n    ghci> words "hey these           are    the words in this\\nsentence"\n    ["hey","these","are","the","words","in","this","sentence"]\n    ghci> unwords ["hey","there","mate"]\n    "hey there mate"\n    ```\n21. nub\n\n    \u5143\u7d20\u53bb\u91cd\n\n    ```haskell\n    ghci> nub [1,2,3,4,3,2,1,2,3,4,3,2,1]\n    [1,2,3,4]\n    ghci> nub "Lots of words and stuff"\n    "Lots fwrdanu"\n    ```\n22. delete\n\n    \u5220\u6389\u5730\u4e00\u4e2a\u5339\u914d\u7684\u5143\u7d20\n\n    ```haskell\n    -- delete takes an element and a list and deletes the first occurence of that element in the list.\n\n    ghci> delete \'h\' "hey there ghang!"\n    "ey there ghang!"\n    ghci> delete \'h\' . delete \'h\' $ "hey there ghang!"\n    "ey tere ghang!"\n    ghci> delete \'h\' . delete \'h\' . delete \'h\' $ "hey there ghang!"\n    "ey tere gang!"\n    ```\n23. \\\\\\\\\n\n')),(0,l.kt)("p",null,"\u5220\u6389\u66f4\u591a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'-- \\\\ is the list difference function. It acts like a set difference, basically. For every element in the right-hand list, it removes a matching element in the left one.\n\nghci> [1..10] \\\\ [2,5,9]\n[1,3,4,6,7,8,10]\nghci> "Im a big baby" \\\\ "big"\n"Im a  baby"\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"\n24. union\n\n    \u6c42\u5e76\u96c6\n\n    ```haskell\n    ghci> \"hey man\" `union` \"man what's up\"\n    \"hey manwt'sup\"\n    ghci> [1..7] `union` [5..10]\n    [1,2,3,4,5,6,7,8,9,10]\n    ```\n25. intersect\n\n    \u6c42\u4ea4\u96c6\n\n    ```haskell\n    ghci> [1..7] `intersect` [5..10]\n    [5,6,7]\n    ```\n26. insert\n\n    \u63d2\u5165\u5457\n\n    ```haskell\n    ghci> insert 4 [3,5,1,2,8,2]\n    [3,4,5,1,2,8,2]\n    ghci> insert 4 [1,3,4,4,1]\n    [1,3,4,4,4,1]\n    ```\n27. deleteBy, unionBy, intersectBy and groupBy\n\n    \u4ee5\u4e00\u4e2a\u6570\u5f00\u59cb\uff0c \u4ee5\u6b64\u6bd4\u8f83\u4ed6\u540e\u9762\u7684\u6570\uff0c\u77e5\u9053\u4e0d\u5339\u914d\uff0c \u7ec4\u6210\u6570\u7ec4\n\n    \u63a5\u7740\u4ee5\u7b2c\u4e00\u4e2a\u4e0d\u5339\u914d\u7684\u6570\u5f00\u59cb\uff0c\u91cd\u590d\u6bd4\u8f83\n\n    ```haskell\n    ghci> let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3]\n    ghci> groupBy (\\x y -> (x > 0) == (y > 0)) values\n    -- \u4e5f\u53ef\u4ee5\u5199\u6210 \\x y -> (x > 0) && (y > 0) || (x <= 0) && (y <= 0)\n    [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]\n    ghci> groupBy (\\x y -> (x>0) == (y<0)) values\n    -- \u7b2c\u4e00\u4e2a\u6570\u548c\u540e\u9762\u7684\u7b26\u53f7\u90fd\u4e0d\u540c\n    [[-4.3],[-2.4],[-1.2,0.4,2.3,5.9,10.5,29.1,5.3],[-2.4],[-14.5,2.9,2.3]]\n    ```\n28. on\n\n    \u8fd8\u6709\u66f4\u597d\u7684\u65b9\u6cd5\u5199\u4e0a\u9762\u7684 lambada \u8868\u8fbe\u5f0f\n\n    on \u9700\u8981\u4ece Data.Function \u5bfc\u5165\n\n    on \u63a5\u53d7\u4e24\u4e2a\u53c2\u6570\uff0c\u7b2c\u4e8c\u4e2a\u4f1a\u5bf9\u53c2\u6570\u505a\u7684\u8fd0\u7b97\uff0c \u7b2c\u4e00\u4e2a\u662f\u51fd\u6570\u4f1a\u6bd4\u8f83\u4e24\u4e2a\u8fd0\u7b97\u540e\u7ed3\u679c\n\n    ```haskell\n    on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\n    f `on` g = \\x y -> f (g x) (g y)\n    ```\n\n### 6.3 Data.Char\n\nData.Char \u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u5904\u7406\u5b57\u7b26\u7684\u51fd\u6570\uff0c\u914d\u5408 map \u548c filter \u4f7f\u7528\u4e5f\u53ef\u4ee5\u7528\u6765\u5904\u7406\u5b57\u7b26\u4e32\n\n**1. \u5224\u65ad\u7c7b**\n\n1. isControl checks whether a character is a control character.\n2. isSpace checks whether a character is a white-space characters. That includes spaces, tab characters, newlines, etc.\n3. isLower checks whether a character is lower-cased.\n4. isUpper checks whether a character is upper-cased.\n5. isAlpha checks whether a character is a letter.\n6. isAlphaNum checks whether a character is a letter or a number.\n7. isPrint checks whether a character is printable. Control characters, for instance, are not printable.\n8. isDigit checks whether a character is a digit.\n9. isOctDigit checks whether a character is an octal digit.\n10. isHexDigit checks whether a character is a hex digit.\n11. isLetter checks whether a character is a letter.\n12. isMark checks for Unicode mark characters. Those are characters that combine with preceding letters to form latters with accents. Use this if you are French.\n13. isNumber checks whether a character is numeric.\n14. isPunctuation checks whether a character is punctuation.\n15. isSymbol checks whether a character is a fancy mathematical or currency symbol.\n16. isSeparator checks for Unicode spaces and separators.\n17. isAscii checks whether a character falls into the first 128 characters of the Unicode character set.\n18. isLatin1 checks whether a character falls into the first 256 characters of Unicode.\n19. isAsciiUpper checks whether a character is ASCII and upper-case.\n20. isAsciiLower checks whether a character is ASCII and lower-case.\n\n**2. \u8f6c\u6362\u7c7b**\n\n1. toUpper converts a character to upper-case. Spaces, numbers, and the like remain unchanged.\n2. toLower converts a character to lower-case.\n3. toTitle converts a character to title-case. For most characters, title-case is the same as upper-case.\n4. digitToInt converts a character to an Int. To succeed, the character must be in the ranges '0'..'9', 'a'..'f' or 'A'..'F'.\n5. intToDigit is the inverse function of digitToInt. It takes an Int in the range of 0..15 and converts it to a lower-case character.\n6. ord and chr convert characters to their corresponding numbers and vice versa:\n\n   ```haskell\n   ghci> ord 'a'\n   97\n   ghci> chr 97\n   'a'\n   ghci> map ord \"abcdefgh\"\n   [97,98,99,100,101,102,103,104]\n")),(0,l.kt)("ol",{start:7},(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"encode"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'-- \u4e00\u79cd\u7f16\u7801\u65b9\u5f0f\nencode :: Int -> String -> String\nencode shift msg =\n    let ords = map ord msg\n        shifted = map (+ shift) ords\n    in  map chr shifted\n-- \u53e6\u4e00\u79cd\u5b9e\u73b0\nmap (chr . (+ shift) . ord) msg.\n-- \u5b9e\u4f8b\u4ee3\u7801\nghci> encode 3 "Heeeeey"\n"Khhhhh|"\nghci> encode 4 "Heeeeey"\n"Liiiii}"\nghci> encode 1 "abcd"\n"bcde"\nghci> encode 5 "Marry Christmas! Ho ho ho!"\n"Rfww~%Hmwnxyrfx&%Mt%mt%mt&"\n')))),(0,l.kt)("h3",{id:"64-datamap"},"6.4 Data.Map"),(0,l.kt)("p",null,"\u4e0b\u9762\u7ed9\u51fa\u4e86\u51e0\u79cd\u5199 map \u7684\u65b9\u6cd5"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'-- \u7b2c\u4e00\u79cd filter \u5b9e\u73b0\nfindKey :: (Eq k) => k -> [(k, v)] -> v\nfindKey key xs = (snd . head . filter (\\ (k, v) -> key == k)) xs\n\n-- \u7b2c\u4e8c\u79cd Maybe \u975e\u7a7a\u6821\u9a8c\nfindKey :: (Eq k) => k -> [(k, v)] -> Maybe v\nfindKey _ [] = Nothing\nfindKey key ((k, v):xs) = if k == key\n                                                        then Just v\n                                                        else findKey key xs\n\n-- \u7b2c\u4e09\u79cd \u4f7f\u7528 foldr \u800c\u975e\u9012\u5f52\uff0c\u56e0\u4e3a\u6bd4\u9012\u5f52\u7684\u53ef\u8bfb\u6027\u66f4\u597d\n-- Note: It\'s usually better to use folds for this standard list recursion pattern instead of explicitly writing the recursion because they\'re easier to read and identify. Everyone knows it\'s a fold when they see the foldr call, but it takes some more thinking to read explicit recursion.\nfindKey :: (Eq k) => k -> [(k,v)] -> Maybe v\nfindKey key xs = foldr (\\(k,v) acc -> if key == k then Just v else acc) Nothing xs\n\nmain :: IO ()\nmain = do\n        let phoneBook =\n                [("aaa","111")\n                ,("bbb","222")\n                ,("ccc","333")\n                ]\n        print $ findKey "bbb" phoneBook\n')),(0,l.kt)("p",null,"\u4e0b\u9762\u662f\u4e00\u5806\u51fd\u6570"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"fromList"),(0,l.kt)("p",{parentName:"li"},"\u521b\u5efa\u4e00\u4e2a Map"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Map.fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]\nfromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]\nghci> Map.fromList [(1,2),(3,4),(3,2),(5,5)]\nfromList [(1,2),(3,2),(5,5)]\n')),(0,l.kt)("p",{parentName:"li"},"\u81ea\u5df1\u5b9e\u73b0"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- We can implement our own fromList by using the empty map, insert and a fold. Watch:\n\nfromList' :: (Ord k) => [(k,v)] -> Map.Map k v\nfromList' = foldr (\\(k,v) acc -> Map.insert k v acc) Map.empty\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"empty"),(0,l.kt)("p",{parentName:"li"},"\u8fd4\u56de\u4e00\u4e2a\u7a7a Map"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.empty\xa0\nfromList [] \xa0\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"insert"),(0,l.kt)("p",{parentName:"li"},"\u63d2\u5165\u4e00\u5bf9 k\uff0cv"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.empty\nfromList []\nghci> Map.insert 3 100 Map.empty\nfromList [(3,100)]\nghci> Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty))\nfromList [(3,100),(4,200),(5,600)]\nghci> Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty\nfromList [(3,100),(4,200),(5,600)]\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"null"),(0,l.kt)("p",{parentName:"li"},"\u68c0\u67e5\u662f\u5426\u4e3a\u7a7a"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.null Map.empty\nTrue\nghci> Map.null $ Map.fromList [(2,3),(5,5)]\nFalse\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"size"),(0,l.kt)("p",{parentName:"li"},"\u8fd4\u56de map \u7684\u5927\u5c0f"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.size Map.empty\n0\nghci> Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]\n5\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"singleton"),(0,l.kt)("p",{parentName:"li"},"\u91cd\u5efa\u53ea\u6709\u4e00\u5bf9 kv \u7684 Map"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.singleton 3 9\nfromList [(3,9)]\nghci> Map.insert 5 9 $ Map.singleton 3 9\nfromList [(3,9),(5,9)]\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"lookup"),(0,l.kt)("p",{parentName:"li"},"\u5c31\u662f get"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"Prelude Map> Map.lookup 4 a\nJust 200\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"member"),(0,l.kt)("p",{parentName:"li"},"\u5c31\u662f in"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)]\nTrue\nghci> Map.member 3 $ Map.fromList [(2,5),(4,5)]\nFalse\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"map and filter"),(0,l.kt)("p",{parentName:"li"},"\u53ea\u4f5c\u7528\u4e8e v"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.map (*100) $ Map.fromList [(1,1),(2,4),(3,9)]\nfromList [(1,100),(2,400),(3,900)]\nghci> Map.filter isUpper $ Map.fromList [(1,'a'),(2,'A'),(3,'b'),(4,'B')]\nfromList [(2,'A'),(4,'B')]\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"toList"),(0,l.kt)("p",{parentName:"li"},"\u5982\u5176\u540d"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.toList . Map.insert 9 2 $ Map.singleton 4 3\n[(4,3),(9,2)]\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"keys and elems"),(0,l.kt)("p",{parentName:"li"},"\u8fd4\u56de keys \u548c values")),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"fromListWith"),(0,l.kt)("p",{parentName:"li"},"\u7c7b\u4f3c\u4e0e fromList\uff0c \u4e0d\u8fc7\u6709\u4e00\u4e2a\u51fd\u6570\u51b3\u5b9a\u91cd\u590d\u7684 key \u5e94\u8be5\u600e\u4e48\u529e"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'-- \u6709\u91cd\u590d\u7684\u952e\nphoneBook =\n    [("betty","555-2938")\n    ,("betty","342-2492")\n    ,("bonnie","452-2928")\n    ,("patsy","493-2928")\n    ,("patsy","943-2929")\n    ,("patsy","827-9162")\n    ,("lucille","205-2928")\n    ,("wendy","939-8282")\n    ,("penny","853-2492")\n    ,("penny","555-2111")\n]\n-- \u91cd\u590d\u7684\u952e\u7684\u503c\u4f1a\u88ab\u52a0\u4e00\u8d77\nphoneBookToMap :: (Ord k) => [(k, String)] -> Map.Map k String\nphoneBookToMap xs = Map.fromListWith (\\number1 number2 -> number1 ++ ", " ++ number2) xs\n\n-- \u67e5\u770b\nghci> Map.lookup "patsy" $ phoneBookToMap phoneBook\n"827-9162, 943-2929, 493-2928"\nghci> Map.lookup "wendy" $ phoneBookToMap phoneBook\n"939-8282"\nghci> Map.lookup "betty" $ phoneBookToMap phoneBook\n"342-2492, 555-2938"\n')),(0,l.kt)("p",{parentName:"li"},"\u4e0b\u9762\u662f\u53e6\u5916\u4e24\u4e2a\u4f8b\u5b50"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]\nfromList [(2,100),(3,29),(4,22)]\nghci> Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]\nfromList [(2,108),(3,62),(4,37)]\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"insertWith"),(0,l.kt)("p",{parentName:"li"},"\u5dee\u4e0d\u591a\uff0c \u6761\u4ef6\u63d2\u5165"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)]\nfromList [(3,104),(5,103),(6,339)]\n")))),(0,l.kt)("h3",{id:"65-dataset"},"6.5 Data.Set"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"fromList"),(0,l.kt)("p",{parentName:"li"},"\u53bb\u91cd"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'text1 = "I just had an anime dream. Anime... Reality... Are they so different?"\ntext2 = "The old man left his garbage can out and now his trash is all over my lawn!"\nghci> let set1 = Set.fromList text1\nghci> let set2 = Set.fromList text2\nghci> set1\nfromList " .?AIRadefhijlmnorstuy"\nghci> set2\nfromList " !Tabcdefghilmnorstuvwy"\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"intersection"),(0,l.kt)("p",{parentName:"li"},"\u6c42\u4ea4\u96c6"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Set.intersection set1 set2\nfromList " adefhilmnorstuy"\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"difference"),(0,l.kt)("p",{parentName:"li"},"\u6c42\u7b2c\u4e00\u4e2a\u96c6\u5408\u6709\u7b2c\u4e8c\u4e2a\u6ca1\u6709"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Set.difference set1 set2\nfromList ".?AIRj"\nghci> Set.difference set2 set1\nfromList "!Tbcgvw"\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"union"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Set.union set1 set2\nfromList " !.?AIRTabcdefghijlmnorstuvwy"\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u5176\u4ed6"),(0,l.kt)("p",{parentName:"li"},"null, size, member, empty, singleton, insert and delete \u5c31\u548c\u4f60\u60f3\u7684\u4e00\u6837"))),(0,l.kt)("h2",{id:"7-\u81ea\u5b9a\u4e49\u7c7b\u578b"},"7. \u81ea\u5b9a\u4e49\u7c7b\u578b"),(0,l.kt)("p",null,"\u4f7f\u7528 data \u5173\u952e\u5b57\u5b9a\u4e49"),(0,l.kt)("p",null,"\u7b49\u53f7\u5de6\u8fb9\u7684\u662f ",(0,l.kt)("strong",{parentName:"p"},"type name"),"\uff0c\u7b49\u597d\u53f3\u8fb9\u7684\u662f ",(0,l.kt)("strong",{parentName:"p"},"value constructors")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"data Bool = False | True\n")),(0,l.kt)("p",null,"Int \u7c7b\u578b\u53ef\u80fd\u6709\u4e0b\u9762\u7684\u5b9a\u4e49"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- \u771f\u5b9e\u4e0d\u662f\u8fd9\u6837\u7684\uff0c\u53ea\u662f\u4e3a\u4e86\u8bf4\u660e\u95ee\u9898\ndata Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647\n")),(0,l.kt)("h3",{id:"71-\u57fa\u672c\u7c7b\u578b\u5b9a\u4e49"},"7.1 \u57fa\u672c\u7c7b\u578b\u5b9a\u4e49"),(0,l.kt)("p",null,"\u4e0b\u9762\u8ba9\u6211\u4eec\u8fdb\u884c\u4e00\u4e2a\u5f62\u72b6\u7684\u5b9a\u4e49"),(0,l.kt)("p",null,"\u4e00\u4e2a\u5706\u7684\u5b9a\u4e49\u53ef\u80fd\u9700\u8981\u4e09\u4e2a\u53c2\u6570\uff0c\u524d\u4e24\u4e2a\u662f\u5706\u7684\u5750\u6807\uff0c\u7b2c\u4e09\u4e2a\u53c2\u6570\u662f\u534a\u5f84\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u60f3 ",(0,l.kt)("inlineCode",{parentName:"p"},"(43.1, 55.0, 10.4)"),"\u8fd9\u6837\u5b9a\u4e49\u4e00\u4e2a\u5706\uff0c\u4f46\u662f\u8fd9\u4e09\u4e2a\u53c2\u6570\u4e5f\u80fd\u8868\u793a\u4e00\u4e2a 3D vector \u6216\u8005\u662f\u522b\u7684\u4ec0\u4e48\u4e1c\u897f\uff0c\u6240\u4ee5\u6211\u4eec\u6700\u597d\u5b9a\u4e49\u4e00\u4e2a\u53eb\u505a Shape \u7684\u65b0\u7c7b\u578b"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"data Shape = Circle Float Float Float | Rectangle Float Float Float Float\n\nghci> :t Circle\nCircle :: Float -> Float -> Float -> Shape\nghci> :t Rectangle\nRectangle :: Float -> Float -> Float -> Float -> Shape\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"new \u4e00\u4e2a\u5b9e\u4f8b")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> Circle 10 20 5\nCircle 10.0 20.0 5.0\nghci> Rectangle 50 230 60 90\nRectangle 50.0 230.0 60.0 90.0\n")),(0,l.kt)("p",null,"type name \u548c value constructor \u9996\u5b57\u6bcd\u9700\u8981\u5927\u5199"),(0,l.kt)("p",null,"\u4e0b\u9762\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5b8c\u6574\u7684 Shape \u6a21\u5757"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- Shape(..) \u4f1a\u5c06\u6240\u6709\u7684\u6784\u9020\u5668\u66b4\u9732\u7ed9\u5916\u90e8\n-- \u7b49\u540c\u4e8e Shape (Rectangle, Circle)\nmodule Shapes\n( Point(..)\n, Shape(..)\n, surface\n, nudge\n, baseCircle\n, baseRect\n) where\n\n-- deriving (Show) \u81ea\u52a8\u5b9e\u73b0 Show\ndata Point = Point Float Float deriving (Show)\ndata Shape = Circle Point Float | Rectangle Point Point deriving (Show)\nsurface :: Shape -> Float\nsurface (Circle _ r) = pi * r ^ 2\nsurface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)\n\nnudge :: Shape -> Float -> Float -> Shape\nnudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r\nnudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))\n\nbaseCircle :: Float -> Shape\nbaseCircle r = Circle (Point 0 0) r\n\nbaseRect :: Float -> Float -> Shape\nbaseRect width height = Rectangle (Point 0 0) (Point width height)\n")),(0,l.kt)("p",null,"\u6211\u4eec\u4e5f\u53ef\u4ee5\u4e0d\u66b4\u9732 Shape\uff0c\u8ba9\u7528\u6237\u53ea\u80fd\u901a\u8fc7 baseCircle\uff0cbaseRect \u6784\u9020\uff0c\u8ba9\u6211\u4eec\u7684\u63a5\u53e3\u66f4\u52a0\u62bd\u8c61"),(0,l.kt)("h3",{id:"72-record-syntax-\u5b9a\u4e49\u7c7b\u578b"},"7.2 record syntax \u5b9a\u4e49\u7c7b\u578b"),(0,l.kt)("p",null,"\u7b2c\u4e00\u79cd\u65b9\u5f0f"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"data Person = Person String String Int Float String String deriving (Show)\nfirstName :: Person -> String\nfirstName (Person firstname _ _ _ _ _) = firstname\n\nlastName :: Person -> String\nlastName (Person _ lastname _ _ _ _) = lastname\n\nage :: Person -> Int\nage (Person _ _ age _ _ _) = age\n\nheight :: Person -> Float\nheight (Person _ _ _ height _ _) = height\n\nphoneNumber :: Person -> String\nphoneNumber (Person _ _ _ _ number _) = number\n\nflavor :: Person -> String\nflavor (Person _ _ _ _ _ flavor) = flavor\n")),(0,l.kt)("p",null,"\u4f7f\u7528 record syntax \u5b9a\u4e49 Person"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"data Person = Person { firstName :: String\n                     , lastName :: String\n                     , age :: Int\n                     , height :: Float\n                     , phoneNumber :: String\n                     , flavor :: String\n                     } deriving (Show)\n")),(0,l.kt)("p",null,"haskell \u4f1a\u81ea\u52a8\u751f\u6210\u4e0a\u9762\u7684\u51fd\u6570"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"ghci> :t flavor\nflavor :: Person -> String\nghci> :t firstName\nfirstName :: Person -> String\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"new \u4e00\u4e2a\u5b9e\u4f8b")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> Car {company="Ford", model="Mustang", year=1967}\nCar {company = "Ford", model = "Mustang", year = 1967}\n')),(0,l.kt)("h3",{id:"73-\u7c7b\u578b\u53c2\u6570"},"7.3 \u7c7b\u578b\u53c2\u6570"),(0,l.kt)("h4",{id:"731-maybe"},"7.3.1 Maybe"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"data Maybe a = Nothing | Just a\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"\u7c7b\u578b\u6784\u9020\u5668")),(0,l.kt)("p",null,"a \u662f\u4e00\u4e2a\u7c7b\u578b\u53c2\u6570\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u7c7b\u578b a\uff0c\u6240\u4ee5\u6211\u4eec\u79f0 Maybe \u662f\u4e00\u4e2a type constructor\uff08\u7c7b\u578b\u6784\u9020\u5668\uff09\uff08\u6ce8\u610f\uff1a\u548c\u4e4b\u524d\u7684 value constructor \u4e0d\u4e00\u6837\uff09\uff0c\u6240\u4ee5 Maybe \u4e0d\u662f\u4e00\u4e2a\u7c7b\u578b"),(0,l.kt)("p",null,"\u6211\u4eec\u80fd\u591f\u4f20\u5165 Char \u6216\u8005 Int\uff0c\u5c31\u80fd\u7684\u5230\u4e00\u4e2a Maybe Char \u6216\u8005 Maybe Int \u7c7b\u578b"),(0,l.kt)("h4",{id:"732-car"},"7.3.2 Car"),(0,l.kt)("p",null,"\u4e0b\u9762\u4e3e\u4e86\u4e00\u4e2a Car \u7684\u4f8b\u5b50\uff0c\u4ed6\u5c31\u53ef\u80fd\u662f (Car String String Int) \u7c7b\u578b"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"    data Car a b c = Car { company :: a\n                         , model :: b\n                         , year :: c\n                         } deriving (Show)\n")),(0,l.kt)("p",null,"\u4f46\u662f\u7528\u8fd9\u79cd\u5f62\u5f0f\u58f0\u660e\u5e76\u6ca1\u6709\u592a\u591a\u597d\u5904\uff0c\u5927\u90e8\u5206\u60c5\u51b5\u4e0b\u6211\u4eec\u53ea\u9700\u8981\u4e00\u79cd\u72b6\u6001 ",(0,l.kt)("inlineCode",{parentName:"p"},"Car String String Int")," \u5c31\u591f\u4e86"),(0,l.kt)("p",null,"\u6240\u4ee5\u6211\u4eec\u4f1a\u7528\u4e0b\u9762\u7684\u65b9\u5f0f"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'data Car = Car { company :: String\n               , model :: String\n               , year :: Int\n               } deriving (Show)\ntellCar :: Car -> String\ntellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y\n')),(0,l.kt)("p",null,"\u6211\u4eec\u4e4b\u524d\u4e5f\u89c1\u8fc7\u4e00\u4e2a\u4f7f\u7528\u7c7b\u578b\u53c2\u6570\u7684\u4f8b\u5b50\uff0c\u5c31\u662f Map\uff0ck\uff0cv \u5206\u522b\u662f key \u548c value \u7684\u7c7b\u578b"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"data (Ord k) => Map k v = ...\n")),(0,l.kt)("h4",{id:"733-vector"},"7.3.3 Vector"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"data Vector2 a = Vector2 [a] [a] [a] deriving (Show)\nvplus :: (Char t) => Vector2 t -> Vector2 t -> Vector2 t\n(Vector2 a1 a2 a3) `vplus` (Vector2 b1 b2 b3) = Vector2 a1++b1 a2++b2 a3++b3\n")),(0,l.kt)("h3",{id:"74-\u6d3e\u751f\u5b9e\u4f8b"},"7.4 \u6d3e\u751f\u5b9e\u4f8b"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Derived instances")),(0,l.kt)("h4",{id:"741-derive"},"7.4.1 derive"),(0,l.kt)("p",null,"Typeclasses \u66f4\u50cf\u662f\u63a5\u53e3\uff0c\u6211\u4eec\u4f7f\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},"derive")," \u5173\u952e\u5b57\u53ef\u4ee5\u81ea\u52a8\u6d3e\u751f\u51fa\u884c\u4e3a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"    data Person = Person { firstName :: String\n                         , lastName :: String\n                         , age :: Int\n                         } deriving (Eq, Show, Read)\n")),(0,l.kt)("p",null,"\u8be5\u7c7b\u578b\u6d3e\u751f\u81ea Eq\uff0c\u6240\u4ee5\u5b9e\u73b0\u4e86 ",(0,l.kt)("inlineCode",{parentName:"p"},"==")," \u548c ",(0,l.kt)("inlineCode",{parentName:"p"},"/="),", \u8fd8\u80fd\u591f\u5e94\u7528\u5728\u4efb\u4f55\u5728\u7c7b\u578b\u7b7e\u540d\u4e0a\u5177\u6709 ",(0,l.kt)("inlineCode",{parentName:"p"},"Eq a")," \u7684\u51fd\u6570"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}\nghci> let adRock = Person {firstName = "Adam", lastName = "Horovitz", age = 41}\nghci> let mca = Person {firstName = "Adam", lastName = "Yauch", age = 44}\nghci> mca == adRock\nFalse\nghci> mikeD == Person {firstName = "Michael", lastName = "Diamond", age = 43}\nTrue\n')),(0,l.kt)("p",null,"Read \u548c Show \u80fd\u5b9e\u73b0\u7c7b\u578b\u548c\u5b57\u7b26\u4e32\u95f4\u7684\u76f8\u4e92\u8f6c\u5316\uff0c\u5f53\u6211\u4eec\u4f7f\u7528 Read \u65f6\uff0c\u9700\u8981\u6307\u5b9a\u7ed3\u679c\u7684\u7c7b\u578b"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'ghci> read "Person {firstName =\\"Michael\\", lastName =\\"Diamond\\", age = 43}" :: Person\nPerson {firstName = "Michael", lastName = "Diamond", age = 43}\n')),(0,l.kt)("p",null,"\u5076\u4eec\u4e5f\u80fd\u591f\u8bfb\u53d6\u53c2\u6570\u5316\u7c7b\u578b\uff08parameterized types\uff09\uff0c\u4f46\u662f\u5fc5\u987b\u586b\u4e0a\u7c7b\u578b"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- So we can't do\nread \"Just 't'\" :: Maybe a\n-- but we can do\nread \"Just 't'\" :: Maybe Char\n")),(0,l.kt)("h4",{id:"742-\u5b9e\u73b0\u4e00\u4e9b-typeclasses"},"7.4.2 \u5b9e\u73b0\u4e00\u4e9b Typeclasses"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Ord \u7684\u6bd4\u8f83\u89c4\u5219\uff0c\u5728\u524d\u9762\u7684\u6bd4\u8f83\u5c0f\uff0c\u4e0e Char \u6bd4\u8f83\u65e0\u5173"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum)\n\nghci> Saturday > Friday\nTrue\n")))),(0,l.kt)("h4",{id:"743-\u7c7b\u578b\u540c\u4e49\u8bcd"},"7.4.3 \u7c7b\u578b\u540c\u4e49\u8bcd"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Type synonyms")),(0,l.kt)("p",null,"\u5c31\u662f\u6362\u4e2a\u540d\u800c\u5df2"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- \u4e0b\u9762\u662f String \u7684\u5b9a\u4e49\ntype String = [Char]\n\ntype IntMap v = Map Int v\ntype IntMap = Map Int\n")),(0,l.kt)("p",null,"\u9700\u8981\u5206\u6e05\u7c7b\u578b\u6784\u9020\u5668\u548c\u503c\u6784\u9020\u5668\uff08type constructors and value constructors\uff09\u7684\u533a\u522b"),(0,l.kt)("h4",{id:"744-either"},"7.4.4 Either"),(0,l.kt)("p",null,"\u4e0b\u9762\u6211\u4eec\u5728\u4ecb\u7ecd\u4e00\u79cd\u7c7b\u578b Either"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- \u5b9a\u4e49\ndata Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"So far, we've seen that Maybe a was mostly used to represent the results of computations that could have either failed or not. But somtimes, Maybe a isn't good enough because Nothing doesn't really convey much information other than that something has  failed. That's cool for functions that can fail in only one way or if  we're just not interested in how and why they failed. A Data.Map lookup fails only if the key we were looking for wasn't in the map, so  we know exactly what happened. However, when we're interested in how  some function failed or why, we usually use the result type of Either a b, where a is some sort of type that can tell us something about the possible failure and b is the type of a successful computation. Hence, errors use the Left value constructor while results use Right.")),(0,l.kt)("p",null,"Maybe \u4e0d\u80fd\u6ee1\u8db3\u6240\u6709\u7684\u9700\u8981\uff0cEither \u901a\u5e38\u7528\u4e8e\u9519\u8bef\u5904\u7406\uff0c\u5de6\u503c\u4e00\u822c\u8868\u793a\u9519\u8bef\u539f\u56e0\uff0c\u53f3\u503c\u4e00\u822c\u662f\u6b63\u786e\u7684\u7ed3\u679c"),(0,l.kt)("p",null,"\u4e0b\u9762\u7ed9\u9664\u4e86\u4e00\u4e2a\u4f8b\u5b50"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'import qualified Data.Map as Map\n\n-- declear LockerMap\ndata LockerState = Taken | Free deriving (Show, Eq)\ntype Code = String\ntype LockerMap = Map.Map Int (LockerState, Code)\n\n-- give a LoockerLookUp function\nlockerLookUp :: Int -> LockerMap -> Either String Code\nlockerLookUp lockerNum map = case Map.lookup lockerNum map of\n        Nothing  -> Left $ "Locker Number" ++ show lockerNum ++ "doesn\'t exist"\n        Just (lockerState, code) -> if lockerState == Taken\n                                 then Left $ "Locker Number" ++ show lockerNum ++ "is already taken!"\n                                 else Right code\n\nmain = do\n    let lockers = Map.fromList[(1, (Taken, "aaa")),(2, (Free, "bbb")),(3, (Taken, "ccc"))]\n    print $ lockerLookUp 1 lockers\n    print $ lockerLookUp 2 lockers\n    print $ lockerLookUp 3 lockers\n    print $ lockerLookUp 4 lockers\n\n')),(0,l.kt)("h4",{id:"745-\u9012\u5f52"},"7.4.5 \u9012\u5f52"),(0,l.kt)("p",null,"\u4e0b\u9762\u7684\u4f8b\u5b50\u5b9e\u73b0\u4e86\u4e00\u4e2a List \u548c\u4e00\u4e2a Tree"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'infixr 5 :-:\ndata List a = Empty | a :-: (List a) deriving (Show, Read, Ord, Eq)\n-- \u6216\u8005\u662f record syntex\n-- data Lsit = Empty | Cons {listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)\n\n-- infixr 5 ++\n-- (++) :: [a] -> [a] -> [a]\n-- [] ++ ys = ys\n-- (x:xs) ++ ys = x:(xs ++ ys)\ninfixr 5 .++\n(.++) :: List a -> List a -> List a\nEmpty .++ ys = ys\n(x :-: xs) .++ ys = x :-: (xs .++ ys)\n\ndata Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq, Ord)\n\nsingleton :: a -> Tree a\nsingleton x = Node x EmptyTree EmptyTree\n\ntreeInsert :: (Ord a) => a -> Tree a -> Tree a\ntreeInsert x EmptyTree = singleton x\ntreeInsert x (Node a left right)\n    | x == a = Node x left right\n    | x  < a = Node a (treeInsert x left) right\n    | x  > a = Node a left (treeInsert x right)\n\ntreeElem :: (Ord) a => a -> Tree a -> Bool\ntreeElem x EmptyTree = False\ntreeElem x (Node a left right)\n    | x == a = True\n    | x < a = treeElem x left\n    | x > a = treeElem x right\n\n\nmain = do\n    putStrLn "start..."\n    let a = 3 :-: 4 :-: 5 :-: Empty\n    print a\n    let b = 6 :-: 7 :-: Empty\n    print(a .++ b)\n    let nums = [8, 6, 4, 1, 3, 5]\n    let numsTree = foldr treeInsert EmptyTree nums\n    print numsTree\n    print $ treeElem 4 numsTree\n    putStrLn "end..."\n\n')),(0,l.kt)("h4",{id:"746-typeclasses-102"},"7.4.6 Typeclasses 102"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"A quick recap on typeclasses: typeclasses are like interfaces. A  typeclass defines some behavior (like comparing for equality, comparing  for ordering, enumeration) and then types that can behave in that way  are made instances of that typeclass. The behavior of typeclasses is  achieved by defining functions or just type declarations that we then  implement. So when we say that a type is an instance of a typeclass, we  mean that we can use the functions that the typeclass defines with that  type.")),(0,l.kt)("p",null,"\u5bf9 typeclasses \u7684\u7b80\u8981\u56de\u987e\uff1atypeclasses \u5c31\u50cf\u63a5\u53e3\u3002\u4e00\u4e2a typeclasses \u5b9a\u4e49\u4e86\u4e00\u4e9b\u884c\u4e3a\uff08\u6bd4\u5982\u6bd4\u8f83\uff0c\u6392\u5e8f\uff09\uff0c\u53ef\u4ee5\u5b9e\u73b0\u8fd9\u4e9b\u884c\u4e3a\u7684\u7c7b\u578b\u5c31\u662f\u8fd9\u4e9b typeclass \u7684\u5b9e\u4f8b\uff0c\u901a\u8fc7\u5b9a\u4e49\u51fd\u6570\u6216\u8005\u58f0\u660e\u53bb\u5b9e\u73b0\u8fd9\u4e9b\u884c\u4e3a\uff0c\u56e0\u6b64\uff0c\u5f53\u6211\u4eec\u8bf4\u7c7b\u578b\u662f\u7c7b\u578b\u7684\u4e00\u4e2a\u7c7b\u578b\u7684\u5b9e\u4f8b\u65f6\uff0c\u6211\u4eec\u7684\u610f\u601d\u662f\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 TypeClass \u5b9a\u4e49\u8be5\u7c7b\u578b\u7684\u51fd\u6570\u3002"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- \u4f7f\u7528 :info Num \u53ef\u4ee5\u67e5\u770b typeclass \u5b9a\u4e49\nPrelude> :info Num\ntype Num :: * -> Constraint\nclass Num a where\n  (+) :: a -> a -> a\n  (-) :: a -> a -> a\n  (*) :: a -> a -> a\n  negate :: a -> a\n  abs :: a -> a\n  signum :: a -> a\n  fromInteger :: Integer -> a\n  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}\n        -- Defined in \u2018GHC.Num\u2019\ninstance Num Word -- Defined in \u2018GHC.Num\u2019\ninstance Num Integer -- Defined in \u2018GHC.Num\u2019\ninstance Num Int -- Defined in \u2018GHC.Num\u2019\ninstance Num Float -- Defined in \u2018GHC.Float\u2019\ninstance Num Double -- Defined in \u2018GHC.Float\u2019\n\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"1. \u5b9a\u4e49 typeclasses")),(0,l.kt)("p",null,"\u4e0b\u9762\u662f Eq \u5728\u6807\u51c6\u5e93\u7684\u5b9a\u4e49"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"class Eq a where\n    (==) :: a -> a -> Bool\n    (/=) :: a -> a -> Bool\n    x == y = not (x /= y)\n    x /= y = not (x == y)\n")),(0,l.kt)("p",null,"class \u5b9a\u4e49\u4e86\u4e00\u4e2a typeclass\uff0cEq \u662f\u540d\u5b57\uff0ca \u662f\u5b9e\u4f8b\uff0ca \u53ea\u8981\u662f\u4e00\u4e2a\u5c0f\u5199\u7684\u5355\u8bcd\u5c31\u884c"),(0,l.kt)("p",null,"\u63a5\u7740\u6211\u4eec\u5b9a\u4e49\u4e86\u4e00\u4e9b\u51fd\u6570\uff0c\u5728 class \u91cc\u5b9e\u73b0\u51fd\u6570\u4e0d\u662f\u5f3a\u5236\u7684\uff0c\u53ea\u9700\u8981\u4e00\u4e2a\u5b9a\u4e49\u5c31\u591f\u4e86"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Some people might understand this better if we wrote class Eq equatable where and then specified the type declarations like ",(0,l.kt)("inlineCode",{parentName:"p"},"(==) :: equatable -> equatable -> Bool"),"."),(0,l.kt)("p",{parentName:"blockquote"},"\u8fd9\u79cd\u5199\u6cd5\u53ef\u80fd\u66f4\u597d\u7406\u89e3\uff1a",(0,l.kt)("inlineCode",{parentName:"p"},"(==) :: equatable -> equatable -> Bool"))),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"If we have say class Eq a where and then define a type declaration within that class like (==) :: a -> -a -> Bool, then when we examine the type of that function later on, it will have the type of ",(0,l.kt)("inlineCode",{parentName:"p"},"(Eq a) => a -> a -> Bool"),"."),(0,l.kt)("p",{parentName:"blockquote"},"\u5f53\u6211\u4eec\u5728 class \u4e2d\u5b9a\u4e49\u8fd9\u4e2a\u51fd\u6570\u540e\uff0c\u5728\u67e5\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u7c7b\u578b\u65f6\uff0c\u5c31\u4f1a\u663e\u793a\u51fa typeclasses")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"2. \u5b9e\u73b0 typeclass")),(0,l.kt)("p",null,"\u4e0b\u9762\u6211\u4eec\u5b9e\u73b0\u4e00\u4e2a ",(0,l.kt)("inlineCode",{parentName:"p"},"TrafficLight")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'data TrafficLight = Red | Yellow | Green\n-- \u5b9e\u73b0\u6bd4\u8f83\ninstance Eq TrafficLight where\n    Red == Red = True\n    Green == Green = True\n    Yellow == Yellow = True\n    _ == _ = False\n-- \u624b\u52a8\u5b9e\u73b0\u5b57\u7b26\u4e32\u8f6c\u6362\ninstance Show TrafficLight where\n    show Red = "Red light"\n    show Yellow = "Yellow light"\n    show Green = "Green light"\nmain = do\n    putStrLn "start..."\n    print $ Red == Red\n    print $ show [Red, Yellow, Green]\n')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"3. subtypeclasses")),(0,l.kt)("p",null,"\u4e0b\u9762\u662f Num \u5728\u6807\u51c6\u5e93\u4e2d\u7684\u5b9a\u4e49\uff08\u7b2c\u4e00\u884c\uff09"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"class (Eq a) => Num a where\n")),(0,l.kt)("p",null,"\u5728\u5b9e\u73b0 Num \u524d\uff0c\u5fc5\u987b\u4fdd\u8bc1 a \u5b9e\u73b0\u4e86 Eq"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"\u5bf9\u4e8e\u591a\u6001\u7c7b\u578b")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Eq (Maybe m) where\n    Just x == Just y = x == y\n    Nothing == Nothing = True\n    _ == _ = False\n\n")),(0,l.kt)("p",null,"\u4e0a\u9762\u7684\u4f8b\u5b50\u597d\u50cf\u89e3\u51b3\u4e86\u95ee\u9898\uff0c\u4f46\u662f\u4e0d\u80fd\u786e\u5b9a m \u7684\u7c7b\u578b\u5b9e\u73b0\u4e86 Eq\uff0c\u6240\u4ee5\u6211\u4eec\u5e94\u8be5\u4fee\u6539\u4e0a\u9762\u7684\u58f0\u660e\uff1a"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"instance (Eq m) => Eq (Maybe m) where\n    Just x == Just y = x == y\n    Nothing == Nothing = True\n    _ == _ = False\n")),(0,l.kt)("p",null,"\u8fd9\u6b21\u6211\u4eec\u589e\u52a0\u4e86\u4e00\u4e2a\u7c7b\u578b\u9650\u5b9a\uff0c\u6211\u4eec\u9650\u5b9a\u4e86\u6240\u6709 Maybe m \u7c7b\u578b\u90fd\u662f Eq\uff0c\u9664\u975e m \u4e5f\u662f Eq"),(0,l.kt)("p",null,"\ud83c\udf4f"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Take into account that the type you're trying to make an instance of will replace the parameter in the ",(0,l.kt)("em",{parentName:"p"},"class")," declaration. The a from class Eq a where will be replaced with a real type when you make an instance, so try  mentally putting your type into the function type declarations as well. (==) :: Maybe -> Maybe -> Bool doesn't make much sense but (==) :: (Eq m) => Maybe m -> Maybe m -> Bool does. But this is just something to think about, because == will always have a type of (==) :: (Eq a) => a -> a -> Bool, no matter what instances we make."),(0,l.kt)("p",{parentName:"blockquote"},"\u4e00\u5b9a\u8981 \u6ce8\u610f 'a' \u5728\u5b9e\u73b0\u65f6\u9700\u8981\u88ab\u66ff\u6362\u4e3a concrete type")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"4. \u5b9e\u73b0\u4e00\u4e2a\u73a9\u5177")),(0,l.kt)("p",null,"\u5728 js \u4e2d\uff0c\u4efb\u4f55\u975e\u7a7a\u7c7b\u578b\u90fd\u88ab\u5f53\u6210\u662f true"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},'if (0) alert("YEAH!") else alert("NO!")\nif ("") alert ("YEAH!") else alert("NO!")\nif (false) alert("YEAH") else alert("NO!)\n//etc. and all of these will throw an alert of NO!. If you do\nif ("WHAT") alert ("YEAH") else alert("NO!")\n// it will alert a "YEAH!"\n')),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"A yesno typeclass")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'class YesNo a where\n    yesno :: a -> Bool\n\ninstance YesNo Int where\n    yesno 0 = False\n    yesno _ = True\n\ninstance YesNo [a] where\n    yesno [] = False\n    yesno _ = True\n\n-- Bool \u4e5f\u4e0d\u8981\u5fd8\u4e86\ninstance YesNo Bool where\n    yesno = id\n\n-- \u56e0\u4e3a\u6211\u4eec\u5e76\u4e0d\u5173\u5fc3 Maybe \u5305\u542b\u4ec0\u4e48\u7c7b\u578b\uff0c\u53ea\u8981\u4ed6\u6709\u4e1c\u897f\u5c31\u884c\u4e86\uff0c\u6240\u4ee5\u6ca1\u6709\u52a0\u7c7b\u578b\u9650\u5b9a\ninstance YesNo (Maybe a) where\n    yesno (Just _) = True\n    yesno Nothing = False\n\n-- \u4eff\u7167\u7740\u5199\u4e00\u4e2a if\nyesnoIf :: (YesNo a) => a -> b -> b -> b\nyesnoIf a onyes onno = if yesno a then onyes else onno\n\nmain :: IO ()\nmain = do\n    putStrLn "start..."\n    print $ length []\n    print $ yesno [0]\n    print $ yesno Nothing\n    print $ yesno True\n    putStrLn $ yesnoIf (Just 1) "yes !" "No -_-"\n\n')),(0,l.kt)("h4",{id:"747-functor-\u548c-kinds"},"7.4.7 Functor \u548c Kinds"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"1. \u4ec0\u4e48\u662f Kind")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"We used :k on a type to get its kind, just like we can use :t on a value to get its type. Like we said, types are the labels of  values and kinds are the labels of types and there are parallels between the two.")),(0,l.kt)("p",null,"\u6211\u4eec\u80fd\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},":t")," \u67e5\u770b\u4e00\u4e2a\u503c (value) \u7684\u7c7b\u578b (type)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"-- '=>'\u662f\u7c7b\u578b\u9650\u5b9a !!!\nPrelude> :t 1\n1 :: Num p => p\n\nPrelude> :t [1, 2]\n[1, 2] :: Num a => [a]\n\nPrelude> :t Just 1\nJust 1 :: Num a => Maybe a\n")),(0,l.kt)("p",null,"\u4e5f\u80fd\u7528 ",(0,l.kt)("inlineCode",{parentName:"p"},":k")," \u67e5\u770b\u4e00\u4e2a\u7c7b\u578b (type) \u7684 Kind"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"Prelude> :k Int\nInt :: *\n\nPrelude> :k Num\nNum :: * -> Constraint\n\nPrelude> :k Maybe\nMaybe :: * -> *\n\nPrelude> :k Either\nEither :: * -> * -> *\n\nPrelude> :k Functor\nFunctor :: (* -> *) -> Constraint\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"'*' \u662f\u4ec0\u4e48")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"A ",(0,l.kt)("em",{parentName:"p"}," means that the type is a concrete type. A concrete type is a type that doesn't take any type parameters and  values can only have types that are concrete types. If I had to read ")," out loud (I haven't had to do that so far), I'd say ",(0,l.kt)("em",{parentName:"p"},"star")," or just ",(0,l.kt)("em",{parentName:"p"},"type"),".")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"*")," \u5c31\u662f\u4e00\u4e2a\u56fa\u5b9a\u7684\u7c7b\u578b\uff0c\u4e0d\u80fd\u643a\u5e26 Type parameter"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"* -> *")," \u5c31\u662f\u63a5\u53d7\u4e00\u4e2a type parameter\uff0c\u8fd4\u56de\u4e00\u4e2a\u7c7b\u578b\uff0c\u6bd4\u5982 Maybe \u548c Maybe Int"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"* -> * -> *")," \u540c\u7406"),(0,l.kt)("p",null,"\u6240\u4ee5 Functor \u7684\u7c7b\u578b\u5c31\u597d\u7406\u89e3\u4e86"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"class Functor f where\n    fmap :: (a -> b) -> f a -> f b\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"2. \u4ec0\u4e48\u662f Functor")),(0,l.kt)("p",null,"\u770b\u4e00\u773c fmap \u7684\u5b9a\u4e49\uff0c\u5b9e\u73b0\u4e86 Functor \u7684\u7c7b\u578b\uff0cfmap \u80fd\u591f\u628a\u8fd9\u4e9b\u7c7b\u578b",(0,l.kt)("em",{parentName:"p"},"\u91cc\u9762"),"\u7684\u4e1c\u897f\u8f6c\u6362\u5230\u53e6\u4e00\u79cd\u4e1c\u897f\uff0c\u5c31\u662f\u8bf4 fmap \u53ea\u4f5c\u7528\u4e8e box \u91cc\u9762\u7684\u4e1c\u897f"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"class Functor f where\n    fmap :: (a -> b) -> f a -> f b\n")),(0,l.kt)("p",null,"\u8fd9\u4e2a\u662f map \u7684\u5b9a\u4e49"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"map :: (a -> b) -> [a] -> [b]\n")),(0,l.kt)("p",null,"map \u5c31\u662f\u7279\u6b8a\u5316\u7684 fmap ,\u53ea\u80fd\u7528\u4e8e [],\u4e0d\u80fd\u7528\u4e8e Maybe, Ehther \u7b49\u7c7b\u578b"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"anything like a box that can hold something can impl Functor, lsuch as Maybe, [], Tree = Empty | Tree a left rght, Either")),(0,l.kt)("p",null,"\u6240\u6709\u80fd\u591f\u627f\u8f7d\u5176\u4ed6\u7c7b\u578b\u7684\u4e1c\u897f\u90fd\u80fd\u5b9e\u73b0 Functor\uff0c\u6bd4\u5982 Maybe, [], Tree, Either"),(0,l.kt)("p",null,"\u4e0b\u9762\u662f\u5173\u4e8e Either \u7684 Functor \u5b9e\u73b0"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Functor (Either a) where\n    fmap f (Right x) = Right (f x)\n    fmap f (Left x) = Left x\n-- (b -> c) -> Either a b -> Ether a c\n-- \u548c\u4e0b\u9762\u7684\u4e00\u6837\n-- (b -> c) -> (Either a) b -> (Either a) c\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"-- in this case, we only mapped the right value constructor,\n-- well, if we look at the define of Either:\n-- data Either a b = Left a | Right b\n-- we can't make sure f can handle both type a and type b\n-- Another example is Map.Map, where fmap just map a function v -> v' over a Map k v, and return Map k v'")),(0,l.kt)("p",null,"\u5728\u8fd9\u4e2a\u4f8b\u5b50\u91cc\uff0c\u6211\u4eec\u53ea map \u4e86 Either \u7684\u53f3\u503c\uff0c\u56e0\u4e3a\u4e0d\u80fd\u4fdd\u8bc1 Either a b \u7684\u7c7b\u578b\u76f8\u540c\uff0cMap.Map \u4e5f\u662f\uff0c\u53ea\u6709 value \u6539\u53d8"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"3. \u5b9e\u73b0\u4e00\u4e2a Tofu")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"class Tofu t where\n    tofu :: j a -> t a j\n\ndata Frank a b = Frank {frankField :: b a} deriving (Show)\n\ninstance Tofu Frank where\n    tofu x = Frank x\n\ndata Barry t k p = Barry { yabba :: p, dabba :: t k }\n\ninstance Functor (Barry a b) where\n    fmap f (Barry { yabba = x, dabba = y }) = Barry {yabba = f x, dabba = y }\n\nmain :: IO ()\nmain = do\n    let a = Frank { frankField = Just 'c' }\n    print a\n    let b = tofu (Just 'a') :: Frank Char Maybe\n    print b\n    let c = tofu [\"Hello\"] :: Frank [Char] []\n    print c\n    putStrLn \"start...\"\n")),(0,l.kt)("h2",{id:"8-io"},"8. IO"),(0,l.kt)("h3",{id:"81-cmd-\u53c2\u6570"},"8.1 cmd \u53c2\u6570"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"import System.Environment\nimport Data.List\n\nmain = do\n    -- \u83b7\u53d6\u53c2\u6570\n    args <- getArgs\n    -- \u83b7\u53d6\u540d\u5b57\n    progName <- getProgName\n    putStrLn progName\n    mapM_ putStrLn args\n\n")),(0,l.kt)("h3",{id:"82-\u8f93\u5165"},"8.2 \u8f93\u5165"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u83b7\u53d6\u8f93\u5165"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'main = do\n    putStrLn "start..."\n    -- \u83b7\u53d6\u8f93\u5165\u6570\u636e\n    line <- getLine\n    -- \u5224\u65ad\u4e0d\u4e3a\u7a7a\u5c31\u53cd\u8f6c\n    if null line\n        then return ()\n        else do\n            putStrLn $ reverseWords line\n            main\nreverseWords :: String -> String\nreverseWords = unwords . map reverse . words\n'))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"\u6587\u4ef6\u4ea4\u4e92"))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"openFile (fileName, openMode): \u6253\u5f00\u6587\u4ef6\u8fd4\u56de handle \u5bf9\u8c61"),(0,l.kt)("li",{parentName:"ul"},"hGetContents (handle)\uff1a\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9"),(0,l.kt)("li",{parentName:"ul"},"with \u8bed\u6cd5"),(0,l.kt)("li",{parentName:"ul"},"appendFile(fileName, content)\uff1a\u8ffd\u52a0\u5185\u5bb9"),(0,l.kt)("li",{parentName:"ul"},"readBuffer: \u8bbe\u7f6e\u7f13\u51b2\u533a")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'import System.IO\n\nmain = do\n    handle <- openFile "haiku.txt" ReadMode\n    -- Lazy, don\'t read and stored in memory an once\n    contents <- hGetContents handle\n    putStrLn contents\n    hClose handle\n\n    withFile "haiku.txt" ReadMode (\\handle -> do\n    contents <- hGetContents handle\n    putStrLn contents)\n\n    -- withOpen\'s define\n    -- openFle :: FilePath -> IOMode -> (Handle -> IO a) -> IO a\n    -- openFile path mode f = do\n    --     handle <- openFile path mode\n    --     result <- f handle\n    --     hClose f\n    --     return result\n\n    -- More function\n    -- hGetLine hPutStr hPutStrLn hGetChar\n    contents <- readFile "todo.txt"\n    putStrLn contents\n\n    todo <- getLine\n    appendFile "todo.txt" $ todo ++ "\\n"\n\n    -- set buffering manualy\n    -- BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)\n    withFile "todo.txt" ReadMode (\\handle -> do\n        hSetBuffering handle $ BlockBuffering (Just 2)\n        contents <- hGetContents handle\n        putStrLn contents)\n    -- read file in big chunks can help to minimize disk access or when our file is actually a slow network resource\n')),(0,l.kt)("h3",{id:"83-\u5faa\u73af"},"8.3. \u5faa\u73af"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"forever(loop)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'import Control.Monad\nimport Data.Char\n\nmain = forever $ do\n    putStr "Give a input: "\n    l <- getLine\n    putStrLn $ map toUpper l\n')),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},"when(while)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"import Control.Monad\n\nmain = do\n  return ()\n  -- aaa <- return \"aaavvv\"\n  -- putStrLn aaa\n\n  c <- getChar\n  when (c /= ' ') $ do\n    putChar c\n    main\n")),(0,l.kt)("h3",{id:"84-map-io-action"},"8.4 map IO action"),(0,l.kt)("p",null,"mapM & mapM_ & sequence"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"main = do\n  -- 1.1 sequence can run erery IO action in it, and return their result as a list\n  -- rs <- sequence [getLine, getLine, getLine]\n  -- print rs\n\n  -- 1.2\n  -- map print [1, 2, 3]\n  -- [print 1, print 2, print 3]\n  res <- sequence $ map print [1, 2, 3]\n  -- `print 1` just return a `()`\n  -- so res is [(), (), ()]\n  print res\n\n  -- 2.1 mapM can be used to map a function that return IO action\n  mapm <- mapM print [1, 2, 3]\n  print mapm\n  -- 2.2 mapM_ just abundon the results\n  mapm_ <- mapM_ print [1, 2, 3]\n  print mapm_\n")),(0,l.kt)("h3",{id:"86-todo-list"},"8.6 todo list"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'import Data.List\nimport System.Directory\nimport System.Environment\nimport System.IO\n\ndispatch :: [(String, [String] -> IO ())]\ndispatch =\n  [ ("add", add),\n    ("view", view),\n    ("remove", remove)\n  ]\n\nmain = do\n  (command : args) <- getArgs\n  let (Just action) = lookup command dispatch\n  action args\n\nadd :: [String] -> IO ()\nadd [fileName, todoItem] = appendFile fileName (todoItem ++ "\\n")\nadd _ = putStrLn "Plz input [filename, todoItem]"\n\nview :: [String] -> IO ()\nview [fileName] = do\n  contents <- readFile fileName\n  let todoTasks = lines contents\n      numberedTasks = zipWith (\\n line -> show n ++ " - " ++ line) [0 ..] todoTasks\n  putStr $ unlines numberedTasks\nview _ = putStrLn "Plz input [filename]"\n\nremove :: [String] -> IO ()\nremove [fileName, numberString] = do\n  handle <- openFile fileName ReadMode\n  (tempName, tempHandle) <- openTempFile "." "temp"\n  contents <- hGetContents handle\n  let number = read numberString\n      todoTasks = lines contents\n      newTodoItems = delete (todoTasks !! number) todoTasks\n  hPutStr tempHandle $ unlines newTodoItems\n  hClose handle\n  hClose tempHandle\n  removeFile fileName\n  renameFile tempName fileName\nremove _ = putStrLn "Plz input [filename, numberString]"\n')),(0,l.kt)("h3",{id:"87-error-handle"},"8.7 Error Handle"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"try & catch")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'import Control.Exception\nimport System.Environment\nimport System.IO\nimport System.IO.Error\n\nmain = toTry `catch` handler\n\ntoTry :: IO ()\ntoTry = do\n  (fileName : _) <- getArgs\n  contents <- readFile fileName\n  putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"\n\nhandler :: IOError -> IO ()\nhandler e = putStrLn "Whoops, had some trouble!"\n\n-- main = do\n--   toTry `catch` handler1\n--   thenTryThis `catch` handler2\n--   launchRockets\n')),(0,l.kt)("ol",{start:2},(0,l.kt)("li",{parentName:"ol"},"error kind")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'\nimport System.Environment\nimport System.IO\nimport System.IO.Error\nimport Control.Exception\n\nmain = toTry `catch` handler\n\ntoTry :: IO ()\ntoTry = do (fileName:_) <- getArgs\n           contents <- readFile fileName\n           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"\n\nhandler :: IOError -> IO ()\nhandler e\n    | isDoesNotExistError e = putStrLn "The file doesn\'t exist!"\n    | otherwise = ioError e\n\n-- isAlreadyExistsError\n-- isDoesNotExistError\n-- isAlreadyInUseError\n-- isFullError\n-- isEOFError\n-- isIllegalOperation\n-- isPermissionError\n-- isUserError\n')),(0,l.kt)("h2",{id:"9-solve-some-problems"},"9. Solve Some Problems"),(0,l.kt)("h3",{id:"91-\u8ba1\u7b97\u540e\u7f00\u8868\u8fbe\u5f0f"},"9.1 \u8ba1\u7b97\u540e\u7f00\u8868\u8fbe\u5f0f"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'import Data.List\n\nsolveRPN :: (Num a, Read a) => String -> a\nsolveRPN = head . foldl foldingFunction [] . words\n    where\n        foldingFunction (x:y:ys) "*" = (x * y):ys\n        foldingFunction (x:y:ys) "+" = (x + y):ys\n        foldingFunction (x:y:ys) "-" = (x - y):ys\n        foldingFunction xs numString = read numString:xs\n\nsolveRPN2 :: (Num a, Read a, Floating a) => String -> a\nsolveRPN2 = head . foldl foldingFunction [] . words\n    where\n        foldingFunction (x:y:ys) "*" = (x * y):ys\n        foldingFunction (x:y:ys) "+" = (x + y):ys\n        foldingFunction (x:y:ys) "-" = (x - y):ys\n        foldingFunction (x:y:ys) "/" = (y / x):ys\n        foldingFunction (x:y:ys) "^" = (y ** x):ys\n        foldingFunction (x:xs) "ln" = log x:xs\n        foldingFunction xs "sum" = [sum xs]\n        foldingFunction xs numString = read numString:xs\n\n\nmain :: IO ()\nmain = do\n    putStrLn "start..."\n    print $ solveRPN "90 34 12 33 55 66 + * - + -"\n    putStrLn "end..."\n')),(0,l.kt)("h3",{id:"92-\u8ba1\u7b97\u6700\u77ed\u8def"},"9.2 \u8ba1\u7b97\u6700\u77ed\u8def"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},'-- newtype Road = Road Int Node\n-- newtype Node = Node Road Road | EndNode Road\n\n-- newtype Road = Road Int Node\n-- newtype Node = Node Road (Maybe Road)\n\ndata Section = Section\n  { getA :: Int,\n    getB :: Int,\n    getC :: Int\n  }\n  deriving (Show)\n\ntype RoadSystem = [Section]\n\nheadthrowToLondon :: RoadSystem\nheadthrowToLondon = [Section 50 10 30, Section 5 90 20, Section 40 2 25, Section 10 8 0]\n\ndata Label = A | B | C deriving (Show)\n\ntype Path = [(Label, Int)]\n\nroadStep :: (Path, Path) -> Section -> (Path, Path)\nroadStep (pathA, pathB) (Section a b c) =\n  let priceA = sum $ map snd pathA\n      priceB = sum $ map snd pathB\n      forwardPriceToA = priceA + a\n      crossPriceToA = priceB + b + c\n      forwardPriceToB = priceB + b\n      crossPriceToB = priceA + a + c\n      newPathToA =\n        if forwardPriceToA <= crossPriceToA\n          then (A, a) : pathA\n          else (C, c) : (B, b) : pathB\n      newPathToB =\n        if forwardPriceToB <= crossPriceToB\n          then (B, b) : pathB\n          else (C, c) : (A, a) : pathA\n   in (newPathToA, newPathToB)\n\noptimalPath :: RoadSystem -> Path\noptimalPath roadSystem =\n  let (bestAPath, bestBPath) = foldl roadStep ([], []) roadSystem\n   in if sum (map snd bestAPath) <= sum (map snd bestBPath)\n        then reverse bestAPath\n        else reverse bestBPath\n\nmain :: IO ()\nmain = do\n  print $ roadStep ([], []) (head headthrowToLondon)\n  print $ optimalPath headthrowToLondon\n\n\n  contents <- getContents\n  let threes = groupOf 3 (map read $ lines contents)\n      roadSystem = map (\\[a,b,c] -> Section a b c) threes\n      path = optimalPath roadSystem\n      pathString = concat $ map (show . fst) path\n      pathPrice = sum $ map snd path\n  putStrLn $ "The best path to take is: " ++ pathString\n  putStrLn $ "The price is: " ++ show pathPrice\n\n\ngroupOf :: Int -> [a] -> [[a]]\ngroupOf 0 _ = undefined\ngroupOf _ [] = []\ngroupOf n xs = take n xs : groupOf n (drop n xs)\n')),(0,l.kt)("h2",{id:"10-functors-applicative-functors-and-monoids"},"10. Functors, Applicative Functors and Monoids"),(0,l.kt)("p",null,"\u6781\u5ea6\u5efa\u8bae\u53c2\u8003\u4e0b\u9762\u7684\u6587\u7ae0\uff0c\u56fe\u6587\u89e3\u91ca\u5341\u5206\u76f4\u89c2\n",(0,l.kt)("a",{parentName:"p",href:"https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html"},"Functors, Applicatives, And Monads In Pictures")),(0,l.kt)("h3",{id:"101-functor"},"10.1 Functor"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"fmap (+3) (Just 2)\n")),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202022316684.png",alt:null})),(0,l.kt)("h3",{id:"102-applicatives"},"10.2 Applicatives"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"Just (+3) <*> Just 2 == Just 5\n\n> [(*2), (+3)] <*> [1, 2, 3]\n[2, 4, 6, 4, 5, 6]\n")),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202022317350.png",alt:null})),(0,l.kt)("h3",{id:"103-monads"},"10.3 Monads"),(0,l.kt)("p",null,"\u5224\u65ad\u4e00\u4e2a\u6570\u7684\u5947\u5076"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"half x = if even x\n           then Just (x `div` 2)\n           else Nothing\n")),(0,l.kt)("p",null,"\u52a0\u5165 x \u73b0\u5728\u662f\u4e00\u4e2a wrapped \u7684\u6bd4\u5982\u8bf4 Maybe\uff0c\u8fd9\u91cc\u5f15\u5165\u4e00\u4e2a\u65b0\u7684\u64cd\u4f5c\u7b26 ",(0,l.kt)("inlineCode",{parentName:"p"},">>=")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"> Just 3 >>= half\nNothing\n> Just 4 >>= half\nJust 2\n> Nothing >>= half\nNothing\n")),(0,l.kt)("p",null,"\u4e4b\u6240\u4ee5\u80fd\u50cf\u4e0a\u9762\u4e00\u6837\u64cd\u4f5c\u662f\u56e0\u4e3a\uff0cMaybe \u662f\u4e2a Monad"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-haskell"},"instance Monad Maybe where\n    Nothing >>= func = Nothing\n    Just val >>= func  = func val\n")),(0,l.kt)("p",null,"Just\n",(0,l.kt)("img",{parentName:"p",src:"https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202022324827.png",alt:null}),"\nNothing\n",(0,l.kt)("img",{parentName:"p",src:"https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202022324432.png",alt:null})),(0,l.kt)("h3",{id:"104-\u603b\u7ed3"},"10.4 \u603b\u7ed3"),(0,l.kt)("p",null,(0,l.kt)("img",{parentName:"p",src:"https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202022325497.png",alt:null})))}c.isMDXComponent=!0}}]);