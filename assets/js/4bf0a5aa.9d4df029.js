"use strict";(self.webpackChunktrdthg_github_io=self.webpackChunktrdthg_github_io||[]).push([[5234],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>c});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),f=u(n),c=a,m=f["".concat(s,".").concat(c)]||f[c]||d[c]||l;return n?r.createElement(m,i(i({ref:t},p),{},{components:n})):r.createElement(m,i({ref:t},p))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,i=new Array(l);i[0]=f;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var u=2;u<l;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},487:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const l={},i="Rust",o={unversionedId:"rust/rust",id:"rust/rust",title:"Rust",description:"1. \u751f\u547d\u5468\u671f",source:"@site/docs/rust/rust.md",sourceDirName:"rust",slug:"/rust/",permalink:"/docs/rust/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\u5185\u7f51\u7a7f\u900f\u5de5\u5177",permalink:"/docs/projects/net-piercer"},next:{title:"go \u8bed\u8a00",permalink:"/docs/rust/go"}},s={},u=[{value:"1. \u751f\u547d\u5468\u671f",id:"1-\u751f\u547d\u5468\u671f",level:2},{value:"\u81ea\u52a8\u5904\u7406\u751f\u547d\u5468\u671f",id:"\u81ea\u52a8\u5904\u7406\u751f\u547d\u5468\u671f",level:3},{value:"2. \u667a\u80fd\u6307\u9488",id:"2-\u667a\u80fd\u6307\u9488",level:2},{value:"\u57fa\u672c\u6982\u5ff5",id:"\u57fa\u672c\u6982\u5ff5",level:3},{value:"\u7b80\u5355\u5b9e\u73b0",id:"\u7b80\u5355\u5b9e\u73b0",level:3},{value:"\u81ea\u52a8\u89e3\u5f15\u7528\u7684\u65f6\u673a",id:"\u81ea\u52a8\u89e3\u5f15\u7528\u7684\u65f6\u673a",level:3},{value:"\u81ea\u52a8\u7ba1\u7406\u5185\u5b58",id:"\u81ea\u52a8\u7ba1\u7406\u5185\u5b58",level:3},{value:"2. Atomic \u5728 rust \u4e2d\u7684\u5b9e\u8df5",id:"2-atomic-\u5728-rust-\u4e2d\u7684\u5b9e\u8df5",level:2},{value:"\u4f7f\u7528 Atomic \u5b9e\u73b0\u7b80\u5355\u7684 Mutex",id:"\u4f7f\u7528-atomic-\u5b9e\u73b0\u7b80\u5355\u7684-mutex",level:3},{value:"Acquire \u4e0e Release",id:"acquire-\u4e0e-release",level:3},{value:"\u5fc5\u9700\u7528 Seq \u7684\u573a\u666f",id:"\u5fc5\u9700\u7528-seq-\u7684\u573a\u666f",level:3},{value:"3. \u5e38\u7528 Trait",id:"3-\u5e38\u7528-trait",level:2},{value:"3.1 Read",id:"31-read",level:3},{value:"3.2 Write",id:"32-write",level:3},{value:"3.3 Seek &amp; BufReader &amp; BufWriter",id:"33-seek--bufreader--bufwriter",level:3},{value:"4. \u5176\u4ed6",id:"4-\u5176\u4ed6",level:2},{value:"2. Rc &amp; Arc",id:"2-rc--arc",level:3},{value:"\u4ecb\u7ecd",id:"\u4ecb\u7ecd",level:4},{value:"try_unwrap()",id:"try_unwrap",level:4},{value:"4. Cell &amp; RefCell",id:"4-cell--refcell",level:3},{value:"5. Ref &amp; RefMut",id:"5-ref--refmut",level:3},{value:"Ref::map()",id:"refmap",level:4}],p={toc:u};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"rust"},"Rust"),(0,a.kt)("h2",{id:"1-\u751f\u547d\u5468\u671f"},"1. \u751f\u547d\u5468\u671f"),(0,a.kt)("h3",{id:"\u81ea\u52a8\u5904\u7406\u751f\u547d\u5468\u671f"},"\u81ea\u52a8\u5904\u7406\u751f\u547d\u5468\u671f"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// Only one reference in input, so the output must be derived from that input\nfn foo(&A) -> &B; // sugar for:\nfn foo<'a>(&'a A) -> &'a B;\n\n// Many inputs, assume they're all independent\nfn foo(&A, &B, &C); // sugar for:\nfn foo<'a, 'b, 'c>(&'a A, &'b B, &'c C);\n\n// Methods, assume all output lifetimes are derived from `self`\nfn foo(&self, &B, &C) -> &D; // sugar for:\nfn foo<'a, 'b, 'c>(&'a self, &'b B, &'c C) -> &'a D;\n")),(0,a.kt)("h2",{id:"2-\u667a\u80fd\u6307\u9488"},"2. \u667a\u80fd\u6307\u9488"),(0,a.kt)("h3",{id:"\u57fa\u672c\u6982\u5ff5"},"\u57fa\u672c\u6982\u5ff5"),(0,a.kt)("p",null,"\u5b9e\u73b0\u4e86 Deref Trait \u548c Drop Trait \u7684\u5c31\u662f\u667a\u80fd\u6307\u9488"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Deref Trait: \u5177\u6709\u6307\u9488\u8bed\u4e49"),(0,a.kt)("li",{parentName:"ol"},"Drop Trait\uff1a\u62e5\u6709\u5185\u5b58\u81ea\u52a8\u7ba1\u7406\u7684\u673a\u5236")),(0,a.kt)("p",null,"\u770b\u4e00\u773c Box \u7684\u5b9e\u73b0"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'#[stable(feature = "rust1", since = "1.0.0")]\nimpl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n    type Target = T;\n\n    fn deref(&self) -> &T {\n        &**self\n    }\n}\n')),(0,a.kt)("h3",{id:"\u7b80\u5355\u5b9e\u73b0"},"\u7b80\u5355\u5b9e\u73b0"),(0,a.kt)("p",null,"\u6211\u4eec\u5b9e\u73b0\u4e00\u4e2a\u667a\u80fd\u6307\u9488\uff08\u53ea\u5b9e\u73b0\u4e86 Deref Trait\uff09"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::ops::Deref;\n\npub struct MySmartPointer<T> (T);\n\nimpl<T> MySmartPointer<T> {\n    pub fn new(t: T) -> Self {\n        MySmartPointer(t)\n    }\n}\n\nimpl<T> Deref for MySmartPointer<T> {\n    type Target = T;\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n// \u8c03\u7528*x \u5176\u5b9e\u5c31\u662f\u8c03\u7528 *x.deref()\nlet x = 5;\nlet a = MySmartPointer::new(x);\nlet b = Box::new(x);\nassert_eq!(x, *a.deref());\nassert_eq!(x, *a);\nassert_eq!(x, *b.deref());\nassert_eq!(x, *b);\nprint!("{}", a.to_string())\n')),(0,a.kt)("h3",{id:"\u81ea\u52a8\u89e3\u5f15\u7528\u7684\u65f6\u673a"},"\u81ea\u52a8\u89e3\u5f15\u7528\u7684\u65f6\u673a"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u9047\u5230*\u8fd0\u7b97\u7b26\u81ea\u52a8\u63a5\u5f15\u7528"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"assert_eq!(x, *a.deref());\nassert_eq!(x, *a);\n"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u9047\u5230 . \u8fd0\u7b97\u7b26\u63a5\u5f15\u7528\u8c03\u7528\u65b9\u6cd5"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'print!("{}", a.to_string())\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u53c2\u6570\u4f20\u9012\u81ea\u52a8\u89e3\u5f15\u7528"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let s = String::from("aaaa");\nfn take_str(s: &str) {\n    print!("{}", s);\n}\ntake_str(&s);\n\n#[stable(feature = "rust1", since = "1.0.0")]\nimpl ops::Deref for String {\n    type Target = str;\n\n    #[inline]\n    fn deref(&self) -> &str {\n        unsafe { str::from_utf8_unchecked(&self.vec) }\n    }\n}\n')))),(0,a.kt)("h3",{id:"\u81ea\u52a8\u7ba1\u7406\u5185\u5b58"},"\u81ea\u52a8\u7ba1\u7406\u5185\u5b58"),(0,a.kt)("p",null,"\u81ea\u52a8\u5316\u7ba1\u7406\u5185\u5b58 (drop\uff0c\u4f5c\u7528\u57df\u5916\u81ea\u52a8\u91ca\u653e\u5185\u5b58)"),(0,a.kt)("h2",{id:"2-atomic-\u5728-rust-\u4e2d\u7684\u5b9e\u8df5"},"2. Atomic \u5728 rust \u4e2d\u7684\u5b9e\u8df5"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=rMGWeSjctlY"},"Crust of Rust: Atomics and Memory Ordering")),(0,a.kt)("h3",{id:"\u4f7f\u7528-atomic-\u5b9e\u73b0\u7b80\u5355\u7684-mutex"},"\u4f7f\u7528 Atomic \u5b9e\u73b0\u7b80\u5355\u7684 Mutex"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"use std::{sync::atomic::{AtomicBool, Ordering, AtomicUsize}, thread::{self, spawn}, cell::UnsafeCell};\n\nconst UNLOCKED: bool = true;\nconst LOCKED: bool = false;\n\nstruct Mutex<T> {\n    locked: AtomicBool,\n    v: UnsafeCell<T>\n}\n\nunsafe impl<T> Sync for Mutex<T> where T: Send {}\n\nimpl<T> Mutex<T> {\n\n    pub fn new(v: T) -> Self {\n        Self {\n            locked: AtomicBool::new(UNLOCKED),\n            v: UnsafeCell::new(v)\n        }\n    }\n\n    /// \u66b4\u9732\u4e00\u4e2a\u53ef\u53d8\u5f15\u7528\u51fa\u53bb\n    ///\n    /// \u5f53\u7ebf\u7a0b A \u548c\u7ebf\u7a0b B \u540c\u65f6\u6267\u884c\u65f6\uff0cA\uff0cB \u53ef\u80fd\u540c\u65f6\u62ff\u5230\ud83d\udd13\uff0c\u5e76\u540c\u65f6\u4e0a\u9501\uff0c\u8fd9\u4e24\u4e2a\u7ebf\u7a0b\u5e76\u6ca1\u6709`\u770b\u5230`\u5bf9\u65b9\u9875\u62ff\u5230\u4e86\u9501\n    /// \u6240\u4ee5\u5c31\u51fa\u5148\u4e86\uff0c\u7ebf\u7a0b A \u548c B \u540c\u65f6\u4ece\u5bc4\u5b58\u5668\u62ff\u5230\u503c 1\uff0c\u6539\u4e3a\u4e86 2\uff0c\u7136\u540e\u590d\u5236\u5230\u5bc4\u5b58\u5668\u5185\uff0c\u540e\u4fee\u6539\u7684\u4f1a\u8986\u76d6\u524d\u4e00\u6b21\u4fee\u6539\n    /// \u4e3a\u4e86\u89e3\u51b3\u4e0a\u8ff0\u95ee\u9898\uff0c\u4e0b\u9762\u662f\u4e00\u4e9b\u89e3\u51b3\u65b9\u6cd5\n    ///\n    /// \u65b9\u6848 1\uff0c\u4f7f\u7528`compare_exchange`\u5408\u5e76\u52a0\u9501\u4e0a\u9501\u8fc7\u7a0b\n    /// while self.locked.compare_exchange(UNLOCKED, LOCKED, Ordering::Relaxed, Ordering::Relaxed).is_err() {}\n    ///\n    /// #1 compare_exchange \u662f\u4f4e\u6548\u7684\uff0c\u5982\u679c\u662f\u591a\u6838\u90fd\u5728\u540c\u65f6\u4e89\u593a\u9501\uff0c8 \u4e2a\u6838\u4e2d\u6709\u4e00\u4e2a\u548c\u5148\u62ff\u5230\u4e86\u9501\n    /// \u90a3\u4e48\u5269\u4e0b\u7684 7 \u4e2a\u6838\u4f9d\u7136\u4f1a\u4e92\u76f8\u7ade\u4e89\uff0c\u8fd9\u4e2a\u53d8\u91cf\u7684\u5185\u5b58\u5c31\u4f1a\u5728\u591a\u4e2a\u6838\u4e2d\u4e0d\u65ad\u62f7\u8d1d\n    /// #2 \u76f8\u6bd4\u4e8e mutex\uff0cmutex \u62ff\u4e0d\u5230\u9501\u5c31\u4f1a\u963b\u585e\u7ebf\u7a0b\uff0c\u800c compare_exchange \u62ff\u4e0d\u5230\u5c31\u4f1a\u8fd4\u56de\u4e00\u4e2a Err\n    /// #3 rust \u4e2d\u8fd8\u63d0\u4f9b\u4e86 compare_and_exchange_weak\uff0c\u6700\u5927\u7684\u533a\u522b\u662f\n    ///     compare_and_exchange \u53ea\u5141\u8bb8\u5728\u5224\u65ad Current v alue \u548c\u4f20\u5165\u7684\u503c\u4e0d\u4e00\u6837\u65f6\u8fd4\u56de Err\n    ///     compare_and_exchange_weak \u5373\u4f7f\u5728\u4e00\u6837\u7684\u65f6\u5019\u4e5f\u53ef\u80fd\u4f1a\u8fd4\u56de Err\uff0c\u8fd9\u79cd\u7ec6\u5c0f\u7684\u5dee\u522b\u80fd\u591f\u7528\u4e8e\u67d0\u4e9b\u573a\u666f\uff0c\u8ba9\u6027\u80fd\u66f4\u597d\n    ///     \u539f\u56e0\u662f\u7531\u4e8e\u5728\u4e0d\u540c\u5e73\u53f0\u4e0a\u7684\u5b9e\u73b0\u4e0d\u540c\n    ///         x86: compare_and_swap\n    ///         ARM: LDREX STREX\n    ///     \u5728 x86 \u4e0a weak \u4e0e\u666e\u901a\u7684\u76f8\u540c\uff0c\n    ///     \u5728 ARM \u4e0a\uff1a\n    ///         compare_and_exchange: impl using a loop of LDREX and STREX\n    ///         compare_and_exchange_weak: LDREX and STREX with no loop, it may be fake\n    pub fn with_lock<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {\n        // \u62ff\ud83d\udd13 \u4e0a\ud83d\udd13\n        // while self.locked.load(Ordering::Relaxed) != UNLOCKED {}\n        // self.locked.store(LOCKED, Ordering::Relaxed);\n\n        // \u65b9\u6848 1\n        // while self.locked.compare_exchange(UNLOCKED, LOCKED, Ordering::Relaxed, Ordering::Relaxed).is_err() {}\n\n        // \u65b9\u6848 2 \u5728 arm \u4e0b\u6709\u66f4\u597d\u7684\u6027\u80fd\n        while self.locked.compare_exchange_weak(UNLOCKED, LOCKED, Ordering::Relaxed, Ordering::Relaxed).is_err() {\n            // \u5047\u5982\u73b0\u5728 current value \u5c31\u662f UNLOCKED \u72b6\u6001\uff0c\u5df2\u7ecf\u4fee\u6539\u4e3a LOCKED \u72b6\u6001\uff0c\u90a3\u4e48\u5c31\u5df2\u7ecf\u62ff\u5230\u4e86\u6240\u6709\u6743\n            // \u52a0\u5165\u73b0\u5728\u8fd8\u6ca1\u6709\u4fee\u6539\u5b8c\u6210\uff0ccurrent value \u4f9d\u7136\u662f UNLOCKED \u72b6\u6001\uff0c\u5f53\u524d\u7ebf\u7a0b\u5c31\u4f1a\u5361\u4f4f\uff0c\u76f4\u5230\u6709\u522b\u7684\u7ebf\u7a0b\u6210\u529f\u62ff\u5230\u4e86\u6240\u6709\u6743\n            while self.locked.load(Ordering::Relaxed) == LOCKED {\n                thread::yield_now();\n            }\n            thread::yield_now();\n        }\n\n        // \u66b4\u9732\u6570\u636e\n        let ret = f(unsafe { &mut *self.v.get() });\n        // \u89e3\ud83d\udd13\n        self.locked.store(UNLOCKED, Ordering::Relaxed);\n        ret\n    }\n}\n\nfn main() {\n    let l: &'static _ = Box::leak(Box::new(Mutex::new(0)));\n\n    let handles: Vec<_> = (0..1000).map(|_| {\n        thread::spawn(move || {\n            for _ in 0..1000 {\n                l.with_lock(|v| {\n                    *v += 1;\n                })\n            }\n        })\n    }).collect();\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    // \u8fd9\u91cc\u4f9d\u7136\u4f1a\u62a5\u9519\n    assert_eq!(l.with_lock(|v| *v), 1000 * 1000);\n\n}\n")),(0,a.kt)("h3",{id:"acquire-\u4e0e-release"},"Acquire \u4e0e Release"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"/// \u4f46\u662f\u5373\u4f7f\u7528\u4e86\u4e0a\u9762\u7684\u4e1c\u897f\u4e5f\u6709\u53ef\u80fd\u4f1a\u51fa\u95ee\u9898\uff0c\u867d\u7136\u5728 X86 64 \u4f4d\u7cfb\u7edf\u4e0a\u6ca1\u6709\u51fa\u73b0\u95ee\u9898\uff0c\u8fd9\u662f\u56e0\u4e3a\u4ed6\u4e0d\u652f\u6301\uff01\uff0c\u4ed6\u53ea\u652f\u6301 Seq \u7684\uff0c\u4e0d\u8fc7\u8fd8\u662f\u8981\u8bf4\u660e\u95ee\u9898\n/// \u56e0\u4e3a\u4e0b\u9762\u5bf9\u53d8\u91cf v \u7684\u4fee\u6539\u548c\u4e0a\u9501\u91ca\u653e\u9501\u7684\u8fc7\u7a0b\u6beb\u4e0d\u76f8\u5173\uff0c\n/// \u6240\u4ee5\u4e0b\u4e00\u884c\u53ef\u80fd\u88ab\u91cd\u65b0\u6392\u5217\u5728\u52a0\u9501\u4e4b\u524d\uff0c\u6216\u8005\u89e3\u9501\u4e4b\u540e\uff0c\u8fd9\u4e24\u79cd\u90fd\u662f\u4e0d\u5141\u8bb8\u7684\uff0c\u4f46\u662f cpu \u548c\u7f16\u8bd1\u5668\u5c31\u53ef\u80fd\u8fd9\u6837\u505a\n///\n/// \u5bf9\u6b64\u9700\u8981\u4f7f\u7528 Acquire \u548c Release\npub fn with_lock2<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {\n    // \u4efb\u4f55\u4e4b\u540e\u7684\u8bfb\u5199\u64cd\u4f5c\u4e0d\u4f1a\u88ab\u91cd\u6392\u5230 Acquire \u4e4b\u524d\n    // \u522b\u7684\u7ebf\u7a0b\u4e2d\u7684\u5199\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u8fd9\u91cc\u7684 Acquire \u90fd\u662f\u53ef\u89c1\u7684\n    while self.locked.compare_exchange_weak(UNLOCKED, LOCKED, Ordering::Acquire, Ordering::Relaxed).is_err() {\n        while self.locked.load(Ordering::Relaxed) == LOCKED {\n            thread::yield_now();\n        }\n        thread::yield_now();\n    }\n    let ret = f(unsafe { &mut *self.v.get() });\n\n    // \u4efb\u4f55\u4e4b\u524d\u7684\u8bfb\u5199\u64cd\u4f5c\u4e0d\u4f1a\u88ab\u91cd\u6392\u5230 Release \u4e4b\u540e\n    // \u8fd9\u4e2a\u7ebf\u7a0b\u91cc\u7684\u6240\u6709\u5199\u64cd\u4f5c\u5bf9\u522b\u7684\u7ebf\u7a0b\u4e2d\u7684 Acquire \u90fd\u662f\u53ef\u89c1\u7684\n    self.locked.store(UNLOCKED, Ordering::Release);\n    ret\n}\n")),(0,a.kt)("h3",{id:"\u5fc5\u9700\u7528-seq-\u7684\u573a\u666f"},"\u5fc5\u9700\u7528 Seq \u7684\u573a\u666f"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"#[test]\nfn seq_test() {\n    // fetch_add always succeed\n\n    let x: &'static _ = Box::leak(Box::new(AtomicBool::new(false)));\n    let y: &'static _ = Box::leak(Box::new(AtomicBool::new(false)));\n    let z: &'static _ = Box::leak(Box::new(AtomicUsize::new(0)));\n    let tx = thread::spawn(move || {\n        x.store(true, Ordering::Release);                  // \uff01\uff01\uff01\n    });\n    let ty = thread::spawn(move || {\n        y.store(true, Ordering::Release);\n    });\n    let t1 = spawn(move || {\n        while !x.load(Ordering::Acquire) {}\n        if y.load(Ordering::Acquire) {\n            z.fetch_add(1, Ordering::Release);\n        }\n    });\n    let t2 = spawn(move || {\n        while !y.load(Ordering::Acquire) {}                    // \u8fd9\u884c\u548c\u4e0b\u9762\u4e00\u884c\u53ef\u80fd\u91cd\u6392 (\u6216\u8005\u8bf4\u4e0d\u662f\u91cd\u6392\uff0c\u5355\u7eaf\u65f6\u53ef\u89c1\u6027\u7684\u95ee\u9898\uff0c\u4e0b\u9762\u7684 x \u5c31\u662f\u770b\u5230\u4e86 x \u662f false)\n        if x.load(Ordering::Acquire) {                         // \uff01\uff01\uff01x \u4e3a false\uff0c\u5f53 x \u88ab\u4fee\u6539\u4e3a true \u540e\uff0c\u4e5f\u4e0d\u4f1a\u53d1\u751f\u6539\u53d8\n            z.fetch_add(1, Ordering::Release);\n        }\n    });\n    println!(\"{}\", z.load(Ordering::SeqCst));\n\n    // What are the possibles for z?\n    // - is 0 possibly ?\n    //   \u7ecf\u8fc7\u5224\u65ad\uff0c\u81f3\u5c11\u6709\u4e0b\u9762\u7684\u6761\u4ef6\n    //     t1 must run after tx\n    //     t2 must run after ty\n    //   \u51e0\u79cd\u6392\u5217\u7ec4\u5408\u5e94\u8be5\u662f 1 \u6216 2\uff0c\u6ca1\u6709 0\n    //   \u4f46\u662f 0 \u8fd8\u662f\u53ef\u80fd\u7684\uff0c\n    //           t2    t1,t2\n    //   MO(x)  false  true\n    //           t1    t1,t2\n    //   MO(y)  false  true\n    // - is 1 possibly ?\n    //   Yes: tx -> t1 -> ty -> t2\n    // - is 2 possibly ?\n    //   Yes: tx -> ty -> t1 -> t2\n\n}\n")),(0,a.kt)("h2",{id:"3-\u5e38\u7528-trait"},"3. \u5e38\u7528 Trait"),(0,a.kt)("h3",{id:"31-read"},"3.1 Read"),(0,a.kt)("p",null,"Read Trait \u7684\u529f\u80fd\u662f\uff1a\u4ece\u6570\u636e\u6e90\u62c9\u53d6 (Pull) \u4e00\u5b9a\u6570\u636e\u5230\u6307\u5b9a\u7684\u7f13\u51b2\u533a\uff0c\u8fd4\u56de\u8bfb\u53d6\u7684\u5b57\u8282\u6570\u3002"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u5173\u4e8e\u963b\u585e\uff1a")," read \u51fd\u6570\u4e0d\u4fdd\u8bc1 Read \u662f\u5426\u4f1a\u5904\u4e8e\u963b\u585e\u72b6\u6001\uff0c\u5982\u679c\u4e00\u4e2a read \u8fc7\u7a0b\u963b\u585e\u4e86\u800c\u4e14\u7b49\u5f85\u5931\u8d25\uff0c\u90a3\u4ed6\u5c31\u4f1a\u8fd4\u56de\u4e00\u4e2a ","[",(0,a.kt)("inlineCode",{parentName:"p"},"Err"),"]"," \u6807\u8bb0\u3002"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u5173\u4e8e\u8fd4\u56de\u503c\uff1a")," \u5982\u679c",(0,a.kt)("inlineCode",{parentName:"p"},"read()"),"\u8fd4\u56de\u7684\u662f ","[",(0,a.kt)("inlineCode",{parentName:"p"},"OK(n)"),"]"," , \u5b83\u7684\u5b9e\u73b0\u5c31\u5fc5\u987b\u4fdd\u8bc1",(0,a.kt)("inlineCode",{parentName:"p"},"0 <- n < buf.len()"),"\u3002\n\u5982\u679c",(0,a.kt)("inlineCode",{parentName:"p"},"n == 0"),"\uff0c\u90a3\u53ef\u80fd\u6709\u4e24\u79cd\u60c5\u51b5\uff1a"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"reader \u5df2\u7ecf\u5230\u8fbe\u4e86",(0,a.kt)("inlineCode",{parentName:"li"},"the end of file"),"\uff0c\u800c\u4e14\u8fd9\u4e2a",(0,a.kt)("inlineCode",{parentName:"li"},"file"),"\u53ef\u80fd\u4e0d\u4f1a\u5728\u4ea7\u751f\u65b0\u6570\u636e\u3002\u6ce8\u610f\uff0c\u8fd9\u91cc\u53ea\u662f likely\uff0c\u6bd4\u5982\uff1a\u5728 linux\n\u7cfb\u7edf\u4e2d\uff0cread \u53ef\u80fd\u5bf9\u4e00\u4e2a ","[",(0,a.kt)("inlineCode",{parentName:"li"},"TcpStream"),"]"," \u8c03\u7528\u4e86",(0,a.kt)("inlineCode",{parentName:"li"},"recv"),"\u7cfb\u7edf\u8c03\u7528\uff0c0 \u4ee3\u8868\u8fd9\u4e2a\u8fde\u63a5\u5df2\u7ecf\u88ab\u6210\u529f\u5173\u95ed\uff0c\u5982\u679c\u662f\u5bf9 ","[",(0,a.kt)("inlineCode",{parentName:"li"},"File"),"]"," ,\n\u90a3\u5c31\u53ef\u80fd\u610f\u5473\u7740\u786e\u5b9e\u8bfb\u53d6\u5230\u4e86\u6587\u4ef6\u7684\u672b\u5c3e\uff0c\u4f46\u662f\u5982\u679c\u6709\u66f4\u591a\u7684\u6570\u636e\u88ab\u8ffd\u52a0 (append) \u5230\u6587\u4ef6\u672b\u5c3e\uff0c\u90a3\u4e48\u672a\u6765\u7684 read \u64cd\u4f5c\u4f9d\u7136\u80fd\u591f\u6b63\u5e38\u8fd4\u56de\u88ab\u8ffd\u52a0\u7684\u6570\u636e"),(0,a.kt)("li",{parentName:"ol"},"\u7f13\u51b2\u533a (buffer) \u5927\u5c0f\u786e\u5b9e\u5c31\u662f 0")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"n")," \u53ea\u8981\u5c0f\u4e8e\u7f13\u51b2\u533a\u7684\u957f\u5ea6\u4e00\u822c\u5c31\u4e0d\u662f\u4e2a\u9519\u8bef\uff0c\u5373\u4f7f\u6587\u4ef6\u8fd8\u6ca1\u6709\u88ab\u8bfb\u53d6\u5b8c\uff0c\u8fd9\u79cd\u60c5\u51b5\u53ef\u80fd\u4f1a\u53d1\u751f\u5728\uff0c\u5f53\u524d\u53ea\u6709\u4e00\u90e8\u5206\u6570\u636e\u662f\u53ef\u7528\u7684\uff0c\u6216\u8005\u662f read \u64cd\u4f5c\u88ab\u4e00\u4e2a\u4fe1\u53f7\u6253\u65ad\u4e86"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u5173\u4e8e\u5b89\u5168\u6027\uff1a")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u56e0\u4e3a\u5b9e\u73b0\u8fd9\u4e2a Trait \u662f\u5b89\u5168\u7684\uff0c\u8c03\u7528\u8005\u4e0d\u80fd\u7528 ",(0,a.kt)("inlineCode",{parentName:"p"},"n < buf.len()")," \u53bb\u786e\u4fdd\u5b89\u5168\uff0c\u4f7f\u7528 unsafe \u662f\u66f4\u8981\u5c0f\u5fc3\u786e\u4fdd\u8bf8\u5982\u8d8a\u754c\u95ee\u9898\u662f\u5426\u4f1a\u53d1\u751f\u3002")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"read \u4e0d\u4fdd\u8bc1 buf \u91cc\u7684\u6570\u636e\u662f\u5bf9\u7684\uff0c\u6240\u4ee5\u4e0d\u63a8\u8350\u8bfb\u53d6\u7f13\u51b2\u533a\u91cc\u7684\u6570\u636e\uff0c\u53ea\u63a8\u8350\u5411\u7f13\u51b2\u533a\u91cc\u5199\u5165\u6570\u636e")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u76f8\u5e94\u7684\uff0c\u8c03\u7528\u8005\u4e0d\u80fd\u6709\u4efb\u4f55\u5047\u8bbe\uff0c\u8fd9\u4e2a buf \u4f1a\u88ab read \u600e\u4e48\u4f7f\u7528\uff0cread \u51fd\u6570\u4e5f\u53ef\u80fd\u4f1a\u4ece\u4e2d\u8bfb\u53d6\u5185\u5bb9\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4fdd\u8bc1\u5728\u8c03\u7528 read \u524d\uff0c\u8fd9\u4e2a buf\n\u5df2\u7ecf\u88ab\u521d\u59cb\u5316\u8fc7\u4e86\uff0c\u8c03\u7528\u6ca1\u6709\u88ab\u521d\u59cb\u5316\u7684 buf \u662f\u4e0d\u5b89\u5168\u7684\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u672a\u5b9a\u4e49\u7684\u884c\u4e3a"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"*\u5173\u4e8e\u9519\u8bef\uff1a")," \u5982\u679c\u9047\u5230\u4e86 Error\uff0c\u90a3\u5c31\u5fc5\u987b\u4fdd\u8bc1\u6ca1\u6709\u8bfb\u53d6\u8fc7\u4efb\u4f55\u5b57\u8282\uff0c\u5982\u679c\u9047\u5230\u4e86",(0,a.kt)("inlineCode",{parentName:"p"},"ErrorKind::Interrupted"),"\uff0c\u800c\u4e14\u4e0d\u80fd\u4f5c\u522b\u7684\u4e8b\u65f6\uff0c\n\u8bfb\u53d6\u8fc7\u7a0b\u5c31\u5fc5\u987b\u88ab\u56de\u6eda"),(0,a.kt)("p",null,"\u4e0b\u9762\u662f\u4e00\u4e2a\u6765\u81ea doc \u7684\u4f8b\u5b50"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::io;\nuse std::io::prelude::*;\nuse std::fs::File;\nfn main() -> io::Result<()> {\n    let mut f = File::open("foo.txt")?;\n    let mut buffer = [0; 10];\n    // read up to 10 bytes\n    let n = f.read(&mut buffer[..])?;\n    println!("The bytes: {:?}", &buffer[..n]);\n    Ok(())\n}\n')),(0,a.kt)("h3",{id:"32-write"},"3.2 Write"),(0,a.kt)("p",null,"Write \u7684\u57fa\u672c\u529f\u80fd\u5c31\u662f\u5411 writer \u4e2d\u5199\u5165\u4e00\u6bb5 buf\uff0c\u8fd4\u56de\u5199\u5165\u7684\u5b57\u8282\u6570 ",(0,a.kt)("strong",{parentName:"p"},"\u5173\u4e8e\u963b\u585e\uff1a")," write \u4f1a\u5c1d\u8bd5\u5411 writer \u4e2d\u5199\u5165\u6574\u4e2a buf\n\u91cc\u7684\u5185\u5bb9\uff0c\u4f46\u662f\u5199\u5165\u53ef\u80fd\u4e0d\u6210\u529f\uff0c\u6216\u8005\u5199\u5165\u65f6\u4ea7\u751f\u4e86\u4e00\u4e2a\u9519\u8bef\uff0c\u8c03\u7528\u4e00\u6b21 write \u610f\u5473\u7740\u6700\u591a\u4e00\u6b21\u5c1d\u8bd5\u5199\u5165 write \u51fd\u6570\u540c\u6837\u4e0d\u4fdd\u8bc1 Write\n\u662f\u5426\u5904\u4e8e\u963b\u585e\u72b6\u6001\u4ee5\u7b49\u5f85\u6570\u636e\u88ab\u5199\u5165\uff0c\u5982\u679c\u4e00\u6b21\u5199\u5165\u963b\u585e\u4e86\uff0c\u4ed6\u53ef\u80fd\u4f1a\u8fd4\u56de\u4e00\u4e2a ","[",(0,a.kt)("inlineCode",{parentName:"p"},"Err"),"]","\u3002"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u5173\u4e8e\u8fd4\u56de\u503c\uff1a")," \u5982\u679c",(0,a.kt)("inlineCode",{parentName:"p"},"write()"),"\u8fd4\u56de\u7684\u662f ","[",(0,a.kt)("inlineCode",{parentName:"p"},"OK(n)"),"]"," , \u5b83\u7684\u5b9e\u73b0\u5c31\u5fc5\u987b\u4fdd\u8bc1",(0,a.kt)("inlineCode",{parentName:"p"},"0 <- n < buf.len()"),"\u3002\n\u5982\u679c",(0,a.kt)("inlineCode",{parentName:"p"},"n == 0"),"\uff0c\u90a3\u53ef\u80fd\u6709\u4e24\u79cd\u60c5\u51b5\uff1a"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"\u88ab\u5199\u5165\u7684\u4e1c\u897f\u5df2\u7ecf\u4e0d\u4f1a\u63a5\u53d7\u65b0\u6570\u636e\u4e86\uff0c\u4e4b\u540e\u4e5f\u4e0d\u4e00\u5b9a\u4f1a"),(0,a.kt)("li",{parentName:"ol"},"\u7f13\u51b2\u533a (buffer) \u5927\u5c0f\u786e\u5b9e\u5c31\u662f 0")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"n")," \u53ea\u8981\u5c0f\u4e8e\u7f13\u51b2\u533a\u7684\u957f\u5ea6\u4e00\u822c\u5c31\u4e0d\u662f\u4e2a\u9519\u8bef\uff0c\u5373\u4f7f\u6587\u4ef6\u8fd8\u6ca1\u6709\u88ab\u8bfb\u53d6\u5b8c\uff0c\u8fd9\u79cd\u60c5\u51b5\u53ef\u80fd\u4f1a\u53d1\u751f\u5728\uff0c\u5f53\u524d\u53ea\u6709\u4e00\u90e8\u5206\u6570\u636e\u662f\u53ef\u7528\u7684\uff0c\u6216\u8005\u662f read \u64cd\u4f5c\u88ab\u4e00\u4e2a\u4fe1\u53f7\u6253\u65ad\u4e86"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"*\u5173\u4e8e\u9519\u8bef\uff1a")," \u5982\u679c\u9047\u5230\u4e86 Error\uff0c\u90a3\u5c31\u5fc5\u987b\u4fdd\u8bc1\u6ca1\u6709\u4efb\u4f55\u5b57\u8282\u88ab\u6210\u529f\u5199\u5165 \u8fd4\u56de\u503c\u5c0f\u4e8e buf \u7684\u957f\u5ea6\u4e0d\u88ab\u5f53\u6210\u662f\u9519\u8bef\n\u5982\u679c\u9047\u5230\u4e86",(0,a.kt)("inlineCode",{parentName:"p"},"ErrorKind::Interrupted"),"\uff0c\u800c\u4e14\u4e0d\u80fd\u4f5c\u522b\u7684\u4e8b\u65f6\uff0c\u5199\u5165\u8fc7\u7a0b\u5c31\u5fc5\u987b\u88ab\u56de\u6eda"),(0,a.kt)("p",null,"\u540c\u6837\u662f\u5b98\u65b9\u7684 demo"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::io::prelude::*;\nuse std::fs::File;\nfn main() -> std::io::Result<()> {\n    let mut buffer = File::create("foo.txt")?;\n    // Writes some prefix of the byte string, not necessarily all of it.\n    buffer.write(b"some bytes")?;\n    Ok(())\n}\n')),(0,a.kt)("h3",{id:"33-seek--bufreader--bufwriter"},"3.3 Seek & BufReader & BufWriter"),(0,a.kt)("p",null,"[",(0,a.kt)("inlineCode",{parentName:"p"},"Read"),"]"," \u548c ","[",(0,a.kt)("inlineCode",{parentName:"p"},"Write"),"]"," \u662f\u6700\u91cd\u8981\u7684\u4e24\u4e2a Trait\uff0c\u9664\u6b64\u4e4b\u5916\u8fd8\u6709\u4e24\u4e2a\u91cd\u8981\u7684 Trait","[",(0,a.kt)("inlineCode",{parentName:"p"},"Seek"),"]"," \u548c ","[",(0,a.kt)("inlineCode",{parentName:"p"},"BufRead"),"]",",\n\u8fd9\u4e24\u4e2a\u90fd\u5efa\u7acb\u5728 reader \u53ea\u4e0a\uff0c\u7528\u6765\u63a7\u5236 read \u7684\u8fc7\u7a0b\u3002"),(0,a.kt)("p",null,"[",(0,a.kt)("inlineCode",{parentName:"p"},"Seek"),"]"," \u8ba9\u4f60\u63a7\u5236\u4e0b\u4e00\u4e2a\u5b57\u8282\u5c06\u8981\u8bfb\u53d6\u7684\u6765\u81ea\u54ea\u91cc"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::io;\nuse std::io::prelude::*;\nuse std::io::SeekFrom;\nuse std::fs::File;\nfn main() -> io::Result<()> {\n    let mut f = File::open("foo.txt")?;\n    let mut buffer = [0; 10];\n    // skip to the last 10 bytes of the file\n    f.seek(SeekFrom::End(-10))?;\n    // read up to 10 bytes\n    let n = f.read(&mut buffer)?;\n    println!("The bytes: {:?}", &buffer[..n]);\n    Ok(())\n}\n')),(0,a.kt)("p",null,"\u57fa\u4e8e byte \u7684\u63a5\u53e3\u6027\u80fd\u4e0d\u4f73\uff0c\u6240\u4ee5\u63d0\u4f9b\u4e86\u5f88\u591a\u57fa\u4e8e buffer \u7684\u63a5\u53e3 ","[",(0,a.kt)("inlineCode",{parentName:"p"},"BufRead"),"]"," \u5c31\u63d0\u4f9b\u4e86\u66f4\u591a Read \u76f8\u5173\u7684 API"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let f = File::open("foo.txt")?;\nlet mut reader = BufReader::new(f);\nlet mut buffer = String::new();\n// read a line into buffer\nreader.read_line(&mut buffer)?;\n')),(0,a.kt)("p",null,"[",(0,a.kt)("inlineCode",{parentName:"p"},"BufWriter"),"]"," \u6ca1\u6709\u63d0\u4f9b\u66f4\u591a\u5199\u5165\u7684\u65b9\u6cd5\uff0c\u4ed6\u53ea\u662f\u7f13\u51b2\u4e86\u6bcf\u6b21\u8c03\u7528"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let f = File::create("foo.txt")?;\n{\n    let mut writer = BufWriter::new(f);\n\n    // write a byte to the buffer\n    writer.write(&[42])?;\n\n} // the buffer is flushed once writer goes out of scope\n')),(0,a.kt)("h2",{id:"4-\u5176\u4ed6"},"4. \u5176\u4ed6"),(0,a.kt)("h3",{id:"2-rc--arc"},"2. Rc & Arc"),(0,a.kt)("h4",{id:"\u4ecb\u7ecd"},"\u4ecb\u7ecd"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"The key to our design is the RefCell type. The heart of RefCell is a pair of\nmethods:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"fn borrow(&self) -> Ref<'_, T>;\nfn borrow_mut(&self) -> RefMut<'_, T>;\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Introducing inherited mutability roots to shared types Shared smart pointer\ntypes, including Rc and Arc, provide containers that can be cloned and shared\nbetween multiple parties. Because the contained values may be\nmultiply-aliased, they can only be borrowed as shared references, not mutable\nreferences. Without cells it would be impossible to mutate data inside of\nshared boxes at all!")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"It's very common then to put a RefCell inside shared pointer types to\nreintroduce mutability:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::collections::HashMap;\nuse std::cell::RefCell;\nuse std::rc::Rc;\nfn main() {\n    let shared_map: Rc<RefCell<_>> = Rc::new(RefCell::new(HashMap::new()));\n    shared_map.borrow_mut().insert("africa", 92388);\n    shared_map.borrow_mut().insert("kyoto", 11837);\n    shared_map.borrow_mut().insert("piccadilly", 11826);\n    shared_map.borrow_mut().insert("marbles", 38);\n}\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note that this example uses Rc and not Arc. RefCells are for single-threaded\nscenarios. Consider using Mutex if you need shared mutability in a\nmulti-threaded situation")),(0,a.kt)("h4",{id:"try_unwrap"},"try_unwrap()"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Get T from Rc","<","T",">"," try to use ",(0,a.kt)("inlineCode",{parentName:"p"},"try_unwrap()"),", which moves out the contents\nof an Rc if its refcount is 1 ::: warning unwrap on Result requires that you\ncan debug-print the error case. RefCell only implements Debug if T does. Node\ndoesn't implement Debug. try:\nRc::try_unwrap(old_head).ok().unwrap().into_inner().elem :::")),(0,a.kt)("h3",{id:"4-cell--refcell"},"4. Cell & RefCell"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Shareable mutable containers."),(0,a.kt)("p",{parentName:"blockquote"},"Values of the Cell and RefCell types may be mutated through shared references\n(i.e. the common &T type), whereas most Rust types can only be mutated through\nunique (&mut T) references. We say that Cell and RefCell provide 'interior\nmutability', in contrast with typical Rust types that exhibit 'inherited\nmutability'."),(0,a.kt)("p",{parentName:"blockquote"},"Cell types come in two flavors: Cell and RefCell. Cell provides get and set\nmethods that change the interior value with a single method call. Cell though\nis only compatible with types that implement Copy. For other types, one must\nuse the RefCell type, acquiring a write lock before mutating."),(0,a.kt)("p",{parentName:"blockquote"},"RefCell uses Rust's lifetimes to implement 'dynamic borrowing', a process\nwhereby one can claim temporary, exclusive, mutable access to the inner value.\nBorrows for RefCells are tracked 'at runtime', unlike Rust's native reference\ntypes which are entirely tracked statically, at compile time. Because RefCell\nborrows are dynamic it is possible to attempt to borrow a value that is\nalready mutably borrowed; when this happens it results in thread panic.")),(0,a.kt)("h3",{id:"5-ref--refmut"},"5. Ref & RefMut"),(0,a.kt)("h4",{id:"refmap"},"Ref::map()"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"example1")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"map(Ref< T>, f: F) -> Ref<U>\n// Get Ref<T> from Ref<Node<T>>\n// my example\npub fn peek_front(&self) -> Option<Ref<T>> {\n    self.head.as_ref().map(|node| {\n        Ref::map(node.borrow(), |node| &node.elem)\n    })\n}\n")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"example2")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// Makes a new Ref for a component of the borrowed data.\n\n// The RefCell is already immutably borrowed, so this cannot fail.\n\n// This is an associated function that needs to be used as Ref::map(...). A method would interfere with methods of the same name on the contents of a RefCell used through Deref.\n\nuse std::cell::{RefCell, Ref};\n\nlet c = RefCell::new((5, 'b'));\nlet b1: Ref<(u32, char)> = c.borrow();\nlet b2: Ref<u32> = Ref::map(b1, |t| &t.0);\nassert_eq!(*b2, 5)\n")))}d.isMDXComponent=!0}}]);