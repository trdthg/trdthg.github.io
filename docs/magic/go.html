<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>go - Trdthg&#x27;s Self</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">trans</li><li class="chapter-item expanded "><a href="../../trans/2022-04-20-译-使用-Tokio-处理-CPU-密集型任务.html"><strong aria-hidden="true">1.</strong> 2022-04-20-译-使用-Tokio-处理-CPU-密集型任务</a></li><li class="chapter-item expanded "><a href="../../trans/2023-01-03-译-Rust冒险:-滥用-Serde.html"><strong aria-hidden="true">2.</strong> 2023-01-03-译-Rust冒险:-滥用-Serde</a></li><li class="chapter-item expanded "><a href="../../trans/2023-01-01-译-拓展-Rust-中的-Map.html"><strong aria-hidden="true">3.</strong> 2023-01-01-译-拓展-Rust-中的-Map</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-01-译-search_engine.html"><strong aria-hidden="true">4.</strong> 2022-04-01-译-search_engine</a></li><li class="chapter-item expanded "><a href="../../trans/2022-05-04-译-可视化-Rust-各数据类型的内存布局.html"><strong aria-hidden="true">5.</strong> 2022-05-04-译-可视化-Rust-各数据类型的内存布局</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-13-译-tail_latency.html"><strong aria-hidden="true">6.</strong> 2022-04-13-译-tail_latency</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-30-译-什么时候不应该使用-Rust-？.html"><strong aria-hidden="true">7.</strong> 2022-04-30-译-什么时候不应该使用-Rust-？</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-11-译-异步-Rust：协作与抢占式调度.html"><strong aria-hidden="true">8.</strong> 2022-04-11-译-异步-Rust：协作与抢占式调度</a></li><li class="chapter-item expanded "><a href="../../trans/2023-01-02-译-未初始化内存:-unsafe-Rust太难了.html"><strong aria-hidden="true">9.</strong> 2023-01-02-译-未初始化内存:-unsafe-Rust太难了</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/index.html"><strong aria-hidden="true">10.</strong> 2022-04-03-译-Rust-六边形架构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-4-重构.html"><strong aria-hidden="true">10.1.</strong> Rust-六边形架构-4-重构</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-2-内存存储库.html"><strong aria-hidden="true">10.2.</strong> Rust-六边形架构-2-内存存储库</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-7-长期存储库.html"><strong aria-hidden="true">10.3.</strong> Rust-六边形架构-7-长期存储库</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-1-域.html"><strong aria-hidden="true">10.4.</strong> Rust-六边形架构-1-域</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-5-其他用例.html"><strong aria-hidden="true">10.5.</strong> Rust-六边形架构-5-其他用例</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-6-CLI.html"><strong aria-hidden="true">10.6.</strong> Rust-六边形架构-6-CLI</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-3-HTTP-API.html"><strong aria-hidden="true">10.7.</strong> Rust-六边形架构-3-HTTP-API</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/index.html"><strong aria-hidden="true">10.8.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">note</li><li class="chapter-item expanded "><a href="../../note/java/index.html"><strong aria-hidden="true">11.</strong> java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../note/java/java.html"><strong aria-hidden="true">11.1.</strong> java</a></li><li class="chapter-item expanded "><a href="../../note/java/springboot.html"><strong aria-hidden="true">11.2.</strong> springboot</a></li><li class="chapter-item expanded "><a href="../../note/java/spring.html"><strong aria-hidden="true">11.3.</strong> spring</a></li><li class="chapter-item expanded "><a href="../../note/java/sourceread.html"><strong aria-hidden="true">11.4.</strong> sourceread</a></li><li class="chapter-item expanded "><a href="../../note/java/index.html"><strong aria-hidden="true">11.5.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="../../note/frontend/index.html"><strong aria-hidden="true">12.</strong> frontend</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../note/frontend/mini_bundle.html"><strong aria-hidden="true">12.1.</strong> mini_bundle</a></li><li class="chapter-item expanded "><a href="../../note/frontend/js_advanced.html"><strong aria-hidden="true">12.2.</strong> js_advanced</a></li><li class="chapter-item expanded "><a href="../../note/frontend/mini_vue.html"><strong aria-hidden="true">12.3.</strong> mini_vue</a></li><li class="chapter-item expanded "><a href="../../note/frontend/vue.html"><strong aria-hidden="true">12.4.</strong> vue</a></li><li class="chapter-item expanded "><a href="../../note/frontend/list.html"><strong aria-hidden="true">12.5.</strong> list</a></li><li class="chapter-item expanded "><a href="../../note/frontend/http.html"><strong aria-hidden="true">12.6.</strong> http</a></li><li class="chapter-item expanded "><a href="../../note/frontend/flutter.html"><strong aria-hidden="true">12.7.</strong> flutter</a></li><li class="chapter-item expanded "><a href="../../note/frontend/css.html"><strong aria-hidden="true">12.8.</strong> css</a></li><li class="chapter-item expanded "><a href="../../note/frontend/vdom.html"><strong aria-hidden="true">12.9.</strong> vdom</a></li><li class="chapter-item expanded "><a href="../../note/frontend/index.html"><strong aria-hidden="true">12.10.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">blog</li><li class="chapter-item expanded "><a href="../../blog/index.html"><strong aria-hidden="true">13.</strong> README</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">docs</li><li class="chapter-item expanded "><a href="../../docs/log.html"><strong aria-hidden="true">14.</strong> log</a></li><li class="chapter-item expanded "><a href="../../docs/intro.html"><strong aria-hidden="true">15.</strong> intro</a></li><li class="chapter-item expanded "><a href="../../docs/magic/index.html"><strong aria-hidden="true">16.</strong> magic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../docs/magic/riscv.html"><strong aria-hidden="true">16.1.</strong> riscv</a></li><li class="chapter-item expanded "><a href="../../docs/magic/haskell.html"><strong aria-hidden="true">16.2.</strong> haskell</a></li><li class="chapter-item expanded "><a href="../../docs/magic/bash.html"><strong aria-hidden="true">16.3.</strong> bash</a></li><li class="chapter-item expanded "><a href="../../docs/magic/memory_ordering.html"><strong aria-hidden="true">16.4.</strong> memory_ordering</a></li><li class="chapter-item expanded "><a href="../../docs/magic/linuxIO.html"><strong aria-hidden="true">16.5.</strong> linuxIO</a></li><li class="chapter-item expanded "><a href="../../docs/magic/cicd.html"><strong aria-hidden="true">16.6.</strong> cicd</a></li><li class="chapter-item expanded "><a href="../../docs/magic/fd.html"><strong aria-hidden="true">16.7.</strong> fd</a></li><li class="chapter-item expanded "><a href="../../docs/magic/hadoop.html"><strong aria-hidden="true">16.8.</strong> hadoop</a></li><li class="chapter-item expanded "><a href="../../docs/magic/go.html" class="active"><strong aria-hidden="true">16.9.</strong> go</a></li><li class="chapter-item expanded "><a href="../../docs/magic/async.html"><strong aria-hidden="true">16.10.</strong> async</a></li><li class="chapter-item expanded "><a href="../../docs/magic/index.html"><strong aria-hidden="true">16.11.</strong> README</a></li><li class="chapter-item expanded "><a href="../../docs/magic/software_arch.html"><strong aria-hidden="true">16.12.</strong> software_arch</a></li></ol></li><li class="chapter-item expanded "><a href="../../docs/riscv/index.html"><strong aria-hidden="true">17.</strong> riscv</a></li><li class="chapter-item expanded "><a href="../../docs/common/index.html"><strong aria-hidden="true">18.</strong> common</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../docs/common/pgsql.html"><strong aria-hidden="true">18.1.</strong> pgsql</a></li><li class="chapter-item expanded "><a href="../../docs/common/git.html"><strong aria-hidden="true">18.2.</strong> git</a></li><li class="chapter-item expanded "><a href="../../docs/common/linux.html"><strong aria-hidden="true">18.3.</strong> linux</a></li><li class="chapter-item expanded "><a href="../../docs/common/datastructure.html"><strong aria-hidden="true">18.4.</strong> datastructure</a></li><li class="chapter-item expanded "><a href="../../docs/common/docker.html"><strong aria-hidden="true">18.5.</strong> docker</a></li><li class="chapter-item expanded "><a href="../../docs/common/analyze.html"><strong aria-hidden="true">18.6.</strong> analyze</a></li><li class="chapter-item expanded "><a href="../../docs/common/oci.html"><strong aria-hidden="true">18.7.</strong> oci</a></li><li class="chapter-item expanded "><a href="../../docs/common/unsorted.html"><strong aria-hidden="true">18.8.</strong> unsorted</a></li><li class="chapter-item expanded "><a href="../../docs/common/oauth2.html"><strong aria-hidden="true">18.9.</strong> oauth2</a></li><li class="chapter-item expanded "><a href="../../docs/common/vim.html"><strong aria-hidden="true">18.10.</strong> vim</a></li><li class="chapter-item expanded "><a href="../../docs/common/python.html"><strong aria-hidden="true">18.11.</strong> python</a></li><li class="chapter-item expanded "><a href="../../docs/common/index.html"><strong aria-hidden="true">18.12.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="../../docs/rust/index.html"><strong aria-hidden="true">19.</strong> rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../docs/rust/mini_tokio.html"><strong aria-hidden="true">19.1.</strong> mini_tokio</a></li><li class="chapter-item expanded "><a href="../../docs/rust/wasm.html"><strong aria-hidden="true">19.2.</strong> wasm</a></li><li class="chapter-item expanded "><a href="../../docs/rust/rust_quiz.html"><strong aria-hidden="true">19.3.</strong> rust_quiz</a></li><li class="chapter-item expanded "><a href="../../docs/rust/rust.html"><strong aria-hidden="true">19.4.</strong> rust</a></li><li class="chapter-item expanded "><a href="../../docs/rust/print_into_detail.html"><strong aria-hidden="true">19.5.</strong> print_into_detail</a></li><li class="chapter-item expanded "><a href="../../docs/rust/net-piercer.html"><strong aria-hidden="true">19.6.</strong> net-piercer</a></li><li class="chapter-item expanded "><a href="../../docs/rust/rs_channel.html"><strong aria-hidden="true">19.7.</strong> rs_channel</a></li><li class="chapter-item expanded "><a href="../../docs/rust/lists.html"><strong aria-hidden="true">19.8.</strong> lists</a></li><li class="chapter-item expanded "><a href="../../docs/rust/index.html"><strong aria-hidden="true">19.9.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="../../docs/riscv/index.html"><strong aria-hidden="true">20.</strong> riscv</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../docs/riscv/index.html"><strong aria-hidden="true">20.1.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">other</li><li class="chapter-item expanded "><a href="../../other/2023-04-12-remote-usb.html"><strong aria-hidden="true">21.</strong> 2023-04-12-remote-usb</a></li><li class="chapter-item expanded "><a href="../../other/resources.html"><strong aria-hidden="true">22.</strong> resources</a></li><li class="chapter-item expanded "><a href="../../other/i3wm.html"><strong aria-hidden="true">23.</strong> i3wm</a></li><li class="chapter-item expanded "><a href="../../other/lsm.html"><strong aria-hidden="true">24.</strong> lsm</a></li><li class="chapter-item expanded "><a href="../../other/site_update_log.html"><strong aria-hidden="true">25.</strong> site_update_log</a></li><li class="chapter-item expanded "><a href="../../other/ioclub/index.html"><strong aria-hidden="true">26.</strong> ioclub</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../other/ioclub/share_1.html"><strong aria-hidden="true">26.1.</strong> share_1</a></li><li class="chapter-item expanded "><a href="../../other/ioclub/index.html"><strong aria-hidden="true">26.2.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="../../other/2021-后端/index.html"><strong aria-hidden="true">27.</strong> 2021-后端</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_1.html"><strong aria-hidden="true">27.1.</strong> backend_1</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_2.html"><strong aria-hidden="true">27.2.</strong> backend_2</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_3.html"><strong aria-hidden="true">27.3.</strong> backend_3</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_4.html"><strong aria-hidden="true">27.4.</strong> backend_4</a></li></ol></li><li class="chapter-item expanded "><a href="../../other/2021-后端/index.html"><strong aria-hidden="true">28.</strong> 2021-后端</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_1.html"><strong aria-hidden="true">28.1.</strong> backend_1</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_2.html"><strong aria-hidden="true">28.2.</strong> backend_2</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_3.html"><strong aria-hidden="true">28.3.</strong> backend_3</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_4.html"><strong aria-hidden="true">28.4.</strong> backend_4</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/index.html"><strong aria-hidden="true">28.5.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">draft</li><li class="chapter-item expanded "><a href="../../draft/组成原理.html"><strong aria-hidden="true">29.</strong> 组成原理</a></li><li class="chapter-item expanded "><a href="../../draft/计算机网络.html"><strong aria-hidden="true">30.</strong> 计算机网络</a></li><li class="chapter-item expanded "><a href="../../draft/译-pkg_mng.html"><strong aria-hidden="true">31.</strong> 译-pkg_mng</a></li><li class="chapter-item expanded "><a href="../../draft/DistributedSystem.html"><strong aria-hidden="true">32.</strong> DistributedSystem</a></li><li class="chapter-item expanded "><a href="../../draft/oscamp2022.html"><strong aria-hidden="true">33.</strong> oscamp2022</a></li><li class="chapter-item expanded "><a href="../../draft/compile.html"><strong aria-hidden="true">34.</strong> compile</a></li><li class="chapter-item expanded "><a href="../../draft/test.html"><strong aria-hidden="true">35.</strong> test</a></li><li class="chapter-item expanded "><a href="../../draft/ld.html"><strong aria-hidden="true">36.</strong> ld</a></li><li class="chapter-item expanded "><a href="../../draft/数据库设计.html"><strong aria-hidden="true">37.</strong> 数据库设计</a></li><li class="chapter-item expanded "><a href="../../draft/index.html"><strong aria-hidden="true">38.</strong> README</a></li><li class="chapter-item expanded "><a href="../../draft/computer_network/index.html"><strong aria-hidden="true">39.</strong> computer_network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../draft/computer_network/index.html"><strong aria-hidden="true">39.1.</strong> README</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Trdthg&#x27;s Self</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="go-语言"><a class="header" href="#go-语言">Go 语言</a></h1>
<p>###./ 基础</p>
<h4 id="格式化"><a class="header" href="#格式化">格式化</a></h4>
<pre><code class="language-go">fmt.Printf(&quot;type %T value %v \n&quot;, a, a)
</code></pre>
<h4 id="循环"><a class="header" href="#循环">循环</a></h4>
<pre><code class="language-go">if num := 10; num &gt; 0 {
    fmt.Println(num)
}

for i := 1; i &lt; 10; i++ {
    fmt.Println(i)
    if i == 3 {
        break
    }
}

finger := 2
switch finger {
case 1:
    fmt.Println(1)
case 2:
    fmt.Println(2)
    fallthrough
default:
    println(&quot;sss&quot;)
}

dd := 1
switch {
case dd &gt; 0:
    println(0)
case dd &gt; -1:
    println(-1)
}
</code></pre>
<h4 id="数组"><a class="header" href="#数组">数组</a></h4>
<p>数组有固定大小，数组的大小是类型的一部分，因此 [5]int 和 [25]int 是不同类型</p>
<pre><code class="language-go">a := []int{2}
a[0] = 1
fmt.Println(a)

var b [3][2]int
b = [3][2]int{
    {1, 2},
    {1, 2},
    {1, 2},
}
fmt.Println(b)

veggies := []string{&quot;potatoes&quot;, &quot;tomatoes&quot;, &quot;brinjal&quot;}
fruits := []string{&quot;oranges&quot;, &quot;apples&quot;}
food := append(veggies, fruits...)
fmt.Println(&quot;food:&quot;, veggies, fruits, food)
fmt.Println(&quot;food:&quot;, cap(veggies), cap(fruits), cap(food))
fmt.Println(&quot;food:&quot;, len(veggies), len(fruits), len(food))
nums := []int{1, 2}
change(nums...)
pln(nums...)
</code></pre>
<h4 id="map"><a class="header" href="#map">map</a></h4>
<pre><code class="language-go">// map 的零值为 nil，必须使用 make 初始化
// map 是 引用类型，当 map 被赋值给另一个变量是后，他们共享一个
// map 不能使用==判断，==只能用来判断 map 是否为 nil，应该遍历字典元素去比较两个字典
var mm map[string]int
// mm[&quot;s&quot;] = 1                    // 回报错，map is nil
// fmt.Printf(&quot;%T %v \n&quot;, mm, mm) // 这里虽然能打印出 map[]，但是无济于事
if mm == nil {
    mm = make(map[string]int)
    mm[&quot;s&quot;] = 1
    fmt.Printf(&quot;%T %v \n&quot;, mm, mm)
}
mmm := map[string]int{
    &quot;aaa&quot;: 1,
}
if v, ok := mmm[&quot;aa&quot;]; ok == true {
    fmt.Println(v)
    delete(mmm, &quot;aa&quot;)
} else {
    fmt.Println(&quot;no such key&quot;)
    fmt.Println(len(mmm))
    for k, v := range mmm {
        fmt.Println(k, v)
    }
}
</code></pre>
<h4 id="字符串-与-切片"><a class="header" href="#字符串-与-切片">字符串 与 切片</a></h4>
<pre><code class="language-go">// 字符串
name := &quot;Señor&quot;
for i := 0; i &lt; len(name); i++ {
    fmt.Printf(&quot;%c&quot;, name[i])
}
fmt.Printf(&quot;\n&quot;)
for _, v := range name {
    fmt.Printf(&quot;%c&quot;, v)
}
fmt.Printf(&quot;\n&quot;)
name_ := []rune(name)
for i := 0; i &lt; len(name_); i++ {
    fmt.Printf(&quot;%c&quot;, name_[i])
}
</code></pre>
<p>当对切片调用<code>append(slice, ...elems)</code>是，如果超出切片的 cap，就会重新分配内存空间，因此必须需要用变量接受返回值</p>
<pre><code class="language-go">//关于切片
// a[x] 是 (*a)[x] 的简写形式
// arr := [3]int{1, 2, 3}
// modify(&amp;arr)
// modify(arr[:]) 这种更常用
// arr++ 这种直接进行指针操作不被允许
func modify1(arr *[3]int) {
	(*arr)[0] = 90
}
func modify2(arr *[3]int) {
	arr[0] = 90
}

func change(elems ...int) {
	for i, v := range elems {
		v += 1        // 无效
		elems[i] += 1 // 有效
	}
}

func pln(elems ...int) {
	for i, v := range elems {
		fmt.Printf(&quot;index: %v value %v\n&quot;, i, v)
	}
}
</code></pre>
<h3 id="结构体"><a class="header" href="#结构体">结构体</a></h3>
<ul>
<li>结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。如果两个结构体变量的对应字段相等，则这两个变量也是相等的。</li>
<li>如果结构体包含不可比较的字段，则结构体变量也不可比较。</li>
</ul>
<h4 id="书写"><a class="header" href="#书写">书写</a></h4>
<ul>
<li>
<p>匿名结构体：string,int 就是字段名，字段不能重复</p>
<pre><code class="language-go">type Person struct {
    string
    int
}
person := Person{&quot;aa&quot;, 1}
fmt.Println(person.int, person.string)
</code></pre>
</li>
<li>
<p>提升字段：嵌入的结构体，可以直接调用里面的字段</p>
<pre><code class="language-go">type Group struct {
    string
    int
    Person
}
</code></pre>
</li>
<li>
<p>匿名 + 提升，向上面的情况</p>
<p>匿名的类型可以重复，但是会以自身的为准</p>
<pre><code class="language-go">group := Group{&quot;bb&quot;, 1, person}
fmt.Print(group.string, group.string)
</code></pre>
</li>
</ul>
<h4 id="结构体-tag"><a class="header" href="#结构体-tag">结构体 Tag</a></h4>
<p><strong>格式</strong> 空格分割的键值对</p>
<p><strong>使用</strong> 示例：json 库能够反序列化结构体</p>
<ul>
<li>如果加上 omitepty，当结构体为空是就会被忽略</li>
<li>如果不加，为空的字段会被解析为空字符串&quot;&quot;</li>
</ul>
<pre><code class="language-go">type Person struct {
    Name string `json:&quot;name&quot;`
	Age  int    `json:&quot;age&quot;`
	Addr string `json:&quot;addr&quot;` // ,omitempty
}

func main() {
    p1 := Person{
		Name: &quot;Jack&quot;,
		Age:  22,
	}
	data1, _ := json.Marshal(p1)
	fmt.Printf(&quot;%s\n&quot;, data1)
}
</code></pre>
<p><strong>可以通过反射读取 tag</strong></p>
<pre><code class="language-go">// 三种获取 field
field := reflect.TypeOf(obj).FieldByName(&quot;Name&quot;)
field := reflect.ValueOf(obj).Type().Field(i)  // i 表示第几个字段
field := reflect.ValueOf(&amp;obj).Elem().Type().Field(i)  // i 表示第几个字段

// 获取 Tag
tag := field.Tag

// 获取键值对
labelValue := tag.Get(&quot;label&quot;)  // 获取不到就会返回 &quot;&quot;
labelValue,ok := tag.Lookup(&quot;label&quot;)
</code></pre>
<ul>
<li>获取键值对，有 Get 和 Lookup 两种方法，但其实 Get 只是对 Lookup 函数的简单封装而已，当没有获取到对应 tag
的内容，会返回空字符串。
<pre><code class="language-go">func (tag StructTag) Get(key string) string {
    v, _ := tag.Lookup(key)
    return v
}
</code></pre>
</li>
<li>空 Tag 和不设置 Tag 效果是一样的</li>
</ul>
<h3 id="方法--函数"><a class="header" href="#方法--函数">方法 &amp; 函数</a></h3>
<h4 id="结构体上的方法"><a class="header" href="#结构体上的方法">结构体上的方法</a></h4>
<ul>
<li>结构体方法：不管是一个值，还是一个可以解引用的指针，调用这样的方法都是合法的。或者说：用<strong>一个指针</strong>或者<strong>一个可取得地址的值</strong>来调用都是合法的</li>
<li>匿名字段的方法：属于结构体的匿名字段的方法可以被直接调用，就好像这些方法是属于定义了匿名字段的结构体一样。</li>
</ul>
<pre><code class="language-go">type rectangle struct {
	length int
	width  int
}

func (r *rectangle) area() {
	r.length += 1
}

// func (r rectangle) area() {
// 	r.length += 1
// }

r := rectangle{
    length: 10,
    width:  5,
}

r.area()
(&amp;r).area()
// {12, 5}
// 如果改为 不带*的方法，{10, 5}
</code></pre>
<p>那么什么时候使用指针接收器，什么时候使用值接收器？</p>
<ul>
<li>一般来说，指针接收器可以使用在：对方法内部的接收器所做的改变应该对调用者可见时。</li>
<li>指针接收器也可以被使用在如下场景：当拷贝一个结构体的代价过于昂贵时。考虑下一个结构体有很多的字段。在方法内使用这个结构体做为值接收器需要拷贝整个结构体，这是很昂贵的。在这种情况下使用指针接收器，结构体不会被拷贝，只会传递一个指针到方法内部使用。</li>
<li>在其他的所有情况，值接收器都可以被使用。</li>
</ul>
<h4 id="孤儿规则"><a class="header" href="#孤儿规则">孤儿规则🐶</a></h4>
<p>下面的不允许，因为 int 类型和这个方法，不再同一个包里</p>
<pre><code class="language-go">func (a int) add(b int) {
}
</code></pre>
<p>解决方法</p>
<ul>
<li>定义类型别名</li>
</ul>
<pre><code class="language-go">type myInt int

func (a myInt) add(b myInt) myInt {
    return a + b
}
</code></pre>
<ul>
<li>wrapper 包装</li>
</ul>
<h4 id="函数"><a class="header" href="#函数">函数</a></h4>
<p><strong>匿名函数</strong></p>
<pre><code class="language-go">func main() {
    func(n string) {
        fmt.Println(&quot;Welcome&quot;, n)
    }(&quot;Gophers&quot;)
}
</code></pre>
<p><strong>自定义函数类型</strong></p>
<pre><code class="language-go">type add func(a int, b int) int

func main() {
    var a add = func(a int, b int) int {
        return a + b
    }
    s := a(5, 6)
    fmt.Println(&quot;Sum&quot;, s)
}
</code></pre>
<p><strong>高阶函数</strong></p>
<pre><code class="language-go">// 接受函数
func simple(a func(a, b int) int) {
    fmt.Println(a(60, 7))
}

// 返回函数
func simple() func(a, b int) int {
    f := func(a, b int) int {
        return a + b
    }
    return f
}
</code></pre>
<h3 id="接口"><a class="header" href="#接口">接口</a></h3>
<p>类似于 dyn Train</p>
<pre><code class="language-go">type SalaryCalculator interface {
    CalculateSalary() int
}
employees := []SalaryCalculator{pemp1, pemp2, cemp1}
</code></pre>
<h4 id="接口的断言"><a class="header" href="#接口的断言">接口的断言</a></h4>
<ul>
<li>类型断言</li>
</ul>
<pre><code class="language-go">func assert(i interface{}) {
    v, ok := i.(int)
    fmt.Println(v, ok)
    // 如果不是 int 类型，v 就会被赋为 T 的零值
}
func main() {
    var s interface{} = 56
    assert(s)
    var i interface{} = &quot;Steven Paul&quot;
    assert(i)
}
</code></pre>
<ul>
<li>switch type 注意：把变量传递到函数中后会自动转换类型到 interface，因此调用函数能行，但是下面直接 switch 就不行</li>
<li>回报错：a (variable of type int) is not an interface</li>
</ul>
<pre><code class="language-go">func findType(i interface{}) {
    switch i.(type) {
    case string:
        fmt.Printf(&quot;I am a string and my value is %s\n&quot;, i.(string))
    case int:
        fmt.Printf(&quot;I am an int and my value is %d\n&quot;, i.(int))
    default:
        fmt.Printf(&quot;Unknown type\n&quot;)
    }
}

func main() {
	a := 1
	findType(a)

	switch interface{}(a).(type) {
	case string:
		fmt.Printf(&quot;I am a string and my value is %s\n&quot;, interface{}(a).(string))
	case int:
		fmt.Printf(&quot;I am an int and my value is %d\n&quot;, interface{}(a).(int))
	default:
		fmt.Printf(&quot;Unknown type\n&quot;)
	}
}
</code></pre>
<h4 id="接口类型变量"><a class="header" href="#接口类型变量">接口类型变量</a></h4>
<p>声明一个变量是接口类型，那么这个变量可以被赋值为，任何实现了接口的类型</p>
<pre><code class="language-go">type Describer interface {
    Describe()
}
type Person struct {
    name string
    age  int
}
type Address struct {
    state   string
    country string
}
</code></pre>
<p>现在还不能赋值，接下来为两个 struct 我们实现接口</p>
<p>为 person 实现 describe，使用<strong>值</strong>接受者，下面两种赋值都可以，也都能调用方法</p>
<pre><code class="language-go">func (p Person) Describe() { // 使用值接受者实现
    fmt.Printf(&quot;%s is %d years old\n&quot;, p.name, p.age)
}
var d1 Describer
p1 := Person{&quot;Sam&quot;, 25}
d1 = p1
d1.Describe()
p2 := Person{&quot;James&quot;, 32}
d1 = &amp;p2
d1.Describe()
</code></pre>
<p>为 Address 实现 describer，使用<strong>指针</strong>接受者，下面就比较特殊 d =
a 不能直接赋值，如果是在结构体的方法中，下面的两种赋值都是可以的，但是在接口中不行</p>
<p>其原因是：对于使用指针接受者的方法，用<strong>一个指针</strong>或者<strong>一个可取得地址的值</strong>来调用都是合法的。但接口中存储的具体值（Concrete
Value）并不能取到地址，因此在下面的例子中，对于编译器无法自动获取 a 的地址，于是程序报错。</p>
<pre><code class="language-go">func (a *Address) Describe() { // 使用指针接受者实现
    fmt.Printf(&quot;State %s Country %s&quot;, a.state, a.country)
}
var d Describer
a := Address{&quot;Washington&quot;, &quot;USA&quot;}

//d = a  // 这是不合法的，会报错：Address does not implement Describer

d = &amp;a // 这是合法的，Address 类型的指针实现了 Describer 接口
d.Describe()
</code></pre>
<h4 id="接口可以嵌套"><a class="header" href="#接口可以嵌套">接口可以嵌套</a></h4>
<p>类似于匿名结构体的嵌套 一个结构体实现了 A，B，那就说它也实现了 C</p>
<pre><code class="language-go">type A interface {
    foo()
}

type B interface {
    bar() int
}

type C interface {
    A
    B
}
</code></pre>
<h4 id="接口的零值"><a class="header" href="#接口的零值">接口的零值</a></h4>
<p>接口的零值是 nil，同时其底层值（Underlying Value）和具体类型（Concrete Type）都为 nil。调用方法会 panic</p>
<h4 id="接口的坑"><a class="header" href="#接口的坑">接口的坑</a></h4>
<ul>
<li>不能把 interface 赋值为别的类型
<pre><code class="language-go">func main() {
    // 声明 a 变量，类型 int，初始值为 1
    var a int = 1

    // 声明 i 变量，类型为 interface{}, 初始值为 a，此时 i 的值变为 1
    var i interface{} = a

    // 声明 b 变量，尝试赋值 i
    var b int = i
}
</code></pre>
</li>
<li>切片也不能再分
<pre><code class="language-go">func main() {
    sli := []int{2, 3, 5, 7, 11, 13}

    var i interface{}
    i = sli

    g := i[1:3]
    fmt.Println(g)
}
</code></pre>
</li>
</ul>
<h3 id="channel"><a class="header" href="#channel">channel</a></h3>
<h4 id="特性"><a class="header" href="#特性">特性</a></h4>
<ul>
<li>go 的 channel 默认是双向的，既可以 send，也可以 recv</li>
<li>channel 必须有发送端和接收端，否则就 panic</li>
<li>make(chan int, n) n 表示缓冲区大小，可以省略，默认为 0
<ul>
<li>而对于无缓冲 channel，接受和发送都要在不同携程之间，不让两个人互相阻塞</li>
<li>对于有缓冲区 channel，在缓冲区大小内，两个不会互相阻塞，可以在同一协程内</li>
<li>如果超过缓冲区大小，就会 panic，所以超过缓冲区大小的还是必须在其他的协程中处理</li>
</ul>
</li>
<li>缓冲区也有 len 和 cap 的概念</li>
<li>对于 rust，如果超出缓冲区大小 send 就会返回 Error</li>
</ul>
<pre><code class="language-go">func sendData(sendch chan&lt;- int) {
    sendch &lt;- 10
}

func main() {
    cha1 := make(chan int)
    go sendData(cha1)
    fmt.Println(&lt;-cha1)
}
</code></pre>
<h4 id="单向-channel"><a class="header" href="#单向-channel">单向 channel</a></h4>
<pre><code class="language-go">// 声明参数是一个只能发送的 ch
func sendData(sendch chan&lt;- int) {
    sendch &lt;- 10
}

func main() {
    // 声明一个只能发送的 channel，下面使用它去接受就会 panic
    // 如果声明为 chan int，下面的接受不会 panic，在 sendData 会被转换为只能发送的 channel，而 main 中的仍然是双向的
    sendch := make(chan&lt;- int)
    go sendData(sendch)
    fmt.Println(&lt;-sendch)
}
</code></pre>
<h4 id="关闭-channel"><a class="header" href="#关闭-channel">关闭 channel</a></h4>
<p>不能一直 send 或者一直 recv，处理完及时把一端 close 了</p>
<pre><code class="language-go">func producer(chnl chan int) {
    for i := 0; i &lt; 10; i++ {
        chnl &lt;- i
    }
    // 发送完成后，使用 send 函数显式关闭 channel
    close(chnl)
}

func main() {
    ch := make(chan int)
    go producer(ch)
    for {
        // 通过 ok 判断 channel 是否关闭
        v, ok := &lt;-ch
        if ok == false {
            break
        }
        fmt.Println(&quot;Received &quot;, v, ok)
    }
}
</code></pre>
<h4 id="waitgroup"><a class="header" href="#waitgroup">waitGroup</a></h4>
<p>等待一群协程结束</p>
<p>注意一定要使用指针</p>
<h4 id="工作池"><a class="header" href="#工作池">工作池</a></h4>
<pre><code class="language-go">// 模拟耗时的计算
func calculate(number int) int {
	time.Sleep(2 * time.Second)
	return number
}

// 生产者，分发工作
func produceJobs(jobs chan&lt;- Job, n int) {
	for i := 0; i &lt; n; i++ {
		// fmt.Printf(&quot;sending %d \n&quot;, i)
		jobs &lt;- Job{
			id:     i,
			number: i,
		}
	}
	close(jobs)
}

// 消费者，接受工作，干完活就通知以下管理员
func consumeFunc(jobs &lt;-chan Job, results chan&lt;- int, wg *sync.WaitGroup) {
	// 每个 worker 都在抢工作，真积极啊
	for job := range jobs {
		// fmt.Printf(&quot;id: %d\n&quot;, job.id)
		results &lt;- calculate(job.number)
	}
	wg.Done()
}

// 管理员，等待所有工人都通知他，每次被通知，计数器就减 1，当计数器为 0 是就不再阻塞
func consumeJobs(jobs &lt;-chan Job, results chan&lt;- int, worker_number int) {
	// 等待一批 goroutine 结束，类似于 join
	var wg sync.WaitGroup
	// 为每一个工作开启一个 goroutine
	for i := 0; i &lt; worker_number; i++ {
		wg.Add(1)
		go consumeFunc(jobs, results, &amp;wg)
	}
	wg.Wait() // 阻塞当前 goroutine 直到计数器归 0，所有 job 都应该做完了，result 应该也都发送出去了
	close(results)
}

type Job struct {
	id     int
	number int
}

func main() {
	startTime := time.Now()

	jobs := make(chan Job, 10)
	results := make(chan int, 10)

	// 发送 work, jobs send
	go produceJobs(jobs, 100)
	// jobs recv | results send
	go consumeJobs(jobs, results, 50)
	// results recv
	a := 0
	for res := range results {
		a += res
	}
	fmt.Print(&quot;res: &quot;, a)

	endTime := time.Now()
	diff := endTime.Sub(startTime)
	fmt.Println(&quot;total time taken &quot;, diff.Seconds(), &quot;seconds&quot;)

}
</code></pre>
<h4 id="select"><a class="header" href="#select">select</a></h4>
<p>用法挺普通</p>
<ul>
<li>channel 不限制 send/recv，只要是对 channel 的操作就行</li>
<li>如果有多个 channel 准备就绪，就随机选择一个执行</li>
<li>死锁与默认情况：如果 select 一直没有命中，就会触发死锁，导致 panic，空 select 一样也会导致 panic</li>
<li>可以准备一个 timeout chan，到时间就 send 作为超时信号</li>
</ul>
<pre><code class="language-go">func main() {
    ch := make(chan string)
    select {
    case &lt;-ch:
    default:
        fmt.Println(&quot;default case executed&quot;)
    }
}
</code></pre>
<h3 id="并发"><a class="header" href="#并发">并发</a></h3>
<p>goroutine 不能保证并发安全，下面是一些解决方法</p>
<ul>
<li>总体说来，当 Go 协程需要与其他协程通信时，可以使用 channel。而当只允许一个协程访问临界区时，可以使用 Mutex。</li>
<li>就我们上面解决的问题而言，我更倾向于使用 Mutex，因为该问题并不需要协程间的通信。所以 Mutex 是很自然的选择。</li>
</ul>
<h4 id="mutex"><a class="header" href="#mutex">mutex</a></h4>
<pre><code class="language-go">func aa(wg *sync.WaitGroup, m *sync.Mutex) {
	m.Lock()
	x += 1
	m.Unlock()
	wg.Done()
}

func main() {
    var wg sync.WaitGroup
    var m sync.Mutex
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go aa(&amp;wg, &amp;m)
    }
    wg.Wait()
    fmt.Print(x)
}
</code></pre>
<h4 id="channel-1"><a class="header" href="#channel-1">channel</a></h4>
<p>使用缓冲为 1 的 channel 实现</p>
<pre><code class="language-go">func aa(wg *sync.WaitGroup, ch chan bool) {
	ch &lt;- true
	x += 1
	&lt;-ch
	wg.Done()
}

func main() {
	startTime := time.Now()
	var wg sync.WaitGroup
	var ch = make(chan bool, 1)
	for i := 0; i &lt; 1000; i++ {
		wg.Add(1)
		go aa(&amp;wg, ch)
	}
	wg.Wait()
	fmt.Print(x)
}
</code></pre>
<h3 id="defer"><a class="header" href="#defer">defer</a></h3>
<h4 id="实参求值"><a class="header" href="#实参求值">实参求值</a></h4>
<p>当执行 defer 语句的时候，就会对延迟函数的实参进行求值。</p>
<pre><code class="language-go">func printA(a int) {
    fmt.Println(&quot;value of a in deferred function&quot;, a)
}
func main() {
    a := 5
    defer printA(a)
    a = 10
}
// value of a in deferred function 5
</code></pre>
<h4 id="defer-栈"><a class="header" href="#defer-栈">defer 栈</a></h4>
<p>当一个函数内多次调用 defer 时，Go 会把 defer 调用放入到一个栈中，随后按照后进先出（Last In First Out, LIFO）的顺序执行。</p>
<p>下面的程序，使用 defer 栈，将一个字符串逆序打印。</p>
<pre><code class="language-go">func main() {
    name := &quot;Naveen&quot;
    for _, v := range []rune(name) {
        defer fmt.Printf(&quot;%c&quot;, v)
    }
}
// 倒叙输出：neevaN
</code></pre>
<h4 id="defer-在-return-后执行"><a class="header" href="#defer-在-return-后执行">defer 在 return 后执行</a></h4>
<pre><code class="language-go">import &quot;fmt&quot;

var name string = &quot;go&quot;

func myfunc() string {
    defer func() {
        name = &quot;python&quot;
    }()

    fmt.Printf(&quot;myfunc 函数里的 name：%s\n&quot;, name) // go
    return name
}

func main() {
    myname := myfunc()
    fmt.Printf(&quot;main 函数里的 name: %s\n&quot;, name) // python
    fmt.Println(&quot;main 函数里的 myname: &quot;, myname) // go
}
</code></pre>
<h4 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h4>
<pre><code class="language-go">func (r rect) area(wg *sync.WaitGroup) {
    // defer wg.Done() // 代替下面的 3 个 return 中的 wg.Done()
    if r.length &lt; 0 {
        fmt.Printf(&quot;rect %v's length should be greater than zero\n&quot;, r)
        wg.Done()
        return
    }
    if r.width &lt; 0 {
        fmt.Printf(&quot;rect %v's width should be greater than zero\n&quot;, r)
        wg.Done()
        return
    }
    area := r.length * r.width
    fmt.Printf(&quot;rect %v's area %d\n&quot;, r, area)
    wg.Done()
}
</code></pre>
<h3 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h3>
<h4 id="错误接口"><a class="header" href="#错误接口">错误接口</a></h4>
<p>在标准库里的定义</p>
<pre><code class="language-go">type error interface {
    Error() string
}
</code></pre>
<p>open 函数的设计</p>
<pre><code class="language-go">type PathError struct {
    Op   string
    Path string
    Err  error
}

func (e *PathError) Error() string { return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error() }
</code></pre>
<h4 id="错误类型断言"><a class="header" href="#错误类型断言">错误类型断言</a></h4>
<p>通过类型断言拿到错误信息</p>
<pre><code class="language-go">func main() {
    f, err := os.Open(&quot;/test.txt&quot;)
    if err, ok := err.(*os.PathError); ok {
        fmt.Println(&quot;File at path&quot;, err.Path, &quot;failed to open&quot;)
        return
    }
    fmt.Println(f.Name(), &quot;opened successfully&quot;)
}
</code></pre>
<h4 id="子错误类型"><a class="header" href="#子错误类型">子错误类型</a></h4>
<pre><code class="language-go">type DNSError struct {
    ...
}

func (e *DNSError) Error() string {
    ...
}
func (e *DNSError) Timeout() bool {
    ...
}
func (e *DNSError) Temporary() bool {
    ...
}

func main() {
    addr, err := net.LookupHost(&quot;golangbot123.com&quot;)
    if err, ok := err.(*net.DNSError); ok {
        if err.Timeout() {
            fmt.Println(&quot;operation timed out&quot;)
        } else if err.Temporary() {
            fmt.Println(&quot;temporary error&quot;)
        } else {
            fmt.Println(&quot;generic error: &quot;, err)
        }
        return
    }
    fmt.Println(addr)
}
</code></pre>
<h4 id="panic-和-recover"><a class="header" href="#panic-和-recover">panic 和 recover</a></h4>
<p>下面使用 recover 去恢复 panic</p>
<ul>
<li>注意：Go 协程中调用 recover 才管用。recover 不能恢复一个不同协程的 panic。</li>
</ul>
<pre><code class="language-go">func recoverName() {
    if r := recover(); r!= nil {
        fmt.Println(&quot;recovered from &quot;, r)
    }
}

func fullName(firstName *string, lastName *string) {
    defer recoverName()
    if firstName == nil {
        panic(&quot;runtime error: first name cannot be nil&quot;)
    }
    if lastName == nil {
        panic(&quot;runtime error: last name cannot be nil&quot;)
    }
    fmt.Printf(&quot;%s %s\n&quot;, *firstName, *lastName)
    fmt.Println(&quot;returned normally from fullName&quot;)
}
</code></pre>
<h4 id="恢复后获得堆栈"><a class="header" href="#恢复后获得堆栈">恢复后获得堆栈</a></h4>
<pre><code class="language-go">import (
    &quot;runtime/debug&quot;
)

func r() {
    if r := recover(); r != nil {
        fmt.Println(&quot;Recovered&quot;, r)
        debug.PrintStack()
    }
}
</code></pre>
<h3 id="反射"><a class="header" href="#反射">反射</a></h3>
<p><strong>基础</strong></p>
<pre><code class="language-go">type order struct {
	ordId      int
	customerId int
}

func play(q interface{}) {
	t := reflect.TypeOf(q)
	k := t.Kind()

	v := reflect.ValueOf(q)
	fieldsNum := v.NumField()
	fmt.Println(&quot;Type: &quot;, t, &quot;Kind: &quot;, k)
	fmt.Println(&quot;Value: &quot;, v, &quot;FieldNum: &quot;, fieldsNum)
	for i := 0; i &lt; fieldsNum; i++ {
		fmt.Println(t.Field(i).Name, v.Field(i).Type(), v.Field(i))
	}
}

func createQuery(q interface{}) {
    // 拿到类型
    if reflect.TypeOf(q).Kind() != reflect.Struct {
		return
	}
    // 拿到类型名称
	t := reflect.TypeOf(q).Name()
	query := fmt.Sprintf(&quot;insert into %s values(&quot;, t)
    // 拿到值
	v := reflect.ValueOf(q)
    // 拿到字段数量
	for i := 0; i &lt; v.NumField(); i++ {
        // 拿到字段类型，字段名称，字段值
		switch v.Field(i).Kind() {
		case reflect.Int:
			if i == 0 {
				query = fmt.Sprintf(&quot;%s%d&quot;, query, v.Field(i).Int())
			} else {
				query = fmt.Sprintf(&quot;%s, %d&quot;, query, v.Field(i).Int())
			}
		case reflect.String:
			if i == 0 {
				query = fmt.Sprintf(&quot;%s\&quot;%s\&quot;&quot;, query, v.Field(i).String())
			} else {
				query = fmt.Sprintf(&quot;%s, \&quot;%s\&quot;&quot;, query, v.Field(i).String())
			}
		default:
			fmt.Println(&quot;unsupported field type&quot;)
			return
		}
	}
	query = fmt.Sprintf(&quot;%s)&quot;, query)
	fmt.Println(query)
	return
}

func main() {
	o := order{
		ordId:      456,
		customerId: 56,
	}
	play(o)
	println(&quot;----------------------------------------&quot;)
	createQuery(o)

	var a int = 1
	b := reflect.ValueOf(a).String()
	fmt.Println(reflect.TypeOf(b))
}
</code></pre>
<p><strong>修改类型</strong></p>
<pre><code class="language-go">func main() {
    var age interface{} = 25
    v := reflect.ValueOf(age)
    // 从反射对象到接口变量
    i := v.Interface().(int)
}
</code></pre>
<p><strong>可写性</strong></p>
<pre><code class="language-go">func main() {
    var name string = &quot;Go 编程时光&quot;
    v1 := reflect.ValueOf(&amp;name)
    fmt.Println(&quot;v1 可写性为：&quot;, v1.CanSet())

    v2 := v1.Elem()
    fmt.Println(&quot;v2 可写性为：&quot;, v2.CanSet())
}
</code></pre>
<h2 id="进阶"><a class="header" href="#进阶">进阶</a></h2>
<h3 id="变量"><a class="header" href="#变量">变量</a></h3>
<h4 id="make"><a class="header" href="#make">make</a></h4>
<p>make 函数创建 slice、map 或 chan 类型变量</p>
<p><strong>和 new 的区别</strong></p>
<ul>
<li>
<p>new：为所有的类型分配内存，并初始化为零值，返回指针。</p>
</li>
<li>
<p>make：只能为 slice，map，chan 分配内存，并初始化，返回的是类型 (指针)。因为这三个本身就是引用类型</p>
</li>
<li>
<p>slice、map 和 chan 是 Go 中的引用类型，它们的创建和初始化，一般使用 make。特别的，chan 只能用 make。slice 和 map
还可以简单的方式：</p>
</li>
</ul>
<pre><code class="language-go">slice := []int{0, 0}
m := map[string]int{}
</code></pre>
<h4 id="匿名变量"><a class="header" href="#匿名变量">匿名变量</a></h4>
<ul>
<li>不分配内存，不占用内存空间</li>
</ul>
<h4 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h4>
<p>浮点数转二进制时丢失了精度，计算完再转回十进制时和理论结果不同。</p>
<ul>
<li>f32: 1 8</li>
<li>f64: 1 11</li>
</ul>
<h4 id="作用域"><a class="header" href="#作用域">作用域</a></h4>
<p><strong>分类</strong></p>
<ul>
<li>内置作用域：不需要自己声明，所有的关键字和内置类型、函数都拥有全局作用域</li>
<li>包级作用域：必須函数外声明，在该包内的所有文件都可以访问</li>
<li>文件级作用域：不需要声明，导入即可。一个文件中通过 import 导入的包名，只在该文件内可用</li>
<li>局部作用域：在自己的语句块内声明，包括函数，for、if 等语句块，或自定义的 {} 语句块形成的作用域，只在自己的局部作用域内可用</li>
</ul>
<p><strong>作用规则</strong></p>
<ul>
<li>低层作用域，可以访问高层作用域</li>
<li>同一层级的作用域，是相互隔离的</li>
<li>低层作用域里声明的变量，会覆盖高层作用域里声明的变量</li>
</ul>
<p><strong>动态作用域</strong></p>
<p>下面的 bash 脚本中，func02 在 func01 内部可以访问到 value，但在 func01 外面不能，属于动态作用域</p>
<pre><code class="language-shell">#!/bin/bash
func01() {
    local value=1
    func02
}
func02() {
    echo &quot;func02 sees value as ${value}&quot;
}

# 执行函数
func01
func02
</code></pre>
<h3 id="协程池"><a class="header" href="#协程池">协程池</a></h3>
<pre><code class="language-go">type Pool struct {
	work chan func()   // 任务
	sem  chan struct{} // 使用缓冲区大小控制工人数量
}

func New(size int) *Pool {
	return &amp;Pool{
		work: make(chan func()),
		sem:  make(chan struct{}, size),
	}
}
func (p *Pool) worker(task func()) {
	defer func() { &lt;-p.sem }()
	for {
		task()
		task = &lt;-p.work
	}
}
func (p *Pool) NewTask(task func()) {
	// 第一次加新任务时，work 缓冲区大小为 0，发出去也没人接受，所以一定会走第二个
	// 相当于找到了第一个工人处理任务，worker 本身是个 for 循环，它处理完第一个任务后会继续接受新任务
	// 第二次加入时，就被第一个工人处理了，
	// 如果第三个加入，因为 sem 缓冲区大小的限制，不会继续产生新的 worker
	select {
	case p.work &lt;- task:
	case p.sem &lt;- struct{}{}:
		go p.worker(task)
	}
}
func main() {
	pool := New(2)
	for i := 0; i &lt; 5; i++ {
		pool.NewTask(func() {
			time.Sleep(1 * time.Second)
			fmt.Println(time.Now())
		})
	}
	time.Sleep(4 * time.Second)
}
</code></pre>
<h3 id="动态类型"><a class="header" href="#动态类型">动态类型</a></h3>
<p>接口分为两种<code>iface</code>和<code>eface</code></p>
<p>所有的变量都实现了空接口 (eface)</p>
<pre><code class="language-go">// 定义静态类型
i := (int)(25)
i = &quot;Go 编程时光&quot; // 会报错

// 定义动态类型
i := (interface{})(25)
var i interface{}
i = 18

i = &quot;Go 编程时光&quot; // 上面三种都行，不会报错
</code></pre>
<pre><code class="language-go">var reader io.Reader

tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}

reader = tty
</code></pre>
<p>第一行代码结束后，reader 的静态类型为<code>io.Reader</code>还没有动态类型
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203060928375.png" alt="" />
被赋值为 tty 后，reader 的动态类型变为<code>*os.File</code>
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203060936153.png" alt="" /></p>
<pre><code class="language-go">//不带函数的 interface
var empty interface{}

tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}

empty = tty
</code></pre>
<p>刚开始 empty 是 eface，<code>_type</code>为 nil
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203060938295.png" alt="" />
被赋值后，<code>_type</code>的<strong>静态类型</strong>为<code>*os.File</code>
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203060938635.png" alt="" /></p>
<h3 id="导入"><a class="header" href="#导入">导入</a></h3>
<p>导入方式：</p>
<ul>
<li>绝对导入：从 <code>$GOPATH/src</code> 或 <strong><code>$GOROOT</code></strong> 或者 <code>$GOPATH/pkg/mod</code> 目录下搜索包并导入</li>
<li>相对导入：从当前目录中搜索包并开始导入。就像下面这样</li>
</ul>
<p>注意：</p>
<ul>
<li>导入时，是按照目录导入。导入目录后，可以使用这个目录下的所有包。</li>
<li>只要不是<code>.</code>或<code>..</code>开头，全都是绝对路径</li>
</ul>
<h3 id="context"><a class="header" href="#context">context</a></h3>
<p>当一个 goutine 开启后，只能通过 channel 的通知实现管理，使用 context 更方便了</p>
<p>当你把 Context 传递给多个 goroutine 使用时，只要执行一次 cancel 操作，所有的 goroutine 就可以收到
取消的信号，Context 是线程安全的，可以放心地在多个 goroutine 中使用。</p>
<p>context 创建依赖于 4 个函数</p>
<ul>
<li>withCancel 最普通，只能使用 cancel 去结束</li>
<li>withDeadline 和 WithDeadline 会在超时后自动 cancel，传递的是绝对时间和相对时间</li>
<li>withValue 能够携带一些键值对 (键应该是可比的，值必须是线程安全的)</li>
</ul>
<pre><code class="language-go">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
func WithValue(parent Context, key, val interface{}) Context
</code></pre>
<pre><code class="language-go">func monitor(ctx context.Context, number int)  {
    for {
        select {
        case &lt;- ctx.Done():
            fmt.Printf(&quot;监控器%v，监控结束。\n&quot;, number)
            return
        default:
            fmt.Printf(&quot;监控器%v，正在监控中...\n&quot;, number)
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    ctx01, cancel := context.WithCancel(context.Background())
    ctx02, cancel := context.WithDeadline(ctx01, time.Now().Add(1 * time.Second))

    defer cancel()

    for i :=1 ; i &lt;= 5; i++ {
        go monitor(ctx02, i)
    }

    time.Sleep(5  * time.Second)
    if ctx02.Err() != nil {
        fmt.Println(&quot;监控器取消的原因：&quot;, ctx02.Err())
    }

    fmt.Println(&quot;主程序退出！！&quot;)
}
</code></pre>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651439981&amp;idx=4&amp;sn=b1ad1fd6e9ddf4618b0db904b067f7f6&amp;scene=19#wechat_redirect">2020 重学 Go 系列：34. 图解静态类型与动态类型</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../docs/magic/hadoop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../docs/magic/async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../docs/magic/hadoop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../docs/magic/async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
