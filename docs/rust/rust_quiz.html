<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-rust/rust_quiz">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Rust Quiz | Trdthg&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://trdthg.github.io//docs/rust/rust_quiz"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Rust Quiz | Trdthg&#x27;s blog"><meta data-rh="true" name="description" content="1 statement boundry"><meta data-rh="true" property="og:description" content="1 statement boundry"><link data-rh="true" rel="icon" href="/img/logo_png.png"><link data-rh="true" rel="canonical" href="https://trdthg.github.io//docs/rust/rust_quiz"><link data-rh="true" rel="alternate" href="https://trdthg.github.io//docs/rust/rust_quiz" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://trdthg.github.io//docs/rust/rust_quiz" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Trdthg&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Trdthg&#39;s blog Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4TM86KZ83J"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-4TM86KZ83J",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.6b28552f.css">
<link rel="preload" href="/assets/js/runtime~main.097b9c32.js" as="script">
<link rel="preload" href="/assets/js/main.916d2c7b.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="è·³åˆ°ä¸»è¦å†…å®¹"><a href="#" class="skipToContent_fXgn">è·³åˆ°ä¸»è¦å†…å®¹</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo_png.png" alt="Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo_png.png" alt="Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Trdthg</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">æ–‡æ¡£</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/trdthg" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="åˆ‡æ¢æµ…è‰²/æš—é»‘æ¨¡å¼ï¼ˆå½“å‰ä¸ºæµ…è‰²æ¨¡å¼ï¼‰" aria-label="åˆ‡æ¢æµ…è‰²/æš—é»‘æ¨¡å¼ï¼ˆå½“å‰ä¸ºæµ…è‰²æ¨¡å¼ï¼‰"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="å›åˆ°é¡¶éƒ¨" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/docs/category/-æ‹“å±•">ğŸ”® æ‹“å±•</a><button aria-label="æ‰“å¼€/æ”¶èµ·ä¾§è¾¹æ èœå•ã€ŒğŸ”® æ‹“å±•ã€" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/async">åç¨‹ä¸å¼‚æ­¥</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/bash">Bash</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/cicd">CI/CD</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/fd">æ–‡ä»¶ç³»ç»Ÿ</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/go">Go è¯­è¨€</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/hadoop">å¤§æ•°æ®</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/haskell">Haskell è¯­è¨€</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/linuxIO">IO å¤šè·¯å¤ç”¨</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/memory_ordering">åŸå­æ“ä½œä¸å†…å­˜é¡ºåº</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/software_arch">è½¯ä»¶æ¶æ„</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/-rust-è¯­è¨€">ğŸ¦€ Rust è¯­è¨€</a><button aria-label="æ‰“å¼€/æ”¶èµ·ä¾§è¾¹æ èœå•ã€ŒğŸ¦€ Rust è¯­è¨€ã€" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item green"><a class="menu__link" tabindex="0" href="/docs/rust">Rust è¯­è¨€</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/lists">Too-Many-Lists</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/mini_tokio">å¼‚æ­¥è¿è¡Œæ—¶</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/net-piercer">å†…ç½‘ç©¿é€å·¥å…·</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/print_into_detail">Rust print! å®</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/rs_channel">Channel æºç å‰–æ</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/rust/rust_quiz">Rust Quiz</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/wasm">Wasm å®ç°ç”Ÿå‘½æ¸¸æˆ</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/-å­¦ä¹ ç¬”è®°">ğŸ“š å­¦ä¹ ç¬”è®°</a><button aria-label="æ‰“å¼€/æ”¶èµ·ä¾§è¾¹æ èœå•ã€ŒğŸ“š å­¦ä¹ ç¬”è®°ã€" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/-èµ„æ–™åº“">ğŸ“¦ èµ„æ–™åº“</a><button aria-label="æ‰“å¼€/æ”¶èµ·ä¾§è¾¹æ èœå•ã€ŒğŸ“¦ èµ„æ–™åº“ã€" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/-io-club">âš½ IO Club</a><button aria-label="æ‰“å¼€/æ”¶èµ·ä¾§è¾¹æ èœå•ã€Œâš½ IO Clubã€" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">æ–‡æ¡£é¡µ</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/log">æ—¥å¿—</a></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="é¡µé¢è·¯å¾„"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="ä¸»é¡µé¢" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/-rust-è¯­è¨€"><span itemprop="name">ğŸ¦€ Rust è¯­è¨€</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Rust Quiz</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">æœ¬é¡µæ€»è§ˆ</button></div><div class="theme-doc-markdown markdown"><h1>Rust Quiz</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-statement-boundry">#1 <code>statement boundry</code><a class="hash-link" href="#1-statement-boundry" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ä¸‹é¢çš„ 1 è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿ</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($( $s:stmt )*) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        $(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            { stringify!($s); 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )&lt;&lt;*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;{}{}{}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m! { return || true },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m! { (return) || true },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m! { {return} || true },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º">æç¤º<a class="hash-link" href="#æç¤º" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>å®çš„è¾“å‡ºä¸­çš„è¡¨è¾¾å¼ä¸ <code>1 &lt;&lt; (n - 1)</code> æ•ˆæœç›¸åŒï¼Œå…¶ä¸­ n æ˜¯å®è¾“å…¥ä¸­åŒ…å«çš„ Rust è¯­å¥çš„æ•°é‡ã€‚</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="è§£ç­”">è§£ç­”<a class="hash-link" href="#è§£ç­”" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š122</p><p>è¿™ä¸ªé—®é¢˜å›´ç»•ç€ Rust çš„è¯­æ³•è¾¹ç•Œè®¾è®¡ã€‚</p><blockquote><p>This question revolves around where the Rust grammar places statement
boundaries.</p></blockquote><p>å®çš„è¾“å…¥è§„åˆ™æ˜¯ <code>$( $s:stmt )*</code>, å®ƒèƒ½å¤ŸåŒ¹é…åˆ° 0 æˆ–å¤šä¸ª Rust è¯­å¥ã€‚</p><p>è¯¥è§„åˆ™å†…éƒ¨çš„ <code>$s: stmt</code> æ˜¯ä¸€ä¸ªç‰‡æ®µåˆ†ç±»ç¬¦ï¼Œå®ƒèƒ½å¤ŸåŒ¹é…åˆ°ä¸€ä¸ªç¬¦åˆ Rust è¯­æ³•è§„èŒƒçš„è¡¨è¾¾å¼ã€‚è¢«åŒ¹é…åˆ°çš„è¯­å¥å¯ä»¥åœ¨å±•å¼€åçš„ä»£ç ä¸­ä½œä¸º <code>$s</code> ã€‚</p><p>è€Œå¤–éƒ¨çš„ <code>$(...)*</code> éƒ¨åˆ†è¡¨ç¤ºä¸€ä¸ªé‡å¤ï¼Œå®ƒå¯ä»¥é‡å¤åŒ¹é… 0 æˆ–å¤šæ¬¡å†…å®¹ã€‚</p><blockquote><p>The input rule of the macro m! is $($s:stmt)<em>which matches zero or more Rust
statements. The $(...)</em> part of the rule is a repetition which matches the
contents of the repetition zero or more times, and the $s:stmt is a fragment
specifier that matches a Rust statement (stmt) conforming to the rules of the
Rust grammar. The matched statements are available within the expanded code as
the fragment variable $s.</p></blockquote><p>è¯­å¥æ˜¯å‡½æ•°ä½“ä¸­å…è®¸çš„æœ€é«˜çº§åˆ«çš„è¯­æ³•å•ä½ã€‚ä¸‹é¢æ‰€æœ‰çš„å†…å®¹éƒ½æ˜¯è¯­å¥çš„ä¾‹å­ã€‚</p><blockquote><p>A statement is the top-level unit of syntax permitted within a function body.
All of the following are examples of statements.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Items are statements.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct S { x: u64 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Let-bindings are statements.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut s = S { x: 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Expressions are statements.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">s.x + 1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>å‡½æ•°ä½“çš„è¯­æ³•è¦æ±‚æŸäº›ç±»å‹çš„è¯­å¥åé¢æœ‰ä¸€ä¸ªåˆ†å·ï¼Œä½†å¯¹äºå®çš„è¯­æ³•è€Œè¨€ï¼Œåˆ†å·å¹¶ä¸æ˜¯è¯­å¥çš„ä¸€éƒ¨åˆ†ã€‚</p><blockquote><p>The grammar of function bodies requires that some types of statements are followed by a semicolon, but the semicolon is not part of the statement for the purpose of macro syntax.</p></blockquote><p><code>m!</code> å°†ä¼šå±•å¼€æˆ 0 æˆ–å¤šä¸ªç”± <code>&lt;&lt;</code> åˆ†å‰²çš„ <code>{ stringify!($s); 1 }</code>ã€‚<code>$(...)&lt;&lt;*</code> éƒ¨åˆ†è¡¨ç¤ºé‡å¤è¯­å¥ä¹‹é—´ä½¿ç”¨ <code>&lt;&lt;</code> ä½œä¸ºåˆ†éš”ç¬¦ã€‚</p><blockquote><p>The macro m! expands to zero or more copies of <code>{ stringify!($s); 1 }</code> separated by the <code>&lt;&lt;</code> token. The <code>$(...)&lt;&lt;*</code> part of the rule is a repetition using <code>&lt;&lt;</code> as the separator.</p></blockquote><p>åœ¨å®ä¸­ä½¿ç”¨ <code>&lt;&lt;</code> ä½œä¸ºåˆ†éš”ç¬¦éå¸¸ä¸å¸¸è§ã€‚æœ€å¸¸ç”¨çš„åˆ†éš”ç¬¦æ˜¯é€—å·ï¼Œ<code>$(...),*</code>ï¼Œå…¶ä»–çš„å•ä¸€ç¬¦å·ä¹Ÿæ˜¯å…è®¸çš„ã€‚é‡è¦çš„æ˜¯ï¼Œ<code>macro_rules!</code> æŠŠæ‰€æœ‰çš„ Rust å†…ç½®æ“ä½œç¬¦éƒ½å½“æˆå• token</p><blockquote><p>Using <code>&lt;&lt;</code> as a separator in a repetition in a macro is highly unusual. The most commmonly used separator is the comma, written as <code>$(...),*</code>, but any other single token is allowed here. Crucially, macro_rules! treats all built-in Rust operators as single tokens, even those that consist of multiple characters like <code>&lt;&lt;</code>.</p></blockquote><p><code>{ stringify!($s); 1 }</code> æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒçš„è¿”å›å€¼æ°¸è¿œæ˜¯ 1ã€‚<code>stringify!($s)</code> è¢«ä¸¢å¼ƒäº†ï¼Œæ‰€ä»¥å®ƒå’Œ <code>{ 1 }</code> çš„æ•ˆæœæ˜¯ç›¸åŒçš„ã€‚è¿™é‡Œä½¿ç”¨ <code>stringify!($s)</code> æ˜¯ä¸ºäº†æ§åˆ¶é‡å¤çš„æ¬¡æ•°ï¼Œè§„åˆ™ä¸­å®šä¹‰çš„æ ‡å¿—ç¬¦</p><blockquote><p>The <code>{ stringify!($s); 1 }</code> is an expression whose value is always 1. The value of <code>stringify!($s)</code> is discarded, so this is equivalent to the expression <code>{ 1 }</code>. The reason for having <code>stringify!($s)</code> in there is to control the number of times the repetition is repeated, which is determined by which fragment variables are used within the repetition. Writing a repetition without using any fragment variables inside of it would not be legal.</p></blockquote><p>å‡è®¾æˆ‘ä»¬è°ƒç”¨å®æ—¶ä¼ å…¥ä¸‰æ¡è¯­å¥ï¼š</p><blockquote><p>Suppose we call this macro with three of the statements shown above as input.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">m! {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct S { x: u64 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = S { x: 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.x + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>è¿™ä¸ªå®ä¼šè¢«å±•å¼€ä¸ºï¼š</p><blockquote><p>The macro expands to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{ stringify!(struct S { x: u64 }); 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { stringify!(let mut s = S { x: 1 }); 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { stringify!(s.x + 1); 1 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æ¯ä¸ª stringifys éƒ½ä¼šè¢«è½¬ä¸ºå­—ç¬¦ä¸²å­—é¢é‡ï¼š</p><blockquote><p>Each of the stringifys expands to a string literal:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{ &quot;struct S { x: u64 }&quot;; 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { &quot;let mut s = S { x: 1 }&quot;; 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { &quot;s.x + 1&quot;; 1 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>å­—ç¬¦ä¸²å­—é¢é‡çš„å€¼æ²¡æœ‰è¢«ä½¿ç”¨ã€‚æ‰€ä»¥è¿™ä¸ªç»“æœç­‰ä»·äº <code>{ 1 } &lt;&lt; { 1 } &lt;&lt; { 1 }</code>ï¼Œä¹Ÿç­‰ä»·äº <code>1 &lt;&lt; 1 &lt;&lt; 1</code>ã€‚<code>&lt;&lt;</code> æ“ä½œç¬¦å°±æ˜¯å·¦ç§»ï¼›ç»“æœæ˜¯ 4ã€‚</p><blockquote><p>The values of the string literals are not used. In this case the expression is equivalent to <code>{ 1 } &lt;&lt; { 1 } &lt;&lt; { 1 }</code>, which is equivalent to <code>1 &lt;&lt; 1 &lt;&lt; 1</code>. The <code>&lt;&lt;</code> operator is left-associative; the numeric value of this expression is 4.</p></blockquote><p>æ€»çš„æ¥è¯´ï¼ŒRust è¯­å¥æœ‰å¤šå°‘ï¼Œ1 å°±é‡å¤å¤šå°‘æ¬¡ã€‚æ‰€ä»¥è¿™ä¸ªå®å°±ç›¸å½“äº <code>1 &lt;&lt; (n - 1)</code>ã€‚å½“ n ä¸º 0 æ—¶ï¼Œè¯­å¥æ— æ³•å±•å¼€ï¼Œä¼šç¼–è¯‘å¤±è´¥ã€‚</p><blockquote><p>Altogether, the relevant behavior of this macro is that it evaluates to <code>1 &lt;&lt; 1 &lt;&lt; 1 &lt;&lt; ...</code> where the number of ones is equal to the number of Rust statements in the input of the macro. In closed form, the numeric value is <code>1 &lt;&lt; (n - 1)</code> where n is the number of statements, except in the case that n is zero where the macro expands to nothing and we get a syntax error at the call site.</p></blockquote><p>å‰©ä¸‹çš„å°±æ˜¯åˆ¤æ–­ä¸€ä¸‹è¿™ 3 æ¬¡è°ƒç”¨åˆ†åˆ«ä¼ å…¥äº†å¤šå°‘ä¸ª Rust è¯­å¥ã€‚</p><blockquote><p>It remains to determine how many statements are in the three invocations of m! in the quiz code.</p></blockquote><ol><li><code>return || true</code></li></ol><p>è¿™æ˜¯ä¸€æ¡ return è¯­å¥ï¼Œä»–è¿”å›çš„ y æ˜¯ä¸€ä¸ªé—­åŒ… <code>|| true</code>ã€‚ç­‰ä»·äº <code>(|| true)</code>ã€‚æ‰€ä»¥ä»–ä¼šè¢«è§£æä¸ºä¸€æ¡è¯­å¥ï¼Œè°ƒç”¨ <code>m!</code> çš„ç»“æœæ˜¯ 1ã€‚</p><blockquote><p>This is a return-expression that would return the closure <code>|| true</code>. It is
equivalent to return <code>(|| true)</code>. It is parsed as a single statement so the m! invocation evaluates to 1</p></blockquote><ol start="2"><li><code>(return) || true</code></li></ol><p>è¿™æ˜¯ä¸€æ¡é€»è¾‘æˆ–è¯­å¥ã€‚<code>||</code> æ˜¯ä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦ï¼Œå·¦ä¾§æ˜¯ä¸€ä¸ª <code>(return)</code> è¯­å¥ (æˆ–è€…è¯´ <code>!</code> ç±»å‹)ï¼Œå³ä¾§æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ <code>true</code>ã€‚æ‰€ä»¥ <code>(return) || true</code> æ˜¯ä¸€ä¸ªè¯­å¥ï¼Œ<code>m!</code> çš„å€¼ä»ç„¶ä¸º 1ã€‚</p><blockquote><p>This is a logical-OR expression. The <code>||</code> is a binary operator, where the left-hand side is the expression <code>(return)</code> (of diverging type <code>!</code>) and the right-hand side is the expression <code>true</code>. This expression is a single statement so m! again evaluates to 1.</p></blockquote><ol start="3"><li><code>{return} || true</code></li></ol><p>è¿™æ¡æ˜¯ä¸¤ä¸ªè¯­å¥ï¼ä¸€ä¸ªå—è¡¨è¾¾å¼ <code>return</code>ï¼Œåé¢åˆè·Ÿä¸€ä¸ªé—­åŒ… <code>|| true</code>ã€‚</p><blockquote><p>This one is two statements! A block-statement <code>{return}</code> followed by a closure expression <code>|| true</code>.</p></blockquote><p>Rust çš„è¯­æ³•åŒºåˆ†äº†éœ€è¦åˆ†å·çš„è¡¨è¾¾å¼ (ä½œä¸ºå•ä¸ªè¡¨è¾¾å¼) å’Œæ— éœ€åˆ†å·çš„ä¸€ç»„è¡¨è¾¾å¼ã€‚çœ‹çœ‹ä¸‹é¢çš„ä¸¤ä¸ªä¾‹å­ï¼š</p><blockquote><p>The Rust grammar distinguishes between expressions that require a semicolon in order to stand alone as a statement, and expressions that can be statements even without a semicolon. Consider two examples:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ç»“å°¾ä¸éœ€è¦åˆ†å·ã€‚</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for t in vec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* ... */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// ç»“å°¾éœ€è¦åˆ†å·ã€‚</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">self.skip_whitespace()?;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ä¸éœ€è¦åˆ†å·çš„è¡¨è¾¾å¼éƒ½å®šä¹‰åœ¨ libsyntex é‡Œã€‚The distinction informs a few different early bail-out cases where the parser decides to finish parsing the current expression.(èƒ½åŠ›æœ‰é™ï¼Œä¸ä¼šç¿»è¯‘)</p><blockquote><p>The list of expression types that stand alone without a semicolon is defined here in libsyntax. The distinction informs a few different early bail-out cases where the parser decides to finish parsing the current expression.</p></blockquote><p>å—è¡¨è¾¾å¼ <code>{ /* ... */ }</code> ç»ˆæ­¢ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå’Œæœ¬é¢˜çš„æƒ…å†µç›¸åŒã€‚å¦‚æœè¿™æ ·åšåœ¨è¯­æ³•ä¸Šæ˜¯åˆç†çš„ï¼Œé‚£å°±æ„å‘³ç€è§£æå™¨åœ¨å—è¡¨è¾¾å¼ä¹‹åä¸ä¼šç«‹å³æ¶ˆè€—äºŒå…ƒè¿ç®—ç¬¦ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ã€‚</p><blockquote><p>Relevant to our case is that block expressions <code>{ /* ... */ }</code> terminate an expression if doing so would be syntactically sensible. The parser does not eagerly consume binary operators after a block expression. Thus one might write:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn f() -&gt; &amp;&#x27;static &amp;&#x27;static bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // å—è¡¨è¾¾å¼ã€‚</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;What a silly function.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // true çš„å¼•ç”¨çš„å¼•ç”¨ã€‚</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;&amp;true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ä¸ºäº†æ­£ç¡®è§£æè¿™ç§æƒ…å†µï¼ˆå—è¡¨è¾¾å¼åé¢ç´§è·Ÿä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦ï¼‰ï¼Œè§£æå™¨éœ€è¦åœ¨è¡¨è¾¾å¼çš„æœ«å°¾åŠæ—¶ç»ˆæ­¢ã€‚</p><blockquote><p>In order to parse a block followed by a binary operator, we would need to make it syntactically insensible for the parser to terminate an expression at the close curly brace. This would usually be done by wrapping in parentheses.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn f() -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ({ true } &amp;&amp; true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æ€»ä¹‹ï¼Œè¯¥ç¨‹åºçš„è¾“å‡ºæ˜¯ 112ã€‚</p><blockquote><p>Anyhow, the output of the program is 112.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-impl-bitand">#2 <code>impl BitAnd</code><a class="hash-link" href="#2-impl-bitand" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-1">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-1" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S(i32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl std::ops::BitAnd&lt;S&gt; for () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Output = ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn bitand(self, rhs: S) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, rhs.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = || ( () &amp; S(1) );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let g = || { () &amp; S(2) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let h = || ( {} &amp; S(3) );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let i = || { {} &amp; S(4) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    h();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-1">æç¤º<a class="hash-link" href="#æç¤º-1" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>å…¶ä¸­ä¸€ä¸ªé—­åŒ…å’Œå¦å¤–ä¸‰ä¸ªä¸åŒã€‚</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£">é¢˜è§£<a class="hash-link" href="#é¢˜è§£" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š123</p><p>fï¼Œg å’Œ h éƒ½æ˜¯ <code>impl Fn()</code>ã€‚é—­åŒ…çš„ body éƒ½ä¼šè¢«è§£æä¸ºå¯¹ä¸Šé¢ç”± BitAnd Trait å®šä¹‰çš„ bitwise-AND æ“ä½œç¬¦çš„è°ƒç”¨ã€‚å½“é—­åŒ…è¢«è°ƒç”¨æ—¶ï¼Œbitwise-AND ä¼šæ‰“å°å‡ºå³ä¾§ S çš„å†…å®¹ï¼Œé—­åŒ…åˆ™è¿”å› <code>()</code>ã€‚</p><blockquote><p>The closures f, g, and h are all of type impl Fn(). The closure bodies are parsed as an invocation of the user-defined bitwise-AND operator defined above by the BitAnd trait impl. When the closures are invoked, the bitwise-AND implementation prints the content of the S from the right-hand side and evaluates to ().</p></blockquote><p>é—­åŒ… i åˆ™ä¸ç—›ã€‚ä½¿ç”¨ rustfmt æ ¼å¼åŒ–ä»£ç ä¼šè®©ä»–æ›´æ¸…æ™°ï¼š</p><blockquote><p>The closure i is different. Formatting the code with rustfmt makes it clearer how i is parsed.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let i = || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;S(4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>é—­åŒ…ä½“ç”±ä¸€ä¸ªç©ºçš„å—çŠ¶è¯­å¥ {} å’Œåé¢çš„å¯¹ S(4) çš„å¼•ç”¨ç»„æˆï¼Œè€Œä¸æ˜¯ä¸€ä¸ª bitwise-AND æ“ä½œã€‚i çš„ç±»å‹æ˜¯ <code>impl Fn() -&gt; &amp;&#x27;static S</code>ã€‚</p><blockquote><p>The closure body consists of an empty block-statement {} followed by a reference to S(4), not a bitwise-AND. The type of i is impl Fn() -&gt; &amp;&#x27;static S.</p></blockquote><p>f å¯¹è¿™ç§æƒ…å†µçš„è§£ææ˜¯ç”± libsyntax ä¸­çš„ä»£ç ç®¡ç†çš„ã€‚</p><blockquote><p>The parsing of this case is governed by this code in libsyntax.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-const-initializer">#3 <code>const initializer</code><a class="hash-link" href="#3-const-initializer" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-2">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-2" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const S: S = S { x: 2 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = &amp;mut S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.x += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S.x += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}{}&quot;, v.x, S.x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-2">æç¤º<a class="hash-link" href="#æç¤º-2" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p><code>const</code> å’Œ ä¸å¯å˜çš„ <code>static</code> æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-1">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-1" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š32</p><p>const çš„è¯­ä¹‰æ˜¯ï¼Œä»»ä½•åœ¨è¡¨è¾¾å¼ä½ç½®ä¸Šä»¥åç§°æåŠçš„ <code>const</code> éƒ½ä¼šè¢« const initializer çš„å€¼æ‰€æ›¿ä»£ã€‚ä¸Šé¢çš„ä»£ç å…¶å®ç­‰åŒäºï¼š</p><blockquote><p>The semantics of const is that any mention of the const by name in expression position is substituted with the value of the const initializer. In this quiz code the behavior is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = &amp;mut S { x: 2 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.x += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S { x: 2 }.x += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}{}&quot;, v.x, S { x: 2 }.x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>è¿™é‡Œæˆ‘åªæ˜¯ç®€å•åœ°æŠŠæ¯ä¸€ä¸ªæåˆ° S çš„åœ°æ–¹éƒ½ç”¨ <code>const S</code> çš„å€¼æ¥ä»£æ›¿ï¼Œå³ <code>S { x: 2 }</code>ã€‚</p><blockquote><p>I have simply substituted every mention of S in expresson position with the value of const S which is S { x: 2 }.</p></blockquote><p>main çš„ç¬¬ä¸€è¡Œç­‰åŒäºï¼š</p><blockquote><p>The first line of main is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let mut _tmp0 = S { x: 2 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let v = &amp;mut _tmp0;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>main çš„ç¬¬äºŒè¡Œæ”¹å˜äº† v æŒ‡å‘çš„ xï¼Œåœ¨ v å‰©ä½™çš„ç”Ÿå‘½æœŸå†…ï¼Œx ä»ç„¶å¯ä»¥é€šè¿‡ v è®¿é—®ï¼Œå› æ­¤æ‰“å°çš„ç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯ 3ã€‚</p><blockquote><p>The second line of main mutates the value pointed to by v. The same value remains accessible through v for the rest of the lifetime of v, which is why the first character printed is 3.</p></blockquote><p>main çš„ç¬¬ä¸‰è¡Œæ”¹å˜äº†ä¸€ä¸ªä¸´æ—¶å˜é‡ï¼Œè¯¥å˜é‡åœ¨åˆ†å·ç»“å°¾å°±ç«‹å³è¶…å‡ºäº†ä½œç”¨åŸŸã€‚æ‰“å°çš„ç¬¬äºŒä¸ªå­—ç¬¦æ¥è‡ªä¸€ä¸ªå…¨æ–°çš„<code>S { x: 2 }</code>ï¼Œæ‰€ä»¥ç¬¬äºŒä¸ªæ‰“å°çš„æ˜¯ 2ã€‚</p><blockquote><p>The third line of main mutates a temporary that immediately goes out of scope at the semicolon. The second character printed is coming from a brand new S { x: 2 }, so 2 is printed.</p></blockquote><p>è¿™æ®µä»£ç ä¸­è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œæ˜¯ Rust ä¸­å…³äºå‘½åç©ºé—´å’Œåå­—è§£æçš„æ¦‚å¿µã€‚ä»»ä½•æŒ‡ä»£ç±»å‹çš„åå­—éƒ½åœ¨ç±»å‹å‘½åç©ºé—´ï¼Œä»»ä½•æŒ‡ä»£å€¼çš„åå­—éƒ½åœ¨å€¼å‘½åç©ºé—´ã€‚</p><p>è¿™æ˜¯ä¸¤ç»„ä¸åŒçš„åå­—ï¼Œè€Œè¯­è¨€çš„ç»“æ„ä½¿æˆ‘ä»¬æ€»æ˜¯å¯ä»¥çŸ¥é“åœ¨å“ªä¸ªå‘½åç©ºé—´ä¸­æŸ¥æ‰¾ä¸€ä¸ªåå­—ã€‚</p><blockquote><p>One additional wrinkle in this code is the concept of namespaces and name resolution in Rust. Any name that refers to a type lives in the type namespace, and any name that refers to a value lives in the value namespace. These are two separate sets of names, and the language is structured such that we can always tell which namespace to look up a name in.</p></blockquote><p>åœ¨ä»£ç çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œç»“æ„ä½“ S çš„åç§°æ˜¯ç±»å‹åç§°ç©ºé—´çš„ä¸€éƒ¨åˆ†ï¼Œè€Œå¸¸é‡ S çš„åç§°æ˜¯å€¼åç§°ç©ºé—´çš„ä¸€éƒ¨åˆ†ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬å¯ä»¥ï¼Œåœ¨åŒä¸€æ—¶é—´çœ‹åˆ°ä¸¤ä¸ªç›¸åŒåç§°çš„ä¸åŒäº‹ç‰©ã€‚</p><blockquote><p>In the context of the quiz code, the name of the struct S is part of the type namespace and the name of the const S is part of the value namespace. That is how we can have seemingly two different things with the same name in scope at the same time.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-">#4 <code>..</code><a class="hash-link" href="#4-" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-3">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-3" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (.., x, y) = (0, 1, ..);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, b&quot;066&quot;[y][x]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-3">æç¤º<a class="hash-link" href="#æç¤º-3" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p><code>..</code> åœ¨è¡¨è¾¾ä¸­å’Œæ¨¡å¼åŒ¹é…ä¸­å«ä¹‰ä¸åŒã€‚</p><blockquote><p>.. means one thing in an expression and something else in a pattern.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-2">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-2" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š54</p><p>è¿™ä¸ªé—®é¢˜å±•ç¤ºäº† <code>..</code>ä¸åŒå«ä¹‰</p><blockquote><p>This question demonstrates two different meanings of ...</p></blockquote><p>åœ¨è¡¨è¾¾å¼çš„ä¸€ä¾§ (å³ä¾§), <code>..</code> æ˜¯æ„é€ é—° <code>Range</code> ç±»å‹çš„è¯­æ³•ï¼Œè¡¨è¾¾å¼ <code>(0, 1, ..)</code> æ˜¯ä¸€ä¸ªæ‹¥æœ‰ä¸‰ä¸ªå…ƒç´ çš„å…ƒç»„ï¼Œå…¶ä¸­çš„ç¬¬ä¸‰ä¸ªæ‹¥æœ‰ RangeFull ç±»å‹ã€‚</p><blockquote><p>In expression position, .. is the syntax for constructing various types of ranges. Here the expression (0, 1, ..) is a tuple with three elements, the third one having type RangeFull.</p></blockquote><p>åœ¨æ¨¡å¼çš„ä¸€ä¾§ï¼Œ<code>..</code> è¢«ç”¨æ¥è¡¨ç¤ºä»»ä½•æ•°é‡çš„å…ƒç´ ã€‚æ‰€ä»¥æ¨¡å¼ <code>(.., x, y)</code> ä¼šåŒ¹é…åˆ°ä¸€ä¸ªæ‹¥æœ‰ä¸¤ä¸ªæˆ–è€…æ›´å¤šå…ƒç´ çš„å…ƒç»„ï¼Œå¹¶æŠŠå€’æ•°ç¬¬ 2 ä¸ªå…ƒç´ ç»‘å®šåˆ° x ä¸Šï¼Œæœ€åä¸€ä¸ªæ•°ç»‘å®šåˆ° y ä¸Šã€‚</p><blockquote><p>On the other hand in a pattern, .. is used to mean &quot;any number of elements&quot;. So the pattern (.., x, y) matches a tuple with 2 or more elements, binding the second-last one to x and the last one to y.</p></blockquote><p>æ‰€ä»¥åœ¨é¢çš„ç¬¬ 1 è¡Œï¼Œx çš„å€¼ä¸º 1ï¼Œy çš„å€¼ä¸º <code>(..)</code>ã€‚å› æ­¤æ‰“å°å‡ºæ¥çš„æ˜¯ <code>b&quot;066[..][1]&quot;</code>ã€‚</p><blockquote><p>Coming out of the first line of main, we have x = 1 and y = (..). Thus the value printed is going to be b&quot;066&quot;<!-- -->[..][1]<!-- -->.</p></blockquote><p><code>b&quot;066&quot;</code> æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä»–æ˜¯ä¸€ä¸ª Byte å½¢å¼çš„å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå®ƒçš„ç±»å‹æ˜¯ <code>&amp;&#x27;static [u8; 3]</code>, æ‹¥æœ‰ä¸‰ä¸ª ASCII å­—ç¬¦ <code>b&#x27;0&#x27;</code>, <code>b&#x27;6&#x27;</code>, <code>b&#x27;6&#x27;</code>ã€‚</p><blockquote><p>The expression b&quot;066&quot; is a byte-string literal of type &amp;&#x27;static <!-- -->[u8; 3]<!-- --> containing the three ASCII bytes b&#x27;0&#x27;, b&#x27;6&#x27;, b&#x27;6&#x27;.</p></blockquote><p>å½“æˆ‘ä»¬ç”¨ RangeFull å¯¹å­—èŠ‚ä¸²è¿›åˆ‡ç‰‡æ—¶ï¼Œæˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªé•¿åº¦ä¸º 3 çš„åŠ¨æ€å¤§å°çš„åˆ‡ç‰‡ <!-- -->[u8]<!-- -->ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬è®¿é—®åˆ‡ç‰‡åœ¨ 1 å¤„çš„å…ƒç´ ï¼Œå³ç±»å‹ä¸º u8 çš„å­—èŠ‚ <code>b&#x27;6&#x27;</code>ã€‚å½“æ‰“å°æ—¶ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„æ˜¯ ASCII æ•°å­— 6 çš„åè¿›åˆ¶è¡¨ç¤ºï¼Œä¹Ÿå°±æ˜¯æ•°å­— 54ã€‚</p><blockquote><p>When we slice the byte-string with RangeFull we get a dynamically sized slice <!-- -->[u8]<!-- --> of length 3. Next we access element 1 of the slice, which is the byte b&#x27;6&#x27; of type u8. When printed, we see the decimal representation of the byte value of the ASCII digit 6, which is the number 54.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-t-or-t">#5 <code>T or &amp;T</code><a class="hash-link" href="#5-t-or-t" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-4">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-4" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; Trait for fn(T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; Trait for fn(&amp;T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn f(_: u8) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn g(_: &amp;u8) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a: fn(_) = f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b: fn(_) = g;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c: fn(&amp;_) = g;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a.p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b.p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c.p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-4">æç¤º<a class="hash-link" href="#æç¤º-4" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>å¦‚æœä½ ç†Ÿæ‚‰é«˜çº§ç”Ÿå‘½å‘¨æœŸç»‘å®šçš„è¯­æ³•ï¼Œå¯ä»¥å°è¯•å°† impl ç­¾åä¸­çš„æ‰€æœ‰ç±»å‹å’Œ main ä¸­çš„ç±»å‹è§£æ„ä¸ºå®Œå…¨æ˜¾å¼çš„å½¢å¼ã€‚</p><blockquote><p>If you are familiar with higher-rank trait bound syntax, try desugaring all the types in the impl signatures and types in main into their fully explicit form.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-3">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-3" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š112</p><p>ç¬¬ä¸€ä¸ª impl é€‚ç”¨äº <code>fn(T)</code> ç±»å‹çš„å‡½æ•°æŒ‡é’ˆï¼Œå…¶ä¸­ T æ˜¯ä»»ä½•å•ä¸€çš„å…·ä½“ç±»å‹ã€‚ç¬¬äºŒä¸ª impl é€‚ç”¨äºæ›´é«˜ç­‰çº§çš„ <code>for&lt;&#x27;a&gt; fn(&amp;&#x27;a T)</code> ç±»å‹çš„å‡½æ•°æŒ‡é’ˆï¼Œå…¶ä¸­ T ç±»å‹çš„ç”Ÿå‘½å‘¨æœŸè¶…è¿‡ <code>&#x27;a</code>ã€‚</p><blockquote><p>The first impl applies to function pointers of type fn(T) where T is any single concrete type. The second impl applies to function pointers of higher-ranked type for&lt;&#x27;a&gt; fn(&amp;&#x27;a T) for some concrete type T that outlives &#x27;a.</p></blockquote><p>åœ¨ main ä¸­ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨ä½¿ç”¨ç±»å‹æ¨å¯¼ï¼Œç”¨æŸç§å…·ä½“çš„ç±»å‹æ¥æ›¿ä»£æ‰€æœ‰å‡ºç°çš„ <code>_</code>ã€‚</p><blockquote><p>Inside of main, the compiler is going to use type inference to substitute all occurrences of _ in a type by some concrete type.</p></blockquote><p>å¯¹äºé—­åŒ… aï¼Œæˆ‘ä»¬æ¨æ–­ <code>_ = u8</code>ï¼Œé—­åŒ…ç±»å‹ä¸º <code>fn(u8)</code>ï¼Œæ¥å—ä¸€ä¸ª <code>u8</code> ç±»å‹çš„å‚æ•°å¹¶è¿”å› <code>()</code>ã€‚</p><blockquote><p>For the closure a we infer _ = u8, yielding the closure type fn(u8) taking an argument of type u8 and returning ().</p></blockquote><p>å¯¹äº bï¼Œæˆ‘ä»¬æ¨æ–­ <code>_ = &amp;&#x27;x u8</code>, ä¸ºä¸€äº›å…·ä½“çš„ç”Ÿå‘½å‘¨æœŸ <code>&#x27;x</code>ï¼Œæœ€ç»ˆå°†è¢«é€å…¥å€Ÿç”¨æ£€æŸ¥å™¨ã€‚b çš„ç±»å‹æ˜¯ <code>fn(&amp;&#x27;x u8)</code>ã€‚</p><blockquote><p>For b we infer _ = &amp;&#x27;x u8 for some concrete lifetime &#x27;x that will ultimately feed into the borrow checker. The type of b is fn(&amp;&#x27;x u8).</p></blockquote><p>æœ€åï¼Œå¯¹äº cï¼Œæˆ‘ä»¬æ¨æ–­ <code>_ = u8</code>ï¼Œäº§ç”Ÿæ›´é«˜ç­‰çº§çš„é—­åŒ…ç±»å‹ <code>&lt;&#x27;a&gt; fn(&amp;&#x27;a u8)</code>ã€‚</p><blockquote><p>And finally for c we infer _ = u8, yielding the higher-ranked closure type for&lt;&#x27;a&gt; fn(&amp;&#x27;a u8).</p></blockquote><p>ä»¥æ­¤ä¸ºæ¡†æ¶ï¼Œå¯ä»¥çœ‹å‡ºï¼Œåœ¨ main ç»“å°¾å‡ºä¼šæ‰“å° 112ã€‚</p><blockquote><p>Framed in this way, it follows that the trait method calls at the end of main print 112.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-size-of-">#6 <code>size of ()</code><a class="hash-link" href="#6-size-of-" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-5">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-5" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::mem;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = a = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, mem::size_of_val(&amp;a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-5">æç¤º<a class="hash-link" href="#æç¤º-5" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>æœ‰ä¸¤ä¸ªåä¸º a çš„å˜é‡ï¼Œå®ƒä»¬å„è‡ªçš„ç±»å‹æ˜¯ä»€ä¹ˆï¼Ÿ</p><blockquote><p>There are two variables named a. What is the type of each one?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-4">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-4" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š0</p><p>è¿™é‡Œæœ‰ä¸¤ä¸ªåä¸º a e çš„å˜é‡ï¼Œç¬¬äºŒä¸ªä¼š &quot;é®è”½&quot; ç¬¬ä¸€ä¸ªï¼Œè¿™æ®µç¨‹åºç­‰ä»·äºï¼š</p><blockquote><p>There are two variables named a, one shadowing the other. The program is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = a = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print!(&quot;{}&quot;, mem::size_of_val(&amp;b));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æ›´è¿›ä¸€æ­¥ï¼Œä¸º b èµ‹çš„å€¼æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ <code>a = true</code>;</p><blockquote><p>Further, the value being assigned to b is the expression a = true.</p></blockquote><p>åœ¨ Rust é‡Œï¼Œèµ‹å€¼è¡¨è¾¾å¼çš„è¿”å›å€¼å§‹ç»ˆæ˜¯ <code>()</code>ã€‚åœ¨ç®€åŒ–ä¸€ä¸‹ä»£ç ï¼š</p><blockquote><p>In Rust, assignment expressions always have the value (). Simplified some more, the quiz code is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let a = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print!(&quot;{}&quot;, mem::size_of_val(&amp;b));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>å…³äºå®ƒçš„è¡Œä¸ºè§„èŒƒï¼Œè¯·å‚è€ƒ size_of_val çš„æ–‡æ¡£ï¼Œä½†åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒè¢«å®ä¾‹åŒ–ä¸º <code>T = ()</code>ï¼Œæˆ‘ä»¬æœ€ç»ˆä¼šæ‰“å°å‡º <code>size_of::&lt;()&gt;()</code> çš„å€¼ã€‚</p><blockquote><p>Refer to the documentation of size_of_val for a specification of its behavior, but in this case it is being instantiated with T = () and we end up printing the value of size_of::&lt;()&gt;().</p></blockquote><p><code>()</code> æ˜¯é›¶å¤§å°ç±»å‹æˆ– ZST çš„ä¸€ä¸ªä¾‹å­ï¼Œåœ¨è¿è¡Œæ—¶ç”±é›¶å­—èŠ‚çš„æ•°æ®è¡¨ç¤ºï¼Œæ‰€ä»¥ç¨‹åºä¼šæ‰“å°å‡º 0ã€‚</p><blockquote><p>() is one example of a zero-sized type or ZST and is represented by zero bytes of data at runtime, so the program prints 0.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-match">#7 <code>match</code><a class="hash-link" href="#7-match" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-6">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-6" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[repr(u8)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Enum {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    First,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Second,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Enum {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            First =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Second =&gt; print!(&quot;2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Enum::p(unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        std::mem::transmute(1u8)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-6">æç¤º<a class="hash-link" href="#æç¤º-6" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>è°ƒç”¨ <code>Enum::p</code> æ—¶ä¼ å…¥çš„å‚æ•°ä¸€å®šæ˜¯ <code>Enum::Second</code>ã€‚</p><blockquote><p>The argument of the call to Enum::p is guaranteed to be Enum::Second.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-5">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-5" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š1</p><p>å±•å¼€éšè—çš„æ¡ä»¶ï¼Œè¿™æ®µ Enum çš„å®šä¹‰å…¶å®ç­‰åŒäºï¼š</p><blockquote><p>Filling in the implicit discriminants, the definition of Enum is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[repr(u8)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Enum {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    First = 0u8,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Second = 1u8,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>unsafe transmute</code> åªæ˜¯è½¬ç§»ä½ çš„æ³¨æ„ã€‚<code>#[repr(u8)]</code> ä¼šç¡®ä¿æˆ‘ä»¬çš„ç±»å‹å’Œ u8 æœ‰ç›¸åŒçš„å†…å­˜å¸ƒå±€ï¼Œè€Œ <code>Enum::Second</code> çš„åˆ¤åˆ«ä¼šç¡®ä¿ <code>Enum::Second</code> å’Œ 1u8 çš„å¸ƒå±€ç›¸åŒã€‚å› æ­¤è¿™é‡Œçš„ <code>transmute</code> çš„å®šä¹‰æ˜ç¡®ï¼Œç­‰ä»·äº <code>Enum::Second</code>ã€‚</p><blockquote><p>The unsafe transmute is a red herring. The attribute #<!-- -->[repr(u8)]<!-- --> guarantees that our type has the same representation as u8, and the discriminant on Enum::Second guarantees that Enum::Second has the same representation as 1u8. The transmute is well-defined and evaluates to Enum::Second.</p></blockquote><p>å¦‚æœæ–¹æ³• p çš„å®šæ—¶æ˜¯è¿™æ ·çš„ï¼š</p><blockquote><p>If the method p had been written as:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Enum::First =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Enum::Second =&gt; print!(&quot;2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>è¿™ä¸ªç¨‹åºä¼šæ‰“å° 2ã€‚</p><blockquote><p>then this program would print 2.</p></blockquote><p>ä½†æ˜¯ï¼Œæ¨¡å¼åŒ¹é…é‡Œçš„ä¸¤ä¸ªåˆ†æ”¯éƒ½æ˜¯é€šé…ç¬¦ï¼Œèƒ½å¤ŸåŒ¹é…åˆ°ä»»ä½•å€¼ï¼Œå¹¶æŠŠå®ƒç»‘å®šåˆ° First æˆ–è€… Second ä¸Šã€‚æ¨¡å¼æŒ‰é¡ºåºåŒ¹é…ï¼Œæ‰€ä»¥è¿™é‡Œæ€»æ˜¯ä¼šåŒ¹é…åˆ° First åˆ†æ”¯ã€‚</p><blockquote><p>However, as written, both arms of the match expression are wildcard matches that successfully match any value and bind a variable with the name First or Second. Match arms are applied in order so the wildcard match in the first arm is always the one matched.</p></blockquote><p>ç¼–è¯‘å™¨ä¼šç»™æˆ‘ä»¬ä¸¤æ¡è­¦å‘Šã€‚ç¬¬ä¸€ä¸ªæ˜¯å®ƒæè¿°äº†åŒ¹é…çš„è¿‡ç¨‹ã€‚</p><blockquote><p>The compiler helps us out with not one but two relevant warnings. First it describes exactly how this match is parsed and why that is probably silly.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">warning: unreachable pattern</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; questions/007.rs:11:13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 |             First =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |             ----- matches any value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 |             Second =&gt; print!(&quot;2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |             ^^^^^^ unreachable pattern</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ç¬¬äºŒä¸ªæ˜¯ç¼–è¯‘å™¨æ„è¯†åˆ°äº†ç¨‹åºå‘˜å¯èƒ½å†™é”™äº†ä»£ç ï¼Œå¹¶ç»™å‡ºäº†å¯èƒ½æ­£ç¡®çš„æç¤ºã€‚</p><blockquote><p>Second, it recognizes what the programmer has done wrong and what they probably meant to write instead.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">warning[E0170]: pattern binding `First` is named the same as one of the variants of the type `Enum`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; questions/007.rs:10:13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 |             First =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |             ^^^^^ help: to match on the variant, qualify the path: `Enum::First`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>åœ¨æ¨¡å¼ä¸­ç›´æ¥å†™é™å®šè·¯å¾„çš„æ–¹æ³•æ˜¯æŠŠæšä¸¾çš„å˜ä½“ä¹Ÿå¼•å…¥ä½œç”¨åŸŸï¼š</p><blockquote><p>An alternative to writing qualified paths in the pattern is to bring the variants into scope.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use Enum::*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">match self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    First =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Second =&gt; print!(&quot;2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>é€šè¿‡<a href="https://doc.rust-lang.org/std/prelude/index.html" target="_blank" rel="noopener noreferrer">æ ‡å‡†åº“çš„ prelude</a>ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ¨¡å¼åŒ¹é…ä¸­ç›´æ¥ä½¿ç”¨ <code>OK</code> å’Œ <code>Some</code> (è€Œä¸æ˜¯ <code>Result::OK</code> å’Œ <code>Option::Some</code>)ã€‚</p><blockquote><p>Having variants brought into scope by the standard library prelude is what allows us to write Ok and Some in match arms, rather than the qualified paths Result::Ok and Option::Some.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="8---">#8 <code>= = &gt;</code><a class="hash-link" href="#8---" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-7">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-7" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (==&gt;) =&gt; { print!(&quot;1&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (= = &gt;) =&gt; { print!(&quot;2&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (== &gt;) =&gt; { print!(&quot;3&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (= =&gt;) =&gt; { print!(&quot;4&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(==&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(= = &gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(== &gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(= =&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-7">æç¤º<a class="hash-link" href="#æç¤º-7" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>æ ¹æ® <code>macro_rules!</code> çš„è§„åˆ™ï¼Œ<code>==</code> æ˜¯ä¸€ä¸ª tokenï¼Œ<code>=&gt;</code> ä¹Ÿæ˜¯ä¸€ä¸ª tokenã€‚</p><blockquote><p>According to macro_rules!, == is one token and =&gt; is one token.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-6">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-6" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š1214</p><p>åœ¨ <code>macro_rules!</code> çš„è¾“å…¥æ¨¡å¼ä¸­ï¼Œç›¸é‚»çš„æ ‡ç‚¹ç¬¦å·æ ¹æ®å®ƒä»¬çš„ç”¨æ³•ä¸åŒï¼Œä¼šè¢«åˆ’åˆ†ä¸ºå‡ ç»„ã€‚</p><blockquote><p>Adjacent punctuation characters in the input pattern of a macro_rules! macro are grouped according to how those characters are used by native Rust tokens.</p></blockquote><p><a href="https://docs.rs/syn/0.15.22/syn/token/index.html#structs" target="_blank" rel="noopener noreferrer">è¿™é‡Œ</a>åˆ—å‡ºäº† Rust ä¸­çš„å•å­—ç¬¦å’Œå¤šå­—ç¬¦ token åˆ—è¡¨</p><blockquote><p>This page contains a list of the single-character and multi-character punctuation tokens involved in the Rust grammar.</p></blockquote><p>åˆ—è¡¨ä¸­çš„æœ‰ä¸€ä¸ªä¾‹å­ï¼Œ<code>&lt;&lt;=</code> æ˜¯ä¸€ä¸ª tokenï¼ŒRust è¯­æ³•æŠŠå®ƒä½œä¸ºå·¦ç§»èµ‹å€¼ã€‚å› æ­¤åŒ…å« <code>&lt;&lt;=</code> çš„ä¸€ä¸ª <code>macro_rules!</code> è¾“å…¥ï¼Œåªæœ‰é‡åˆ° <code>&lt;&lt;=</code> ä¸”ä¸­é—´æ²¡æœ‰ç©ºæ ¼æ—¶æ‰ä¼šåŒ¹é…ã€‚</p><blockquote><p>As one example from that list, <code>&lt;&lt;=</code> is a single token because the Rust grammar uses that sequence of characters to mean left shift assignment. Thus a macro_rules! input rule containing <code>&lt;&lt;=</code> would only match if all three characters <code>&lt;&lt;=</code> are written consecutively without spaces in the invocation.</p></blockquote><p>ä½†æ˜¯ <code>=&lt;&lt;</code> åœ¨ Rust è¯­æ³•ä¸­ä¸æ˜¯ä¸€ä¸ª native tokenã€‚macro_rulesï¼çš„è§£æå™¨ä¼šæ ¹æ®è´ªå¿ƒå°†å…¶åˆ†è§£ä¸º Rust æ ‡è®°ã€‚ <code>=&lt;</code> ä¹Ÿä¸æ˜¯ä¸€ä¸ª native tokenï¼Œæ‰€ä»¥é¦–å…ˆæˆ‘ä»¬éœ€è¦åŒ¹é…ä¸€ä¸ª <code>=</code> æœ¬èº«ã€‚ç„¶åï¼Œ<code>&lt;&lt;</code> æ˜¯ä¸€ä¸ª native tokenã€‚åœ¨å®è§„åˆ™ä¸­å†™ <code>=&lt;&lt;</code> çš„è¡Œä¸ºä¸å†™ <code>= &lt;&lt;</code> çš„è¡Œä¸ºå®Œå…¨ç›¸åŒã€‚</p><blockquote><p>But for example <code>=&lt;&lt;</code> is not a native token in the Rust grammar. The parser of macro_rules! will decompose this into Rust tokens according to a greedy process. <code>=&lt;</code> is also not a native token, so first we would need to match a <code>=</code> by itself. Then <code>&lt;&lt;</code> is a native token. Writing <code>=&lt;&lt;</code> in a macro rule behaves exactly the same as writing <code>= &lt;&lt;</code>.</p></blockquote><p>ç°åœ¨è®©æˆ‘ä»¬ä»¥åŒæ ·çš„æ–¹å¼åˆ†è§£ä»£ç ä¸­çš„è§„åˆ™ã€‚</p><blockquote><p>Now let&#x27;s decompose the rules in the quiz code the same way.</p></blockquote><ul><li><code>==&gt;</code> åˆ†è§£ä¸º <code>== &gt;</code>ã€‚</li><li><code>= = &gt;</code> å·²ç»è¢«åˆ†è§£äº†ã€‚</li><li><code>== &gt;</code> å·²ç»è¢«åˆ†è§£äº†ã€‚</li><li><code>= =&gt;</code> å·²ç»è¢«åˆ†è§£äº†ã€‚</li></ul><p>åœ¨æˆ‘ä»¬çš„å®é‡Œï¼Œç¬¬ä¸€æ¡è§„åˆ™åŠ ä¸åŠ ç©ºæ ¼æ˜¯ä¸€æ ·çš„ã€‚ç¬¬ä¸‰æ¡è§„åˆ™æ˜¯ä¸å¯è¾¾çš„ã€‚</p><blockquote><p>Our macro is the same as if we had written the first rule with a space. The third rule is unreachable.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (== &gt;) =&gt; { print!(&quot;1&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (= = &gt;) =&gt; { print!(&quot;2&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (== &gt;) =&gt; { print!(&quot;3&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (= =&gt;) =&gt; { print!(&quot;4&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>åœ¨ main ä¸­ï¼Œç¬¬ä¸€è¡Œå’Œç¬¬ä¸‰è¡Œéƒ½ç¬¦åˆç¬¬ä¸€æ¡å®è§„åˆ™ã€‚ç¬¬äºŒè¡ŒåŒ¹é…ç¬¬äºŒæ¡è§„åˆ™ï¼Œç¬¬å››è¡ŒåŒ¹é…ç¬¬å››æ¡è§„åˆ™ã€‚è¾“å‡ºç»“æœæ˜¯ 1214ã€‚</p><blockquote><p>Within main, the first and third lines both match the first macro rule. The second line matches the second rule and the fourth line matches the fourth rule. The output is 1214.</p></blockquote><p>è¿‡ç¨‹å®ä½¿ç”¨æ›´çµæ´»ã€æ›´å¼ºå¤§çš„å® APIï¼Œå¹¶ä¸”æ€»æ˜¯èƒ½å¤ŸåŒºåˆ†ç›¸åŒå­—ç¬¦çš„ä¸åŒé—´éš”ï¼Œä¾‹å¦‚ <code>== &gt;</code> ä¸ <code>==&gt;</code>ã€‚</p><blockquote><p>Procedural macros use a more flexible and powerful macro API and can always distinguish between different spacings of the same characters, such as == &gt; vs ==&gt;.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="9-tttt">#9 <code>$tt:tt</code><a class="hash-link" href="#9-tttt" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-8">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-8" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (1) =&gt; { print!(&quot;1&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($tt:tt) =&gt; { print!(&quot;2&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! e {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($e:expr) =&gt; { m!($e) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! t {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($tt:tt) =&gt; { e!($tt); m!($tt); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t!(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-8">æç¤º<a class="hash-link" href="#æç¤º-8" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ä¸€æ—¦è¢«åŒ¹é…ä¸º <code>$:expr</code>ï¼ŒåŒ¹é…åˆ°çš„è¡¨è¾¾å¼å°±å˜æˆäº†ä¸€ä¸ªä¸é€æ˜çš„æ ‡è®°æ ‘ã€‚</p><blockquote><p>Upon being matched as a $:expr, the matched expression becomes a single opaque token tree.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-7">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-7" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š21</p><p>è¿™ä¸ªé—®é¢˜æ¶‰åŠåˆ°å®åŒ¹é…å™¨åœ¨åŒ¹é…å®çš„å…ƒå˜é‡æ—¶çš„è¡Œä¸ºã€‚</p><blockquote><p>This question involves the behavior of macro matchers as regards matching macro metavariables.</p></blockquote><p>ä»ä»£ç çš„æœ€åä¸€è¡Œçœ‹èµ·ï¼Œ<code>t!(1)</code> ä¼šåŒ¹é…åˆ° <code>t!</code> çš„ç¬¬ä¸€æ¡è§„åˆ™ï¼Œç„¶åå±•å¼€ä¸º <code>e!(1); m!(1);</code></p><blockquote><p>Starting from the bottom of the quiz code, the invocation t!(1) matches the first rule of t! and expands to e!(1); m!(1);.</p></blockquote><p>è°ƒç”¨ <code>e!(1)</code> ä¼šåŒ¹é… <code>e!</code> çš„ç¬¬ä¸€æ¡è§„åˆ™ã€‚ä½œä¸ºè¿™ä¸ªåŒ¹é…çš„ä¸€éƒ¨åˆ†ï¼Œè¡¨è¾¾å¼ <code>1</code> ä¼šè¢«æ‰“åŒ…æˆä¸€ä¸ªä¸é€æ˜çš„è¡¨è¾¾å¼ tokenï¼Œç§°ä¸º <code>$e</code>ã€‚åœ¨æ¥ä¸‹æ¥çš„ä»»ä½•æ—¶å€™ï¼Œä»»ä½• <code>macro_rulesï¼</code>å®éƒ½ä¸å¯èƒ½æŸ¥çœ‹ <code>$e</code> çš„å†…éƒ¨ï¼Œå”¯ä¸€å¯ä»¥çŸ¥é“çš„æ˜¯ <code>$e</code> æ˜¯æŸä¸ªè¡¨è¾¾å¼ã€‚</p><blockquote><p>The invocation e!(1) matches the first rule of e!. As part of this match, the expression 1 is packaged into an opaque expression token called $e. At no subsequent point will it be possible for any macro_rules! macro to look inside of $e. All that can be known is that $e is some expression.</p></blockquote><p>åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼Œ<code>e!(1)</code> éƒ½ä¼šæ‰©å±•ä¸º <code>m!($e)</code>ï¼Œå…¶ä¸­ <code>$e</code> æ˜¯ä¸€ä¸ªåŒ…å« <code>1</code> çš„ä¸é€æ˜è¡¨è¾¾å¼ã€‚<code>m!($e)</code> å¹¶ä¸ç¬¦åˆ <code>m!</code> çš„ç¬¬ä¸€æ¡è§„åˆ™ï¼Œå› ä¸º <code>$e</code> æ˜¯ä¸é€æ˜çš„ã€‚æ‰€ä»¥å®ƒåŒ¹é…äº† <code>m!</code> çš„ç¬¬äºŒæ¡è§„åˆ™ï¼Œå¹¶æ‰“å°å‡º 2ã€‚</p><blockquote><p>In any case, e!(1) expands to m!($e) where $e is an opaque expression containing 1. That m!($e) does not match the first rule of m! because $e is opaque. Instead it matches the second rule of m! and prints 2.</p></blockquote><p>åœ¨ <code>e!(1)</code> ä¹‹åæœ‰ä¸€ä¸ªå¯¹ <code>m!(1)</code> çš„è°ƒç”¨ï¼Œæ¥è‡ª <code>t!</code> çš„å±•å¼€ã€‚è¿™ä¸ªè°ƒç”¨ç¡®å®ç¬¦åˆ <code>m!</code> çš„ç¬¬ä¸€æ¡è§„åˆ™ï¼Œå¹¶æ‰“å°å‡º 1ã€‚æ‰€ä»¥è¿™ä¸ªç¨‹åºçš„è¾“å‡ºæ˜¯ 21ã€‚</p><blockquote><p>After e!(1) there is an invocation m!(1) coming from the expansion of t!. That one does match the first rule of m! and prints 1. The output of this program is 21.</p></blockquote><p>å¤§å¤šæ•°ç‰‡æ®µåˆ†ç±»ç¬¦éƒ½æœ‰è¿™ç§å˜ä¸ºä¸é€æ˜ token çš„è¡Œä¸ºï¼Œä½†æœ‰äº›æ²¡æœ‰ã€‚ä¸€æ—¦åŒ¹é…åˆ°å°±å˜ä¸ºä¸é€æ˜ token çš„ç‰‡æ®µåˆ†ç±»ç¬¦ï¼š</p><blockquote><p>Most fragment specifiers have this behavior of becoming opaque token boxes, but some do not. Specifiers that are opaque once matched:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$:block</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:expr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:item</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:literal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:meta</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:pat</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:path</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:stmt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:ty</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>å‰©ä¸‹çš„ç‰‡æ®µåˆ†ç±»ç¬¦åŒ¹é…æˆåŠŸåä¸ä¼šå˜ä¸ºä¸é€æ˜çš„ï¼Œå¯ä»¥è¢«åç»­çš„è§„åˆ™æ£€æŸ¥åˆ°ï¼š</p><blockquote><p>The rest of the specifiers do not become opaque and can be inspected by subsequent rules:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$:ident</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:lifetime</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:tt</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æ¯”å¦‚ï¼š</p><blockquote><p>For example:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (&#x27;a) =&gt; {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! l {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($l:lifetime) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // $l is not opaque.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m!($l);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">l!(&#x27;a);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="10-traitf">#10 <code>Trait::f</code><a class="hash-link" href="#10-traitf" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-9">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-9" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a&gt; dyn Trait + &#x27;a {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Trait::f(&amp;true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Trait::f(&amp;true as &amp;dyn Trait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;_ as Trait&gt;::f(&amp;true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;bool as Trait&gt;::f(&amp;true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;dyn Trait as Trait&gt;::f(&amp;true as &amp;dyn Trait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-9">æç¤º<a class="hash-link" href="#æç¤º-9" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>è¿™å¹¶ä¸èƒ½å¸®åŠ©ä½ è§£å†³é—®é¢˜ï¼Œä½†å¯èƒ½ä¼šè®©ä½ å¥½å—äº›ï¼šä½œè€…ä¹Ÿè¢«è¿™ä¸ªé—®é¢˜éš¾ä½äº†ã€‚</p><blockquote><p>This won&#x27;t help you answer the question but may help feel better: the quiz author was also stumped by this one.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-8">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-8" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š222222</p><p>è¿™é“é¢˜é‡Œæœ‰ä¸€ä¸ª Trait æ–¹æ³• <code>Trait::f</code>ï¼ŒåŒæ—¶è¿˜æœ‰ç‰¹å¾å¯¹è±¡ <code>dyn Trait</code> çš„ f æ–¹æ³•ã€‚</p><blockquote><p>This question contains a trait method <code>Trait::f</code> as well as an inherent method f on the trait object type dyn Trait.</p></blockquote><p>æ®æˆ‘æ‰€çŸ¥ï¼Œé‰´äºè¿™äº›åå­—ä¼šç›¸äº’é®è”½ï¼Œåœ¨ <code>dyn Trait</code> å®ç°çš„ <code>f</code> æ–¹æ³•å®é™…ä¸Šæ˜¯æ— æ³•è°ƒç”¨çš„ã€‚ç›®å‰ï¼ŒRust ä¸­æ²¡æœ‰ä»»ä½•è¯­æ³•å¯ä»¥åœ¨ <code>dyn Trait</code> ä¸Šè°ƒç”¨å®ƒçš„ <code>f</code>ã€‚</p><blockquote><p>As far as I know, given that these names shadow each other, the inherent method is literally uncallable. There is currently no syntax in Rust for calling the inherent f on dyn Trait.</p></blockquote><p>å¦‚æœ trait æ–¹æ³•çš„åå­—å¯ä»¥ä»¥ä¸åŒçš„æ–¹å¼å‘½åï¼Œå¹¶ä¸”åªæœ‰ <code>dyn Trait</code> çš„æ–¹æ³•è¢«ç§°ä¸º <code>f</code>ï¼Œé‚£ä¹ˆ main çš„å‰ä¸¤è¡Œå°±ä¼šæˆåŠŸè°ƒç”¨ <code>dyn Trait</code> çš„æ–¹æ³•ã€‚ç„¶è€Œï¼Œç”±äºå†™çš„æ˜¯è¢«é®è”½çš„åå­—ï¼Œè¿™ä¼šå¯¼è‡´æ­§ä¹‰ï¼Œæœ€åè°ƒç”¨çš„æ˜¯ Trait çš„æ–¹æ³•ã€‚</p><blockquote><p>If the trait method were named something different and only the inherent method were called f, then the first two lines of main would successfully call the inherent method. However, as written with shadowed names, they disambiguate to the trait method.</p></blockquote><p>è¿˜æœ‰ä¸€ç§å¯ä»¥å°è¯•çš„è¯­æ³•ï¼š</p><blockquote><p>One additional syntax to try would be:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dyn Trait&gt;::f(&amp;true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dyn Trait&gt;::f(&amp;true as &amp;dyn Trait);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>å¦‚æœç‰¹å¾æ–¹æ³•çš„å‘½åä¸åŒï¼Œè¿™ä¸¤ä¸ªè°ƒç”¨éƒ½ä¼šè°ƒç”¨ <code>dyn Trait</code> çš„ <code>f</code> æ–¹æ³•ã€‚å¦‚æœ <code>dyn Trait</code> çš„æ–¹æ³•è¢«å‘½åä¸ºä¸åŒçš„ä¸œè¥¿ï¼Œè¿™ä¸¤ä¸ªæ–¹æ³•éƒ½ä¼šè°ƒç”¨ Trait æ–¹æ³•ã€‚ä½†æ˜¯å¦‚æœ <code>Trait</code> æ–¹æ³•å’Œ <code>dyn Trait</code> æ–¹æ³•éƒ½å«ä½œ fï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šæŠ¥å‘Šä¸€ä¸ªæ­§ä¹‰ã€‚</p><blockquote><p>If the trait method were named something different, both of these would call the inherent method. If the inherent method were named something different, both of these would call the trait method. But if the trait method and the inherent method are both f then the compiler reports an ambiguity.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error[E0034]: multiple applicable items in scope</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; questions/010.rs:18:5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 |     &lt;dyn Trait&gt;::f(&amp;true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |     ^^^^^^^^^^^^^^ multiple `f` found</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">note: candidate #1 is defined in an impl for the type `dyn Trait`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; questions/010.rs:6:5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6  |     fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |     ^^^^^^^^^^^</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">note: candidate #2 is defined in the trait `Trait`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; questions/010.rs:2:5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2  |     fn f(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |     ^^^^^^^^^^^^</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   = help: to disambiguate the method call, write `Trait::f(...)` instead</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ä¹Ÿè®¸æœ‰ä¸€å¤©ï¼Œåœ¨ä¸€ä¸ªè¢«ç‰¹å¾æ–¹æ³•æ‰€é®è”½çš„ç‰¹å¾å¯¹è±¡ä¸Šè°ƒç”¨å®ƒçš„æ–¹æ³•å¯èƒ½æ¶ˆé™¤æ­§ä¹‰ã€‚ä½†æ˜¯ç°åœ¨ï¼Œä»£ç åªèƒ½æ‰“å°å‡º 222222ã€‚</p><blockquote><p>Maybe some day it will be possible to disambiguate a call to an inherent method on a trait object shadowed by a trait method. For now, the quiz code prints 222222.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="11-early--late-bound">#11 <code>early &amp; late bound</code><a class="hash-link" href="#11-early--late-bound" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-10">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-10" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn f&lt;&#x27;a&gt;() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn g&lt;&#x27;a: &#x27;a&gt;() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pf = f::&lt;&#x27;static&gt; as fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pg = g::&lt;&#x27;static&gt; as fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, pf == pg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-10">æç¤º<a class="hash-link" href="#æç¤º-10" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>f å’Œ g çš„å†™æ³•æ˜¯ä¸èƒ½äº’æ¢çš„ã€‚</p><blockquote><p>The way that f and g are written is not interchangeable.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-9">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-9" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼šç¼–è¯‘å¤±è´¥</p><p>æ¯”è¾ƒå‡½æ•°æŒ‡é’ˆæ˜¯ä¸€ä¸ªåä¸»æ„ã€‚åœ¨ä¼˜åŒ–åçš„æ„å»ºä¸­ï¼Œå¾ˆå®¹æ˜“å‡ºç°æ— æ„ä¹‰çš„è¡Œä¸ºã€‚å…³äºè¿™ç§è¡Œä¸ºçš„ä¸€ä¸ªä»¤äººç ç›®ç»“èˆŒçš„ä¾‹å­ï¼Œè¯·çœ‹ <a href="https://github.com/rust-lang/rust/issues/54685" target="_blank" rel="noopener noreferrer">rust-lang/rust#54685</a>ï¼Œå…¶ä¸­ x == y åŒæ—¶ä¸ºçœŸï¼Œåˆä¸ä¸ºçœŸã€‚(è¯‘è€…æ³¨ï¼šè¯¥é—®é¢˜å·²ä¿®å¤)</p><blockquote><p>Function pointer comparison is generally a Bad Idea. It is easily possible to get nonsensical behavior in optimized builds. For a jaw-dropping example of such behavior, check out rust-lang/rust#54685 in which x == y is both true and not true at the same time.</p></blockquote><p>é‚£å°±æ˜¯è¯´ï¼Œè¿™æ®µä»£ç ç¼–è¯‘å¤±è´¥ã€‚ä¸‹é¢æ˜¯ç¼–è¯‘çš„è¾“å‡ºï¼š</p><blockquote><p>That said, the quiz code in this question fails to compile. Here is the compiler output:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> --&gt; questions/011.rs:5:18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5 |     let pf = f::&lt;&#x27;static&gt; as fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |                  ^^^^^^^</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">note: the late bound lifetime parameter is introduced here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> --&gt; questions/011.rs:1:18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1 | fn f&lt;&#x27;a&gt;() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |      ^^</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æ³›å‹å‚æ•°å¯ä»¥æ˜¯æ—©ç»‘å®šä¹Ÿå¯ä»¥æ˜¯æ™šç»‘å®šã€‚ç›®å‰ (ä»¥åŠå¯ä»¥é‡è§çš„æœªæ¥) ç±»å‹å‚æ•°éƒ½æ˜¯æ—©ç»‘å®šï¼Œä½†æ˜¯ç”Ÿå‘½å‘¨æœŸå‚æ•°ä¸¤è€…éƒ½æœ‰å¯èƒ½ã€‚</p><blockquote><p>Generic parameters can be either early bound or late bound. Currently (and for the foreseeable future) type parameters are always early bound, but lifetime parameters can be either early or late bound.</p></blockquote><p>æ—©ç»‘å®šæ˜¯åœ¨ç¼–è¯‘å™¨åœ¨å•æ€åŒ–è¿‡ç¨‹ä¸­å†³å®šçš„ã€‚å› ä¸ºç±»å‹å‚æ•°æ€»æ˜¯æ—©ç»‘å®šï¼Œä½ ä¸èƒ½æ‹¥æœ‰ä¸€ä¸ªæ³›å‹æœªæŒ‡å®šçš„å€¼ã€‚</p><blockquote><p>Early bound parameters are determined by the compiler during monomorphization. Since type parameters are always early bound, you cannot have a value whose type has an unresolved type parameter. For example:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn m&lt;T&gt;() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let m1 = m::&lt;u8&gt;; // ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let m2 = m; // error: cannot infer type for `T`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ä½†æ˜¯ï¼Œå¯¹äºç”Ÿå‘½å‘¨æœŸæ˜¯åˆæ³•çš„ï¼š</p><blockquote><p>However, this is often allowed for lifetime parameters:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn m&lt;&#x27;a&gt;(_: &amp;&#x27;a ()) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let m1 = m; // å³ä½¿æ²¡æœ‰æä¾› &#x27;a ä¹Ÿå¯ä»¥</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>å› ä¸º &#x27;a çš„å…·ä½“å–å€¼å–å†³ä¸å®ƒå¦‚ä½•è¢«è°ƒç”¨ï¼Œç”¨æˆ·å¯ä»¥çœç•¥ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä»–ä¼šåœ¨è°ƒç”¨æ˜¯å†³å®šã€‚ç”Ÿå‘½å‘¨æœŸç”šè‡³å¯ä»¥åœ¨æ¯æ¬¡è°ƒç”¨æ—¶éƒ½ä¸ä¸€æ ·ã€‚</p><blockquote><p>Since the actual choice of lifetime &#x27;a depends on how it is called, we are allowed to omit the lifetime parameter and it will be determined at the call site. The lifetime can even be different for each time it gets called.</p></blockquote><p>é‰´äºæ­¤ï¼Œæˆ‘ä»¬ä¸èƒ½åœ¨è°ƒç”¨å‰æŒ‡å®šå‡½æ•°ä¸Šçš„ç”Ÿå‘½å‘¨æœŸã€‚</p><blockquote><p>For this reason, we cannot specify the lifetime on this function until it is called:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let m2 = m::&lt;&#x27;static&gt;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æˆ‘ä»¬ç”šè‡³ä¸èƒ½è®©å€Ÿç”¨æ£€æŸ¥å™¨æå‰è‡ªåŠ¨æ¨æ–­ï¼š</p><blockquote><p>We may not even ask the borrow checker to infer it too soon:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let m3 = m::&lt;&#x27;_&gt;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æ™šç»‘å®šå‚æ•°çš„æ¦‚å¿µä¸ Rust ä¸­çš„å¦ä¸€ä¸ªç‰¹æ€§ &quot;é«˜é˜¶ç”Ÿå‘½å‘¨æœŸ&quot; æœ‰äº›é‡å¤ã€‚è¿™æ˜¯ä¸€ç§ç”¨äºè¡¨è¾¾ç‰¹å¾å‚æ•°çš„è¾¹ç•Œæ˜¯æ™šç»‘å®šçš„æœºåˆ¶ã€‚ç›®å‰è¿™åªé™äºç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä½†åœ¨å…¶ä»–è¯­è¨€ï¼ˆå¦‚ Haskellï¼‰ä¸­ä¹Ÿå­˜åœ¨åŒæ ·çš„æƒ³æ³•ï¼Œç”¨äºç±»å‹å‚æ•°ï¼Œè¿™å°±æ˜¯ &quot;é«˜çº§&quot; ä¸€è¯çš„ç”±æ¥ã€‚</p><blockquote><p>The idea of late bound parameters overlaps considerably with a feature of Rust called &quot;higher ranked trait bounds&quot; (HRTB). This is a mechanism for expressing that bounds on a trait&#x27;s parameters are late bound. Currently this is limited to lifetime parameters, but the same idea exists in other languages (such as Haskell) for type parameters, which is where the term &quot;higher ranked&quot; comes from.</p></blockquote><p>è¡¨è¾¾ HRTB çš„è¯­æ³•éœ€è¦ä½¿ç”¨ for å…³é”®å­—ã€‚ä¸ºäº†è¡¨è¾¾ä¸Šé¢ m1 çš„ç±»å‹ï¼Œä½ å¯ä»¥è¿™ä¹ˆå†™ï¼š</p><blockquote><p>The syntax to express a HRTB for lifetimes uses the for keyword. To express the type of m1 above, we could have written:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let m1: impl for&lt;&#x27;r&gt; Fn(&amp;&#x27;r ()) = m;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ä½ å¯ä»¥æŠŠå®ƒçœ‹æˆï¼š&quot;è¿™é‡Œæœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œä½†æ˜¯ç›®å‰æˆ‘ä»¬ä¸éœ€è¦çŸ¥é“å®ƒå…·ä½“æ˜¯ä»€ä¹ˆ&quot;.</p><blockquote><p>You can think of this as meaning: &quot;There is a lifetime but we don&#x27;t need to know what it is just yet&quot;.</p></blockquote><p>æ™šç»‘å®šçš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ— é™åˆ¶çš„ï¼›æ²¡æœ‰æ˜ç¡®çš„è¯­æ³•æ¥è¡¨è¾¾ä¸€ä¸ªæ™šç»‘å®šçš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»è¶…è¿‡å…¶ä»–çš„ç”Ÿå‘½å‘¨æœŸã€‚</p><blockquote><p>Late bound lifetimes are always unbounded; there is no syntax for expressing a late bound lifetime that must outlive some other lifetime.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error: lifetime bounds cannot be used in this context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> --&gt; src/main.rs:5:20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5 |     let _: for&lt;&#x27;b: &#x27;a&gt; fn(&amp;&#x27;b ());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |                    ^^</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æ•°æ®ç±»å‹ä¸Šçš„ç”Ÿå‘½å‘¨æœŸæ€»æ˜¯æ—©ç»‘å®šï¼Œé™¤éå¼€å‘è€…æ˜ç¡®ä½¿ç”¨ HRBT çš„è¯­æ³•ã€‚åœ¨å‡½æ•°ä¸Šï¼Œç”Ÿå‘½å‘¨æœŸé»˜è®¤æ˜¯æ™šç»‘å®šï¼Œåœ¨ä¸‹åˆ—æƒ…å†µä¸‹å¯ä»¥æ˜¯æ—©ç»‘å®šï¼š</p><blockquote><p>Lifetimes on data types are always early bound except when the developer has explicitly used the HRTB for syntax. On functions, lifetimes are late bound by default but can be early bound if:</p></blockquote><ul><li><p>ç”Ÿå‘½å‘¨æœŸåœ¨å‡½æ•°ç­¾åä¹‹å¤–å£°æ˜ï¼Œä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªç»“æ„ä½“çš„æ–¹æ³•ä¸­;æˆ–è€…</p><blockquote><p>The lifetime is declared outside the function signature, e.g. in an associated method of a struct it could be from the struct itself; or</p></blockquote></li><li><p>ç”Ÿå‘½å‘¨æœŸå‚æ•°è¢«å…¶ä»–ä¸€äº›æ›´é•¿çš„ç”Ÿå‘½å‘¨æœŸæ‰€çº¦æŸã€‚æ­£å¦‚æˆ‘ä»¬æ‰€çœ‹åˆ°çš„ï¼Œè¿™ç§çº¦æŸåœ¨ HRTB ä¸­æ˜¯æ— æ³•è¡¨è¾¾çš„ï¼Œå› ä¸º HRTB ä¼šæ¶‰åŠåˆ°ç”Ÿå‘½å‘¨æœŸçš„æ™šç»‘å®šã€‚</p><blockquote><p>The lifetime parameter is bounded below by some other lifetime that it must outlive. As we&#x27;ve seen, this constraint is not expressible in the HRTB that would be involved in late binding the lifetime.</p></blockquote></li></ul><p>æ ¹æ®è¿™äº›è§„åˆ™ï¼Œç­¾å <code>fn f&lt;&#x27;a&gt;()</code> æœ‰ä¸€ä¸ªæ™šæœŸç»‘å®šçš„ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œè€Œç­¾å <code>fn g&lt;&#x27;a: &#x27;a&gt;()</code> æœ‰ä¸€ä¸ªæ—©ç»‘å®šçš„ç”Ÿå‘½å‘¨æœŸå‚æ•° -- å°½ç®¡è¿™é‡Œçš„çº¦æŸæ˜¯æ— æ•ˆçš„ã€‚</p><blockquote><p>By these rules, the signature fn f&lt;&#x27;a&gt;() has a late bound lifetime parameter while the signature fn g&lt;&#x27;a: &#x27;a&gt;() has an early bound lifetime parameter â€” even though the constraint here is ineffectual.</p></blockquote><p>é€šå¸¸æƒ…å†µä¸‹ï¼Œè¿™äº›åŒºåˆ«æ˜¯ç¼–è¯‘å™¨å†…éƒ¨çš„æœ¯è¯­ï¼ŒRust ç¨‹åºå‘˜åœ¨æ—¥å¸¸ç¼–å†™ä»£ç æ—¶å¹¶ä¸éœ€è¦äº†è§£æˆ–æ€è€ƒè¿™äº›æœ¯è¯­ã€‚åªæœ‰åœ¨å°‘æ•°è¾¹ç¼˜æƒ…å†µä¸‹ï¼Œç±»å‹ç³»ç»Ÿçš„è¿™ä¸ªæ–¹é¢åœ¨è¯­è¨€ä¸­æ˜¯å¯ä»¥è§‚å¯Ÿåˆ°çš„ï¼Œæ¯”å¦‚åœ¨è¿™é“ Quiz çš„ä»£ç ä¸­ã€‚</p><blockquote><p>Ordinarily these distinctions are compiler-internal terminology that Rust programmers are not intended to know about or think about in everyday code. There are only a few edge cases where this aspect of the type system becomes observable in the surface language, such as in the original quiz code.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="12-let-s--x----s">#12 <code>let S { x, .. } = S</code><a class="hash-link" href="#12-let-s--x----s" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-11">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-11" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct D(u8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for D {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, self.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    d: D,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: u8,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let S { x, .. } = S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        d: D(1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let S { ref x, .. } = S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        d: D(3),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x: 4,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-11">æç¤º<a class="hash-link" href="#æç¤º-11" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>æ¨¡å¼ <code>S { ref x, .. }</code> ä» S ç±»å‹çš„å€¼çš„æ‰€æœ‰è€…é‚£é‡Œå€Ÿç”¨äº†ä¸€ä¸ª x æˆå‘˜ï¼Œå¹¶ç»‘å®šåˆ°äº†å˜é‡ x ä¸Šã€‚</p><blockquote><p>The pattern <code>S { ref x, .. }</code> borrows a binding x from the owner of a value of type S.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-10">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-10" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š1243</p><p>æ¨¡å¼ <code>S { ref x, .. }</code> ä» S ç±»å‹çš„å€¼çš„æ‰€æœ‰è€…é‚£é‡Œå€Ÿç”¨ä¸€ä¸ªç»‘å®šçš„ xã€‚è¿™ä¸ªé—®é¢˜æ¶‰åŠåˆ° drop è§¦å‘çš„ä½ç½®ã€‚D åœ¨å“ªé‡Œè¢« dropï¼Ÿ</p><blockquote><p>This question involves drop-placement. Where does D get dropped?</p></blockquote><p>åœ¨ç¬¬ä¸€ä¸ª let-binding ä¸­ï¼Œæˆ‘ä»¬å°†ä¸€ä¸ª S ç±»å‹çš„å€¼è§£æ„ä¸ºå®ƒçš„ u8 ç±»å‹çš„å­—æ®µ x ä»¥åŠä»£è¡¨ &quot;S çš„å…¶ä½™éƒ¨åˆ†&quot; çš„ <code>..</code>ã€‚<code>..</code> ä¼šç«‹å³è¢« dropï¼Œå› ä¸ºå®ƒä¸å†æœ‰æ‰€æœ‰è€…ã€‚</p><blockquote><p>In the first let-binding, we destructure a value of type S into its field x of type u8 as well as .. which represents &quot;the rest of S&quot;. The part that is the rest of S is dropped immediately at that point because it no longer has an owner.</p></blockquote><p>åœ¨ç¬¬äºŒä¸ª let-binding ä¸­ï¼Œæˆ‘ä»¬ä» S ç±»å‹çš„å€¼çš„æ‰€æœ‰è€…é‚£é‡Œå€Ÿç”¨ä¸€ä¸ªå­—æ®µ xã€‚åœ¨å­—æ®µ x è¢«å€Ÿç”¨æœŸé—´ï¼Œæ•´ä¸ª S ç±»å‹çš„å€¼å°†ä¿æŒåœ¨ä½œç”¨åŸŸå†…ï¼Œå¹¶åœ¨ main çš„é—­åˆå¤§æ‹¬å·å¤„é€€å‡ºä½œç”¨åŸŸã€‚</p><blockquote><p>In the second let-binding, we borrow a field x from the owner of a value of type S. The whole value of type S remains in scope during the time that its field x is borrowed, and goes out of scope at the close curly brace of main.</p></blockquote><p>æœ€åçš„è¾“å‡ºæ˜¯ 1243ã€‚</p><blockquote><p>The output is 1243.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="13-eq">#13 <code>eq</code><a class="hash-link" href="#13-eq" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-12">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-12" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let [x, y] = &amp;mut [S, S];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let eq = x as *mut S == y as *mut S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, eq as u8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-12">æç¤º<a class="hash-link" href="#æç¤º-12" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ä¸¤ä¸ªå¯å˜å¼•ç”¨æŒ‡å‘åŒä¸€ä¸ªå†…å­˜ä½ç½®å¯ä»¥å—ï¼Ÿä¼šå‡ºä»€ä¹ˆé—®é¢˜å‘¢ï¼Ÿ</p><blockquote><p>Is it okay for two mutable references to point to the same memory location? What could go wrong?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-11">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-11" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š1</p><p>åœ¨è¿™æ®µä»£ç ä¸­ï¼ŒS æ˜¯ä¸€ä¸ªé›¶å¤§å°ç±»å‹ã€‚é›¶å¤§å°ç±»å‹æ˜¯ç¼–è¯‘æ—¶çš„æ¦‚å¿µï¼Œåœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ä¼šæ¶ˆå¤±ï¼Œåœ¨è¿è¡Œæ—¶ä¼šä»¥é›¶å­—èŠ‚è¡¨ç¤ºã€‚</p><blockquote><p>In this code, S is a zero sized type or ZST. Zero sized types are compile-time concepts that disappear during compilation and have a runtime representation of zero bytes.</p></blockquote><p>main çš„ç¬¬ä¸€è¡Œåˆ›å»ºäº†ä¸€ä¸ªç±»å‹ä¸º <!-- -->[S; 2]<!-- --> çš„æœ¬åœ°å€¼ã€‚è®©æˆ‘ä»¬æŠŠè¿™ä¸ªä¸´æ—¶å€¼ç§°ä¸º tmpã€‚let-binding åœ¨ tmp ä¸­ç»‘å®šäº†ä¸¤ä¸ªå¼•ç”¨ï¼Œx æŒ‡çš„æ˜¯ <code>&amp;mut tmp[0]</code>ï¼Œy æŒ‡çš„æ˜¯ <code>&amp;mut tmp[1]</code>ã€‚</p><blockquote><p>The first line of main creates a local value of type <!-- -->[S; 2]<!-- -->. Let&#x27;s refer to that temporary as tmp. The let-binding binds two references into tmp, x referring to &amp;mut tmp<!-- -->[0]<!-- --> and y referring to &amp;mut tmp<!-- -->[1]<!-- -->.</p></blockquote><p>åœ¨ main çš„ç¬¬äºŒè¡Œï¼Œæˆ‘ä»¬æƒ³çŸ¥é“ä½œä¸ºæŒ‡é’ˆçš„ x å’Œ y æ˜¯å¦æœ‰ç›¸åŒçš„å€¼ã€‚</p><blockquote><p>On the second line of main we want to know whether x and y as pointers have the same value.</p></blockquote><p>æ•°ç»„ç±»å‹ <code>[S; 2]</code> æœ¬èº«å°±æ˜¯ä¸€ä¸ªé›¶å¤§å°çš„ç±»å‹ã€‚ä½ å¯ä»¥é€šè¿‡æ‰“å° <code>std::mem::size_of::&lt;[S; 2]&gt;()</code> çš„å€¼æ¥ç¡®è®¤è¿™ç‚¹ã€‚äº‹å®ä¸Šï¼Œæ•°ç»„çš„ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªå…ƒç´ æœ‰ç›¸åŒçš„å†…å­˜åœ°å€ã€‚</p><blockquote><p>The array type <code>[S; 2]</code> is itself a zero sized type. You can confirm this by printing the value of <code>std::mem::size_of::&lt;[S; 2]&gt;()</code>. Indeed the first and second element of the array have the same memory address.</p></blockquote><p>é€šå¸¸æƒ…å†µä¸‹ï¼Œå¯¹åŒä¸€å†…å­˜ä½ç½®æœ‰å¤šä¸ªå¯å˜å¼•ç”¨æ˜¯ä¸å®‰å…¨çš„ï¼Œä½†æ˜¯åœ¨å¯¹é›¶å¤§å°ç±»å‹çš„å¯å˜å¼•ç”¨çš„æƒ…å†µä¸‹ï¼Œè§£å¼•ç”¨æ˜¯ä¸å¯è¡Œçš„ï¼Œæ‰€ä»¥è¿™ç§æ–¹å¼æ²¡æœ‰è¿åä»»ä½•å†…å­˜å®‰å…¨ä¿è¯ã€‚</p><blockquote><p>Ordinarily having multiple mutable references to the same memory location would not be safe, but in the case of mutable references to zero sized types, dereferencing is a no-op so there is no way to violate any memory safety guarantees this way.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="14-trait-scope">#14 <code>trait scope</code><a class="hash-link" href="#14-trait-scope" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-13">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-13" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait: Sized {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn is_reference(self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a, T&gt; Trait for &amp;&#x27;a T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn is_reference(self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match 0.is_reference() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        true =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        false =&gt; print!(&quot;0&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match &#x27;?&#x27;.is_reference() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        true =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        false =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            impl Trait for char {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                fn is_reference(self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            print!(&quot;0&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-13">æç¤º<a class="hash-link" href="#æç¤º-13" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>åœ¨è¿™ä¸ª <a href="https://stackoverflow.com/a/28552082/6086311" target="_blank" rel="noopener noreferrer">Stack Overflow</a> çš„ç­”æ¡ˆä¸­æ¶‰åŠåˆ° trait æ–¹æ³•çš„è‡ªåŠ¨å¼•ç”¨ã€‚</p><blockquote><p>Trait method auto-ref is covered in this Stack Overflow answer.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-12">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-12" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š10</p><p>ç¨‹åºä¸­æ‰€æœ‰çš„ <code>Trait impls</code> éƒ½æ˜¯åœ¨ä½œç”¨åŸŸå†…çš„ï¼Œæ‰€ä»¥åœ¨ä¸€ä¸ªä»£ç å—å†…ç¼–å†™çš„å¯¹ char çš„ Trait impl æ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚ç‰¹åˆ«æ˜¯ï¼Œè¿™ä¸ª impl åœ¨æ•´ä¸ªç¨‹åºä¸­éƒ½æ˜¯å¯è§çš„ï¼Œè€Œä¸ä»…ä»…æ˜¯åœ¨åŒ…å«è¯¥ impl çš„ä»£ç å—ä¸­ã€‚</p><blockquote><p>Trait impls anywhere in a program are always in scope, so there is no significance to the impl Trait for char being written inside of a block of code. In particular, that impl is visible throughout the whole program, not just within the block containing the impl.</p></blockquote><p>è¿™ä¸ªé—®é¢˜ä¸ trait æ–¹æ³•è‡ªåŠ¨å¼•ç”¨çš„è¡Œä¸ºæœ‰å…³ï¼Œè¿™ä¸ªé—®é¢˜åœ¨ <a href="https://stackoverflow.com/a/28552082/6086311" target="_blank" rel="noopener noreferrer">Stack Overflow</a> çš„ç­”æ¡ˆä¸­æœ‰æ‰€æ¶‰åŠã€‚</p><blockquote><p>This question relates to the behavior of trait method auto-ref which is covered in this Stack Overflow answer.</p></blockquote><p>å¯¹ <code>0.is_reference()</code> çš„è°ƒç”¨è§‚å¯Ÿåˆ°æ²¡æœ‰ä¸€ä¸ªæˆ‘ä»¬å¯ä»¥ç›´æ¥è°ƒç”¨çš„ä¸ºæ•´æ•°ç±»å‹çš„ Trait çš„å®ç°ã€‚æ‰€ä»¥æ–¹æ³•è§£æè‡ªåŠ¨æ’å…¥äº†ä¸€ä¸ªå¼•ç”¨ï¼Œå³ <code>(&amp;0).is_reference()</code>ã€‚è¿™ä¸€æ¬¡çš„è°ƒç”¨ä¸ <code>&amp;&#x27;a, T&gt; Trait</code> çš„ <code>impl&lt;&#x27;a, T&gt;</code> åŒ¹é…ï¼Œå¹¶æ‰“å°å‡º 1ã€‚</p><blockquote><p>The call to <code>0.is_reference()</code> observes that there is no implementation of Trait for an integer type that we could call directly. Method resolution inserts an auto-ref, effectively evaluating <code>(&amp;0).is_reference()</code>. This time the call matches impl&lt;&#x27;a, T&gt; Trait for &amp;&#x27;a T and prints 1.</p></blockquote><p>å¯¹ <code>&#x27;?&#x27;.is_reference()</code> çš„è°ƒç”¨åè€Œæ‰¾åˆ°äº† <code>char</code> çš„ <code>implated Trait</code>ï¼Œæ‰“å°å‡º 0ã€‚</p><blockquote><p>The call to <code>&#x27;?&#x27;.is_reference()</code> instead finds impl Trait for char, printing 0.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="15-type-inference">#15 <code>type inference</code><a class="hash-link" href="#15-type-inference" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-14">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-14" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a&gt; Trait for &amp;&#x27;a i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = &amp;0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-14">æç¤º<a class="hash-link" href="#æç¤º-14" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç±»å‹æ¨æ–­ä¼šæ¨æ–­å‡º x æ˜¯ä»€ä¹ˆç±»å‹ï¼Ÿ</p><blockquote><p>What type would type inference infer for x?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-13">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-13" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š1</p><p>åœ¨ç±»å‹æ¨æ–­è¿‡ç¨‹ä¸­ï¼Œå˜é‡ x çš„ç±»å‹æ˜¯ <code>&amp;{integer}</code>ï¼Œæ˜¯å¯¹æŸä¸ªå°šæœªç¡®å®šçš„æ•´æ•°ç±»å‹çš„å¼•ç”¨ã€‚</p><blockquote><p>During type inference the variable x has type &amp;{integer}, a reference to some as yet undetermined integer type.</p></blockquote><p>å¦‚æœæˆ‘ä»¬æƒ³è§£å†³ trait æ–¹æ³•çš„è°ƒç”¨ <code>Trait::f(x)</code>ï¼Œæˆ‘ä»¬å‘ç°å®ƒçš„å‚æ•° x å¿…é¡»æ˜¯ <code>&amp;Self</code> ç±»å‹ï¼Œå³å®ç°äº† Trait çš„æŸä¸ª Self ç±»å‹ã€‚æˆ‘ä»¬å‘ç°æ¨æ–­ <code>0: u32</code> æ—¢æ»¡è¶³äº† u32 æ˜¯ä¸€ä¸ªæ•´æ•°çš„çº¦æŸï¼Œä¹Ÿæ»¡è¶³äº† u32 å®ç°äº† Traitï¼Œæ‰€ä»¥è¿™ä¸ªæ–¹æ³•è°ƒç”¨æœ€ç»ˆè°ƒç”¨äº† <code>&lt;u32 as Trait&gt;::f(x)</code> å¹¶æ‰“å°å‡º 1ã€‚</p><blockquote><p>If we want to resolve the trait method call <code>Trait::f(x)</code>, we find that its argument x must be of type <code>&amp;Self</code> for some type Self that implements Trait. We find that inferring 0: u32 satisfies both the constraint that u32 is an integer as well as u32 implements Trait, so the method call ends up calling <code>&lt;u32 as Trait&gt;::f(x)</code> and prints 1.</p></blockquote><p>åœ¨è¿™ä¸ª <a href="https://stackoverflow.com/a/28552082/6086311" target="_blank" rel="noopener noreferrer">Stack Overflow</a> çš„ç­”æ¡ˆä¸­è¯¦ç»†ä»‹ç»äº† Trait æ–¹æ³•çš„è§£æã€‚</p><blockquote><p>Trait method resolution is covered in more detail in this <a href="https://stackoverflow.com/a/28552082/6086311" target="_blank" rel="noopener noreferrer">Stack Overflow</a> answer.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="16---i">#16 <code>--i</code><a class="hash-link" href="#16---i" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-15">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-15" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut x = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    --x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}{}&quot;, --x, --x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-15">æç¤º<a class="hash-link" href="#æç¤º-15" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>Rust æ‰€æ”¯æŒçš„è¿ç®—ç¬¦é›†åœ¨ <code>std::ops</code> ä¸­æœ‰ç›¸å…³æ–‡æ¡£ã€‚</p><blockquote><p>The set of operators supported by Rust is documented in <code>std::ops</code>.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-14">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-14" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š44</p><p>ä¸ C æˆ– Java ä¸åŒï¼ŒRust ä¸­æ²¡æœ‰è‡ªå¢è‡ªå‡è¿ç®—ç¬¦ã€‚Rust è¯­è¨€è®¾è®¡çš„ FAQï¼ˆç½‘ä¸Šå·²ç»æ²¡æœ‰äº†ï¼‰æ›¾ç»æ¶‰åŠè¿‡åŸå› ã€‚</p><blockquote><p>Unlike C or Java, there is no unary increment or decrement operator in Rust. The Rust language design FAQ (no longer available online) used to touch on the reason:</p></blockquote><p>ä¸ºä»€ä¹ˆ Rust æ²¡æœ‰è‡ªå¢å’Œè‡ªå‡è¿ç®—ç¬¦ï¼Ÿ</p><blockquote><p>Why doesn&#x27;t Rust have increment and decrement operators?</p></blockquote><p>Preincrement å’Œ Postincrementï¼ˆä»¥åŠä¸ä¹‹å¯¹åº”çš„ Decrementï¼‰ï¼Œè™½ç„¶æ–¹ä¾¿ï¼Œä½†ä¹Ÿç›¸å½“å¤æ‚ã€‚å®ƒä»¬éœ€è¦å¯¹è®¡ç®—é¡ºåºè¶³å¤Ÿäº†è§£ï¼Œå¹¶ç»å¸¸å¯¼è‡´ C å’Œ C++ ä¸­ä¸€äº›å¾®å¦™çš„é”™è¯¯å’Œæœªå®šä¹‰çš„è¡Œä¸ºã€‚</p><blockquote><p>Preincrement and postincrement (and the decrement equivalents), while convenient, are also fairly complex. They require knowledge of evaluation order, and often lead to subtle bugs and undefined behavior in C and C++. x = x + 1 or x += 1 is only slightly longer, but unambiguous.</p></blockquote><p>åœ¨æ²¡æœ‰è‡ªå‡è¿ç®—ç¬¦çš„æƒ…å†µä¸‹ï¼Œ<code>--x</code> è¢«è§£æä¸º <code>-(-x)</code>ã€‚åœ¨ <code>x = 4</code> çš„æƒ…å†µä¸‹ï¼Œè¿™å°†æ˜¯ <code>-(-4)</code>ï¼Œä¹Ÿå°±æ˜¯ 4ã€‚è¯¥ç¨‹åºç­‰åŒäºï¼š</p><blockquote><p>In the absense of a decrement operator, --x is parsed as -(-x). In the case of x = 4 this would be -(-4) which is 4. The program is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut x = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}{}&quot;, 4, 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="17--------">#17 <code>-- - --</code><a class="hash-link" href="#17--------" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-16">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-16" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut a = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut b = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, a-- - --b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-16">æç¤º<a class="hash-link" href="#æç¤º-16" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>Rust æ”¯æŒçš„æ“ä½œç¬¦éƒ½åœ¨ <code>stdï¼šï¼šops</code>ã€‚</p><blockquote><p>The set of operators supported by Rust is documented in <code>std::ops</code>.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-15">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-15" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š2</p><p>ä¸åƒ C æˆ–è€… Javaï¼ŒRust æ²¡æœ‰è‡ªå¢å’Œè‡ªå‡è¿ç®—ç¬¦ã€‚Rust è¯­è¨€è®¾è®¡çš„ FAQï¼ˆç½‘ä¸Šå·²ç»æ²¡æœ‰äº†ï¼‰æ›¾ç»æ¢è®¨è¿‡è¿™ä¸ªåŸå› ã€‚</p><blockquote><p>Unlike C or Java, there is no unary increment or decrement operator in Rust. The Rust language design FAQ (no longer available online) used to touch on the reason:</p></blockquote><p>ä¸ºä»€ä¹ˆ Rust æ²¡æœ‰è‡ªå¢å’Œè‡ªå‡è¿ç®—ç¬¦ï¼Ÿ</p><p>Preincrement (<code>++i</code>) å’Œ Postincrement (<code>--i</code>)ï¼ˆä»¥åŠä¸ä¹‹å¯¹åº”çš„ Decrementï¼‰ï¼Œè™½ç„¶æ–¹ä¾¿ï¼Œä½†ä¹Ÿç›¸å½“å¤æ‚ã€‚ç”¨æˆ·éœ€è¦çŸ¥é“æ±‚å€¼é¡ºåºï¼Œè¿™ç»å¸¸å¯¼è‡´ä¸€äº› C å’Œ C++ ä¸­å¾®å¦™çš„é”™è¯¯å’Œæœªå®šä¹‰çš„è¡Œä¸ºã€‚</p><blockquote><p>Why doesn&#x27;t Rust have increment and decrement operators?
Preincrement and postincrement (and the decrement equivalents), while convenient, are also fairly complex. They require knowledge of evaluation order, and often lead to subtle bugs and undefined behavior in C and C++. x = x + 1 or x += 1 is only slightly longer, but unambiguous.</p></blockquote><p>åœ¨æ²¡æœ‰è‡ªå‡è¿ç®—ç¬¦ (åŒ…æ‹¬ <code>i--</code> å’Œ <code>--i</code>) çš„æƒ…å†µä¸‹ï¼Œ<code>a-- --b</code> ä¼šè¢«è§£æä¸º <code>a-(-(-(-b))))</code>ã€‚åœ¨ <code>a=5</code> å’Œ <code>b=3</code> çš„æƒ…å†µä¸‹ï¼Œè¿™ä¸ªè¡¨è¾¾å¼çš„å€¼æ˜¯ <code>5-3</code>ï¼Œä¹Ÿå°±æ˜¯ <code>2</code>ã€‚</p><blockquote><p>In the absense of postfix and prefix decrement operators, a-- - --b is parsed as a - (-(-(-(-b)))). In the case of a = 5 and b = 3 the value of this expression is 5 - 3 which is 2.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="18-f-and-f">#18 <code>f() and f()</code><a class="hash-link" href="#18-f-and-f" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-17">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-17" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f: fn(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let print2 = || print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S { f: print2 }.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-17">æç¤º<a class="hash-link" href="#æç¤º-17" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>è°ƒç”¨ <code>.f()</code> å¯ä»¥è§£æä¸ºå­—æ®µ f æˆ–å›ºæœ‰çš„æ–¹æ³• fï¼Œä½ å¦‚ä½•å†™å‡ºå¯¹å¦ä¸€ä¸ªçš„è°ƒç”¨ï¼Ÿ</p><blockquote><p>The call .f() resolves to either the field f or the inherent method f. How would you write a call to the other one?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-16">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-16" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š1</p><p>ä¸€ä¸ªçœ‹èµ·æ¥åƒ <code>.f()</code>çš„è°ƒç”¨æ€»ä¼šè§£æåˆ°ä¸€ä¸ªæ–¹æ³•ï¼Œåœ¨è¿™é‡Œæ˜¯å›ºæœ‰çš„æ–¹æ³• <code>S::f</code>ã€‚å¦‚æœä½œç”¨åŸŸå†…æ²¡æœ‰æ–¹æ³• fï¼Œé‚£ä¹ˆå³ä½¿å­—æ®µ f å­˜åœ¨å¹¶åŒ…å«ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œè¿™æ ·çš„è°ƒç”¨ä¹Ÿä¸èƒ½ç¼–è¯‘ã€‚</p><blockquote><p>A call that looks like .f() always resolves to a method, in this case the inherent method <code>S::f</code>. If there were no method f in scope, a call like this would fail to compile even if a field f exists and contains a function pointer.</p></blockquote><p>ä¸ºäº†è°ƒç”¨å­˜å‚¨åœ¨å­—æ®µ f ä¸­çš„å‡½æ•°æŒ‡é’ˆï¼Œæˆ‘ä»¬éœ€è¦åœ¨å­—æ®µå‘¨å›´å†™ä¸Šåœ†æ‹¬å·ã€‚</p><blockquote><p>To call the function pointer stored in field f, we would need to write parentheses around the field access:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let print2 = || print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (S { f: print2 }.f)();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="19-move-or-drop">#19 <code>move or drop</code><a class="hash-link" href="#19-move-or-drop" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-18">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-18" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _ = s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-18">æç¤º<a class="hash-link" href="#æç¤º-18" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>s æ‰€æœ‰æƒç§»åŠ¨äº†å—ï¼Ÿ</p><blockquote><p>Does s get moved?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-17">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-17" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š21</p><p>ç›¸å…³çš„ä¸€è¡Œæ˜¯ <code>let _ = s</code>ã€‚å¦‚æœè¿™ä¸€è¡Œæ²¡æœ‰ç§»åŠ¨ sï¼Œé‚£ä¹ˆ s å°†ç»§ç»­å­˜åœ¨ï¼Œç›´åˆ°å¤§æ‹¬å·ç»“å°¾ï¼Œç¨‹åºå°†æ‰“å° 21ã€‚ä½†æ˜¯å¦‚æœè¿™ä¸€è¡Œç§»åŠ¨äº† sï¼Œè€Œæ²¡æœ‰ç»‘å®šå®ƒï¼Œé‚£ä¹ˆè¢«ç§»åŠ¨çš„ S ç±»å‹çš„å€¼å°†è¢«ç«‹å³ dropï¼Œç¨‹åºå°†æ‰“å° 12ã€‚</p><blockquote><p>The relevant line is let _ = s. If this line does not move s then s will continue to live until the close curly brace and the program would print 21. But if this line does move s, without binding it, then the moved value of type S would be dropped immediately and the program would print 12.</p></blockquote><p>äº‹å®ä¸Šï¼Œs å¹¶æ²¡æœ‰è¢«ç§»åŠ¨ï¼Œè¾“å‡ºç»“æœæ˜¯ 21ã€‚</p><blockquote><p>In fact s does not get moved and the output is 21.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="20-return-and-return">#20 <code>return and return</code><a class="hash-link" href="#20-return-and-return" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-19">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-19" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn return1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (return { print!(&quot;1&quot;) }) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn return2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if return { print!(&quot;2&quot;) } {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn break1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (break { print!(&quot;1&quot;) }) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn break2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if break { print!(&quot;2&quot;) } {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    break1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    break2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-19">æç¤º<a class="hash-link" href="#æç¤º-19" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>Rust ä¸­æ¶‰åŠ break çš„è¯­æ³•ä¸æ¶‰åŠ return çš„è¯­æ³•ä¸åŒã€‚</p><blockquote><p>The Rust grammar involving break is different from the grammar involving return.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-18">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-18" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š121</p><p>è®©æˆ‘ä»¬ä»¥æ­¤ç ”ç©¶è¿™äº›å‡½æ•°ã€‚</p><blockquote><p>Let&#x27;s work through the functions one at a time.</p></blockquote><ul><li><p><code>fn return1</code></p><p>  if è¯­å¥çš„ï¼Œæ¡ä»¶ã€‚è¢«è§£æä¸ºä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè¿™ä¸ªè¡¨è¾¾å¼ä¼šè¿”å› <code>{ print!(&quot;1&quot;) }</code> å³ ().è¿™ä¸ªå€¼éœ€è¦åœ¨è¿”å›å‰è¢«è®¡ç®—ï¼Œæ‰€ä»¥æœ€ç»ˆæ‰“å° 1.</p><blockquote><p>The condition of the if-statement is parsed as a return-expression that returns the value { print!(&quot;1&quot;) } of type (). The value needs to be evaluated prior to being returned so this function prints 1.</p></blockquote></li><li><p><code>fn return2</code></p><p> è¿™ä¸ªå‡½æ•°å’Œ <code>return1</code> ä¸€æ ·ã€‚<code>return</code> å…³é”®å­—ä¼šç«‹å³æ¶ˆè€—æ‰è¿”å›å€¼ï¼Œå³ä½¿è¿”å›å€¼è¢«å¤§æ‹¬å·åŒ…è£¹ï¼ç”šè‡³æ˜¯åœ¨ if è¯­å¥çš„æ¡ä»¶ä¸­ï¼Œå¤§æ‹¬å· (ä¾‹å¦‚ç»“æ„ä½“) é€šå¸¸ä¹Ÿä¸ä¼šè¢«æ¥å—ã€‚</p><blockquote><p>This function is parsed the same as return1. The return keyword eagerly consumes a trailing return value, even if the return value begins with a curly brace, and even in the condition of an if-statement where curly braces such as in a struct literal would ordinarly not be accepted. This function prints 2.</p></blockquote></li><li><p><code>fn break1</code></p><p>  if è¯­å¥çš„æ¡ä»¶æ˜¯æ˜¯ä¸ª break-with-value è¡¨è¾¾å¼ï¼Œå®ƒä¼šç»“æŸæ•´ä¸ªå¾ªç¯ï¼Œå¹¶è¿”å› <code>{ print!(&quot;1&quot;) }</code>, å³ ()ï¼Œå’Œ <code>return1</code> ç±»ä¼¼ï¼Œä¸ºäº†åœ¨æ‰“ç ´å¾ªç¯æ—¶è¿”å›å€¼ï¼Œè¿™ä¸ªå€¼éœ€è¦è¢«è®¡ç®—ï¼Œæ‰€ä»¥æœ€ç»ˆæ‰“å° 1ï¼›</p><blockquote><p>The condition of the if-statement is a break-with-value expression that breaks out of the enclosing loop with the value { print!(&quot;1&quot;) } of type (). Similar to return1, in order to break with this value the value needs to be evaluated and this function prints 1.</p></blockquote></li><li><p><code>fn break2</code></p><p>  è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° break å’Œ return è¯­æ³•çš„åŒºåˆ«ã€‚ä¸åƒ returnï¼Œif æ¡ä»¶é‡Œçš„ break å…³é”®å­—ä¸ä¼šç«‹å³è§£æå‡ºåé¢å¤§æ‹¬å·çš„å€¼ã€‚è¿™æ®µä»£ç ä¼šè¢«è§£æä¸ºï¼š</p><blockquote><p>Here we observe a difference between the grammar of break and the grammar of return. Unlike return, the break keyword in the condition of this if-statement does not eagerly parse a value that begins with a curly brace. This code is parsed as:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if break {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  æˆ‘ä»¬åœ¨æ‰§è¡Œ print å‰æ‰“ç ´äº†å¾ªç¯ï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°ä¸ä¼šæ‰§è¡Œ print.</p><blockquote><p>We break out of the loop before executing the print, so this function does not print anything.</p></blockquote><p>  æˆ‘ç›¸ä¿¡ return å’Œ break ä¸åŒçš„åŸå› æ˜¯ï¼Œreturn åœ¨ Rust 1.0 ä»¥åŠä¹‹å‰æ˜¾ç„¶éƒ½æ˜¯æ”¯æŒçš„ï¼Œä½†æ˜¯ break-with-value æ˜¯åœ¨ Rust 1.19 æ‰è¢«å¼•å…¥ä¹‹åã€‚<code>break2</code> ä¸­çš„ä»£ç ä¸€ç›´éƒ½æ˜¯åˆæ³•çš„ Rust ä»£ç ï¼Œæ‰€ä»¥åœ¨å®ç° break-with-value è¿™ä¸ªè¯­è¨€ç‰¹æ€§æ—¶ä¹Ÿè€ƒè™‘åˆ°ä¸èƒ½æ”¹å˜å®ƒçš„è¡Œä¸ºã€‚</p><blockquote><p>I believe the reason for the difference between return and break is that returning a value was obviously supported at Rust 1.0 and well before, but break-with-value was introduced fairly late, in Rust 1.19. The code in break2 was perfectly legal Rust code prior to Rust 1.19 so we cannot change its behavior when implementing the break-with-value language feature.</p></blockquote><p>  æœªæ¥çš„ç‰ˆæœ¬æœ‰å¯èƒ½å¯¹è¿™ä¸¤ç§è¯­æ³•è¿›è¡Œè°ƒæ•´ï¼Œä½¿ä¹‹ç›¸äº’ä¸€è‡´ã€‚</p><blockquote><p>It is possible that a future Edition would adjust the two grammars to align with each other.</p></blockquote></li></ul><p>main çš„è¾“å‡ºä¸º 121ã€‚</p><blockquote><p>The output from main is 121.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-return--break">#21 <code>return &amp; break</code><a class="hash-link" href="#21-return--break" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-20">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-20" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;F: FnOnce() -&gt; bool&gt; Trait for F {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = || { (return) || true; };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x().f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = loop { (break) || true; };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = || { return (|| true); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x().f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = loop { break (|| true); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = || { return || true; };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x().f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = loop { break || true; };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-20">æç¤º<a class="hash-link" href="#æç¤º-20" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>åœ¨æœ¬é¢˜ä¸­ï¼Œbreak å’Œ return å…³é”®å­—çš„è¯­æ³•æ˜¯ä¸€æ ·çš„ã€‚</p><blockquote><p>The break and return keywords have the same grammar in this question.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-19">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-19" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š221111</p><p>æˆ‘ä»¬æƒ³çŸ¥é“ <code>return || true;</code> å’Œ <code>break || true;</code> çš„æ¯ä¸€ä¸ªå¯èƒ½çš„æ‹¬å·æ˜¯å¦è¯„ä¼°ä¸ºé—­åŒ… <code>|| true</code> æˆ–å•ä½å€¼ ()ã€‚</p><blockquote><p>We want to know whether each possible parenthesization of return || true; and break || true; evaluates to the closure || true or to the unit value ().</p></blockquote><ul><li><p><code>let x = || { (return) || true; };</code></p><p>  åœ¨è¿™ä¸€è¡Œï¼Œx æ˜¯ä¸€ä¸ªè¿”å› () çš„é—­åŒ…ã€‚ç­‰ä»·äº <code>let x = || {}</code>.å½“æˆ‘ä»¬è°ƒç”¨ <code>x().f()</code> æ—¶ï¼Œæ–¹æ³• f ä¼šè¢«è§£æä¸º <code>impl Trait for ()</code>, å¹¶æ‰“å° 2.</p><blockquote><p>On this line, x is a closure that returns (). It is equivalent to let x = || {}. When we call x().f(), the method f resolves to impl Trait for () which prints 2.</p></blockquote><p>  è¡¨è¾¾å¼ <code>(treturn)</code> çš„ç±»å‹æ˜¯åŸå§‹çš„ never ç±»å‹ï¼Œé€šå¸¸å†™æˆ <code>ï¼</code>ã€‚è®¡ç®— <code>! || true</code> æ˜¯åˆæ³•çš„ï¼Œå› ä¸º <code>!</code> å¯ä»¥è½¬ä¸ºä»»ä½•ç±»å‹ï¼Œåœ¨è¿™é‡Œæ˜¯ <code>bool</code>ã€‚è¡¨è¾¾å¼ <code>! || true</code> æ˜¯ä¸€ä¸ªé€»è¾‘æˆ–ï¼Œå·¦ä¾§å’Œå³ä¾§éƒ½æ˜¯ <code>bool</code>ã€‚</p><blockquote><p>The type of the expression (return) is the primitive never type, usually written as !. It is legal to compute ! || true because ! can fill in for any type, in this case bool. The expression ! || true is a logical-OR with bool on both the left-hand side and right-hand side.</p></blockquote><p>  <code>!</code> å¯ä»¥è½¬ä¸ºä»»ä½•ç±»å‹çš„è¡Œä¸ºå…è®¸æˆ‘ä»¬å†™å‡ºå¦‚ä¸‹ä»£ç ï¼š</p><blockquote><p>The behavior of ! of filling in for any type is what allows us to write:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn f() -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unimplemented!()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  å…¶ä¸­ <code>unimplemented!()</code> çš„ç±»å‹ï¼Œå› ä¸ºå®ƒåœ¨æ²¡æœ‰æ±‚å€¼çš„æƒ…å†µä¸‹ç›´æ¥ panicï¼Œå®ƒçš„è¿”å›å€¼ç±»å‹ä¹Ÿæ˜¯ <code>ï¼</code>ã€‚</p><blockquote><p>in which the type of unimplemented!(), since it panics without evaluating to any value, is also !.</p></blockquote></li><li><p><code>let x = loop { (break) || true; };</code></p><p>  å’Œ <code>(return)</code> ç±»ä¼¼ï¼Œ<code>(break)</code> çš„ç±»å‹ä¹Ÿæ˜¯ <code>!</code>. è¿™è¡Œä»£ç ä¼šæ‰“ç ´å¾ªç¯ï¼Œå¹¶è¿”å› <code>()</code>, æ‰€ä»¥ <code>x</code> çš„ç±»å‹æ˜¯ <code>()</code>.è°ƒç”¨ <code>x.f()</code> ä¼šæ‰“å° 2.</p><blockquote><p>Similar to (return), the type of (break) is the never type !. This code breaks out of the loop with the implicit value (), so x is of type (). Calling x.f() will print 2.</p></blockquote></li><li><p><code>let x = || { return (|| true); };</code></p><p>  åœ¨è¿™ä¸€è¡Œï¼Œ<code>x</code> æ˜¯ä¸€ä¸ªé—­åŒ…ï¼Œå®ƒè¿”å›ä¸€ä¸ªè¿”å› true çš„é—­åŒ…ã€‚ä½ å¯ä»¥å†™ <code>x()()</code>ï¼Œå®ƒçš„å€¼ä¼šæ˜¯ trueã€‚</p><blockquote><p>On this line x is a closure that returns a closure that returns true. You could write x()() and that would be true.</p></blockquote><p>  Quiz ä»£ç è°ƒç”¨äº† <code>x().f()</code>, è¿™ä¼šè§£æä¸º <code>impl&lt;F&gt; Trait for F where F: FnOnce() -&gt; bool</code>. æœ€ç»ˆæ‰“å° 1.</p><blockquote><p>The quiz code calls <code>x().f()</code> which resolves to <code>impl&lt;F&gt; Trait for F where F: FnOnce() -&gt; bool</code>. That trait impl prints 1.</p></blockquote></li><li><p><code>let x = loop { break (|| true); };</code></p><p>  è¿™æ˜¯ä¸€ä¸ªåŒ…å« <code>break-with-value</code> è¡¨è¾¾å¼çš„å¾ªç¯ã€‚<code>break</code> çš„å‚æ•°å˜æˆäº†å¾ªç¯çš„è¿”å›å€¼ã€‚è¿™æ®µä»£ç ç­‰åŒäº <code>let x = || true</code>ã€‚</p><blockquote><p>This is a loop containing a break-with-value expression. The argument of the break becomes the value of the enclosing loop. This code is equivalent to let <code>x = || true</code>.</p></blockquote><p>  å½“æˆ‘ä»¬è°ƒç”¨ <code>x.f()</code> æ—¶ï¼Œå®ƒä½¿ç”¨äº† FnOnce çš„ Trait å®ç°ï¼Œæ‰“å°å‡º 1ã€‚</p><blockquote><p>When we call <code>x.f()</code> it uses the FnOnce impl of Trait which prints 1.</p></blockquote></li><li><p><code>let x = || { return || true; };</code></p><p>  ç°åœ¨æˆ‘ä»¬æ¥åˆ°äº†è¿™ä¸ªé—®ç­”é—®é¢˜çš„æ ¸å¿ƒã€‚<code>return || true</code> çš„è§£æä¸ <code>(return) || true</code> ç›¸åŒï¼Œè¿˜æ˜¯ä¸ <code>return (|| true)</code> ç›¸åŒï¼Ÿ</p><blockquote><p>Now we arrive at the meat of this quiz question. Is <code>return || true</code> parsed the same as <code>(return) || true</code> or as <code>return (|| true)</code>?</p></blockquote><p>  ç»“æœæ˜¯åè€…ï¼Œæ‰€ä»¥ x æ˜¯ä¸€ä¸ªè¿”å› true çš„é—­åŒ…ã€‚<code>x().f()</code> æ‰“å° 1ã€‚</p><blockquote><p>It turns out to be the latter, so x is a closure that returns a closure that returns true. <code>x().f()</code> prints 1.</p></blockquote></li><li><p><code>let x = loop { break || true; };</code></p><p>  è¿™ä¸ªä¹Ÿæ˜¯ç±»ä¼¼çš„é—®é¢˜ï¼Œè¿™æ˜¯ <code>(break) || true</code> è¿˜æ˜¯ <code>break (|| true)</code>ï¼Ÿ</p><blockquote><p>Similar question here, is this <code>(break) || true</code> or <code>break (|| true)</code>?</p></blockquote><p>  <code>break-with-value</code> è¯­è¨€åŠŸèƒ½æ˜¯åœ¨ 1.0 ä¹‹åçš„ä¸¤å¹´å (Rust 1.19) åŠ å…¥çš„ã€‚åœ¨ break-with-value ä¹‹å‰ï¼Œ<code>break || true</code> æ˜¯å®Œå…¨åˆæ³•çš„ Rust ä»£ç ï¼Œè§£æä¸º <code>(break) || true</code>ã€‚</p><blockquote><p>The break-with-value language feature was added to Rust more than two years after 1.0, in Rust 1.19. Prior to break-with-value, <code>break || true</code> was perfectly legal Rust code that parsed as <code>(break) || true</code>.</p></blockquote><p>  åœ¨ Rust 1.19 ä¸­ï¼Œè¿™æ®µä»£ç çš„è¡Œä¸ºè¢«è¯­è¨€æ— æ„ä¸­æ‰“ç ´äº†ï¼Œç°åœ¨å®ƒè¢«è§£æä¸º <code>break (|| true)</code>ï¼Œæ‰“å°å‡ºæ¥çš„å€¼æ˜¯ 1ã€‚</p><blockquote><p>In Rust 1.19 the behavior of this code was unintentionally broken by the language such that now it parses as <code>break (|| true)</code> and the printed value is 1.</p></blockquote><p>  å¦‚æœæˆ‘ä»¬åœ¨ Rust 1.19 çš„å¼€å‘è¿‡ç¨‹ä¸­æ³¨æ„åˆ°è¿™ç§æ„ä¹‰ä¸Šçš„å˜åŒ–ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šè°ƒæ•´è§£æä»¥ä¿ç•™ç°æœ‰ä»£ç çš„æ„ä¹‰ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™æ ·åšä¼šå¯¼è‡´è¯­æ³•åœ¨ return å’Œ break ä¹‹é—´æœ‰ä¸åŒçš„è¡¨ç°ï¼Œé™¤äº†å†å²çš„æ„å¤–ï¼Œæ²¡æœ‰ä»»ä½•åˆç†çš„ç†ç”±ã€‚</p><blockquote><p>If we had noticed this change in meaning during the development of Rust 1.19, we may have adjusted the parsing to preserve the meaning of existing code. Unfortunately doing so would result in a grammar that behaves differently between return and break for no justifiable reason other than an accident of history.</p></blockquote><p>  æˆ–è€…ï¼Œæˆ‘ä»¬ä¹Ÿæœ‰å¯èƒ½è®¤ä¸ºè¿™æ˜¯ä¸€ä¸ªæ°¸è¿œä¸ä¼šå‡ºç°åœ¨çœŸå®ä»£ç ä¸­çš„è¯­æ³•è¾¹ç¼˜æ¡ˆä¾‹ï¼Œç”¨ Crater æ¥éªŒè¯è¿™ä¸€å‡è®¾ï¼Œå¹¶æœ‰æ„æ‰“ç ´è¿™ä¸€è¡Œä¸ºã€‚</p><blockquote><p>Or it is possible we would have ruled this an edge case of syntax that would never appear in real code, used Crater to validate that hypothesis, and broken the behavior intentionally.</p></blockquote></li></ul><p>main çš„å®Œæ•´è¾“å‡ºæ˜¯ 221111.</p><blockquote><p>The total output from main is 221111.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="22---is-a-token">#22 <code>- is a token</code><a class="hash-link" href="#22---is-a-token" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-21">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-21" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt) =&gt; { print!(&quot;1&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt) =&gt; { print!(&quot;2&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt $c:tt) =&gt; { print!(&quot;3&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt $c:tt $d:tt) =&gt; { print!(&quot;4&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt $c:tt $d:tt $e:tt) =&gt; { print!(&quot;5&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt) =&gt; { print!(&quot;6&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt $g:tt) =&gt; { print!(&quot;7&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(-1.);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(-1.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(-1.0e1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(-1.0e-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-21">æç¤º<a class="hash-link" href="#æç¤º-21" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>macro ä¼šè®¡ç®—è¾“å…¥çš„ &quot;token&quot; çš„æ•°é‡ã€‚</p><blockquote><p>The macro is counting how many &quot;tokens&quot; are in its input.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-20">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-20" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š22222</p><p>æ‰€æœ‰çš„ mï¼è°ƒç”¨éƒ½ä¼ é€’äº†ä¸¤ä¸ªæ ‡è®°ä½œä¸ºè¾“å…¥ï¼šä¸€ä¸ªå‡å·ï¼Œç„¶åæ˜¯ä¸€ä¸ªæ•´æ•°æˆ–æµ®ç‚¹å­—æ ·çš„æ ‡è®°ã€‚</p><blockquote><p>All five invocations of m! pass two tokens as input: a minus sign followed by an integer or floating point literal token.</p></blockquote><p>æµ®ç‚¹å­—é¢ç¬¦å· <code>1.</code>ã€<code>1.0</code>ã€<code>1.0e1</code>ã€<code>1.0e-1</code> éƒ½æ˜¯å•ä¸€çš„åŸå­ç¬¦å·ã€‚</p><blockquote><p>The floating point literals 1., 1.0, 1.0e1, 1.0e-1 are each a single atomic token.</p></blockquote><p>Rust ç¼–è¯‘å™¨å†…ç½®çš„è§£æå™¨æ€»æ˜¯å°†è´Ÿå·ä½œä¸ºä¸€ä¸ªå•ç‹¬çš„æ ‡è®°ï¼Œä¸æ•°å­—è¿›è¡ŒåŒºåˆ†ã€‚ç„¶è€Œï¼Œåœ¨è¿‡ç¨‹å®ä¸­ï¼Œç”¨æˆ·å®šä¹‰çš„è§£æå™¨å¯ä»¥é€šè¿‡å‘ <code>proc_macro::Literal</code> çš„æ„é€ å™¨ä¹‹ä¸€ä¼ é€’ä¸€ä¸ªè´Ÿçš„æ•´æ•°æˆ–è´Ÿçš„æµ®ç‚¹æ•°æ¥æ„é€ ä¸€ä¸ªè´Ÿæ•°ä½œä¸ºå•ä¸ªæ ‡è®°ã€‚å¦‚æœè¿™æ ·çš„è´Ÿæ•°æœ€ç»ˆå‡ºç°åœ¨éšåçš„è¿‡ç¨‹å®è°ƒç”¨çš„è¾“å…¥ä¸­ï¼Œåˆ™ç”±ç¼–è¯‘å™¨å†³å®šæ˜¯é‡å†™æˆä¸€å¯¹æ ‡è®°è¿˜æ˜¯å°†å…¶ä½œä¸ºä¸€ä¸ªæ ‡è®°ã€‚</p><blockquote><p>The parser built into the Rust compiler always parses a negative sign as a separate token from the numeric literal that is being negating. However, it is possible for a user-defined parser within a procedural macro to construct a negative number as a single token by passing a negative integer or negative floating point value to one of the constructors of <code>proc_macro::Literal</code>. If such a negative literal ends up in the input of a subsequent procedural macro invocation, it is up to the compiler whether to rewrite into a pair of tokens or keep them as one.</p></blockquote><p>ç¼–è¯‘å™¨çš„è§£æå™¨çš„è¡Œä¸ºåœ¨è¯­è¨€è¡¨é¢ä¹Ÿæ˜¯å¯ä»¥è§‚å¯Ÿåˆ°çš„ï¼Œä¸ä»…ä»…æ˜¯åœ¨å®ä¸­ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„ä»£ç æ‰“å°å‡º -81ï¼Œå› ä¸ºè¡¨è¾¾å¼è¢«è§£æä¸º <code>-(3i32.pow(4))</code> è€Œä¸æ˜¯ <code>(-3i32).pow(4)</code>ã€‚</p><blockquote><p>The behavior of the compiler&#x27;s parser is observable in the surface language as well, not only in macros. For example the following code prints -81 because the expression is parsed as -(3i32.pow(4)) rather than (-3i32).pow(4).</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let n = -3i32.pow(4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="23-method-lookup-order">#23 <code>method lookup order</code><a class="hash-link" href="#23-method-lookup-order" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-22">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-22" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn g(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn g(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn g(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S.g();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-22">æç¤º<a class="hash-link" href="#æç¤º-22" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>æˆ‘ä¸èƒ½å¸®åŠ©ä½ è§£å†³è¿™ä¸ªé—®é¢˜ã€‚è¿™æ˜¯ç”±è¯­è¨€æœ¬èº«åšå‡ºçš„ä¸€ä¸ªç›¸å½“éšæ„çš„é€‰æ‹©ã€‚è¯•è¯•æ‰€æœ‰çš„å¯èƒ½å§ï¼</p><blockquote><p>I can&#x27;t help you with this one. This is a pretty arbitrary choice made by the language. Try all the possibilities!</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-21">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-21" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š12</p><p><code>S.f()</code> ä¼šè°ƒç”¨å›ºæœ‰æ–¹æ³• fã€‚å¦‚æœä¸€ä¸ªå›ºæœ‰æ–¹æ³•å’Œä¸€ä¸ª Trait æ–¹æ³•åŒåï¼Œå¹¶ä¸”è¿”å›å€¼ç›¸åŒï¼Œæ™®é€šçš„æ–¹æ³•è°ƒç”¨æ€»æ˜¯ä¼šé€‰æ‹©å›ºæœ‰æ–¹æ³•ã€‚è°ƒç”¨è¿™å¿…é¡»å†™ <code>Trait::f(&amp;s)</code> æˆ–è€… <code>&lt;S as Trait&gt;::f(&amp;s)</code> å»è°ƒç”¨ Trait æ–¹æ³•ã€‚ </p><blockquote><p><code>S.f()</code> calls the inherent method f. If an inherent method and a trait method have the same name and receiver type, plain method call syntax will always prefer the inherent method. The caller would need to write <code>Trait::f(&amp;S)</code> or <code>&lt;S as Trait&gt;::f(&amp;S)</code> in order to call the trait method.</p></blockquote><p>å¯¹äºå®çš„ä½œè€…æ¥è¯´ï¼Œæ„è¯†åˆ°è¿™ä¸€ç‚¹å¾ˆé‡è¦ã€‚å®ç”Ÿæˆçš„ä»£ç é€šå¸¸ä¸åº”è¯¥ä½¿ç”¨æ™®é€šçš„æ–¹æ³•è°ƒç”¨è¯­æ³•æ¥è°ƒç”¨ç”¨æˆ·å®šä¹‰çš„ç±»å‹ä¸Šçš„ç‰¹å¾æ–¹æ³•ã€‚è¿™äº›è°ƒç”¨å¯èƒ½ä¼šè¢«ä¸ç‰¹è´¨æ–¹æ³•åŒåçš„å›ºæœ‰æ–¹æ³•æ— æ„ä¸­åŠ«æŒã€‚</p><blockquote><p>It is important for macro authors to be aware of this. Macro-generated code typically should not use method call syntax to invoke trait methods on types defined by the user. Those calls could get unintentially hijacked by inherent methods having the same name as the trait method.</p></blockquote><p>å¦ä¸€æ–¹é¢ï¼Œ<code>S.g()</code> è°ƒç”¨ç‰¹è´¨æ–¹æ³• <code>g</code>ã€‚åœ¨æ–¹æ³•è§£æè¿‡ç¨‹ä¸­ï¼Œå¦‚æœ <code>&amp;</code> å’Œ <code>ï¼†mut</code> éƒ½å¯ä»¥è°ƒç”¨ï¼Œè‡ªåŠ¨å¼•ç”¨æ€»æ˜¯å€¾å‘äºå°†æŸæ ·ä¸œè¥¿å˜æˆ <code>&amp;</code>ï¼Œè€Œä¸æ˜¯å°†å…¶å˜æˆ <code>&amp;mut</code>ã€‚</p><blockquote><p>On the other hand, S.g() calls the trait method g. Auto-ref during method resolution always prefers making something into &amp; over making it into &amp;mut where either one would work.</p></blockquote><p>è¯·å‚é˜… <a href="https://stackoverflow.com/a/28552082/6086311" target="_blank" rel="noopener noreferrer">Stack Overflow</a> çš„ç­”æ¡ˆï¼Œäº†è§£æ–¹æ³•è§£æè¿‡ç¨‹ä¸­è‡ªåŠ¨å¼•ç”¨çš„æ›´è¯¦ç»†è§£é‡Šã€‚</p><blockquote><p>See this Stack Overflow answer for a more detailed explanation of auto-ref during method resolution.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="24-hygiene">#24 <code>Hygiene</code><a class="hash-link" href="#24-hygiene" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-23">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-23" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x: u8 = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const K: u8 = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            print!(&quot;{}{}&quot;, x, K);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let x: u8 = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const K: u8 = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m!();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-23">æç¤º<a class="hash-link" href="#æç¤º-23" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>å®çš„å«ç”Ÿæ€§åªæ˜¯ç”¨äºå±€éƒ¨å˜é‡ã€‚</p><blockquote><p>Hygiene in macro_rules! only applies to local variables.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-22">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-22" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š14</p><p>è¿™ä¸ªç¨‹åºæ‰“å°å‡º 14ï¼Œå› ä¸ºå®çš„ &quot;å«ç”Ÿæ€§&quot;(Hygiene) åªé€‚ç”¨äºå±€éƒ¨å˜é‡ã€‚</p><blockquote><p>This program prints 14 because hygiene in macro_rules! only applies to local variables.</p></blockquote><p>ä½ å¯ä»¥æŠŠ Hygiene æƒ³è±¡æˆï¼šç»™æ¯æ¬¡æåˆ°çš„å±€éƒ¨å˜é‡çš„åå­—åˆ†é…ä¸€ç§é¢œè‰²ï¼Œå…è®¸åœ¨èŒƒå›´å†…æœ‰å¤šä¸ªå¯åŒºåˆ†çš„å±€éƒ¨å˜é‡åŒæ—¶å…·æœ‰ç›¸åŒçš„åå­—ã€‚</p><blockquote><p>You can imagine hygiene as a way of assigning a color to each mention of the name of a local variable, allowing for there to be multiple distinguishable local variables in scope simultaneously with the same name.</p></blockquote><p>åœ¨ main çš„é¡¶ç«¯ï¼Œå‡è®¾æˆ‘ä»¬è®¤ä¸ºå±€éƒ¨å˜é‡ x çš„åå­—æ˜¯ç´«è‰²çš„ xï¼Œå¸¸é‡ K çš„åå­—åªæ˜¯æ™®é€šçš„ Kï¼Œå› ä¸ºå¸¸é‡è¢«è®¤ä¸ºæ˜¯é¡¹ (Item) è€Œä¸æ˜¯å±€éƒ¨å˜é‡ï¼ˆä½ å¯ä»¥æŠŠé¡¹æ”¾åœ¨å‡½æ•°ä½“ä¹‹å¤–ï¼›ä½†æ˜¯ä¸èƒ½æŠŠå±€éƒ¨å˜é‡æ”¾åœ¨å‡½æ•°ä½“ä¹‹å¤–ï¼‰ã€‚</p><blockquote><p>At the top of main, suppose we consider the name of the local variable x to be a purple x. The name of the constant K is just plain K, as constants are considered items rather than local variables (you can place items outside of a function body; you cannot place local variables outside of a function body).</p></blockquote><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let   x: u8 = 1; // x ä¸ºç´«è‰²</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const K: u8 = 2; // K ä¸ºæ— è‰²</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æˆ‘ä»¬ç»§ç»­å¾€ä¸‹çœ‹ï¼Œåœ¨ macro m! çš„å£°æ˜ä¸­ï¼Œæœ‰ä¸¤ä¸ªè¢«ç”¨åˆ°çš„æ ‡è¯†ç¬¦ã€‚å› ä¸ºä½œç”¨åŸŸå†…æœ‰ä¸€ä¸ªå˜é‡ xï¼Œæ‰€ä»¥åœ¨ m! å†…ä½¿ç”¨çš„æ ‡è¯†ç¬¦ x çš„é¢œè‰²ä¸å±€éƒ¨å˜é‡ x ç›¸åŒã€‚åœ¨ä½œç”¨åŸŸå†…æ²¡æœ‰å±€éƒ¨å˜é‡ Kï¼Œæ‰€ä»¥åœ¨å®çš„å£°æ˜ä¸­çš„ K è¢«åˆ†é…äº†ä¸€äº›æ–°çš„é¢œè‰²ï¼Œä¾‹å¦‚æ©™è‰²ã€‚</p><blockquote><p>Continuing down the body of main, within the declaration of the macro m! there are identifiers x and K being used. Since there is a local variable x in scope, the use of the identifier x within the macro body picks up the same color as the local variable x. There is no local variable K in scope so the K within the declaration of the macro is assigned some new color, say orange.</p></blockquote><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}{}&quot;, x, K); // x ä¸ºç´«è‰²ï¼ŒK ä¸ºæ©™è‰²</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æ¥ä¸‹æ¥æˆ‘ä»¬è¿›å…¥ä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸï¼ˆç”¨å¤§æ‹¬å·åˆ’å®šï¼‰ï¼ŒåŒ…å«å¦ä¸€ä¸ª x å’Œ Kã€‚æ¯ä¸€ä¸ªæ–°çš„å±€éƒ¨å˜é‡æ€»æ˜¯ä¼šå¼•å…¥ä¸€ä¸ªæ–°çš„é¢œè‰²ï¼Œæ‰€ä»¥æˆ‘ä»¬æŠŠè¿™ä¸ª x å«åšè“è‰²ã€‚const ä¾ç„¶ä¸æ˜¯ä¸€ä¸ªå±€éƒ¨å˜é‡ï¼Œæ‰€ä»¥æ²¡æœ‰ç»™ K åˆ†é…é¢œè‰²ã€‚</p><blockquote><p>Next we enter a new scope (delimited by curly braces) containing another x and K. Every new local variable always introduces a new color so let&#x27;s call this x blue. The const again is not a local variable so no color is assigned to K.</p></blockquote><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let   x: u8 = 3; // x ä¸ºè“è‰²</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const K: u8 = 4; // K ä¸ºæ— è‰²</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>å½“ <code>m!()</code> å±•å¼€æ—¶ï¼Œå±•å¼€çš„ä»£ç åŒ…å«ä¸€ä¸ªç´«è‰²çš„ x å’Œä¸€ä¸ªæ©™è‰²çš„ Kã€‚ç´«è‰²çš„ x å¯ä»¥å’Œè“è‰²çš„ x åŒºåˆ†å¼€æ¥ï¼Œæ‰€ä»¥ç´«è‰²çš„ x çš„å€¼è¢«æ‰“å°å‡ºæ¥ï¼Œæ˜¯ 1ã€‚è‡³äº Kï¼Œä¸€ä¸ªä¸å«ç”Ÿçš„ï¼ˆæœªç€è‰²çš„ï¼‰K è¢«å…è®¸åƒä»»ä½•é¢œè‰²ä¸€æ ·ã€‚ç¬¬äºŒä¸ª K ä¼šé®è”½ç¬¬ä¸€ä¸ª Kã€‚å½“ m! å¯»æ‰¾ä¸€ä¸ªæ©™è‰²çš„ K æ—¶ï¼Œä¼šè¯†åˆ«åˆ°ç¬¬äºŒä¸ª Kï¼Œç¬¬äºŒä¸ª K çš„å€¼è¢«æ‰“å°å‡ºæ¥ï¼Œå³ 4ã€‚</p><blockquote><p>When m!() expands, the expanded code refers to a purple x and an orange K. The purple x is distinguishable from the blue x -- the value of the purple x is printed which is 1. As for the K, an unhygienic (uncolored) K is allowed to act like any color. The second K is shadowing the first one. It gets picked up when looking for an orange K and its value is printed, which is 4.</p></blockquote><p>æ‰€ä»¥è¾“å‡ºæ˜¯ 14ã€‚</p><blockquote><p>So the output of the quiz code is 14.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="25-drop">#25 <code>drop</code><a class="hash-link" href="#25-drop" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-24">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-24" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::fmt::{self, Display};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Display for S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        formatter.write_str(&quot;1&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn f() -&gt; S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let S = f(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, S);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-24">æç¤º<a class="hash-link" href="#æç¤º-24" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>å¼„æ¸…æ¥šå“ªäº›å€¼è¢«å“ªäº›å˜é‡æ‰€æ‹¥æœ‰ã€‚å½“ä¸€ä¸ªå€¼ä¸å†æœ‰æ‰€æœ‰è€…æ—¶ï¼Œå®ƒå°±è¢« drop äº†ã€‚</p><blockquote><p>Figure out what values are owned by which variables where. A value is dropped when it no longer has an owner.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-23">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-23" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š212</p><p>ç¨‹åºæ‰“å° 212ã€‚</p><blockquote><p>This program prints 212.</p></blockquote><p>åœ¨å‡½æ•° f å†…ï¼Œæ²¡æœ‰ S ä¼šè¢« dropã€‚f å‡½æ•°å†…äº§ç”Ÿä¸€ä¸ª Sï¼Œç„¶åæŠŠå®ƒçš„æ‰€æœ‰æƒè¿”å›ç»™ f çš„è°ƒç”¨è€…ï¼›è°ƒç”¨è€…ä¼šå†³å®šä»€ä¹ˆæ—¶å€™ drop æ‰ä»–æ‹¿åˆ°çš„ Sã€‚</p><blockquote><p>No value of type S gets dropped within the body of function f. The function f conjures an S and returns ownership of it to the caller of f; the caller determines when to drop the S of which it received ownership.</p></blockquote><p>åœ¨ main çš„ç¬¬ä¸€è¡Œï¼Œæˆ‘ä»¬è°ƒç”¨äº† f(),ä½†æ˜¯å¹¶æ²¡æœ‰æŠŠå®ƒç»‘å®šåˆ°æŸä¸€ä¸ªå˜é‡ä¸Šã€‚æ‰€ä»¥ f() è¿”å›çš„ S ä¼šè¢«ç«‹å³ dropï¼Œæ‰“å°äº† 2ã€‚<code>let S = f()</code> ä¸­çš„ S æ˜¯ä¸€ä¸ªå•å…ƒç»“æ„ä½“çš„æ¨¡å¼åŒ¹é… (ä¸æ˜¯ä¸€ä¸ªå˜é‡)ï¼Œå®ƒèƒ½å¤Ÿé€šè¿‡è§£æ„åŒ¹é…åˆ° S ç»“æ„ä½“é‡Œçš„å­—æ®µï¼Œä½†æ˜¯è¿™é‡Œå¹¶æ²¡æœ‰å°†åŒ¹é…åˆ°çš„å­—æ®µç»‘å®šåˆ°æŸä¸€å˜é‡ã€‚</p><blockquote><p>On the first line of main, we call f() and perform an infallible match that binds no new variables. As no variables are declared on this line, there is no variable that could be the owner of the S returned by f() so that S is dropped at that point, printing 2. The S in let S = f() is a unit struct pattern (not a variable name) that matches a value of type S via destructuring but does not bind the value to any variable.</p></blockquote><p>main çš„ç¬¬äºŒè¡Œäº§ç”Ÿä¸€ä¸ªæ–°çš„ Sï¼Œå¹¶æ‰“å°ï¼Œæœ€ååœ¨åˆ†å·å¤„ drop å®ƒã€‚</p><blockquote><p>The second line of main conjures a new S, prints it, and drops it at the semicolon.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="26-lazy-map">#26 <code>lazy map</code><a class="hash-link" href="#26-lazy-map" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-25">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-25" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let input = vec![1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let parity = input</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .iter()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map(|x| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            print!(&quot;{}&quot;, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            x % 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for p in parity {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-25">æç¤º<a class="hash-link" href="#æç¤º-25" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>è¯·æŸ¥é˜… <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html" target="_blank" rel="noopener noreferrer">Iterator</a> Trait çš„æ–‡æ¡£</p><blockquote><p>Refer to the documentation of the Iterator trait.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-24">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-24" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š112031</p><p>æ­£å¦‚ <code>Iterator::map</code> æ–¹æ³•çš„æ–‡æ¡£ä¸­æ‰€æè¿°çš„ï¼Œmap æ“ä½œæ˜¯æƒ°æ€§æ‰§è¡Œçš„ã€‚ä½œä¸ºå‚æ•°æä¾›ç»™ map çš„é—­åŒ…åªæœ‰åœ¨å€¼ä»ç»“æœè¿­ä»£å™¨ä¸­è¢«æ¶ˆè€—æ—¶æ‰ä¼šè¢«è°ƒç”¨ã€‚é—­åŒ…å¹¶ä¸ä¼šç«‹å³åº”ç”¨äºæ•´ä¸ªè¾“å…¥æµã€‚</p><blockquote><p>As described in the documentation of the Iterator::map method, the map operation is performed lazily. The closure provided as an argument to map is only invoked as values are consumed from the resulting iterator. The closure is not applied eagerly to the entire input stream up front.</p></blockquote><p>åœ¨è¿™æ®µä»£ç ä¸­ï¼Œfor å¾ªç¯æ˜¯é©±åŠ¨è¿­ä»£çš„å› ç´ ã€‚å¯¹äºä»å¥‡å¶æ€§è¿­ä»£å™¨ä¸­æ¶ˆè€—çš„æ¯ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬çš„é—­åŒ…éƒ½éœ€è¦è¢«æ‰§è¡Œä¸€æ¬¡ã€‚å› æ­¤ï¼Œè¾“å‡ºå°†åœ¨ç”±é—­åŒ…æ‰“å°çš„æ•°å­—å’Œç”±å¾ªç¯ä½“æ‰“å°çš„æ•°å­—ä¹‹é—´äº¤æ›¿è¿›è¡Œã€‚</p><blockquote><p>In this code, the for loop is what drives the iteration. For each element consumed from the parity iterator, our closure needs to be evaluated one time. Thus the output will alternate between numbers printed by the closure and numbers printed by the loop body.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="27-dyn-trait">#27 <code>dyn Trait</code><a class="hash-link" href="#27-dyn-trait" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-26">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-26" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Base {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Derived: Base {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BothTraits;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Base for BothTraits {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Derived for BothTraits {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn dynamic_dispatch(x: &amp;dyn Base) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.method();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn static_dispatch&lt;T: Base&gt;(x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.method();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dynamic_dispatch(&amp;BothTraits);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static_dispatch(BothTraits);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-26">æç¤º<a class="hash-link" href="#æç¤º-26" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p><code>Base::method</code> å’Œ <code>Derived::method</code> ç¢°å·§æœ‰ç›¸åŒçš„åå­—ï¼Œä½†æ˜¯æ˜¯æ¯«ä¸ç›¸å…³çš„ä¸¤ä¸ªæ–¹æ³•ã€‚ä¸ä¼šäº’ç›¸è¦†ç›–ã€‚</p><blockquote><p>Base::method and <code>Derived::method</code> happen to have the same name but are otherwise unrelated methods. One does not override the other.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-25">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-25" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š11</p><p>è¿™ä¸¤ä¸ª Traitï¼Œ<code>Base</code> å’Œ <code>Derived</code> å„è‡ªå®šä¹‰äº†ä¸€ä¸ªåä¸º method çš„ Trait æ–¹æ³•ã€‚è¿™ä¸¤ä¸ªæ–¹æ³•åªæ˜¯ç¢°å·§æ‹¥æœ‰ç›¸åŒçš„åç§°ï¼Œä½†åœ¨å…¶ä»–æ–¹é¢å¹¶ä¸ç›¸å…³ï¼Œå¦‚ä¸‹æ–‡æ‰€è§£é‡Šã€‚</p><blockquote><p>The two traits Base and Derived each define a trait method called method. These methods happen to have the same name but are otherwise unrelated methods as explained below.</p></blockquote><p>ä¸¤ä¸ª Trait éƒ½ä¸º method æä¾›äº†ä¸€ä¸ªé»˜è®¤çš„å®ç°ã€‚å¦‚æœæŸä¸ªå…·ä½“å®ç°æ²¡æœ‰å®šä¹‰æ–¹æ³•ï¼Œé‚£ä¹ˆé»˜è®¤çš„å®ç°åœ¨æ¦‚å¿µä¸Šä¼šè¢«å¤åˆ¶åˆ°å…·ä½“çš„å®ç°ä¸­ã€‚</p><p>é»˜è®¤å®ç°åœ¨æ¦‚å¿µä¸Šè¢«å¤åˆ¶åˆ°æ¯ä¸ªæ²¡æœ‰æ˜ç¡®å®šä¹‰ç›¸åŒæ–¹æ³•çš„ trait impl ä¸­ã€‚ä¾‹å¦‚ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒBothTraits çš„ impl Base æ²¡æœ‰æä¾›è‡ªå·±çš„ Base::method çš„å®ç°ï¼Œè¿™æ„å‘³ç€ BothTraits çš„ Base çš„å®ç°å°†ä½¿ç”¨è¯¥ trait å®šä¹‰çš„é»˜è®¤è¡Œä¸ºï¼Œå³ print!</p><blockquote><p>Both traits provide a default implementation of their trait method. Default implementations are conceptually copied into each trait impl that does not explicitly define the same method. In this case for example impl Base for BothTraits does not provide its own implementation of <code>Base::method</code>, which means the implementation of Base for BothTraits will use the default behavior defined by the trait i.e. print!(&quot;1&quot;).</p></blockquote><p>æ­¤å¤–ï¼ŒDerived å°† Base ä½œä¸ºä¸€ä¸ª supertraitï¼Œè¿™æ„å‘³ç€æ¯ä¸ªå®ç° Derived çš„ç±»å‹ä¹Ÿéƒ½éœ€è¦å®ç° Baseã€‚è¿™ä¸¤ä¸ª trait æ–¹æ³•å°½ç®¡åå­—ç›¸åŒï¼Œä½†å´æ²¡æœ‰å…³ç³» -- å› æ­¤ä»»ä½•å®ç° Derived çš„ç±»å‹éƒ½ä¼šæœ‰ Derived::method å’Œ Base::method çš„å®ç°ï¼Œè€Œä¸”è¿™ä¸¤ä¸ªæ–¹æ³•å¯ä»¥è‡ªç”±åœ°æœ‰ä¸åŒçš„è¡Œä¸ºã€‚Supertraits ä¸æ˜¯ç»§æ‰¿ï¼Supertraits æ˜¯ä¸€ç§ç‰¹å¾çº¦æŸï¼Œå¦‚æœè¦å®ç° Derivedï¼Œé‚£ä¹ˆ Base ä¹Ÿå¿…é¡»è¢«å®ç°ã€‚</p><blockquote><p>Additionally, Derived has Base as a supertrait which means that every type that implements Derived is also required to implement Base. The two trait methods are unrelated despite having the same name -- thus any type that implements Derived will have an implementation of Derived::method as well as an implementation of <code>Base::method</code> and the two are free to have different behavior. Supertraits are not inheritance! Supertraits are a constraint that if some trait is implemented, some other trait must also be implemented.</p></blockquote><p>è®©æˆ‘ä»¬çœ‹ä¸€ä¸‹ä» main è°ƒç”¨çš„ä¸¤ä¸ªæ–¹æ³•çš„å…·ä½“è¿‡ç¨‹ã€‚</p><blockquote><p>Let&#x27;s consider what happens in each of the two methods called from main.</p></blockquote><ul><li><p><code>dynamic_dispatch(&amp;BothTraits)</code></p><p>  å‚æ•° x æ˜¯ä¸€ä¸ªå¯¹ç‰¹å¾å¯¹è±¡ <code>dyn Base</code> çš„å¼•ç”¨ã€‚ç‰¹å¾å¯¹è±¡æ˜¯ç”±ç¼–è¯‘å™¨ç”Ÿæˆçš„ä¸€ä¸ª &quot;å°å«ç‰‡&quot;ï¼Œå®ƒå…·æœ‰å’Œ Trait ç›¸åŒçš„åç§° (å¦‚ä¸‹æ‰€ç¤º)ï¼Œå¯ä»¥é€šè¿‡å°†æ‰€æœ‰ç‰¹è´¨æ–¹æ³•çš„è°ƒç”¨ï¼Œè½¬å‘åˆ°åŸå§‹ç±»å‹çš„ç‰¹è´¨æ–¹æ³•ã€‚è½¬å‘æ˜¯é€šè¿‡è¯»å–ç‰¹å¾å¯¹è±¡é‡ŒåŒ…å«çš„å‡½æ•°æŒ‡é’ˆè¡¨æ¥å®Œæˆçš„ã€‚</p><blockquote><p>The argument x is a reference to the trait object type dyn Base. A trait object is a little shim generated by the compiler that implements the trait with the same name by forwarding all trait method calls to trait methods of whatever type the trait object was created from. The forwarding is done by reading from a table of function pointers contained within the trait object.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Generated by the compiler.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// This is an implementation of the trait `Base` for the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// trait object type `dyn Base`, which you can think of as</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// a struct containing function pointers.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Base for (dyn Base) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some automatically generated implementation detail</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        that ends up calling the right type&#x27;s impl of the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        trait method Base::method.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  åœ¨ quiz ä»£ç é‡Œï¼Œ<code>x.method()</code> å®é™…ä¸Šæ˜¯è°ƒç”¨ç”±ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆçš„æ–¹æ³•ï¼Œå®ƒçš„åå­—æ˜¯ <code>&lt;dyn Base as Base&gt;::method</code>ã€‚ç”±äº x æ˜¯é€šè¿‡å°† <code>BothTraits</code> è½¬æ¢ä¸º <code>dyn Base</code> å¾—åˆ°çš„ï¼Œè‡ªåŠ¨ç”Ÿæˆçš„å®ç°å°†è½¬å‘åˆ° <code>&lt;BothTraits as Base&gt;::method</code>ï¼Œæœ€åæ‰“å°å‡º 1ã€‚</p><blockquote><p>In the quiz code, <code>x.method()</code> is a call to this automatically generated method whose fully qualified name is <code>&lt;dyn Base as Base&gt;::method</code>. Since x was obtained by converting a BothTraits to dyn Base, the automatically generated implementation detail will wind up forwarding to <code>&lt;BothTraits as Base&gt;::method</code> which prints 1.</p></blockquote><p>  å¸Œæœ›ä»è¿™ä¸€åˆ‡å¯ä»¥çœ‹å‡ºï¼Œè¿™é‡Œæ²¡æœ‰ä»»ä½•ä¸œè¥¿ä¸ <code>BothTraits</code> å®šä¹‰çš„ <code>Derived::method</code> æœ‰å…³ã€‚ç‰¹åˆ«è¦æ³¨æ„çš„æ˜¯ï¼Œ<code>x.method()</code> ä¸å¯èƒ½æ˜¯å¯¹ <code>Derived::method</code> çš„è°ƒç”¨ï¼Œå› ä¸º x æ˜¯ <code>dyn Base</code> ç±»å‹ï¼Œè€Œ <code>dyn Base</code> å¹¶æ²¡æœ‰ <code>Derived</code> çš„å®ç°ã€‚</p><blockquote><p>Hopefully it&#x27;s clear from all of this that nothing here has anything to do with the unrelated trait method Derived::method defined by BothTraits. Especially notice that <code>x.method()</code> cannot be a call to Derived::method because x is of type dyn Base and there is no implementation of Derived for dyn Base.</p></blockquote></li><li><p>static_dispatch(BothTraits)</p><p>  åœ¨ç¼–è¯‘æ—¶æˆ‘ä»¬çŸ¥é“ <code>x.method()</code> æ˜¯å¯¹ <code>&lt;T as Base&gt;::method</code> çš„è°ƒç”¨ã€‚Rust ä¸­å¯¹æ³›å‹å‡½æ•°çš„ç±»å‹æ¨æ–­æ˜¯ç‹¬ç«‹äºæ³›å‹å‡½æ•°çš„ä»»ä½•å…·ä½“å®ä¾‹è€Œå‘ç”Ÿçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æˆ‘ä»¬çŸ¥é“ T å¯èƒ½æ˜¯ä»€ä¹ˆä¹‹å‰ï¼ŒåªçŸ¥é“å®ƒå®ç°äº† Base è¿™ä¸€äº‹å®ã€‚å› æ­¤ï¼Œå…·ä½“ç±»å‹ T ä¸Šçš„ä»»ä½•å›ºæœ‰æ–¹æ³•æˆ–ä»»ä½•å…¶ä»–ç‰¹å¾æ–¹æ³•éƒ½ä¸å¯èƒ½å½±å“ <code>x.method()</code> çš„è°ƒç”¨ã€‚åœ¨å†³å®š T çš„æ—¶å€™ï¼Œå·²ç»ç¡®å®š <code>x.method()</code> ä¼šè°ƒç”¨ <code>&lt;T as Base&gt;::method</code>ã€‚</p><blockquote><p>At compile time we know that <code>x.method()</code> is a call to <code>&lt;T as Base&gt;::method</code>. Type inference within generic functions in Rust happens independently of any concrete instantiation of the generic function i.e. before we know what T may be, other than the fact that it implements Base. Thus no inherent method on the concrete type T or any other trait method may affect what method <code>x.method()</code> is calling. By the time that T is decided, it has already been determined that <code>x.method()</code> is calling <code>&lt;T as Base&gt;::method</code>.</p></blockquote><p>  æ³›å‹å‡½æ•°åœ¨å®ä¾‹åŒ–æ—¶ï¼ŒT ç­‰äº BothTraitsï¼Œæ‰€ä»¥è¿™å°†ä¼šè°ƒç”¨ <code>&lt;BothTraits as Base&gt;::method</code>ï¼Œæ‰“å°å‡º 1ã€‚</p><blockquote><p>The generic function is instantiated with T equal to BothTraits so this is going to call <code>&lt;BothTraits as Base&gt;::method</code> which prints 1.</p></blockquote></li></ul><blockquote><p>If you are familiar with C++, the behavior of this code in Rust is different from the behavior of superficially analogous C++ code. In C++ the output would be 22 as seen in the following implementation. This highlights the difference between Rust&#x27;s traits and supertraits vs C++&#x27;s inheritance.</p></blockquote><p>å¦‚æœä½ ç†Ÿæ‚‰ C++ï¼Œè¿™æ®µä»£ç åœ¨ Rust ä¸­çš„è¡Œä¸ºä¸è¡¨é¢ä¸Šç±»ä¼¼çš„ C++ä»£ç çš„è¡Œä¸ºæ˜¯ä¸åŒçš„ã€‚åœ¨ <code>C++</code> ä¸­ï¼Œè¾“å‡ºå°†æ˜¯ 22ï¼Œæ­£å¦‚åœ¨ä¸‹é¢çš„å®ç°ä¸­çœ‹åˆ°çš„é‚£æ ·ã€‚è¿™çªå‡ºäº† Rust çš„ traits å’Œ supertraits ä¸ C++ çš„ç»§æ‰¿ä¹‹é—´çš„åŒºåˆ«ã€‚</p><div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">include</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property string" style="color:#e3116c">&lt;iostream&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">Base</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">virtual</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">method</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        std</span><span class="token double-colon punctuation" style="color:#393A34">::</span><span class="token plain">cout </span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;1&quot;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">Derived</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token base-clause class-name">Base</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">method</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        std</span><span class="token double-colon punctuation" style="color:#393A34">::</span><span class="token plain">cout </span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;2&quot;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">dynamic_dispatch</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> Base </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">x</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">method</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">template</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token keyword" style="color:#00009f">typename</span><span class="token plain"> </span><span class="token class-name">T</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">static_dispatch</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> T x</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">method</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">main</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">dynamic_dispatch</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">Derived</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">static_dispatch</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">Derived</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="28-_guard--_">#28 <code>_guard &amp; _</code><a class="hash-link" href="#28-_guard--_" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-27">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-27" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Guard;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for Guard {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _guard = Guard;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _ = Guard;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-27">æç¤º<a class="hash-link" href="#æç¤º-27" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>å½“ä¸€ä¸ªå€¼ä¸å†æœ‰æ‰€æœ‰è€…æ—¶ï¼Œå®ƒå°±è¢« drop äº†ã€‚</p><blockquote><p>A value is dropped when it no longer has an owner.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-26">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-26" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š3121</p><p>è¯¥ç¨‹åºæ‰“å°å‡º 3121ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ<code>let _guard = Guard</code> çš„ <code>Drop</code> åœ¨ main çš„æœ«å°¾è¿è¡Œï¼Œä½†æ˜¯ <code>let _ = Guard</code> çš„ <code>Drop</code> å´ç«‹å³è¿è¡Œã€‚</p><blockquote><p>The program prints 3121. That is, the Drop impl for let <em>guard = Guard runs at the end of main but the Drop impl for let </em> = Guard runs right away.</p></blockquote><p>ä¸€èˆ¬æ¥è¯´ï¼Œå½“ä¸€ä¸ªå€¼ä¸å†æœ‰æ‰€æœ‰è€…æ—¶ï¼Œå®ƒå°±ä¼šè¢«æ”¾å¼ƒã€‚å˜é‡ <code>_guard</code> æ‹¥æœ‰ Guard ç±»å‹çš„ç¬¬ä¸€ä¸ªå€¼ï¼Œå¹¶ä¸”åœ¨ main ç»“æŸå‰ä¸€ç›´å¤„äºä½œç”¨åŸŸä¸­ã€‚<code>_</code> ä¸æ˜¯ä¸€ä¸ªå˜é‡ï¼Œè€Œæ˜¯ä¸€ä¸ªé€šé…ç¬¦æ¨¡å¼ï¼Œå®ƒæ²¡æœ‰ç»‘å®šä»»ä½•ä¸œè¥¿ï¼›å› ä¸ºè¿™ä¸€è¡Œæ²¡æœ‰ç»‘å®šä»»ä½•å˜é‡ï¼Œæ‰€ä»¥æ²¡æœ‰å˜é‡æˆä¸º Guard ç±»å‹çš„ç¬¬äºŒä¸ªå€¼çš„æ‰€æœ‰è€…ï¼Œè¯¥å€¼åœ¨åŒä¸€è¡Œè¢«ä¸¢å¼ƒã€‚</p><blockquote><p>In general, a value is dropped when it no longer has an owner. The variable <em>guard owns the first value of type Guard and remains in scope until the end of main. The </em> is not a variable but a wildcard pattern that binds nothing; since no variables are bound on this line, there is no variable to be the owner of the second value of type Guard and that value is dropped on the same line.</p></blockquote><p>ä¸‹åˆ’çº¿æ¨¡å¼ä¸å¸¦ä¸‹åˆ’çº¿çš„å˜é‡ä¹‹é—´çš„åŒºåˆ«åœ¨æŸäº›æƒ…å†µä¸‹å¾ˆé‡è¦ï¼Œç‰¹åˆ«æ˜¯å½“åœ¨ unsafe ä»£ç ä¸­ä½¿ç”¨é”æ—¶ï¼Œ</p><blockquote><p>This distinction between the underscore pattern vs variables with a leading underscore is incredibly important to remember when working with lock guards in unsafe code.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::sync::Mutex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static MUTEX: Mutex&lt;()&gt; = Mutex::new(());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// MUTEX must be held when accessing this value.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static mut VALUE: usize = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _guard = MUTEX.lock().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        VALUE += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>å¦‚æœè¿™æ®µä»£ç ä½¿ç”¨ <code>let _ = MUTEX.lock().unwrap()</code>ï¼Œåˆ™ä¼šç«‹å³é‡Šæ”¾äº’æ–¥é”ï¼Œæ— æ³•å¯¹ <code>VALUE</code> çš„è®¿é—®è¿›è¡Œé™åˆ¶ã€‚</p><blockquote><p>If this code were to use <code>let _ = MUTEX.lock().unwrap()</code> then the mutex guard would be dropped immediately, releasing the mutex and failing to guard the access of VALUE.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="29-t--t">#29 <code>(T) &amp; (T,)</code><a class="hash-link" href="#29-t--t" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-28">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-28" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for (u32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(&amp;self) { print!(&quot;1&quot;); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for (i32,) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(&amp;self) { print!(&quot;2&quot;); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for (u32, u32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(&amp;self) { print!(&quot;3&quot;); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for (i32, i32,) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(&amp;self) { print!(&quot;4&quot;); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0).p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0,).p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0, 0).p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0, 0,).p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-28">æç¤º<a class="hash-link" href="#æç¤º-28" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>æ‹¬å·å†…çš„å€¼ä¸åªæœ‰ä¸€ä¸ªå…ƒç´ çš„å…ƒç»„çš„ç±»å‹ä¸ä¸€æ ·ã€‚</p><blockquote><p>A value in parentheses does not have the same type as a 1-tuple.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-27">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-27" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š1244</p><p>åœ¨å•å…ƒç´ å…ƒç»„çš„æƒ…å†µä¸‹ï¼Œå°¾éƒ¨çš„é€—å·æ˜¯å¿…é¡»çš„ï¼Œå› ä¸ºå®ƒå¯ä»¥å°†å…¶ä¸ä¸ <code>(0)</code> åŒºåˆ†å¼€æ¥ (<code>(0)</code> å’Œ <code>0</code> ç›¸åŒ)ã€‚ç„¶è€Œï¼Œå¯¹äºæ›´å¤§çš„å…ƒç»„ï¼Œå®ƒæ˜¯å®Œå…¨å¯é€‰çš„ï¼š<code>(i32)</code> ä¸ <code>(i32,)</code> æ˜¯ä¸åŒçš„ç±»å‹ï¼Œä½†æ˜¯ <code>(i32, i32)</code> å’Œ <code>(i32, i32, )</code> æ˜¯ç›¸åŒçš„ã€‚</p><blockquote><p>The trailing comma is required in the case of a 1-tuple, (0,), because it disambiguates it from (0) which is identical to 0. However, for larger tuples, it is entirely optional: (i32) is a distinct type from (i32,), but (i32, i32) and (i32, i32,) are the same.</p></blockquote><p>ä¸€ä¸ªæ•´å½¢ 0 å¯ä»¥è¢«æ¨æ–­ä¸ºä»»ä½•æ•´æ•°ç±»å‹ï¼Œä½†å¦‚æœæ²¡æœ‰è¶³å¤Ÿçš„ç±»å‹ä¿¡æ¯ï¼Œåˆ™é»˜è®¤æ¨æ–­ä¸º i32ã€‚<code>(0)</code> è¢«æ¨æ–­ä¸º <code>u32</code>ï¼Œ<code>(0,)</code> è¢«æ¨æ–­ä¸º <code>(i32,)</code>ï¼Œå› ä¸ºå®ƒä»¬åˆ†åˆ«å…·æœ‰å”¯ä¸€çš„ Trait å®ç°ã€‚</p><blockquote><p>An integral literal 0 can be inferred to be any integer type, but defaults to i32 if insufficient type information is available. (0) is inferred to be a u32 and (0,) is inferred to be a (i32,) because those are respectively the only integral and 1-tuple types with an implementation for Trait.</p></blockquote><p>ç”±äº <code>(0, 0)</code> å’Œ <code>(0, 0,)</code> å…·æœ‰ç›¸åŒçš„ç±»å‹ï¼Œå®ƒä»¬çš„ <code>p</code> æ–¹æ³•çš„è¾“å‡ºä¹Ÿæ˜¯ç›¸åŒçš„ï¼Œä½†æ˜¯ Rust éœ€è¦åœ¨ Trait çš„ä¸¤ç§å¯èƒ½çš„å®ç°ä¸­è¿›è¡Œé€‰æ‹©ï¼Œå³ <code>(u32, u32)</code> å’Œ <code>(i32, i32)</code>ã€‚ç”±äº <code>i32</code> æ˜¯é»˜è®¤çš„æ•´å½¢ç±»å‹ï¼Œæ‰€ä»¥åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹éƒ½ä¼šé€‰æ‹© <code>(i32, i32)</code>ã€‚</p><blockquote><p>Since (0, 0) and (0, 0,) have the same type, the output of their p methods must be the same, but Rust needs to somehow choose between the two possible implementations of Trait, namely (u32, u32) and (i32, i32). Since i32 is the default integral type, (i32, i32) is chosen in both cases.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="30-clone">#30 <code>clone</code><a class="hash-link" href="#30-clone" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-29">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-29" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::rc::Rc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn p&lt;X&gt;(x: X) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match std::mem::size_of::&lt;X&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0 =&gt; print!(&quot;0&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = &amp;A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(a.clone());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b = &amp;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(b.clone());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c = Rc::new(());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(Rc::clone(&amp;c));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(c.clone());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-29">æç¤º<a class="hash-link" href="#æç¤º-29" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ä¸å¯å˜çš„æŒ‡é’ˆ <code>&amp;T</code> å’Œ <code>Rc&lt;T&gt;</code> å®ç°äº† <code>Clone</code>ï¼Œå³ä½¿ <code>T</code> å¹¶æ²¡æœ‰å®ç°ã€‚</p><blockquote><p>Immutable pointers <code>&amp;T</code> and <code>Rc&lt;T&gt;</code> implement Clone even if T doesn&#x27;t.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-28">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-28" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š111011</p><p>è¿™é‡Œå‡ºç°çš„ä¸¤ä¸ªéå¼•ç”¨ç±»å‹ï¼Œ<code>()</code> å’Œ <code>A</code> éƒ½æ˜¯é›¶å¤§å°ç±»å‹ (ZST)ã€‚å¦‚æœä½ å‘å‡½æ•° <code>p&lt;X&gt;</code> ä¼ ä¸€ä¸ª <code>X = ()</code> æˆ–è€… <code>X = A</code>ï¼Œé‚£ä¹ˆä¼šæ‰“å° 0ã€‚å¦‚æœä¼ çš„æ˜¯ <code>X = ï¼†()</code> æˆ–è€… <code>X = &amp;A</code>ï¼Œæ— è®ºæŒ‡é’ˆæœ‰å¤šå¤§ï¼Œæ€»ä¼šæ‰“å° 1ã€‚</p><blockquote><p>Both of our non-reference types, <code>()</code> and <code>A</code>, are zero-sized types (ZST). The function <code>p&lt;X&gt;</code> will print 0 if it is passed a value of type <code>X = ()</code> or <code>X = A</code>, and it will print 1 if passed a reference <code>X = &amp;()</code> or <code>X = &amp;A</code> regardless of exactly how big pointers happen to be.</p></blockquote><p><code>p(a)</code> ç”¨ <code>X = &amp;A</code> è°ƒç”¨ pï¼Œå› ä¸ºå‚æ•° a æ˜¯ <code>&amp;A</code> ç±»å‹çš„ï¼›æ‰“å°å‡º 1ã€‚</p><blockquote><p>p(a) invokes p with X = &amp;A because the argument a is of type <code>&amp;A</code>; this prints 1.</p></blockquote><p>åœ¨ä¸‹ä¸€è¡Œ <code>p(a.clone())</code>ï¼Œå¦‚æœ A å®ç°äº† Cloneï¼Œé‚£ä¹ˆ <code>a.clone()</code> ä¼šè°ƒç”¨å¯¹åº”çš„å®ç°ã€‚ä½†æ˜¯å®ƒæ²¡æœ‰ï¼Œç¼–è¯‘å™¨å‘ç° <code>&amp;T</code> å®ç°äº† Cloneï¼Œæ‰€ä»¥è¿™é‡Œä¼šè°ƒç”¨ <code>&amp;A</code> å®ç°çš„ Cloneï¼Œå®ƒä¼šé€šè¿‡ç®€å•åœ°é‡å¤å¼•ç”¨ï¼Œå°†ä¸€ä¸ª <code>&amp;&amp;A</code> è½¬ä¸º <code>&amp;A</code>ã€‚å¯¹ p çš„è°ƒç”¨ä¸­ï¼Œ<code>X = &amp;A</code>ï¼Œä¹Ÿä¼šæ‰“å° 1ã€‚åœ¨å®è·µä¸­ï¼Œå½“åŒ…å«å¼•ç”¨çš„ç»“æ„æƒ³è¦æ´¾ç”Ÿå‡º Clone æ—¶ï¼ŒClone å¯¹å¼•ç”¨çš„å½±å“æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œä½†æ­£å¦‚è¿™é‡Œæ‰€çœ‹åˆ°çš„ï¼Œå®ƒæœ‰æ—¶ä¼šæ„å¤–åœ°å¯åŠ¨ã€‚</p><blockquote><p>On the next line, if A implemented Clone then a.clone() would be a call to that impl. But since it doesn&#x27;t, the compiler finds another applicable impl which is the implementation of Clone for references &amp;T -- so concretely the clone call is calling the impl of Clone for &amp;A which turns a &amp;&amp;A into a &amp;A by simply duplicating the reference. We get another call to p with X = &amp;A printing 1. The impl of Clone for references is useful in practice when a struct containing a reference wants to derive Clone, but as seen here it can sometimes kick in unexpectedly.</p></blockquote><p>ç±»å‹ <code>()</code> ç¡®å®å®ç°äº† Cloneï¼Œæ‰€ä»¥ <code>b.clone()</code> è°ƒç”¨äº†è¯¥å®ç°ï¼Œäº§ç”Ÿäº† <code>()</code>ã€‚å¯¹ <code>&amp;()</code>çš„ Clone å®ç°ä¹Ÿé€‚ç”¨äº A çš„æƒ…å†µï¼Œä½†æ˜¯ç¼–è¯‘å™¨æ›´å–œæ¬¢è°ƒç”¨ trait impl for ()ï¼Œå°† <code>&amp;()</code> è½¬æ¢ä¸º <code>()</code> ï¼Œè€Œä¸æ˜¯ trait impl for &amp;()ï¼Œå°† <code>&amp;&amp;()</code> è½¬æ¢ä¸º <code>&amp;()</code>ï¼Œå› ä¸ºå‰è€…å¯¹ trait solver æ’å…¥çš„éšå¼å¼•ç”¨æˆ–å–æ¶ˆå¼•ç”¨çš„è¦æ±‚æ›´å°‘ã€‚åœ¨å¯¹ <code>b.clone()</code> çš„è°ƒç”¨ä¸­ï¼Œ<code>b</code> çš„ç±»å‹æ˜¯ <code>&amp;()</code>ï¼Œä¸ <code>impl Clone for ()</code> çš„å‚æ•°å®Œå…¨åŒ¹é…ï¼Œè€Œä¸ºäº†æ‹¿åˆ° <code>&amp;&amp;()</code> ä½œä¸ºå‚æ•°ä¼ é€’ç»™ <code>impl Clone for &amp;()</code>ï¼Œç‰¹å¾æ±‚è§£å™¨è¿˜éœ€è¦æ’å…¥é¢å¤–çš„éšå¼å¼•ç”¨å±‚ -- æœ‰æ•ˆåœ°è®¡ç®— <code>(&amp;b).clone()</code>ã€‚</p><blockquote><p>The type () does implement Clone so b.clone() invokes that impl and produces (). The implementation of Clone for &amp;() would also be applicable as happened in the case of A, but the compiler prefers calling the trait impl for () which converts &amp;() to () over the trait impl for &amp;() which converts &amp;&amp;() to &amp;() because the former is the one that requires fewer implicit references or dereferences inserted by the trait solver. In the call to b.clone(), b is of type &amp;() which exactly matches the argument of the impl Clone for (), while in order to obtain a &amp;&amp;() to pass as argument to the impl Clone for &amp;() the trait solver would need to insert an additional layer of referencing implicitly -- effectively computing (&amp;b).clone().</p></blockquote><p>æˆ‘ä»¬åœ¨è°ƒç”¨ <code>p(b)</code> æ—¶å®é™…ä¼ å…¥çš„ <code>X = ï¼†()</code>ï¼Œè°ƒç”¨ <code>p(b.clone())</code> æ—¶åˆ™æ˜¯ <code>X = ()</code>ã€‚</p><blockquote><p>What we get is p(b) calling p with X = &amp;() and p(b.clone()) calling p with X = (). Together these print 10.</p></blockquote><p>æœ€åæ˜¯ Rcï¼Œä¸¤æ¬¡å¯¹ b çš„è°ƒç”¨éƒ½æ˜¯ <code>X = Rc&lt;()&gt;</code>ï¼Œå¤§å°ä¸ä¸ºé›¶ã€‚ä½¿ç”¨ <code>Rc::clone(&amp;c)</code> è€Œä¸æ˜¯ <code>c.clone()</code> æ¥å…‹éš†ä¸€ä¸ª Rc è¢«è®¤ä¸ºæ˜¯ä¹ æƒ¯æ€§çš„ï¼Œå› ä¸º <code>Rc::clone()</code> ä½¿äººæ˜æ˜¾æ„Ÿè§‰åˆ°è¿™æ˜¯ä¸€ä¸ªå¼•ç”¨è®¡æ•°çš„å¢åŠ ï¼Œè€Œä¸æ˜¯å…‹éš†åº•å±‚æ•°æ®ï¼Œä½†æœ€ç»ˆä¸¤è€…æŒ‡çš„æ˜¯åŒä¸€ä¸ªå‡½æ•°ã€‚è¦åœ¨ Rc å†…éƒ¨è°ƒç”¨ä¸€ä¸ªå€¼çš„å…‹éš†ï¼Œä½ éœ€è¦å…ˆå¯¹å®ƒè§£å¼•ç”¨ï¼š<code>(*c).clone()</code>ã€‚</p><blockquote><p>Finally in the Rc case, both calls to p are with <code>X = Rc&lt;()&gt;</code> which is non-zero sized. It is considered idiomatic to clone a Rc using <code>Rc::clone(&amp;c)</code> instead of <code>c.clone()</code> because it makes it apparent that this is a reference count bump rather than cloning underlying data, but ultimately both refer to the same function. To call the clone method of a value inside a Rc, you would need to dereference it first: <code>(*c).clone()</code>.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="31-method-lookup-order">#31 <code>method lookup order</code><a class="hash-link" href="#31-method-lookup-order" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-30">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-30" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Or {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Or for &amp;T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Or for &amp;&amp;&amp;&amp;T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let t = T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let wt = &amp;T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let wwt = &amp;&amp;T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let wwwt = &amp;&amp;&amp;T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let wwwwt = &amp;&amp;&amp;&amp;T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let wwwwwt = &amp;&amp;&amp;&amp;&amp;T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wt.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wwt.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wwwt.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wwwwt.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wwwwwt.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-30">æç¤º<a class="hash-link" href="#æç¤º-30" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>åœ¨æ–¹æ³•æŸ¥æ‰¾è¿‡ç¨‹ä¸­ï¼ŒRust ä¼šè‡ªåŠ¨è§£å¼•ç”¨ï¼Œå¹¶ä»¥æ˜ç¡®çš„é¡ºåºå€Ÿç”¨æ¥æ”¶å™¨ï¼Œç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªæœ‰åˆé€‚ç­¾åçš„å‡½æ•°ã€‚è¿™ä¸ªé¡ºåºæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ</p><blockquote><p>During a method lookup, Rust automatically derefences and borrows the receiver in a well-defined order until it finds the first function with a suitable signature. What is that order?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-29">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-29" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š111222</p><p>è¿™ç¯‡ <a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html" target="_blank" rel="noopener noreferrer">å¼•ç”¨</a> æè¿°äº† Rust çš„æ–¹æ³•æŸ¥æ‰¾é¡ºåºã€‚ç›¸å…³çš„æ®µè½å¦‚ä¸‹ï¼š </p><p>è·å¾— <!-- -->[å€™é€‰æ¥æ”¶æ–¹ç±»å‹]<!-- --> çš„æ–¹æ³•æ˜¯ï¼šåå¤è§£å¼•ç”¨æ¥å—è€…è¡¨è¾¾å¼çš„ç±»å‹ï¼Œå°†é‡åˆ°çš„æ¯ä¸ªç±»å‹æ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œæœ€åå°è¯•åœ¨æœ€åè¿›è¡Œéå¤§å°èƒè¿«ï¼Œå¦‚æœæˆåŠŸï¼Œåˆ™æ·»åŠ ç»“æœç±»å‹ã€‚ç„¶åï¼Œå¯¹äºæ¯ä¸ªå€™é€‰çš„Tï¼Œå°† <code>&amp;T</code> å’Œ <code>&amp;mut T</code> æ·»åŠ åˆ°ç´§è·Ÿ <code>T</code> çš„åˆ—è¡¨ä¸­ã€‚</p><blockquote><p>The <a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html" target="_blank" rel="noopener noreferrer">Reference</a> describes Rust&#x27;s method lookup order. The relevant paragraph is:</p></blockquote><blockquote><p>Obtain <!-- -->[the candidate receiver type]<!-- --> by repeatedly dereferencing the receiver expression&#x27;s type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, and adding the result type if that is successful. Then, for each candidate T, add &amp;T and &amp;mut T to the list immediately after T.</p></blockquote><p>æŠŠè¿™äº›è§„åˆ™æ·»åŠ åˆ°æ‰€ç»™çš„ä¾‹å­é‡Œï¼š</p><blockquote><p>Applying these rules to the given examples, we have:</p></blockquote><ul><li><p><code>t.f()</code>: æˆ‘ä»¬è¯•å›¾æ‰¾åˆ°ä¸€ä¸ªå®šä¹‰åœ¨ç±»å‹ <code>T</code> ä¸Šçš„å‡½æ•° fï¼Œä½†æ˜¯æ²¡æœ‰ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æœç´¢ç±»å‹ <code>&amp;T</code>ï¼Œå¹¶æ‰¾åˆ° <code>Or</code> ç‰¹å¾çš„ç¬¬ä¸€ä¸ªå®ç°ï¼Œç„¶åæˆ‘ä»¬å°±å®Œæˆäº†ã€‚åœ¨è°ƒç”¨æ—¶ï¼Œæ‰¾åˆ°çš„è°ƒç”¨ä¼šæ‰“å°å‡º 1ã€‚</p><blockquote><p>t.f(): We try to find a function f defined on the type T, but there is none. Next, we search the type &amp;T, and find the first implemenation of the Or trait, and we are done. Upon invocation, the resolved call prints 1.</p></blockquote></li><li><p><code>wt.f()</code>: æˆ‘ä»¬æœç´¢ä¸€ä¸ªå®šä¹‰åœ¨ <code>&amp;T</code> ä¸Šçš„å‡½æ•° fï¼Œç«‹åˆ»å°±æˆåŠŸäº†ã€‚è°ƒç”¨åï¼Œè¯¥å‡½æ•°æ‰“å°å‡º 1ã€‚</p><blockquote><p>We search for a function f defined on &amp;T, which immediately succeeds. Upon invocation, the function prints 1.</p></blockquote></li><li><p><code>wwt.f()</code>: æœç´¢é¡ºåºæ˜¯ <code>&amp;&amp;T -&gt; &amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;T -&gt; &amp;T</code>ï¼Œç»“æœæ‰“å° 1ã€‚</p><blockquote><p>The search order is <code>&amp;&amp;T -&gt; &amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;T -&gt; &amp;T</code>, and we&#x27;re done. Upon invocation, the function prints 1.</p></blockquote></li><li><p><code>wwwt.f()</code>: <code>&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code> è¿™ä¸ªæ‰“å° 2ã€‚</p><blockquote><p><code>&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code>. This prints 2.</p></blockquote></li><li><p><code>wwwwt.f()</code>: <code>&amp;&amp;&amp;&amp;T</code> è¿™ä¸ªæ‰“å° 2ã€‚ </p><blockquote><p><code>&amp;&amp;&amp;&amp;T</code>. This prints 2.</p></blockquote></li><li><p><code>wwwwwt.f()</code>: <code>&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code> è¿™ä¸ªæ‰“å° 2ã€‚</p><blockquote><p><code>&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code>. This prints 2.</p></blockquote></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="32-march-arm--if-guard">#32 <code>march arm &amp; if guard</code><a class="hash-link" href="#32-march-arm--if-guard" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-31">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-31" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn check(x: i32) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match (1, 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (x, _) | (_, x) if check(x) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            print!(&quot;3&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; print!(&quot;4&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-31">æç¤º<a class="hash-link" href="#æç¤º-31" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>æ— è®ºå“ªç§æ–¹å¼ï¼Œåœ¨ä¸åŒçš„æƒ…å†µä¸‹éƒ½ä¼šä»¤äººå›°æƒ‘ï¼›æ²¡æœ‰ä¸€ä¸ªæ˜ç¡®çš„æ­£ç¡®è¡Œä¸ºï¼Œæç¤ºå¯ä»¥å¸®åŠ©è¯†åˆ«ã€‚çŒœæµ‹ä¸¤è€…éƒ½æ˜¯ã€‚</p><blockquote><p>Either way would be confusing in different situations; there isn&#x27;t a clear right behavior that a hint could help identify. Guess both. :/</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-30">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-30" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š124</p><p>è¿™ä¸ªé—®é¢˜è¦†ç›–äº† match åˆ†æ”¯å’Œ guards çš„è¡Œä¸ºã€‚</p><blockquote><p>This question covers two behaviors of match arms and guards.</p></blockquote><p>é¦–å…ˆï¼ŒåŒ…å« <code>|</code> çš„åŒ¹é…è‡‚ä¸Šçš„ if guard æ˜¯é€‚ç”¨äºåŒ¹é…è‡‚ä¸­çš„æ‰€æœ‰å¤‡é€‰æ–¹æ¡ˆï¼Œè¿˜æ˜¯åªé€‚ç”¨äºå®ƒç›¸é‚»çš„æ–¹æ¡ˆã€‚åœ¨æµ‹éªŒä»£ç ä¸­ï¼Œ<code>check(x)</code> æ˜¯åŒæ—¶å¯¹ <code>(x, _)</code> å’Œ <code>(_, x)</code> æ‰§è¡Œï¼Œè¿˜æ˜¯åªè¦†ç›–äº† <code>(_, x)</code>ï¼Ÿæˆ‘ä»¬å¸Œæœ›åªæœ‰åœ¨å‰è€…çš„æƒ…å†µä¸‹ï¼Œ1 æ‰ä¼šè¢«æ‰“å°å‡ºæ¥ã€‚äº‹å®ä¸Šï¼Œ1 ç¡®å®è¢«æ‰“å°å‡ºæ¥äº†ã€‚ä¸€ä¸ªåŒ¹é…è‡‚æœ€å¤šåªèƒ½æœ‰ä¸€ä¸ª if guardï¼Œè€Œä¸”è¿™ä¸ª guard é€‚ç”¨äºåŒ¹é…è‡‚ä¸­æ‰€æœ‰çš„ç”± <code>|</code> åˆ†éš”çš„å¤‡é€‰æ–¹æ¡ˆã€‚</p><blockquote><p>First, whether an if guard on a match-arm containing <code>|</code> applies to all alternatives in the match-arm or just to the one it is adjacent to. In the quiz code, does <code>check(x)</code> execute at all for <code>(x, _)</code> or does it only cover the <code>(_, x)</code> case? We would expect 1 would get printed if and only if the former is the case. In fact 1 does get printed. A match-arm gets to have at most one if guard and that guard applies to all the <code>|</code>-separated alternatives in the arm.</p></blockquote><p>å…¶æ¬¡ï¼Œè¿™ä¸ªé—®é¢˜è¿˜åŒ…æ‹¬åŒ¹é…è‡‚çš„ä¸€ç§ &quot;å›æº¯&quot; è¡Œä¸ºã€‚å½“ <code>check(x)</code> åœ¨ <code>(x, _)</code> ä¸Šè¿”å› false æ—¶ï¼Œæ•´ä¸ªåŒ¹é…è‡‚æ˜¯åœ¨è¿™é‡ŒåŒ¹é…å¤±è´¥ï¼Œè¿˜æ˜¯ Rust ç»§ç»­å‰è¿›åˆ° <code>(_, x)</code> å¹¶ç¬¬äºŒæ¬¡æ‰§è¡Œ guardï¼Ÿæˆ‘ä»¬æœŸæœ›å½“ä¸”ä»…å½“åä¸€ç§æƒ…å†µå‡ºç°æ—¶ 2 ä¼šè¢«æ‰“å°å‡ºæ¥ã€‚äº‹å®ä¸Šï¼Œ2 ç¡®å®è¢«æ‰“å°å‡ºæ¥äº†ï¼›if guard è¢«è¿è¡Œäº†å¤šæ¬¡ï¼Œåœ¨åŒ¹é…è‡‚ä¸­çš„æ¯ä¸€ä¸ª <code>|</code> åˆ†éš”çš„é€‰é¡¹ä¸­éƒ½æœ‰ä¸€æ¬¡ã€‚</p><blockquote><p>But second, this question also covers a kind of &quot;backtracking&quot; behavior of match-arms. After <code>check(x)</code> returns false on <code>(x, _)</code>, does the whole match-arm fail to match at that point or does Rust move on to <code>(_, x)</code> and execute the guard a second time? We would expect 2 to be printed if and only if the latter is the case. In fact 2 does get printed; the guard is being run multiple times, once per <code>|</code>-separated alternative in the match-arm.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="33-ranges-method">#33 <code>Range&#x27;s method</code><a class="hash-link" href="#33-ranges-method" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-32">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-32" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::ops::RangeFull;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) -&gt; fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for RangeFull {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) -&gt; fn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        || print!(&quot;3&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;F: FnOnce() -&gt; T, T&gt; Trait for F {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) -&gt; fn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        || print!(&quot;4&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (|| .. .method())();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-32">æç¤º<a class="hash-link" href="#æç¤º-32" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p><code>||</code> æ˜¯ä¸€ä¸ªé—­åŒ…ã€‚<code>..</code> æ˜¯ range çš„è¯­æ³•ï¼Œé€šå¸¸ä¼šåœ¨åˆ‡ç‰‡ä¸­çœ‹åˆ°ï¼Œä¾‹å¦‚ <code>&amp;s[1..4]</code> æˆ–è€… <code>&amp;s[..s.len() - 1]</code>ã€‚</p><blockquote><p><code>||</code> is a closure introducer. <code>..</code> is range syntax, normally seen in slicing operations like <code>&amp;s[1..4]</code> or <code>&amp;s[..s.len() - 1]</code>.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-31">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-31" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š24</p><p>ä¸¤ä¸ªåˆç†çš„å¯èƒ½æ˜¯ 1 æˆ– 24ï¼Œå–å†³äºå¦‚ä½•åŒºåˆ† <code>|| .. .method()</code> çš„ä¼˜å…ˆçº§ã€‚</p><blockquote><p>The two rational possibilities are 1 or 24, depending on how the precedence of <code>|| .. .method()</code> is disambiguated.</p></blockquote><p>å¦‚ <code>|| ((..).method())</code>ï¼Œè¿™æ˜¯ä¸€ä¸ªé—­åŒ…ï¼Œå…¶ä¸»ä½“è°ƒç”¨äº†æˆ‘ä»¬å¯¹ <code>RangeFull</code> çš„å®ç°çš„ Trait æ–¹æ³•ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œmain ä¼šæ‰“å° 1ã€‚å®ƒä¸ä¼šæ‰“å° 13ï¼Œå› ä¸ºä» <code>(..).method()</code> è¿”å›çš„ <code>fn()</code> ä»æœªè¢« main è°ƒç”¨ã€‚</p><blockquote><p>As <code>|| ((..).method())</code>, which is a closure whose body invokes our impl of Trait on <code>RangeFull</code>. In this case main would print 1. It would not print 13 because the <code>fn()</code> returned from <code>(..).method()</code> is never invoked by main.</p></blockquote><p>å¦‚ <code>(|| ..).method()</code>ï¼Œå®ƒæ˜¯æˆ‘ä»¬å¯¹ <code>FnOnce()-&gt;T</code> å®ç°çš„ Trait çš„è°ƒç”¨ï¼Œå…¶ä¸­ <code>T</code> è¢«æ¨æ–­ä¸º <code>RangeFull</code>ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œmain ä¼šæ‰“å° 24ã€‚</p><blockquote><p>As <code>(|| ..).method()</code>, which is an invocation of our impl of Trait on <code>FnOnce() -&gt; T</code> where T is inferred to be <code>RangeFull</code>. In this case main would print 24.</p></blockquote><p>åè€…æ‰æ˜¯æ­£ç¡®çš„ç­”æ¡ˆã€‚</p><blockquote><p>The latter of those is the correct answer.</p></blockquote><p>æˆ‘ä»¬å¯ä»¥é€šè¿‡æ˜¾å¼çš„æ‹¬å·æ¥å®ç°å‰è€…çš„è¡Œä¸ºï¼Œå¦‚ä¸Šæ–‡ä¸­æ‰€ç¤ºã€‚</p><blockquote><p>We can achieve the former behavior by explicitly parenthesizing as shown in the bullet above.</p></blockquote><p>åªæœ‰éƒ¨åˆ†æ‹¬å·å¦‚ <code>|| (.. .method())</code> æ˜¯ä¸å¤Ÿçš„ã€‚è¿™ä¼šå¯¼è‡´ä¸€ä¸ªè§£æé”™è¯¯ã€‚</p><blockquote><p>Partially parenthesizing as <code>|| (.. .method())</code> is not sufficient. This results in a parse error.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error: expected one of `)` or `,`, found `.`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; src/main.rs:22:13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 |     (|| (.. .method()))();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |            -^ expected one of `)` or `,`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |            |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |            help: missing `,`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æ­£ç¡®å¤„ç†åƒ <code>|| .. .method()</code> è¿™æ ·ç›¸å½“æ¨¡ç³Šçš„è¡¨è¾¾å¼å¯¹ Rust tooling æ¥è¯´æ˜¯ä¸€ä¸ªæŒ‘æˆ˜ï¼Œä» Rustfmt (<a href="https://github.com/rust-lang/rustfmt/issues/4808" target="_blank" rel="noopener noreferrer">rust-lang/rustfmt#4808</a>) å’Œ Syn (<a href="https://github.com/dtolnay/syn/issues/1019" target="_blank" rel="noopener noreferrer">dtolnay/syn#1019</a>) çš„ç›¸å…³é”™è¯¯ä¸­å¯ä»¥çœ‹å‡ºã€‚</p><blockquote><p>Correctly handling a quite ambiguous expression like || .. .method() is a challenge for tooling, as seen by the associated bugs in Rustfmt (<a href="https://github.com/rust-lang/rustfmt/issues/4808" target="_blank" rel="noopener noreferrer">rust-lang/rustfmt#4808</a>) and Syn (<a href="https://github.com/dtolnay/syn/issues/1019" target="_blank" rel="noopener noreferrer">dtolnay/syn#1019</a>).</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="34-size-of-fn">#34 <code>size of fn</code><a class="hash-link" href="#34-size-of-fn" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-33">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-33" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn d&lt;T&gt;(_f: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match std::mem::size_of::&lt;T&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0 =&gt; print!(&quot;0&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1 =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; print!(&quot;2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn a&lt;T&gt;(f: fn(T)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    d(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a(a::&lt;u8&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    d(a::&lt;u8&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-33">æç¤º<a class="hash-link" href="#æç¤º-33" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç”¨ä»»ä½•å…¶ä»–æ•´æ•°ç±»å‹ä»£æ›¿ u8ï¼Œç­”æ¡ˆéƒ½æ˜¯ä¸€æ ·çš„ã€‚</p><blockquote><p>The answer would be the same with any other integer type in place of u8.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-32">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-32" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š20</p><p>è¡¨è¾¾å¼ <code>a::&lt;u8&gt;</code> çš„ç±»å‹æ˜¯ä¸€ä¸ªé›¶å¤§å°ç±»å‹ï¼ˆZSTï¼‰ã€‚</p><blockquote><p>The expression <code>a::&lt;u8&gt;</code>&#x27;s type is a zero-sized type (ZST).</p></blockquote><p>Rust å›´ç»•å‡½æ•°ç±»å‹çš„ä½œå‡ºçš„é€‰æ‹©å’Œå…·ä½“å®ç°ä¸å‡ ä¹æ‰€æœ‰å…¶ä»–è¯­è¨€éƒ½ä¸åŒï¼Œä½†å®ƒæ˜¯ Rust è®¸å¤šé›¶å¼€é”€æŠ½è±¡çš„é‡è¦ä¿ƒæˆå› ç´ ã€‚åœ¨ Rust ä¸­ï¼Œæ¯ä¸ªå‡½æ•°ï¼ˆæˆ–æ³›å‹å‡½æ•°çš„æ¯ä¸ªä¸åŒå®ä¾‹ï¼‰éƒ½æœ‰è‡ªå·±çš„ç‹¬ç‰¹ç±»å‹ã€‚ç‰¹åˆ«æ˜¯ï¼Œå³ä½¿æ˜¯å…·æœ‰ç›¸åŒå‡½æ•°ç­¾åçš„ä¸¤ä¸ªå‡½æ•°ä¹Ÿä¼šæœ‰ä¸åŒçš„ç±»å‹ã€‚</p><blockquote><p>Rust&#x27;s implementation choices around function types are different from nearly all other languages, but are an important enabler of many of Rust&#x27;s zero-overhead abstractions. In Rust, every function (or every distinct instantiation of a generic function) has its own unique type. In particular, even two functions with the same function signature would have different types.</p></blockquote><p>æ¯ä¸ªå‡½æ•°éƒ½æœ‰ä¸€ä¸ªç‹¬ç‰¹çš„ç±»å‹ï¼Œè¿™ç§ç‰¹æ€§å…è®¸ç±»å‹æœ¬èº«æºå¸¦å°†è¢«è°ƒç”¨çš„å‡½æ•°çš„ä¿¡æ¯ï¼Œä¸éœ€è¦ä»»ä½•è¿è¡Œæ—¶çŠ¶æ€ï¼Œå¦‚æŒ‡é’ˆã€‚</p><blockquote><p>Having a unique type for each function allows the type itself to carry the information of what function will be called, not needing any runtime state such as a pointer.</p></blockquote><p>ä¸ºäº†ç†è§£è¿™ç§ä¼˜åŒ–æ–¹æ³•çš„ä¼˜åŠ¿ï¼Œè€ƒè™‘ <code>Iterator::map</code> å’Œä¸¤ä¸ªè°ƒç”¨ <code>iter.map(f)</code> å’Œ <code>iter.map(g)</code>ï¼Œå…¶ä¸­ <code>f</code> å’Œ <code>g</code> æ˜¯å…·æœ‰ç›¸åŒç­¾åçš„ä¸åŒå‡½æ•°ã€‚å› ä¸º <code>f</code> å’Œ <code>g</code> æœ‰ä¸åŒçš„ç±»å‹ï¼Œè¿™ä¸¤ä¸ª map è°ƒç”¨ä¼šäº§ç”Ÿä¸¤ä¸ªä¸åŒçš„æ³›å‹å‡½æ•°çš„å•æ€å®ä¾‹ï¼Œå…¶ä¸­ä¸€ä¸ªé™æ€åœ°è°ƒç”¨ <code>f</code>ï¼Œå¦ä¸€ä¸ªé™æ€åœ°è°ƒç”¨ <code>g</code>ï¼Œå°±åƒä½ ç›´æ¥ä¸ºæ¯ä¸ªå‡½æ•°å†™äº†ä¸€ä¸ªç‰¹æ®Šçš„ map å®ç°ï¼Œè€Œæ²¡æœ‰ map æä¾›çš„æŠ½è±¡ã€‚å› æ­¤ï¼Œæ³›å‹ map æ˜¯ä¸€ä¸ªé›¶æˆæœ¬çš„æŠ½è±¡ã€‚ä¼ ç»Ÿä¸Šï¼Œåœ¨å…¶ä»–è¯­è¨€å¦‚ C++ æˆ– Go ä¸­ï¼Œf å’Œ g ä¼šè¢«ä½œä¸ºä¸€ä¸ªå‡½æ•°æŒ‡é’ˆä¼ é€’ç»™ mapï¼Œå¹¶ä¸”åªæœ‰ä¸€ä¸ª map çš„å®ä¾‹ï¼ŒåŒ…å«ä¸€ä¸ªæ‰§è¡Œå‡½æ•°è°ƒç”¨çš„åŠ¨æ€åˆ†å‘ï¼Œè¿™é€šå¸¸ä¼šæ¯”é™æ€è°ƒç”¨å‡½æ•°æ›´æ…¢ã€‚è¿™ç§æ€§èƒ½ç¼ºé™·ä½¿å¾—è¿™äº›è¯­è¨€ä¸­çš„ map ä¸æ˜¯ä¸€ä¸ªé›¶æˆæœ¬çš„æŠ½è±¡ã€‚</p><blockquote><p>To understand the optimization advantages of this approach, consider <code>Iterator::map</code> and the two calls <code>iter.map(f)</code> and iter.map(g) where f and g are different functions with the same signature. Because f and g have distinct types, the two map calls would produce two different monomorphic instantiations of the generic map function, one of which statically calls f and the other statically calls g, as if you had directly written a special-purpose map implementation specific to each function without the abstraction provided by map. The generic map is thus a zero-overhead abstraction. Traditionally in other languages such as C++ or Go, in this situation f and g would be passed to map as a function pointer and there would be just one instantiation of map, containing a dynamic dispatch to execute the function call, which is usually going to be slower than statically calling the right function. This performance penalty makes map in those languages not a zero-overhead abstraction.</p></blockquote><p>ç›®å‰åœ¨ Rust ä¸­ï¼Œæ²¡æœ‰è¯­æ³•æ¥è¡¨è¾¾ç‰¹å®šçš„å‡½æ•°ç±»å‹ï¼Œæ‰€ä»¥å®ƒä»¬æ€»æ˜¯ä½œä¸ºä¸€ä¸ªé€šç”¨çš„ç±»å‹å‚æ•°ä¸ <code>FnOnce</code>ã€<code>Fn</code> æˆ– <code>FnMut</code> ç»‘å®šä¼ é€’ã€‚åœ¨é”™è¯¯ä¿¡æ¯ä¸­ï¼Œä½ å¯èƒ½ä¼šçœ‹åˆ°å‡½æ•°ç±»å‹ä»¥ <code>fn(T) -&gt; U {fn_name}</code> çš„å½¢å¼å‡ºç°ï¼Œä½†ä½ ä¸èƒ½åœ¨ä»£ç ä¸­ä½¿ç”¨è¿™ç§è¯­æ³•ã€‚</p><blockquote><p>Currently in Rust there is no syntax to express the type of a specific function, so they are always passed as a generic type parameter with a FnOnce, Fn or FnMut bound. In error messages you might see function types appear in the form fn(T) -&gt; U {fn_name}, but you can&#x27;t use this syntax in code.</p></blockquote><p>å¦ä¸€æ–¹é¢ï¼Œä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œ<code>fn(T) -&gt; U</code>ï¼Œåœ¨è¿è¡Œæ—¶æ˜¯æŒ‡é’ˆå¤§å°ã€‚å‡½æ•°ç±»å‹å¯ä»¥è¢«èƒè¿«ä¸ºå‡½æ•°æŒ‡é’ˆï¼Œè¿™ä¸€ç‚¹åœ¨ä½ éœ€è¦å°† &quot;é€‰æ‹©è°ƒç”¨é‚£ä¸ªå‡½æ•°&quot; æ¨è¿Ÿåˆ°è¿è¡Œæ—¶å¾ˆæœ‰ç”¨ã€‚</p><blockquote><p>On the other hand, a function pointer, fn(T) -&gt; U, is pointer-sized at runtime. Function types can be coerced into function pointers, which can be useful in case you need to defer the choice of function to call until runtime.</p></blockquote><p>åœ¨æµ‹éªŒä»£ç ä¸­ï¼Œmain ä¸­çš„ç¬¬ä¸€ä¸ªè°ƒç”¨åœ¨è°ƒç”¨ d ä¹‹å‰å°† <code>a::&lt;u8&gt;</code> ä»ä¸€ä¸ªå‡½æ•°èƒè¿«ä¸ºä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ<code>(fn(fn(u8)) {a::&lt;u8&gt;}</code> åˆ° <code>fn(fn(u8)))</code>ï¼Œå› æ­¤åœ¨ä¸€ä¸ªå…·æœ‰ 64 ä½å‡½æ•°æŒ‡é’ˆçš„ç³»ç»Ÿä¸­ï¼Œå®ƒçš„å¤§å°ä¸º 8ã€‚main ä¸­çš„ç¬¬äºŒä¸ªè°ƒç”¨ä¸æ¶‰åŠå‡½æ•°æŒ‡é’ˆï¼›d è¢«ç›´æ¥è°ƒç”¨ï¼ŒT æ˜¯ <code>a::&lt;u8&gt;</code> çš„ä¸å¯è¡¨è¾¾çš„ç±»å‹ï¼Œå®ƒçš„å¤§å°ä¸ºé›¶ã€‚</p><blockquote><p>In the quiz code, the first call in main coerces <code>a::&lt;u8&gt;</code> from a function to a function pointer <code>(fn(fn(u8)) {a::&lt;u8&gt;}</code> to <code>fn(fn(u8)))</code> prior to calling d, so its size would be 8 on a system with 64-bit function pointers. The second call in main does not involve function pointers; d is directly called with T being the inexpressible type of <code>a::&lt;u8&gt;</code>, which is zero-sized.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="35-hygiene-2">#35 <code>Hygiene 2</code><a class="hash-link" href="#35-hygiene-2" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-34">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-34" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! x {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($n:expr) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let a = X($n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct X(u64);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for X {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, self.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = X(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x!(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, a.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-34">æç¤º<a class="hash-link" href="#æç¤º-34" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>æœ‰ä¸€äº›ç¨‹åºï¼Œcargo expand äº§ç”Ÿçš„å±•å¼€åçš„ä»£ç å¯ä»¥ç¼–è¯‘ï¼Œä½†å…¶è¡Œä¸ºä¸åŸå§‹ä»£æ€§ç çš„åŸå§‹å®å«ç”Ÿä¸åŒã€‚</p><blockquote><p>There are some programs for which cargo expand produces expanded code that compiles, but behaves differently than the original code with the original macro hygiene.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-33">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-33" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š121</p><p>æ ¹æ®ä½ å¯¹ macro å±•å¼€çš„å‡è®¾ï¼Œæœ¬é¢˜æœ‰ä¸¤æ¡çœ‹ä¼¼åˆç†çš„é”™è¯¯ç­”æ¡ˆï¼š</p><blockquote><p>There are two reasonable paths to an incorrect answer on this question, based on your assumptions around how this macro gets expanded:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. let a = X(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. { let a = X(2); }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>å¦‚æœç¬¬ä¸€ç§å±•å¼€æ–¹å¼æ˜¯æ­£ç¡®çš„ï¼Œè¿™ä¸ªå®ä¼šå¼•å…¥ä¸€ä¸ªæ–°çš„ç»‘å®šï¼Œaï¼Œå®ƒå°†é®è”½ main ä¸­å·²ç»ç›´æ¥åˆ†é…çš„ aã€‚å› æ­¤ï¼Œmain ä¸­çš„ print è¯­å¥å°†é¦–å…ˆæ‰§è¡Œï¼Œæ‰“å° 2ï¼Œç„¶åå˜é‡å°†æŒ‰å¼•å…¥çš„é¡ºåºå€’åº dropï¼Œå…ˆæ‰“å° 2ï¼Œå†æ‰“å° 1ï¼Œæœ€åè¾“å‡º 221ã€‚</p><blockquote><p>If the first expansion were right, the macro would introduce a new binding, a, which shadows the a already directly assigned in main. So the print statement in main would execute first, printing 2, then the variables would drop in reverse order of introduction, printing 2 then 1, with a final output of 221.</p></blockquote><p>å¦‚æœç¬¬äºŒç§å±•å¼€æ–¹å¼æ˜¯æ­£ç¡®çš„ï¼Œè¿™ä¸ªå®ä¼šåœ¨ä¸€ä¸ªåµŒå¥—çš„ä½œç”¨åŸŸä¸­å¼•å…¥ aï¼Œåªåœ¨è¿™ä¸ªä½œç”¨åŸŸä¸­é®è”½å·²ç»å­˜åœ¨çš„ aï¼Œè€Œä¸æ˜¯åœ¨å®ƒä¹‹å¤–ã€‚ç”±äºæ–°çš„ a çš„ä½œç”¨åŸŸåœ¨æ‰“å°è¯­å¥ä¹‹å‰å°±ç»“æŸäº†ï¼Œæ‰€ä»¥å½“å®ƒè¶…å‡ºä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„ Drop impl å°†æ˜¯ç¬¬ä¸€ä¸ªæ‰§è¡Œçš„æ‰“å°ï¼Œæ‰“å° 2ã€‚æ¥ä¸‹æ¥ï¼Œmain ä¸­çš„æ‰“å°å°†æ‰“å° 1ï¼Œä¹Ÿå°±æ˜¯ç¬¬ä¸€ä¸ª a çš„å€¼ï¼Œæœ€åï¼Œå½“è¿™ä¸ªå€¼åœ¨ main ç»“æŸæ—¶ï¼Œå†æ‰“å° 1ï¼Œæœ€ç»ˆè¾“å‡º 211ã€‚</p><blockquote><p>If the second expansion were right, the macro would introduce a in a nested scope, shadowing the already existing a only inside of that scope and not beyond it. Since the new a&#x27;s scope ends before the print statement, its Drop impl when going out of scope would be the first print to execute, printing 2. Next the print in main would print 1 which is the value of the first a, and finally 1 again when that value drops at the end of main, with final output 211.</p></blockquote><p>å¦‚æœä½ è¯»è¿‡å…³äºå®å«ç”Ÿæ€§çš„æ–‡ç« ï¼Œé‚£ä¹ˆä½ å¯èƒ½å·²ç»çŒœåˆ°å®ƒçš„å®ç°æ–¹å¼ä¸ç¬¬äºŒä¸ªé€‰é¡¹ç±»ä¼¼ã€‚é‡è¦çš„æ˜¯ï¼Œå®çš„å†…éƒ¨ç»“æ„ä¸ä¼šä¸è°ƒç”¨åœ°ç‚¹èŒƒå›´å†…çš„å˜é‡å‘ç”Ÿå†²çªï¼Œè€Œä¸” Rust å®åœ¨é˜²æ­¢æ„å¤–çš„åç§°å†²çªæ–¹é¢åšå¾—å¾ˆå¥½ã€‚ç„¶è€Œï¼Œè¿™å¹¶ä¸æ˜¯å«ç”Ÿæ€§çš„å®ç°æ–¹å¼ï¼›åœ¨å®æ‰©å±•å‘¨å›´å¼•å…¥äººä¸ºçš„ä½œç”¨åŸŸä¼šä½¿å®ƒä»¬çš„ä½œç”¨æ›´åŠ æœ‰é™ï¼Œè€Œä¸”ä¸ä¼šè§£å†³å¾ˆå¤šå…¶ä»–çš„å«ç”Ÿæ€§é—®é¢˜ã€‚</p><blockquote><p>If you&#x27;ve read about macro hygiene then you might have guessed it would be implemented something like this second option. It&#x27;s important that internals of a macro don&#x27;t interfere coincidentally with variables in scope at the call site, and Rust macros mostly do a good job of preventing unintended name collisions. However, this is not how hygiene is implemented; introducing artificial scopes around macro expansions would make them more limited in their usefulness, and wouldn&#x27;t solve a lot of other hygiene problems.</p></blockquote><p>ä½ å¯ä»¥æŠŠ lazily calcalute æƒ³è±¡æˆç»™æ¯ä¸ªæåˆ°çš„å±€éƒ¨å˜é‡çš„åå­—åˆ†é…ä¸€ä¸ªé¢œè‰²ï¼Œå…è®¸åœ¨ä½œç”¨åŸŸå†…æœ‰å¤šä¸ªå¯åŒºåˆ†çš„å±€éƒ¨å˜é‡åŒæ—¶æ‹¥æœ‰ç›¸åŒçš„æ–‡æœ¬åç§°ã€‚</p><blockquote><p>You can instead imagine hygiene as a way of assigning a color to each mention of the name of a local variable, allowing for there to be multiple distinguishable local variables in scope simultaneously with the same textual name.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = X(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = X(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, a.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>æ‰€ä»¥æ‰“å°å‡ºæ¥çš„æ˜¯ main çš„æ ‡è¯†ç¬¦ a çš„å€¼ï¼Œä¹Ÿå°±æ˜¯ 1ï¼Œç„¶åä¸¤ä¸ªå€¼æŒ‰ç…§å¼•å…¥çš„ç›¸åé¡ºåºä¸¢æ‰ï¼Œå…ˆæ‰“å° 2 å†æ‰“å° 1ï¼Œç¨‹åºçš„è¾“å‡ºæ˜¯ 121ã€‚</p><blockquote><p>So what&#x27;s printed is the value of main&#x27;s identifier a which is 1, then the two values are dropped in reverse order of introduction printing 2 then 1, and the output of the program is 121.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="36-move--fn">ï¼ƒ36 <code>move &amp; Fn</code><a class="hash-link" href="#36-move--fn" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜ç›®-35">é¢˜ç›®<a class="hash-link" href="#é¢˜ç›®-35" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn call(mut f: impl FnMut() + Copy) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn g(mut f: impl FnMut() + Copy) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    call(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    call(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i = 0i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>æœªå®šä¹‰çš„è¡Œä¸º</li><li>ç¼–è¯‘å¤±è´¥</li><li>ç¨‹åºç¡®å®šä¼šè¾“å‡ºï¼š<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="æç¤º-35">æç¤º<a class="hash-link" href="#æç¤º-35" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>å˜é‡ <code>i</code> è¢«ç¼–è¯‘å™¨ç”Ÿæˆçš„é—­åŒ…å¯¹è±¡æ‰€æ•è·ã€‚</p><blockquote><p>The variable <code>i</code> is captured by value in the compiler-generated closure object.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="é¢˜è§£-34">é¢˜è§£<a class="hash-link" href="#é¢˜è§£-34" title="æ ‡é¢˜çš„ç›´æ¥é“¾æ¥">â€‹</a></h3><p>ç­”æ¡ˆï¼š1223</p><p>ä¼ å…¥ g çš„å¯¹è±¡æ˜¯ä¸€ä¸ª <code>FnMut</code> é—­åŒ…ï¼Œå®ƒæ•è·äº†ä¸€ä¸ªæ•´æ•°ã€‚å®é™…ä¸Šï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸å¯å‘½åçš„ç»“æ„ä½“ï¼ŒåŒ…å«ä¸€ä¸ªç±»å‹ä¸º i32 çš„å­—æ®µï¼Œå¹¶æœ‰ä¸€ä¸ªå‡½æ•°è°ƒç”¨æ“ä½œç¬¦ï¼Œè¯¥æ“ä½œç¬¦æ¥æ”¶ <code>&amp;mut self</code>ã€‚</p><blockquote><p>The object passed into g is a FnMut closure which captures an integer by value. Effectively it&#x27;s an unnameable struct containing a single field whose type is i32, with a function call operator that takes &amp;mut self:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Copy, Clone)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct UnnameableClosure {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl UnnameableClosure {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn unnameable_call_operator(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, self.i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut i = 0i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">g(UnnameableClosure { i });</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>g é‡Œé¢çš„ 4 ä¸ªè°ƒç”¨çš„è¡Œä¸ºå¦‚ä¸‹ã€‚</p><blockquote><p>The behavior of the 4 calls inside g is as follows:</p></blockquote><ul><li><p><code>f()</code> è¿è¡Œé—­åŒ…ï¼Œå…¶é€šè¿‡å€¼æ•è·çš„ <code>i</code> çš„å€¼å˜ä¸º 1ã€‚</p><blockquote><p>f() runs the closure and its by-value captured value of i becomes 1.</p></blockquote></li><li><p><code>call(f)</code> åˆ¶é€ ä¸€ä¸ª <code>f</code> çš„å‰¯æœ¬ï¼Œä½œä¸º call çš„å‚æ•°ã€‚è¿™ä¸ªå‰¯æœ¬è¢«æ‰§è¡Œï¼Œå®ƒçš„ <code>i</code> å˜æˆäº† 2ï¼Œä½†æ˜¯åŸå§‹é—­åŒ…ä»ç„¶ä¿æŒç€å®ƒæ•è·çš„ <code>i</code> çš„å€¼ä¸º 1ã€‚<code>f</code> çš„å‰¯æœ¬åœ¨è°ƒç”¨ä¸»ä½“çš„æœ«å°¾è¶…å‡ºäº†ä½œç”¨åŸŸè¢« dropã€‚</p><blockquote><p>call(f) makes a copy of f to become the argument of call. The copy gets executed and its i becomes 2, but the original closure still holds a value of 1 for its captured i. The copy of the closure gets dropped as it goes out of scope at the end of the body of call.</p></blockquote></li><li><p><code>f()</code> ç¬¬äºŒæ¬¡è¿è¡ŒåŸå§‹é—­åŒ…ï¼Œå…¶ i å˜ä¸º 2ã€‚</p><blockquote><p>f() runs the original closure a second time and its i becomes 2.</p></blockquote></li><li><p><code>call(f)</code> ç¬¬äºŒæ¬¡å¤åˆ¶ f å¹¶æ‰§è¡Œå‰¯æœ¬ï¼Œå®ƒçš„ i å˜æˆäº† 3ã€‚</p><blockquote><p>call(f) copies f a second time and executes the copy, its i becomes 3.</p></blockquote></li></ul><p>ä» Rust 1.26 å¼€å§‹ï¼Œå¦‚æœé—­åŒ…çš„æ‰€æœ‰æ•è·éƒ½å®ç°äº† Cloneï¼Œåˆ™é—­åŒ…è‡ªåŠ¨å®ç°äº† Cloneï¼›å¦‚æœæ‰€æœ‰æ•è·éƒ½å®ç°äº† Copyï¼Œåˆ™é—­åŒ…è‡ªåŠ¨å®ç°äº† Copyã€‚</p><blockquote><p>Since Rust 1.26, closures automatically implement Clone if all their captures implement Clone, and Copy if all the captures implement Copy.</p></blockquote><p>å¦‚æœ quiz ä»£ç ä¸­çœç•¥äº† move å…³é”®å­—ï¼Œç¼–è¯‘å™¨ç”Ÿæˆçš„é—­åŒ…å°†é€šè¿‡å¯å˜å¼•ç”¨è€Œä¸æ˜¯é€šè¿‡å€¼æ•è· iã€‚</p><blockquote><p>If the move keyword were omitted from the quiz code, the compiler-generated closure would capture i by mutable reference instead of by value:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pub struct UnnameableClosure&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i: &amp;&#x27;a mut i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="å¤åˆ¶ä»£ç åˆ°å‰ªè´´æ¿" title="å¤åˆ¶" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>å¹¶ä¸”ä¸å†æœ‰ Copy implï¼Œå› ä¸ºå°†ä¸€ä¸ªå¯å˜å¼•ç”¨å¤åˆ¶æˆå¤šä¸ªå‰¯æœ¬æ˜¯ä¸æ­£ç¡®çš„ï¼ˆaliasing xor mutationï¼›è¿™æ˜¯å€Ÿç”¨æ£€æŸ¥å™¨çš„é‡ç‚¹ï¼‰ã€‚</p><blockquote><p>and there would no longer be a Copy impl, because it&#x27;s incorrect to duplicate a mutable reference into multiple copies (aliasing xor mutation; this is the point of the borrow checker).</p></blockquote><p>å¯¹äº Rust çš„åˆå­¦è€…æ¥è¯´ï¼Œä¸€ä¸ªç»å¸¸å‡ºç°çš„å›°æƒ‘æ˜¯ move, non-move é—­åŒ…ä¸ Fnã€FnMut å’Œ FnOnce é—­åŒ…ä¹‹é—´çš„å…³ç³»ã€‚è¿™æ˜¯ä¸¤ä¸ªå‡ ä¹å®Œå…¨ä¸åŒçš„ä¸œè¥¿ã€‚æ­£å¦‚ä¸Šé¢çš„ <code>UnnameableClosure</code> ä¼ªä»£ç æ‰€ç¤ºï¼Œmove ä¸ non-move æ˜¯æŒ‡ç¼–è¯‘å™¨ç”Ÿæˆçš„é—­åŒ…ç»“æ„çš„å­—æ®µæ˜¯å¦ä¸åŸå§‹è¢«æ•è·å˜é‡çš„ç±»å‹ç›¸åŒï¼Œæˆ–è€…æ˜¯å¯¹åŸå§‹æ•è·å˜é‡ç±»å‹çš„å¼•ç”¨ï¼ˆä¾‹å¦‚ï¼Œ<code>i32</code> ä¸ <code>&amp;mut i32</code>ï¼‰ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œ<code>Fn</code> vs <code>FnMut</code> vs <code>FnOnce</code> æ˜¯å…³äºç¼–è¯‘å™¨ç”Ÿæˆçš„é—­åŒ…ç»“æ„çš„è°ƒç”¨æ–¹æ³•æ˜¯å¦æœ‰ä¸€ä¸ªæ¥æ”¶å™¨ï¼Œè¯¥æ¥æ”¶å™¨æ˜¯ <code>&amp;self</code> vs <code>&amp;mut self</code> vs <code>self</code>ã€‚</p><blockquote><p>One recurring source of confusion for Rust beginners is the relationship between move and non-move closures vs Fn and FnMut and FnOnce closures. These are two nearly-orthogonal things. As illustrated in the UnnameableClosure pseudocode above, move vs non-move is about whether the fields of the compiler-generated closure struct have the same type as the original captured variable&#x27;s type, vs are references to the original captured variable&#x27;s type (i32 vs &amp;mut i32, for example). In contrast, Fn vs FnMut vs FnOnce is about whether the call method of the compiler-generated closure struct has a receiver which is &amp;self vs &amp;mut self vs self.</p></blockquote></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="æ–‡æ¡£åˆ†é¡µå¯¼èˆª"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/rust/rs_channel"><div class="pagination-nav__sublabel">ä¸Šä¸€é¡µ</div><div class="pagination-nav__label">Channel æºç å‰–æ</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/rust/wasm"><div class="pagination-nav__sublabel">ä¸‹ä¸€é¡µ</div><div class="pagination-nav__label">Wasm å®ç°ç”Ÿå‘½æ¸¸æˆ</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-statement-boundry" class="table-of-contents__link toc-highlight">#1 <code>statement boundry</code></a><ul><li><a href="#é¢˜ç›®" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#è§£ç­”" class="table-of-contents__link toc-highlight">è§£ç­”</a></li></ul></li><li><a href="#2-impl-bitand" class="table-of-contents__link toc-highlight">#2 <code>impl BitAnd</code></a><ul><li><a href="#é¢˜ç›®-1" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-1" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#3-const-initializer" class="table-of-contents__link toc-highlight">#3 <code>const initializer</code></a><ul><li><a href="#é¢˜ç›®-2" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-2" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-1" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#4-" class="table-of-contents__link toc-highlight">#4 <code>..</code></a><ul><li><a href="#é¢˜ç›®-3" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-3" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-2" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#5-t-or-t" class="table-of-contents__link toc-highlight">#5 <code>T or &amp;T</code></a><ul><li><a href="#é¢˜ç›®-4" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-4" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-3" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#6-size-of-" class="table-of-contents__link toc-highlight">#6 <code>size of ()</code></a><ul><li><a href="#é¢˜ç›®-5" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-5" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-4" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#7-match" class="table-of-contents__link toc-highlight">#7 <code>match</code></a><ul><li><a href="#é¢˜ç›®-6" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-6" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-5" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#8---" class="table-of-contents__link toc-highlight">#8 <code>= = &gt;</code></a><ul><li><a href="#é¢˜ç›®-7" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-7" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-6" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#9-tttt" class="table-of-contents__link toc-highlight">#9 <code>$tt:tt</code></a><ul><li><a href="#é¢˜ç›®-8" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-8" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-7" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#10-traitf" class="table-of-contents__link toc-highlight">#10 <code>Trait::f</code></a><ul><li><a href="#é¢˜ç›®-9" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-9" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-8" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#11-early--late-bound" class="table-of-contents__link toc-highlight">#11 <code>early &amp; late bound</code></a><ul><li><a href="#é¢˜ç›®-10" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-10" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-9" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#12-let-s--x----s" class="table-of-contents__link toc-highlight">#12 <code>let S { x, .. } = S</code></a><ul><li><a href="#é¢˜ç›®-11" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-11" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-10" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#13-eq" class="table-of-contents__link toc-highlight">#13 <code>eq</code></a><ul><li><a href="#é¢˜ç›®-12" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-12" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-11" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#14-trait-scope" class="table-of-contents__link toc-highlight">#14 <code>trait scope</code></a><ul><li><a href="#é¢˜ç›®-13" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-13" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-12" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#15-type-inference" class="table-of-contents__link toc-highlight">#15 <code>type inference</code></a><ul><li><a href="#é¢˜ç›®-14" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-14" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-13" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#16---i" class="table-of-contents__link toc-highlight">#16 <code>--i</code></a><ul><li><a href="#é¢˜ç›®-15" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-15" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-14" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#17--------" class="table-of-contents__link toc-highlight">#17 <code>-- - --</code></a><ul><li><a href="#é¢˜ç›®-16" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-16" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-15" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#18-f-and-f" class="table-of-contents__link toc-highlight">#18 <code>f() and f()</code></a><ul><li><a href="#é¢˜ç›®-17" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-17" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-16" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#19-move-or-drop" class="table-of-contents__link toc-highlight">#19 <code>move or drop</code></a><ul><li><a href="#é¢˜ç›®-18" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-18" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-17" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#20-return-and-return" class="table-of-contents__link toc-highlight">#20 <code>return and return</code></a><ul><li><a href="#é¢˜ç›®-19" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-19" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-18" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#21-return--break" class="table-of-contents__link toc-highlight">#21 <code>return &amp; break</code></a><ul><li><a href="#é¢˜ç›®-20" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-20" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-19" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#22---is-a-token" class="table-of-contents__link toc-highlight">#22 <code>- is a token</code></a><ul><li><a href="#é¢˜ç›®-21" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-21" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-20" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#23-method-lookup-order" class="table-of-contents__link toc-highlight">#23 <code>method lookup order</code></a><ul><li><a href="#é¢˜ç›®-22" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-22" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-21" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#24-hygiene" class="table-of-contents__link toc-highlight">#24 <code>Hygiene</code></a><ul><li><a href="#é¢˜ç›®-23" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-23" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-22" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#25-drop" class="table-of-contents__link toc-highlight">#25 <code>drop</code></a><ul><li><a href="#é¢˜ç›®-24" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-24" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-23" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#26-lazy-map" class="table-of-contents__link toc-highlight">#26 <code>lazy map</code></a><ul><li><a href="#é¢˜ç›®-25" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-25" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-24" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#27-dyn-trait" class="table-of-contents__link toc-highlight">#27 <code>dyn Trait</code></a><ul><li><a href="#é¢˜ç›®-26" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-26" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-25" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#28-_guard--_" class="table-of-contents__link toc-highlight">#28 <code>_guard &amp; _</code></a><ul><li><a href="#é¢˜ç›®-27" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-27" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-26" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#29-t--t" class="table-of-contents__link toc-highlight">#29 <code>(T) &amp; (T,)</code></a><ul><li><a href="#é¢˜ç›®-28" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-28" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-27" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#30-clone" class="table-of-contents__link toc-highlight">#30 <code>clone</code></a><ul><li><a href="#é¢˜ç›®-29" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-29" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-28" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#31-method-lookup-order" class="table-of-contents__link toc-highlight">#31 <code>method lookup order</code></a><ul><li><a href="#é¢˜ç›®-30" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-30" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-29" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#32-march-arm--if-guard" class="table-of-contents__link toc-highlight">#32 <code>march arm &amp; if guard</code></a><ul><li><a href="#é¢˜ç›®-31" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-31" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-30" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#33-ranges-method" class="table-of-contents__link toc-highlight">#33 <code>Range&#39;s method</code></a><ul><li><a href="#é¢˜ç›®-32" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-32" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-31" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#34-size-of-fn" class="table-of-contents__link toc-highlight">#34 <code>size of fn</code></a><ul><li><a href="#é¢˜ç›®-33" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-33" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-32" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#35-hygiene-2" class="table-of-contents__link toc-highlight">#35 <code>Hygiene 2</code></a><ul><li><a href="#é¢˜ç›®-34" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-34" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-33" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li><li><a href="#36-move--fn" class="table-of-contents__link toc-highlight">ï¼ƒ36 <code>move &amp; Fn</code></a><ul><li><a href="#é¢˜ç›®-35" class="table-of-contents__link toc-highlight">é¢˜ç›®</a></li><li><a href="#æç¤º-35" class="table-of-contents__link toc-highlight">æç¤º</a></li><li><a href="#é¢˜è§£-34" class="table-of-contents__link toc-highlight">é¢˜è§£</a></li></ul></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.097b9c32.js"></script>
<script src="/assets/js/main.916d2c7b.js"></script>
</body>
</html>