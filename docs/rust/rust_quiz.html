<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-rust/rust_quiz">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Rust Quiz | Trdthg&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://trdthg.github.io//docs/rust/rust_quiz"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Rust Quiz | Trdthg&#x27;s blog"><meta data-rh="true" name="description" content="1 statement boundry"><meta data-rh="true" property="og:description" content="1 statement boundry"><link data-rh="true" rel="icon" href="/img/logo_png.png"><link data-rh="true" rel="canonical" href="https://trdthg.github.io//docs/rust/rust_quiz"><link data-rh="true" rel="alternate" href="https://trdthg.github.io//docs/rust/rust_quiz" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://trdthg.github.io//docs/rust/rust_quiz" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Trdthg&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Trdthg&#39;s blog Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4TM86KZ83J"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-4TM86KZ83J",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.6b28552f.css">
<link rel="preload" href="/assets/js/runtime~main.097b9c32.js" as="script">
<link rel="preload" href="/assets/js/main.916d2c7b.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo_png.png" alt="Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo_png.png" alt="Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Trdthg</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">文档</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/trdthg" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/docs/category/-拓展">🔮 拓展</a><button aria-label="打开/收起侧边栏菜单「🔮 拓展」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/async">协程与异步</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/bash">Bash</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/cicd">CI/CD</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/fd">文件系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/go">Go 语言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/hadoop">大数据</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/haskell">Haskell 语言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/linuxIO">IO 多路复用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/memory_ordering">原子操作与内存顺序</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/magic/software_arch">软件架构</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/-rust-语言">🦀 Rust 语言</a><button aria-label="打开/收起侧边栏菜单「🦀 Rust 语言」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item green"><a class="menu__link" tabindex="0" href="/docs/rust">Rust 语言</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/lists">Too-Many-Lists</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/mini_tokio">异步运行时</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/net-piercer">内网穿透工具</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/print_into_detail">Rust print! 宏</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/rs_channel">Channel 源码剖析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/rust/rust_quiz">Rust Quiz</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/rust/wasm">Wasm 实现生命游戏</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/-学习笔记">📚 学习笔记</a><button aria-label="打开/收起侧边栏菜单「📚 学习笔记」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/-资料库">📦 资料库</a><button aria-label="打开/收起侧边栏菜单「📦 资料库」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/-io-club">⚽ IO Club</a><button aria-label="打开/收起侧边栏菜单「⚽ IO Club」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">文档页</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/log">日志</a></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/-rust-语言"><span itemprop="name">🦀 Rust 语言</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Rust Quiz</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>Rust Quiz</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-statement-boundry">#1 <code>statement boundry</code><a class="hash-link" href="#1-statement-boundry" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目">题目<a class="hash-link" href="#题目" title="标题的直接链接">​</a></h3><p>下面的 1 输出是什么？</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($( $s:stmt )*) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        $(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            { stringify!($s); 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )&lt;&lt;*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;{}{}{}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m! { return || true },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m! { (return) || true },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m! { {return} || true },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示">提示<a class="hash-link" href="#提示" title="标题的直接链接">​</a></h3><p>宏的输出中的表达式与 <code>1 &lt;&lt; (n - 1)</code> 效果相同，其中 n 是宏输入中包含的 Rust 语句的数量。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="解答">解答<a class="hash-link" href="#解答" title="标题的直接链接">​</a></h3><p>答案：122</p><p>这个问题围绕着 Rust 的语法边界设计。</p><blockquote><p>This question revolves around where the Rust grammar places statement
boundaries.</p></blockquote><p>宏的输入规则是 <code>$( $s:stmt )*</code>, 它能够匹配到 0 或多个 Rust 语句。</p><p>该规则内部的 <code>$s: stmt</code> 是一个片段分类符，它能够匹配到一个符合 Rust 语法规范的表达式。被匹配到的语句可以在展开后的代码中作为 <code>$s</code> 。</p><p>而外部的 <code>$(...)*</code> 部分表示一个重复，它可以重复匹配 0 或多次内容。</p><blockquote><p>The input rule of the macro m! is $($s:stmt)<em>which matches zero or more Rust
statements. The $(...)</em> part of the rule is a repetition which matches the
contents of the repetition zero or more times, and the $s:stmt is a fragment
specifier that matches a Rust statement (stmt) conforming to the rules of the
Rust grammar. The matched statements are available within the expanded code as
the fragment variable $s.</p></blockquote><p>语句是函数体中允许的最高级别的语法单位。下面所有的内容都是语句的例子。</p><blockquote><p>A statement is the top-level unit of syntax permitted within a function body.
All of the following are examples of statements.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Items are statements.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct S { x: u64 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Let-bindings are statements.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut s = S { x: 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Expressions are statements.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">s.x + 1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>函数体的语法要求某些类型的语句后面有一个分号，但对于宏的语法而言，分号并不是语句的一部分。</p><blockquote><p>The grammar of function bodies requires that some types of statements are followed by a semicolon, but the semicolon is not part of the statement for the purpose of macro syntax.</p></blockquote><p><code>m!</code> 将会展开成 0 或多个由 <code>&lt;&lt;</code> 分割的 <code>{ stringify!($s); 1 }</code>。<code>$(...)&lt;&lt;*</code> 部分表示重复语句之间使用 <code>&lt;&lt;</code> 作为分隔符。</p><blockquote><p>The macro m! expands to zero or more copies of <code>{ stringify!($s); 1 }</code> separated by the <code>&lt;&lt;</code> token. The <code>$(...)&lt;&lt;*</code> part of the rule is a repetition using <code>&lt;&lt;</code> as the separator.</p></blockquote><p>在宏中使用 <code>&lt;&lt;</code> 作为分隔符非常不常见。最常用的分隔符是逗号，<code>$(...),*</code>，其他的单一符号也是允许的。重要的是，<code>macro_rules!</code> 把所有的 Rust 内置操作符都当成单 token</p><blockquote><p>Using <code>&lt;&lt;</code> as a separator in a repetition in a macro is highly unusual. The most commmonly used separator is the comma, written as <code>$(...),*</code>, but any other single token is allowed here. Crucially, macro_rules! treats all built-in Rust operators as single tokens, even those that consist of multiple characters like <code>&lt;&lt;</code>.</p></blockquote><p><code>{ stringify!($s); 1 }</code> 是一个表达式，它的返回值永远是 1。<code>stringify!($s)</code> 被丢弃了，所以它和 <code>{ 1 }</code> 的效果是相同的。这里使用 <code>stringify!($s)</code> 是为了控制重复的次数，规则中定义的标志符</p><blockquote><p>The <code>{ stringify!($s); 1 }</code> is an expression whose value is always 1. The value of <code>stringify!($s)</code> is discarded, so this is equivalent to the expression <code>{ 1 }</code>. The reason for having <code>stringify!($s)</code> in there is to control the number of times the repetition is repeated, which is determined by which fragment variables are used within the repetition. Writing a repetition without using any fragment variables inside of it would not be legal.</p></blockquote><p>假设我们调用宏时传入三条语句：</p><blockquote><p>Suppose we call this macro with three of the statements shown above as input.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">m! {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct S { x: u64 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = S { x: 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.x + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个宏会被展开为：</p><blockquote><p>The macro expands to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{ stringify!(struct S { x: u64 }); 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { stringify!(let mut s = S { x: 1 }); 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { stringify!(s.x + 1); 1 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>每个 stringifys 都会被转为字符串字面量：</p><blockquote><p>Each of the stringifys expands to a string literal:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{ &quot;struct S { x: u64 }&quot;; 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { &quot;let mut s = S { x: 1 }&quot;; 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { &quot;s.x + 1&quot;; 1 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>字符串字面量的值没有被使用。所以这个结果等价于 <code>{ 1 } &lt;&lt; { 1 } &lt;&lt; { 1 }</code>，也等价于 <code>1 &lt;&lt; 1 &lt;&lt; 1</code>。<code>&lt;&lt;</code> 操作符就是左移；结果是 4。</p><blockquote><p>The values of the string literals are not used. In this case the expression is equivalent to <code>{ 1 } &lt;&lt; { 1 } &lt;&lt; { 1 }</code>, which is equivalent to <code>1 &lt;&lt; 1 &lt;&lt; 1</code>. The <code>&lt;&lt;</code> operator is left-associative; the numeric value of this expression is 4.</p></blockquote><p>总的来说，Rust 语句有多少，1 就重复多少次。所以这个宏就相当于 <code>1 &lt;&lt; (n - 1)</code>。当 n 为 0 时，语句无法展开，会编译失败。</p><blockquote><p>Altogether, the relevant behavior of this macro is that it evaluates to <code>1 &lt;&lt; 1 &lt;&lt; 1 &lt;&lt; ...</code> where the number of ones is equal to the number of Rust statements in the input of the macro. In closed form, the numeric value is <code>1 &lt;&lt; (n - 1)</code> where n is the number of statements, except in the case that n is zero where the macro expands to nothing and we get a syntax error at the call site.</p></blockquote><p>剩下的就是判断一下这 3 次调用分别传入了多少个 Rust 语句。</p><blockquote><p>It remains to determine how many statements are in the three invocations of m! in the quiz code.</p></blockquote><ol><li><code>return || true</code></li></ol><p>这是一条 return 语句，他返回的 y 是一个闭包 <code>|| true</code>。等价于 <code>(|| true)</code>。所以他会被解析为一条语句，调用 <code>m!</code> 的结果是 1。</p><blockquote><p>This is a return-expression that would return the closure <code>|| true</code>. It is
equivalent to return <code>(|| true)</code>. It is parsed as a single statement so the m! invocation evaluates to 1</p></blockquote><ol start="2"><li><code>(return) || true</code></li></ol><p>这是一条逻辑或语句。<code>||</code> 是一个二元运算符，左侧是一个 <code>(return)</code> 语句 (或者说 <code>!</code> 类型)，右侧是一个表达式 <code>true</code>。所以 <code>(return) || true</code> 是一个语句，<code>m!</code> 的值仍然为 1。</p><blockquote><p>This is a logical-OR expression. The <code>||</code> is a binary operator, where the left-hand side is the expression <code>(return)</code> (of diverging type <code>!</code>) and the right-hand side is the expression <code>true</code>. This expression is a single statement so m! again evaluates to 1.</p></blockquote><ol start="3"><li><code>{return} || true</code></li></ol><p>这条是两个语句！一个块表达式 <code>return</code>，后面又跟一个闭包 <code>|| true</code>。</p><blockquote><p>This one is two statements! A block-statement <code>{return}</code> followed by a closure expression <code>|| true</code>.</p></blockquote><p>Rust 的语法区分了需要分号的表达式 (作为单个表达式) 和无需分号的一组表达式。看看下面的两个例子：</p><blockquote><p>The Rust grammar distinguishes between expressions that require a semicolon in order to stand alone as a statement, and expressions that can be statements even without a semicolon. Consider two examples:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 结尾不需要分号。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for t in vec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* ... */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 结尾需要分号。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">self.skip_whitespace()?;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>不需要分号的表达式都定义在 libsyntex 里。The distinction informs a few different early bail-out cases where the parser decides to finish parsing the current expression.(能力有限，不会翻译)</p><blockquote><p>The list of expression types that stand alone without a semicolon is defined here in libsyntax. The distinction informs a few different early bail-out cases where the parser decides to finish parsing the current expression.</p></blockquote><p>块表达式 <code>{ /* ... */ }</code> 终止一个表达式，和本题的情况相同。如果这样做在语法上是合理的，那就意味着解析器在块表达式之后不会立即消耗二元运算符。因此，我们可以这样写。</p><blockquote><p>Relevant to our case is that block expressions <code>{ /* ... */ }</code> terminate an expression if doing so would be syntactically sensible. The parser does not eagerly consume binary operators after a block expression. Thus one might write:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn f() -&gt; &amp;&#x27;static &amp;&#x27;static bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 块表达式。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;What a silly function.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // true 的引用的引用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;&amp;true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>为了正确解析这种情况（块表达式后面紧跟一个二元运算符），解析器需要在表达式的末尾及时终止。</p><blockquote><p>In order to parse a block followed by a binary operator, we would need to make it syntactically insensible for the parser to terminate an expression at the close curly brace. This would usually be done by wrapping in parentheses.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn f() -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ({ true } &amp;&amp; true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>总之，该程序的输出是 112。</p><blockquote><p>Anyhow, the output of the program is 112.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-impl-bitand">#2 <code>impl BitAnd</code><a class="hash-link" href="#2-impl-bitand" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-1">题目<a class="hash-link" href="#题目-1" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S(i32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl std::ops::BitAnd&lt;S&gt; for () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Output = ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn bitand(self, rhs: S) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, rhs.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let f = || ( () &amp; S(1) );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let g = || { () &amp; S(2) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let h = || ( {} &amp; S(3) );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let i = || { {} &amp; S(4) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    h();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-1">提示<a class="hash-link" href="#提示-1" title="标题的直接链接">​</a></h3><p>其中一个闭包和另外三个不同。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解">题解<a class="hash-link" href="#题解" title="标题的直接链接">​</a></h3><p>答案：123</p><p>f，g 和 h 都是 <code>impl Fn()</code>。闭包的 body 都会被解析为对上面由 BitAnd Trait 定义的 bitwise-AND 操作符的调用。当闭包被调用时，bitwise-AND 会打印出右侧 S 的内容，闭包则返回 <code>()</code>。</p><blockquote><p>The closures f, g, and h are all of type impl Fn(). The closure bodies are parsed as an invocation of the user-defined bitwise-AND operator defined above by the BitAnd trait impl. When the closures are invoked, the bitwise-AND implementation prints the content of the S from the right-hand side and evaluates to ().</p></blockquote><p>闭包 i 则不痛。使用 rustfmt 格式化代码会让他更清晰：</p><blockquote><p>The closure i is different. Formatting the code with rustfmt makes it clearer how i is parsed.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let i = || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;S(4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>闭包体由一个空的块状语句 {} 和后面的对 S(4) 的引用组成，而不是一个 bitwise-AND 操作。i 的类型是 <code>impl Fn() -&gt; &amp;&#x27;static S</code>。</p><blockquote><p>The closure body consists of an empty block-statement {} followed by a reference to S(4), not a bitwise-AND. The type of i is impl Fn() -&gt; &amp;&#x27;static S.</p></blockquote><p>f 对这种情况的解析是由 libsyntax 中的代码管理的。</p><blockquote><p>The parsing of this case is governed by this code in libsyntax.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-const-initializer">#3 <code>const initializer</code><a class="hash-link" href="#3-const-initializer" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-2">题目<a class="hash-link" href="#题目-2" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const S: S = S { x: 2 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = &amp;mut S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.x += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S.x += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}{}&quot;, v.x, S.x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-2">提示<a class="hash-link" href="#提示-2" title="标题的直接链接">​</a></h3><p><code>const</code> 和 不可变的 <code>static</code> 有什么区别？</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-1">题解<a class="hash-link" href="#题解-1" title="标题的直接链接">​</a></h3><p>答案：32</p><p>const 的语义是，任何在表达式位置上以名称提及的 <code>const</code> 都会被 const initializer 的值所替代。上面的代码其实等同于：</p><blockquote><p>The semantics of const is that any mention of the const by name in expression position is substituted with the value of the const initializer. In this quiz code the behavior is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let v = &amp;mut S { x: 2 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    v.x += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S { x: 2 }.x += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}{}&quot;, v.x, S { x: 2 }.x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里我只是简单地把每一个提到 S 的地方都用 <code>const S</code> 的值来代替，即 <code>S { x: 2 }</code>。</p><blockquote><p>I have simply substituted every mention of S in expresson position with the value of const S which is S { x: 2 }.</p></blockquote><p>main 的第一行等同于：</p><blockquote><p>The first line of main is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let mut _tmp0 = S { x: 2 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let v = &amp;mut _tmp0;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>main 的第二行改变了 v 指向的 x，在 v 剩余的生命期内，x 仍然可以通过 v 访问，因此打印的第一个字符是 3。</p><blockquote><p>The second line of main mutates the value pointed to by v. The same value remains accessible through v for the rest of the lifetime of v, which is why the first character printed is 3.</p></blockquote><p>main 的第三行改变了一个临时变量，该变量在分号结尾就立即超出了作用域。打印的第二个字符来自一个全新的<code>S { x: 2 }</code>，所以第二个打印的是 2。</p><blockquote><p>The third line of main mutates a temporary that immediately goes out of scope at the semicolon. The second character printed is coming from a brand new S { x: 2 }, so 2 is printed.</p></blockquote><p>这段代码中还有一个问题，是 Rust 中关于命名空间和名字解析的概念。任何指代类型的名字都在类型命名空间，任何指代值的名字都在值命名空间。</p><p>这是两组不同的名字，而语言的结构使我们总是可以知道在哪个命名空间中查找一个名字。</p><blockquote><p>One additional wrinkle in this code is the concept of namespaces and name resolution in Rust. Any name that refers to a type lives in the type namespace, and any name that refers to a value lives in the value namespace. These are two separate sets of names, and the language is structured such that we can always tell which namespace to look up a name in.</p></blockquote><p>在代码的上下文中，结构体 S 的名称是类型名称空间的一部分，而常量 S 的名称是值名称空间的一部分。这就是为什么我们可以，在同一时间看到两个相同名称的不同事物。</p><blockquote><p>In the context of the quiz code, the name of the struct S is part of the type namespace and the name of the const S is part of the value namespace. That is how we can have seemingly two different things with the same name in scope at the same time.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-">#4 <code>..</code><a class="hash-link" href="#4-" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-3">题目<a class="hash-link" href="#题目-3" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let (.., x, y) = (0, 1, ..);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, b&quot;066&quot;[y][x]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-3">提示<a class="hash-link" href="#提示-3" title="标题的直接链接">​</a></h3><p><code>..</code> 在表达中和模式匹配中含义不同。</p><blockquote><p>.. means one thing in an expression and something else in a pattern.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-2">题解<a class="hash-link" href="#题解-2" title="标题的直接链接">​</a></h3><p>答案：54</p><p>这个问题展示了 <code>..</code>不同含义</p><blockquote><p>This question demonstrates two different meanings of ...</p></blockquote><p>在表达式的一侧 (右侧), <code>..</code> 是构造闰 <code>Range</code> 类型的语法，表达式 <code>(0, 1, ..)</code> 是一个拥有三个元素的元组，其中的第三个拥有 RangeFull 类型。</p><blockquote><p>In expression position, .. is the syntax for constructing various types of ranges. Here the expression (0, 1, ..) is a tuple with three elements, the third one having type RangeFull.</p></blockquote><p>在模式的一侧，<code>..</code> 被用来表示任何数量的元素。所以模式 <code>(.., x, y)</code> 会匹配到一个拥有两个或者更多元素的元组，并把倒数第 2 个元素绑定到 x 上，最后一个数绑定到 y 上。</p><blockquote><p>On the other hand in a pattern, .. is used to mean &quot;any number of elements&quot;. So the pattern (.., x, y) matches a tuple with 2 or more elements, binding the second-last one to x and the last one to y.</p></blockquote><p>所以在面的第 1 行，x 的值为 1，y 的值为 <code>(..)</code>。因此打印出来的是 <code>b&quot;066[..][1]&quot;</code>。</p><blockquote><p>Coming out of the first line of main, we have x = 1 and y = (..). Thus the value printed is going to be b&quot;066&quot;<!-- -->[..][1]<!-- -->.</p></blockquote><p><code>b&quot;066&quot;</code> 是一个表达式，他是一个 Byte 形式的字符串字面量，它的类型是 <code>&amp;&#x27;static [u8; 3]</code>, 拥有三个 ASCII 字符 <code>b&#x27;0&#x27;</code>, <code>b&#x27;6&#x27;</code>, <code>b&#x27;6&#x27;</code>。</p><blockquote><p>The expression b&quot;066&quot; is a byte-string literal of type &amp;&#x27;static <!-- -->[u8; 3]<!-- --> containing the three ASCII bytes b&#x27;0&#x27;, b&#x27;6&#x27;, b&#x27;6&#x27;.</p></blockquote><p>当我们用 RangeFull 对字节串进切片时，我们得到一个长度为 3 的动态大小的切片 <!-- -->[u8]<!-- -->，接下来我们访问切片在 1 处的元素，即类型为 u8 的字节 <code>b&#x27;6&#x27;</code>。当打印时，我们看到的是 ASCII 数字 6 的十进制表示，也就是数字 54。</p><blockquote><p>When we slice the byte-string with RangeFull we get a dynamically sized slice <!-- -->[u8]<!-- --> of length 3. Next we access element 1 of the slice, which is the byte b&#x27;6&#x27; of type u8. When printed, we see the decimal representation of the byte value of the ASCII digit 6, which is the number 54.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-t-or-t">#5 <code>T or &amp;T</code><a class="hash-link" href="#5-t-or-t" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-4">题目<a class="hash-link" href="#题目-4" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; Trait for fn(T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T&gt; Trait for fn(&amp;T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn f(_: u8) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn g(_: &amp;u8) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a: fn(_) = f;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b: fn(_) = g;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c: fn(&amp;_) = g;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a.p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b.p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c.p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-4">提示<a class="hash-link" href="#提示-4" title="标题的直接链接">​</a></h3><p>如果你熟悉高级生命周期绑定的语法，可以尝试将 impl 签名中的所有类型和 main 中的类型解构为完全显式的形式。</p><blockquote><p>If you are familiar with higher-rank trait bound syntax, try desugaring all the types in the impl signatures and types in main into their fully explicit form.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-3">题解<a class="hash-link" href="#题解-3" title="标题的直接链接">​</a></h3><p>答案：112</p><p>第一个 impl 适用于 <code>fn(T)</code> 类型的函数指针，其中 T 是任何单一的具体类型。第二个 impl 适用于更高等级的 <code>for&lt;&#x27;a&gt; fn(&amp;&#x27;a T)</code> 类型的函数指针，其中 T 类型的生命周期超过 <code>&#x27;a</code>。</p><blockquote><p>The first impl applies to function pointers of type fn(T) where T is any single concrete type. The second impl applies to function pointers of higher-ranked type for&lt;&#x27;a&gt; fn(&amp;&#x27;a T) for some concrete type T that outlives &#x27;a.</p></blockquote><p>在 main 中，编译器会自动使用类型推导，用某种具体的类型来替代所有出现的 <code>_</code>。</p><blockquote><p>Inside of main, the compiler is going to use type inference to substitute all occurrences of _ in a type by some concrete type.</p></blockquote><p>对于闭包 a，我们推断 <code>_ = u8</code>，闭包类型为 <code>fn(u8)</code>，接受一个 <code>u8</code> 类型的参数并返回 <code>()</code>。</p><blockquote><p>For the closure a we infer _ = u8, yielding the closure type fn(u8) taking an argument of type u8 and returning ().</p></blockquote><p>对于 b，我们推断 <code>_ = &amp;&#x27;x u8</code>, 为一些具体的生命周期 <code>&#x27;x</code>，最终将被送入借用检查器。b 的类型是 <code>fn(&amp;&#x27;x u8)</code>。</p><blockquote><p>For b we infer _ = &amp;&#x27;x u8 for some concrete lifetime &#x27;x that will ultimately feed into the borrow checker. The type of b is fn(&amp;&#x27;x u8).</p></blockquote><p>最后，对于 c，我们推断 <code>_ = u8</code>，产生更高等级的闭包类型 <code>&lt;&#x27;a&gt; fn(&amp;&#x27;a u8)</code>。</p><blockquote><p>And finally for c we infer _ = u8, yielding the higher-ranked closure type for&lt;&#x27;a&gt; fn(&amp;&#x27;a u8).</p></blockquote><p>以此为框架，可以看出，在 main 结尾出会打印 112。</p><blockquote><p>Framed in this way, it follows that the trait method calls at the end of main print 112.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-size-of-">#6 <code>size of ()</code><a class="hash-link" href="#6-size-of-" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-5">题目<a class="hash-link" href="#题目-5" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::mem;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = a = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, mem::size_of_val(&amp;a));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-5">提示<a class="hash-link" href="#提示-5" title="标题的直接链接">​</a></h3><p>有两个名为 a 的变量，它们各自的类型是什么？</p><blockquote><p>There are two variables named a. What is the type of each one?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-4">题解<a class="hash-link" href="#题解-4" title="标题的直接链接">​</a></h3><p>答案：0</p><p>这里有两个名为 a e 的变量，第二个会 &quot;遮蔽&quot; 第一个，这段程序等价于：</p><blockquote><p>There are two variables named a, one shadowing the other. The program is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = a = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print!(&quot;{}&quot;, mem::size_of_val(&amp;b));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>更进一步，为 b 赋的值是一个表达式 <code>a = true</code>;</p><blockquote><p>Further, the value being assigned to b is the expression a = true.</p></blockquote><p>在 Rust 里，赋值表达式的返回值始终是 <code>()</code>。在简化一下代码：</p><blockquote><p>In Rust, assignment expressions always have the value (). Simplified some more, the quiz code is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let a = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let b = ();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print!(&quot;{}&quot;, mem::size_of_val(&amp;b));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>关于它的行为规范，请参考 size_of_val 的文档，但在这种情况下，它被实例化为 <code>T = ()</code>，我们最终会打印出 <code>size_of::&lt;()&gt;()</code> 的值。</p><blockquote><p>Refer to the documentation of size_of_val for a specification of its behavior, but in this case it is being instantiated with T = () and we end up printing the value of size_of::&lt;()&gt;().</p></blockquote><p><code>()</code> 是零大小类型或 ZST 的一个例子，在运行时由零字节的数据表示，所以程序会打印出 0。</p><blockquote><p>() is one example of a zero-sized type or ZST and is represented by zero bytes of data at runtime, so the program prints 0.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-match">#7 <code>match</code><a class="hash-link" href="#7-match" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-6">题目<a class="hash-link" href="#题目-6" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[repr(u8)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Enum {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    First,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Second,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Enum {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            First =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Second =&gt; print!(&quot;2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Enum::p(unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        std::mem::transmute(1u8)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-6">提示<a class="hash-link" href="#提示-6" title="标题的直接链接">​</a></h3><p>调用 <code>Enum::p</code> 时传入的参数一定是 <code>Enum::Second</code>。</p><blockquote><p>The argument of the call to Enum::p is guaranteed to be Enum::Second.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-5">题解<a class="hash-link" href="#题解-5" title="标题的直接链接">​</a></h3><p>答案：1</p><p>展开隐藏的条件，这段 Enum 的定义其实等同于：</p><blockquote><p>Filling in the implicit discriminants, the definition of Enum is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[repr(u8)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum Enum {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    First = 0u8,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Second = 1u8,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>unsafe transmute</code> 只是转移你的注意。<code>#[repr(u8)]</code> 会确保我们的类型和 u8 有相同的内存布局，而 <code>Enum::Second</code> 的判别会确保 <code>Enum::Second</code> 和 1u8 的布局相同。因此这里的 <code>transmute</code> 的定义明确，等价于 <code>Enum::Second</code>。</p><blockquote><p>The unsafe transmute is a red herring. The attribute #<!-- -->[repr(u8)]<!-- --> guarantees that our type has the same representation as u8, and the discriminant on Enum::Second guarantees that Enum::Second has the same representation as 1u8. The transmute is well-defined and evaluates to Enum::Second.</p></blockquote><p>如果方法 p 的定时是这样的：</p><blockquote><p>If the method p had been written as:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">match self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Enum::First =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Enum::Second =&gt; print!(&quot;2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个程序会打印 2。</p><blockquote><p>then this program would print 2.</p></blockquote><p>但是，模式匹配里的两个分支都是通配符，能够匹配到任何值，并把它绑定到 First 或者 Second 上。模式按顺序匹配，所以这里总是会匹配到 First 分支。</p><blockquote><p>However, as written, both arms of the match expression are wildcard matches that successfully match any value and bind a variable with the name First or Second. Match arms are applied in order so the wildcard match in the first arm is always the one matched.</p></blockquote><p>编译器会给我们两条警告。第一个是它描述了匹配的过程。</p><blockquote><p>The compiler helps us out with not one but two relevant warnings. First it describes exactly how this match is parsed and why that is probably silly.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">warning: unreachable pattern</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; questions/007.rs:11:13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 |             First =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |             ----- matches any value</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 |             Second =&gt; print!(&quot;2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |             ^^^^^^ unreachable pattern</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第二个是编译器意识到了程序员可能写错了代码，并给出了可能正确的提示。</p><blockquote><p>Second, it recognizes what the programmer has done wrong and what they probably meant to write instead.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">warning[E0170]: pattern binding `First` is named the same as one of the variants of the type `Enum`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; questions/007.rs:10:13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 |             First =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |             ^^^^^ help: to match on the variant, qualify the path: `Enum::First`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在模式中直接写限定路径的方法是把枚举的变体也引入作用域：</p><blockquote><p>An alternative to writing qualified paths in the pattern is to bring the variants into scope.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use Enum::*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">match self {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    First =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Second =&gt; print!(&quot;2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过<a href="https://doc.rust-lang.org/std/prelude/index.html" target="_blank" rel="noopener noreferrer">标准库的 prelude</a>，我们可以在模式匹配中直接使用 <code>OK</code> 和 <code>Some</code> (而不是 <code>Result::OK</code> 和 <code>Option::Some</code>)。</p><blockquote><p>Having variants brought into scope by the standard library prelude is what allows us to write Ok and Some in match arms, rather than the qualified paths Result::Ok and Option::Some.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="8---">#8 <code>= = &gt;</code><a class="hash-link" href="#8---" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-7">题目<a class="hash-link" href="#题目-7" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (==&gt;) =&gt; { print!(&quot;1&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (= = &gt;) =&gt; { print!(&quot;2&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (== &gt;) =&gt; { print!(&quot;3&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (= =&gt;) =&gt; { print!(&quot;4&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(==&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(= = &gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(== &gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(= =&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-7">提示<a class="hash-link" href="#提示-7" title="标题的直接链接">​</a></h3><p>根据 <code>macro_rules!</code> 的规则，<code>==</code> 是一个 token，<code>=&gt;</code> 也是一个 token。</p><blockquote><p>According to macro_rules!, == is one token and =&gt; is one token.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-6">题解<a class="hash-link" href="#题解-6" title="标题的直接链接">​</a></h3><p>答案：1214</p><p>在 <code>macro_rules!</code> 的输入模式中，相邻的标点符号根据它们的用法不同，会被划分为几组。</p><blockquote><p>Adjacent punctuation characters in the input pattern of a macro_rules! macro are grouped according to how those characters are used by native Rust tokens.</p></blockquote><p><a href="https://docs.rs/syn/0.15.22/syn/token/index.html#structs" target="_blank" rel="noopener noreferrer">这里</a>列出了 Rust 中的单字符和多字符 token 列表</p><blockquote><p>This page contains a list of the single-character and multi-character punctuation tokens involved in the Rust grammar.</p></blockquote><p>列表中的有一个例子，<code>&lt;&lt;=</code> 是一个 token，Rust 语法把它作为左移赋值。因此包含 <code>&lt;&lt;=</code> 的一个 <code>macro_rules!</code> 输入，只有遇到 <code>&lt;&lt;=</code> 且中间没有空格时才会匹配。</p><blockquote><p>As one example from that list, <code>&lt;&lt;=</code> is a single token because the Rust grammar uses that sequence of characters to mean left shift assignment. Thus a macro_rules! input rule containing <code>&lt;&lt;=</code> would only match if all three characters <code>&lt;&lt;=</code> are written consecutively without spaces in the invocation.</p></blockquote><p>但是 <code>=&lt;&lt;</code> 在 Rust 语法中不是一个 native token。macro_rules！的解析器会根据贪心将其分解为 Rust 标记。 <code>=&lt;</code> 也不是一个 native token，所以首先我们需要匹配一个 <code>=</code> 本身。然后，<code>&lt;&lt;</code> 是一个 native token。在宏规则中写 <code>=&lt;&lt;</code> 的行为与写 <code>= &lt;&lt;</code> 的行为完全相同。</p><blockquote><p>But for example <code>=&lt;&lt;</code> is not a native token in the Rust grammar. The parser of macro_rules! will decompose this into Rust tokens according to a greedy process. <code>=&lt;</code> is also not a native token, so first we would need to match a <code>=</code> by itself. Then <code>&lt;&lt;</code> is a native token. Writing <code>=&lt;&lt;</code> in a macro rule behaves exactly the same as writing <code>= &lt;&lt;</code>.</p></blockquote><p>现在让我们以同样的方式分解代码中的规则。</p><blockquote><p>Now let&#x27;s decompose the rules in the quiz code the same way.</p></blockquote><ul><li><code>==&gt;</code> 分解为 <code>== &gt;</code>。</li><li><code>= = &gt;</code> 已经被分解了。</li><li><code>== &gt;</code> 已经被分解了。</li><li><code>= =&gt;</code> 已经被分解了。</li></ul><p>在我们的宏里，第一条规则加不加空格是一样的。第三条规则是不可达的。</p><blockquote><p>Our macro is the same as if we had written the first rule with a space. The third rule is unreachable.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (== &gt;) =&gt; { print!(&quot;1&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (= = &gt;) =&gt; { print!(&quot;2&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (== &gt;) =&gt; { print!(&quot;3&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (= =&gt;) =&gt; { print!(&quot;4&quot;); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 main 中，第一行和第三行都符合第一条宏规则。第二行匹配第二条规则，第四行匹配第四条规则。输出结果是 1214。</p><blockquote><p>Within main, the first and third lines both match the first macro rule. The second line matches the second rule and the fourth line matches the fourth rule. The output is 1214.</p></blockquote><p>过程宏使用更灵活、更强大的宏 API，并且总是能够区分相同字符的不同间隔，例如 <code>== &gt;</code> 与 <code>==&gt;</code>。</p><blockquote><p>Procedural macros use a more flexible and powerful macro API and can always distinguish between different spacings of the same characters, such as == &gt; vs ==&gt;.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="9-tttt">#9 <code>$tt:tt</code><a class="hash-link" href="#9-tttt" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-8">题目<a class="hash-link" href="#题目-8" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (1) =&gt; { print!(&quot;1&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($tt:tt) =&gt; { print!(&quot;2&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! e {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($e:expr) =&gt; { m!($e) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! t {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($tt:tt) =&gt; { e!($tt); m!($tt); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t!(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-8">提示<a class="hash-link" href="#提示-8" title="标题的直接链接">​</a></h3><p>一旦被匹配为 <code>$:expr</code>，匹配到的表达式就变成了一个不透明的标记树。</p><blockquote><p>Upon being matched as a $:expr, the matched expression becomes a single opaque token tree.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-7">题解<a class="hash-link" href="#题解-7" title="标题的直接链接">​</a></h3><p>答案：21</p><p>这个问题涉及到宏匹配器在匹配宏的元变量时的行为。</p><blockquote><p>This question involves the behavior of macro matchers as regards matching macro metavariables.</p></blockquote><p>从代码的最后一行看起，<code>t!(1)</code> 会匹配到 <code>t!</code> 的第一条规则，然后展开为 <code>e!(1); m!(1);</code></p><blockquote><p>Starting from the bottom of the quiz code, the invocation t!(1) matches the first rule of t! and expands to e!(1); m!(1);.</p></blockquote><p>调用 <code>e!(1)</code> 会匹配 <code>e!</code> 的第一条规则。作为这个匹配的一部分，表达式 <code>1</code> 会被打包成一个不透明的表达式 token，称为 <code>$e</code>。在接下来的任何时候，任何 <code>macro_rules！</code>宏都不可能查看 <code>$e</code> 的内部，唯一可以知道的是 <code>$e</code> 是某个表达式。</p><blockquote><p>The invocation e!(1) matches the first rule of e!. As part of this match, the expression 1 is packaged into an opaque expression token called $e. At no subsequent point will it be possible for any macro_rules! macro to look inside of $e. All that can be known is that $e is some expression.</p></blockquote><p>在任何情况下，<code>e!(1)</code> 都会扩展为 <code>m!($e)</code>，其中 <code>$e</code> 是一个包含 <code>1</code> 的不透明表达式。<code>m!($e)</code> 并不符合 <code>m!</code> 的第一条规则，因为 <code>$e</code> 是不透明的。所以它匹配了 <code>m!</code> 的第二条规则，并打印出 2。</p><blockquote><p>In any case, e!(1) expands to m!($e) where $e is an opaque expression containing 1. That m!($e) does not match the first rule of m! because $e is opaque. Instead it matches the second rule of m! and prints 2.</p></blockquote><p>在 <code>e!(1)</code> 之后有一个对 <code>m!(1)</code> 的调用，来自 <code>t!</code> 的展开。这个调用确实符合 <code>m!</code> 的第一条规则，并打印出 1。所以这个程序的输出是 21。</p><blockquote><p>After e!(1) there is an invocation m!(1) coming from the expansion of t!. That one does match the first rule of m! and prints 1. The output of this program is 21.</p></blockquote><p>大多数片段分类符都有这种变为不透明 token 的行为，但有些没有。一旦匹配到就变为不透明 token 的片段分类符：</p><blockquote><p>Most fragment specifiers have this behavior of becoming opaque token boxes, but some do not. Specifiers that are opaque once matched:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$:block</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:expr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:item</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:literal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:meta</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:pat</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:path</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:stmt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:ty</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>剩下的片段分类符匹配成功后不会变为不透明的，可以被后续的规则检查到：</p><blockquote><p>The rest of the specifiers do not become opaque and can be inspected by subsequent rules:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$:ident</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:lifetime</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$:tt</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>比如：</p><blockquote><p>For example:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (&#x27;a) =&gt; {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! l {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($l:lifetime) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // $l is not opaque.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m!($l);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">l!(&#x27;a);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="10-traitf">#10 <code>Trait::f</code><a class="hash-link" href="#10-traitf" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-9">题目<a class="hash-link" href="#题目-9" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a&gt; dyn Trait + &#x27;a {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Trait::f(&amp;true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Trait::f(&amp;true as &amp;dyn Trait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;_ as Trait&gt;::f(&amp;true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;bool as Trait&gt;::f(&amp;true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;dyn Trait as Trait&gt;::f(&amp;true as &amp;dyn Trait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-9">提示<a class="hash-link" href="#提示-9" title="标题的直接链接">​</a></h3><p>这并不能帮助你解决问题，但可能会让你好受些：作者也被这个问题难住了。</p><blockquote><p>This won&#x27;t help you answer the question but may help feel better: the quiz author was also stumped by this one.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-8">题解<a class="hash-link" href="#题解-8" title="标题的直接链接">​</a></h3><p>答案：222222</p><p>这道题里有一个 Trait 方法 <code>Trait::f</code>，同时还有特征对象 <code>dyn Trait</code> 的 f 方法。</p><blockquote><p>This question contains a trait method <code>Trait::f</code> as well as an inherent method f on the trait object type dyn Trait.</p></blockquote><p>据我所知，鉴于这些名字会相互遮蔽，在 <code>dyn Trait</code> 实现的 <code>f</code> 方法实际上是无法调用的。目前，Rust 中没有任何语法可以在 <code>dyn Trait</code> 上调用它的 <code>f</code>。</p><blockquote><p>As far as I know, given that these names shadow each other, the inherent method is literally uncallable. There is currently no syntax in Rust for calling the inherent f on dyn Trait.</p></blockquote><p>如果 trait 方法的名字可以以不同的方式命名，并且只有 <code>dyn Trait</code> 的方法被称为 <code>f</code>，那么 main 的前两行就会成功调用 <code>dyn Trait</code> 的方法。然而，由于写的是被遮蔽的名字，这会导致歧义，最后调用的是 Trait 的方法。</p><blockquote><p>If the trait method were named something different and only the inherent method were called f, then the first two lines of main would successfully call the inherent method. However, as written with shadowed names, they disambiguate to the trait method.</p></blockquote><p>还有一种可以尝试的语法：</p><blockquote><p>One additional syntax to try would be:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dyn Trait&gt;::f(&amp;true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;dyn Trait&gt;::f(&amp;true as &amp;dyn Trait);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果特征方法的命名不同，这两个调用都会调用 <code>dyn Trait</code> 的 <code>f</code> 方法。如果 <code>dyn Trait</code> 的方法被命名为不同的东西，这两个方法都会调用 Trait 方法。但是如果 <code>Trait</code> 方法和 <code>dyn Trait</code> 方法都叫作 f，那么编译器会报告一个歧义。</p><blockquote><p>If the trait method were named something different, both of these would call the inherent method. If the inherent method were named something different, both of these would call the trait method. But if the trait method and the inherent method are both f then the compiler reports an ambiguity.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error[E0034]: multiple applicable items in scope</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; questions/010.rs:18:5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 |     &lt;dyn Trait&gt;::f(&amp;true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |     ^^^^^^^^^^^^^^ multiple `f` found</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">note: candidate #1 is defined in an impl for the type `dyn Trait`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; questions/010.rs:6:5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6  |     fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |     ^^^^^^^^^^^</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">note: candidate #2 is defined in the trait `Trait`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; questions/010.rs:2:5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2  |     fn f(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |     ^^^^^^^^^^^^</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   = help: to disambiguate the method call, write `Trait::f(...)` instead</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>也许有一天，在一个被特征方法所遮蔽的特征对象上调用它的方法可能消除歧义。但是现在，代码只能打印出 222222。</p><blockquote><p>Maybe some day it will be possible to disambiguate a call to an inherent method on a trait object shadowed by a trait method. For now, the quiz code prints 222222.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="11-early--late-bound">#11 <code>early &amp; late bound</code><a class="hash-link" href="#11-early--late-bound" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-10">题目<a class="hash-link" href="#题目-10" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn f&lt;&#x27;a&gt;() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn g&lt;&#x27;a: &#x27;a&gt;() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pf = f::&lt;&#x27;static&gt; as fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let pg = g::&lt;&#x27;static&gt; as fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, pf == pg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-10">提示<a class="hash-link" href="#提示-10" title="标题的直接链接">​</a></h3><p>f 和 g 的写法是不能互换的。</p><blockquote><p>The way that f and g are written is not interchangeable.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-9">题解<a class="hash-link" href="#题解-9" title="标题的直接链接">​</a></h3><p>答案：编译失败</p><p>比较函数指针是一个坏主意。在优化后的构建中，很容易出现无意义的行为。关于这种行为的一个令人瞠目结舌的例子，请看 <a href="https://github.com/rust-lang/rust/issues/54685" target="_blank" rel="noopener noreferrer">rust-lang/rust#54685</a>，其中 x == y 同时为真，又不为真。(译者注：该问题已修复)</p><blockquote><p>Function pointer comparison is generally a Bad Idea. It is easily possible to get nonsensical behavior in optimized builds. For a jaw-dropping example of such behavior, check out rust-lang/rust#54685 in which x == y is both true and not true at the same time.</p></blockquote><p>那就是说，这段代码编译失败。下面是编译的输出：</p><blockquote><p>That said, the quiz code in this question fails to compile. Here is the compiler output:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> --&gt; questions/011.rs:5:18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5 |     let pf = f::&lt;&#x27;static&gt; as fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |                  ^^^^^^^</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">note: the late bound lifetime parameter is introduced here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> --&gt; questions/011.rs:1:18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1 | fn f&lt;&#x27;a&gt;() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |      ^^</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>泛型参数可以是早绑定也可以是晚绑定。目前 (以及可以遇见的未来) 类型参数都是早绑定，但是生命周期参数两者都有可能。</p><blockquote><p>Generic parameters can be either early bound or late bound. Currently (and for the foreseeable future) type parameters are always early bound, but lifetime parameters can be either early or late bound.</p></blockquote><p>早绑定是在编译器在单态化过程中决定的。因为类型参数总是早绑定，你不能拥有一个泛型未指定的值。</p><blockquote><p>Early bound parameters are determined by the compiler during monomorphization. Since type parameters are always early bound, you cannot have a value whose type has an unresolved type parameter. For example:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn m&lt;T&gt;() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let m1 = m::&lt;u8&gt;; // ok</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let m2 = m; // error: cannot infer type for `T`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>但是，对于生命周期是合法的：</p><blockquote><p>However, this is often allowed for lifetime parameters:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn m&lt;&#x27;a&gt;(_: &amp;&#x27;a ()) {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let m1 = m; // 即使没有提供 &#x27;a 也可以</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因为 &#x27;a 的具体取值取决与它如何被调用，用户可以省略生命周期参数，他会在调用是决定。生命周期甚至可以在每次调用时都不一样。</p><blockquote><p>Since the actual choice of lifetime &#x27;a depends on how it is called, we are allowed to omit the lifetime parameter and it will be determined at the call site. The lifetime can even be different for each time it gets called.</p></blockquote><p>鉴于此，我们不能在调用前指定函数上的生命周期。</p><blockquote><p>For this reason, we cannot specify the lifetime on this function until it is called:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let m2 = m::&lt;&#x27;static&gt;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们甚至不能让借用检查器提前自动推断：</p><blockquote><p>We may not even ask the borrow checker to infer it too soon:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let m3 = m::&lt;&#x27;_&gt;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>晚绑定参数的概念与 Rust 中的另一个特性 &quot;高阶生命周期&quot; 有些重复。这是一种用于表达特征参数的边界是晚绑定的机制。目前这只限于生命周期参数，但在其他语言（如 Haskell）中也存在同样的想法，用于类型参数，这就是 &quot;高级&quot; 一词的由来。</p><blockquote><p>The idea of late bound parameters overlaps considerably with a feature of Rust called &quot;higher ranked trait bounds&quot; (HRTB). This is a mechanism for expressing that bounds on a trait&#x27;s parameters are late bound. Currently this is limited to lifetime parameters, but the same idea exists in other languages (such as Haskell) for type parameters, which is where the term &quot;higher ranked&quot; comes from.</p></blockquote><p>表达 HRTB 的语法需要使用 for 关键字。为了表达上面 m1 的类型，你可以这么写：</p><blockquote><p>The syntax to express a HRTB for lifetimes uses the for keyword. To express the type of m1 above, we could have written:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let m1: impl for&lt;&#x27;r&gt; Fn(&amp;&#x27;r ()) = m;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>你可以把它看成：&quot;这里有一个生命周期参数，但是目前我们不需要知道它具体是什么&quot;.</p><blockquote><p>You can think of this as meaning: &quot;There is a lifetime but we don&#x27;t need to know what it is just yet&quot;.</p></blockquote><p>晚绑定的生命周期是无限制的；没有明确的语法来表达一个晚绑定的生命周期必须超过其他的生命周期。</p><blockquote><p>Late bound lifetimes are always unbounded; there is no syntax for expressing a late bound lifetime that must outlive some other lifetime.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error: lifetime bounds cannot be used in this context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> --&gt; src/main.rs:5:20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5 |     let _: for&lt;&#x27;b: &#x27;a&gt; fn(&amp;&#x27;b ());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |                    ^^</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>数据类型上的生命周期总是早绑定，除非开发者明确使用 HRBT 的语法。在函数上，生命周期默认是晚绑定，在下列情况下可以是早绑定：</p><blockquote><p>Lifetimes on data types are always early bound except when the developer has explicitly used the HRTB for syntax. On functions, lifetimes are late bound by default but can be early bound if:</p></blockquote><ul><li><p>生命周期在函数签名之外声明，例如，在一个结构体的方法中;或者</p><blockquote><p>The lifetime is declared outside the function signature, e.g. in an associated method of a struct it could be from the struct itself; or</p></blockquote></li><li><p>生命周期参数被其他一些更长的生命周期所约束。正如我们所看到的，这种约束在 HRTB 中是无法表达的，因为 HRTB 会涉及到生命周期的晚绑定。</p><blockquote><p>The lifetime parameter is bounded below by some other lifetime that it must outlive. As we&#x27;ve seen, this constraint is not expressible in the HRTB that would be involved in late binding the lifetime.</p></blockquote></li></ul><p>根据这些规则，签名 <code>fn f&lt;&#x27;a&gt;()</code> 有一个晚期绑定的生命周期参数，而签名 <code>fn g&lt;&#x27;a: &#x27;a&gt;()</code> 有一个早绑定的生命周期参数 -- 尽管这里的约束是无效的。</p><blockquote><p>By these rules, the signature fn f&lt;&#x27;a&gt;() has a late bound lifetime parameter while the signature fn g&lt;&#x27;a: &#x27;a&gt;() has an early bound lifetime parameter — even though the constraint here is ineffectual.</p></blockquote><p>通常情况下，这些区别是编译器内部的术语，Rust 程序员在日常编写代码时并不需要了解或思考这些术语。只有在少数边缘情况下，类型系统的这个方面在语言中是可以观察到的，比如在这道 Quiz 的代码中。</p><blockquote><p>Ordinarily these distinctions are compiler-internal terminology that Rust programmers are not intended to know about or think about in everyday code. There are only a few edge cases where this aspect of the type system becomes observable in the surface language, such as in the original quiz code.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="12-let-s--x----s">#12 <code>let S { x, .. } = S</code><a class="hash-link" href="#12-let-s--x----s" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-11">题目<a class="hash-link" href="#题目-11" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct D(u8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for D {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, self.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    d: D,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x: u8,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let S { x, .. } = S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        d: D(1),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x: 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let S { ref x, .. } = S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        d: D(3),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        x: 4,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-11">提示<a class="hash-link" href="#提示-11" title="标题的直接链接">​</a></h3><p>模式 <code>S { ref x, .. }</code> 从 S 类型的值的所有者那里借用了一个 x 成员，并绑定到了变量 x 上。</p><blockquote><p>The pattern <code>S { ref x, .. }</code> borrows a binding x from the owner of a value of type S.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-10">题解<a class="hash-link" href="#题解-10" title="标题的直接链接">​</a></h3><p>答案：1243</p><p>模式 <code>S { ref x, .. }</code> 从 S 类型的值的所有者那里借用一个绑定的 x。这个问题涉及到 drop 触发的位置。D 在哪里被 drop？</p><blockquote><p>This question involves drop-placement. Where does D get dropped?</p></blockquote><p>在第一个 let-binding 中，我们将一个 S 类型的值解构为它的 u8 类型的字段 x 以及代表 &quot;S 的其余部分&quot; 的 <code>..</code>。<code>..</code> 会立即被 drop，因为它不再有所有者。</p><blockquote><p>In the first let-binding, we destructure a value of type S into its field x of type u8 as well as .. which represents &quot;the rest of S&quot;. The part that is the rest of S is dropped immediately at that point because it no longer has an owner.</p></blockquote><p>在第二个 let-binding 中，我们从 S 类型的值的所有者那里借用一个字段 x。在字段 x 被借用期间，整个 S 类型的值将保持在作用域内，并在 main 的闭合大括号处退出作用域。</p><blockquote><p>In the second let-binding, we borrow a field x from the owner of a value of type S. The whole value of type S remains in scope during the time that its field x is borrowed, and goes out of scope at the close curly brace of main.</p></blockquote><p>最后的输出是 1243。</p><blockquote><p>The output is 1243.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="13-eq">#13 <code>eq</code><a class="hash-link" href="#13-eq" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-12">题目<a class="hash-link" href="#题目-12" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let [x, y] = &amp;mut [S, S];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let eq = x as *mut S == y as *mut S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, eq as u8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-12">提示<a class="hash-link" href="#提示-12" title="标题的直接链接">​</a></h3><p>两个可变引用指向同一个内存位置可以吗？会出什么问题呢？</p><blockquote><p>Is it okay for two mutable references to point to the same memory location? What could go wrong?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-11">题解<a class="hash-link" href="#题解-11" title="标题的直接链接">​</a></h3><p>答案：1</p><p>在这段代码中，S 是一个零大小类型。零大小类型是编译时的概念，在编译过程中会消失，在运行时会以零字节表示。</p><blockquote><p>In this code, S is a zero sized type or ZST. Zero sized types are compile-time concepts that disappear during compilation and have a runtime representation of zero bytes.</p></blockquote><p>main 的第一行创建了一个类型为 <!-- -->[S; 2]<!-- --> 的本地值。让我们把这个临时值称为 tmp。let-binding 在 tmp 中绑定了两个引用，x 指的是 <code>&amp;mut tmp[0]</code>，y 指的是 <code>&amp;mut tmp[1]</code>。</p><blockquote><p>The first line of main creates a local value of type <!-- -->[S; 2]<!-- -->. Let&#x27;s refer to that temporary as tmp. The let-binding binds two references into tmp, x referring to &amp;mut tmp<!-- -->[0]<!-- --> and y referring to &amp;mut tmp<!-- -->[1]<!-- -->.</p></blockquote><p>在 main 的第二行，我们想知道作为指针的 x 和 y 是否有相同的值。</p><blockquote><p>On the second line of main we want to know whether x and y as pointers have the same value.</p></blockquote><p>数组类型 <code>[S; 2]</code> 本身就是一个零大小的类型。你可以通过打印 <code>std::mem::size_of::&lt;[S; 2]&gt;()</code> 的值来确认这点。事实上，数组的第一个和第二个元素有相同的内存地址。</p><blockquote><p>The array type <code>[S; 2]</code> is itself a zero sized type. You can confirm this by printing the value of <code>std::mem::size_of::&lt;[S; 2]&gt;()</code>. Indeed the first and second element of the array have the same memory address.</p></blockquote><p>通常情况下，对同一内存位置有多个可变引用是不安全的，但是在对零大小类型的可变引用的情况下，解引用是不可行的，所以这种方式没有违反任何内存安全保证。</p><blockquote><p>Ordinarily having multiple mutable references to the same memory location would not be safe, but in the case of mutable references to zero sized types, dereferencing is a no-op so there is no way to violate any memory safety guarantees this way.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="14-trait-scope">#14 <code>trait scope</code><a class="hash-link" href="#14-trait-scope" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-13">题目<a class="hash-link" href="#题目-13" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait: Sized {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn is_reference(self) -&gt; bool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a, T&gt; Trait for &amp;&#x27;a T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn is_reference(self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match 0.is_reference() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        true =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        false =&gt; print!(&quot;0&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match &#x27;?&#x27;.is_reference() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        true =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        false =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            impl Trait for char {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                fn is_reference(self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            print!(&quot;0&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-13">提示<a class="hash-link" href="#提示-13" title="标题的直接链接">​</a></h3><p>在这个 <a href="https://stackoverflow.com/a/28552082/6086311" target="_blank" rel="noopener noreferrer">Stack Overflow</a> 的答案中涉及到 trait 方法的自动引用。</p><blockquote><p>Trait method auto-ref is covered in this Stack Overflow answer.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-12">题解<a class="hash-link" href="#题解-12" title="标题的直接链接">​</a></h3><p>答案：10</p><p>程序中所有的 <code>Trait impls</code> 都是在作用域内的，所以在一个代码块内编写的对 char 的 Trait impl 没有任何意义。特别是，这个 impl 在整个程序中都是可见的，而不仅仅是在包含该 impl 的代码块中。</p><blockquote><p>Trait impls anywhere in a program are always in scope, so there is no significance to the impl Trait for char being written inside of a block of code. In particular, that impl is visible throughout the whole program, not just within the block containing the impl.</p></blockquote><p>这个问题与 trait 方法自动引用的行为有关，这个问题在 <a href="https://stackoverflow.com/a/28552082/6086311" target="_blank" rel="noopener noreferrer">Stack Overflow</a> 的答案中有所涉及。</p><blockquote><p>This question relates to the behavior of trait method auto-ref which is covered in this Stack Overflow answer.</p></blockquote><p>对 <code>0.is_reference()</code> 的调用观察到没有一个我们可以直接调用的为整数类型的 Trait 的实现。所以方法解析自动插入了一个引用，即 <code>(&amp;0).is_reference()</code>。这一次的调用与 <code>&amp;&#x27;a, T&gt; Trait</code> 的 <code>impl&lt;&#x27;a, T&gt;</code> 匹配，并打印出 1。</p><blockquote><p>The call to <code>0.is_reference()</code> observes that there is no implementation of Trait for an integer type that we could call directly. Method resolution inserts an auto-ref, effectively evaluating <code>(&amp;0).is_reference()</code>. This time the call matches impl&lt;&#x27;a, T&gt; Trait for &amp;&#x27;a T and prints 1.</p></blockquote><p>对 <code>&#x27;?&#x27;.is_reference()</code> 的调用反而找到了 <code>char</code> 的 <code>implated Trait</code>，打印出 0。</p><blockquote><p>The call to <code>&#x27;?&#x27;.is_reference()</code> instead finds impl Trait for char, printing 0.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="15-type-inference">#15 <code>type inference</code><a class="hash-link" href="#15-type-inference" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-14">题目<a class="hash-link" href="#题目-14" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for u32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;a&gt; Trait for &amp;&#x27;a i32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = &amp;0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-14">提示<a class="hash-link" href="#提示-14" title="标题的直接链接">​</a></h3><p>类型推断会推断出 x 是什么类型？</p><blockquote><p>What type would type inference infer for x?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-13">题解<a class="hash-link" href="#题解-13" title="标题的直接链接">​</a></h3><p>答案：1</p><p>在类型推断过程中，变量 x 的类型是 <code>&amp;{integer}</code>，是对某个尚未确定的整数类型的引用。</p><blockquote><p>During type inference the variable x has type &amp;{integer}, a reference to some as yet undetermined integer type.</p></blockquote><p>如果我们想解决 trait 方法的调用 <code>Trait::f(x)</code>，我们发现它的参数 x 必须是 <code>&amp;Self</code> 类型，即实现了 Trait 的某个 Self 类型。我们发现推断 <code>0: u32</code> 既满足了 u32 是一个整数的约束，也满足了 u32 实现了 Trait，所以这个方法调用最终调用了 <code>&lt;u32 as Trait&gt;::f(x)</code> 并打印出 1。</p><blockquote><p>If we want to resolve the trait method call <code>Trait::f(x)</code>, we find that its argument x must be of type <code>&amp;Self</code> for some type Self that implements Trait. We find that inferring 0: u32 satisfies both the constraint that u32 is an integer as well as u32 implements Trait, so the method call ends up calling <code>&lt;u32 as Trait&gt;::f(x)</code> and prints 1.</p></blockquote><p>在这个 <a href="https://stackoverflow.com/a/28552082/6086311" target="_blank" rel="noopener noreferrer">Stack Overflow</a> 的答案中详细介绍了 Trait 方法的解析。</p><blockquote><p>Trait method resolution is covered in more detail in this <a href="https://stackoverflow.com/a/28552082/6086311" target="_blank" rel="noopener noreferrer">Stack Overflow</a> answer.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="16---i">#16 <code>--i</code><a class="hash-link" href="#16---i" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-15">题目<a class="hash-link" href="#题目-15" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut x = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    --x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}{}&quot;, --x, --x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-15">提示<a class="hash-link" href="#提示-15" title="标题的直接链接">​</a></h3><p>Rust 所支持的运算符集在 <code>std::ops</code> 中有相关文档。</p><blockquote><p>The set of operators supported by Rust is documented in <code>std::ops</code>.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-14">题解<a class="hash-link" href="#题解-14" title="标题的直接链接">​</a></h3><p>答案：44</p><p>与 C 或 Java 不同，Rust 中没有自增自减运算符。Rust 语言设计的 FAQ（网上已经没有了）曾经涉及过原因。</p><blockquote><p>Unlike C or Java, there is no unary increment or decrement operator in Rust. The Rust language design FAQ (no longer available online) used to touch on the reason:</p></blockquote><p>为什么 Rust 没有自增和自减运算符？</p><blockquote><p>Why doesn&#x27;t Rust have increment and decrement operators?</p></blockquote><p>Preincrement 和 Postincrement（以及与之对应的 Decrement），虽然方便，但也相当复杂。它们需要对计算顺序足够了解，并经常导致 C 和 C++ 中一些微妙的错误和未定义的行为。</p><blockquote><p>Preincrement and postincrement (and the decrement equivalents), while convenient, are also fairly complex. They require knowledge of evaluation order, and often lead to subtle bugs and undefined behavior in C and C++. x = x + 1 or x += 1 is only slightly longer, but unambiguous.</p></blockquote><p>在没有自减运算符的情况下，<code>--x</code> 被解析为 <code>-(-x)</code>。在 <code>x = 4</code> 的情况下，这将是 <code>-(-4)</code>，也就是 4。该程序等同于：</p><blockquote><p>In the absense of a decrement operator, --x is parsed as -(-x). In the case of x = 4 this would be -(-4) which is 4. The program is equivalent to:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut x = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}{}&quot;, 4, 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="17--------">#17 <code>-- - --</code><a class="hash-link" href="#17--------" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-16">题目<a class="hash-link" href="#题目-16" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut a = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut b = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, a-- - --b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-16">提示<a class="hash-link" href="#提示-16" title="标题的直接链接">​</a></h3><p>Rust 支持的操作符都在 <code>std：：ops</code>。</p><blockquote><p>The set of operators supported by Rust is documented in <code>std::ops</code>.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-15">题解<a class="hash-link" href="#题解-15" title="标题的直接链接">​</a></h3><p>答案：2</p><p>不像 C 或者 Java，Rust 没有自增和自减运算符。Rust 语言设计的 FAQ（网上已经没有了）曾经探讨过这个原因。</p><blockquote><p>Unlike C or Java, there is no unary increment or decrement operator in Rust. The Rust language design FAQ (no longer available online) used to touch on the reason:</p></blockquote><p>为什么 Rust 没有自增和自减运算符？</p><p>Preincrement (<code>++i</code>) 和 Postincrement (<code>--i</code>)（以及与之对应的 Decrement），虽然方便，但也相当复杂。用户需要知道求值顺序，这经常导致一些 C 和 C++ 中微妙的错误和未定义的行为。</p><blockquote><p>Why doesn&#x27;t Rust have increment and decrement operators?
Preincrement and postincrement (and the decrement equivalents), while convenient, are also fairly complex. They require knowledge of evaluation order, and often lead to subtle bugs and undefined behavior in C and C++. x = x + 1 or x += 1 is only slightly longer, but unambiguous.</p></blockquote><p>在没有自减运算符 (包括 <code>i--</code> 和 <code>--i</code>) 的情况下，<code>a-- --b</code> 会被解析为 <code>a-(-(-(-b))))</code>。在 <code>a=5</code> 和 <code>b=3</code> 的情况下，这个表达式的值是 <code>5-3</code>，也就是 <code>2</code>。</p><blockquote><p>In the absense of postfix and prefix decrement operators, a-- - --b is parsed as a - (-(-(-(-b)))). In the case of a = 5 and b = 3 the value of this expression is 5 - 3 which is 2.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="18-f-and-f">#18 <code>f() and f()</code><a class="hash-link" href="#18-f-and-f" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-17">题目<a class="hash-link" href="#题目-17" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f: fn(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let print2 = || print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S { f: print2 }.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-17">提示<a class="hash-link" href="#提示-17" title="标题的直接链接">​</a></h3><p>调用 <code>.f()</code> 可以解析为字段 f 或固有的方法 f，你如何写出对另一个的调用？</p><blockquote><p>The call .f() resolves to either the field f or the inherent method f. How would you write a call to the other one?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-16">题解<a class="hash-link" href="#题解-16" title="标题的直接链接">​</a></h3><p>答案：1</p><p>一个看起来像 <code>.f()</code>的调用总会解析到一个方法，在这里是固有的方法 <code>S::f</code>。如果作用域内没有方法 f，那么即使字段 f 存在并包含一个函数指针，这样的调用也不能编译。</p><blockquote><p>A call that looks like .f() always resolves to a method, in this case the inherent method <code>S::f</code>. If there were no method f in scope, a call like this would fail to compile even if a field f exists and contains a function pointer.</p></blockquote><p>为了调用存储在字段 f 中的函数指针，我们需要在字段周围写上圆括号。</p><blockquote><p>To call the function pointer stored in field f, we would need to write parentheses around the field access:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let print2 = || print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (S { f: print2 }.f)();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="19-move-or-drop">#19 <code>move or drop</code><a class="hash-link" href="#19-move-or-drop" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-18">题目<a class="hash-link" href="#题目-18" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let s = S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _ = s;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-18">提示<a class="hash-link" href="#提示-18" title="标题的直接链接">​</a></h3><p>s 所有权移动了吗？</p><blockquote><p>Does s get moved?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-17">题解<a class="hash-link" href="#题解-17" title="标题的直接链接">​</a></h3><p>答案：21</p><p>相关的一行是 <code>let _ = s</code>。如果这一行没有移动 s，那么 s 将继续存在，直到大括号结尾，程序将打印 21。但是如果这一行移动了 s，而没有绑定它，那么被移动的 S 类型的值将被立即 drop，程序将打印 12。</p><blockquote><p>The relevant line is let _ = s. If this line does not move s then s will continue to live until the close curly brace and the program would print 21. But if this line does move s, without binding it, then the moved value of type S would be dropped immediately and the program would print 12.</p></blockquote><p>事实上，s 并没有被移动，输出结果是 21。</p><blockquote><p>In fact s does not get moved and the output is 21.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="20-return-and-return">#20 <code>return and return</code><a class="hash-link" href="#20-return-and-return" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-19">题目<a class="hash-link" href="#题目-19" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn return1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (return { print!(&quot;1&quot;) }) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn return2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if return { print!(&quot;2&quot;) } {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn break1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (break { print!(&quot;1&quot;) }) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn break2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if break { print!(&quot;2&quot;) } {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    break1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    break2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-19">提示<a class="hash-link" href="#提示-19" title="标题的直接链接">​</a></h3><p>Rust 中涉及 break 的语法与涉及 return 的语法不同。</p><blockquote><p>The Rust grammar involving break is different from the grammar involving return.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-18">题解<a class="hash-link" href="#题解-18" title="标题的直接链接">​</a></h3><p>答案：121</p><p>让我们以此研究这些函数。</p><blockquote><p>Let&#x27;s work through the functions one at a time.</p></blockquote><ul><li><p><code>fn return1</code></p><p>  if 语句的，条件。被解析为一个表达式，这个表达式会返回 <code>{ print!(&quot;1&quot;) }</code> 即 ().这个值需要在返回前被计算，所以最终打印 1.</p><blockquote><p>The condition of the if-statement is parsed as a return-expression that returns the value { print!(&quot;1&quot;) } of type (). The value needs to be evaluated prior to being returned so this function prints 1.</p></blockquote></li><li><p><code>fn return2</code></p><p> 这个函数和 <code>return1</code> 一样。<code>return</code> 关键字会立即消耗掉返回值，即使返回值被大括号包裹．甚至是在 if 语句的条件中，大括号 (例如结构体) 通常也不会被接受。</p><blockquote><p>This function is parsed the same as return1. The return keyword eagerly consumes a trailing return value, even if the return value begins with a curly brace, and even in the condition of an if-statement where curly braces such as in a struct literal would ordinarly not be accepted. This function prints 2.</p></blockquote></li><li><p><code>fn break1</code></p><p>  if 语句的条件是是个 break-with-value 表达式，它会结束整个循环，并返回 <code>{ print!(&quot;1&quot;) }</code>, 即 ()，和 <code>return1</code> 类似，为了在打破循环时返回值，这个值需要被计算，所以最终打印 1；</p><blockquote><p>The condition of the if-statement is a break-with-value expression that breaks out of the enclosing loop with the value { print!(&quot;1&quot;) } of type (). Similar to return1, in order to break with this value the value needs to be evaluated and this function prints 1.</p></blockquote></li><li><p><code>fn break2</code></p><p>  这里我们可以看到 break 和 return 语法的区别。不像 return，if 条件里的 break 关键字不会立即解析出后面大括号的值。这段代码会被解析为：</p><blockquote><p>Here we observe a difference between the grammar of break and the grammar of return. Unlike return, the break keyword in the condition of this if-statement does not eagerly parse a value that begins with a curly brace. This code is parsed as:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">loop {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if break {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  我们在执行 print 前打破了循环，所以这个函数不会执行 print.</p><blockquote><p>We break out of the loop before executing the print, so this function does not print anything.</p></blockquote><p>  我相信 return 和 break 不同的原因是，return 在 Rust 1.0 以及之前显然都是支持的，但是 break-with-value 是在 Rust 1.19 才被引入之后。<code>break2</code> 中的代码一直都是合法的 Rust 代码，所以在实现 break-with-value 这个语言特性时也考虑到不能改变它的行为。</p><blockquote><p>I believe the reason for the difference between return and break is that returning a value was obviously supported at Rust 1.0 and well before, but break-with-value was introduced fairly late, in Rust 1.19. The code in break2 was perfectly legal Rust code prior to Rust 1.19 so we cannot change its behavior when implementing the break-with-value language feature.</p></blockquote><p>  未来的版本有可能对这两种语法进行调整，使之相互一致。</p><blockquote><p>It is possible that a future Edition would adjust the two grammars to align with each other.</p></blockquote></li></ul><p>main 的输出为 121。</p><blockquote><p>The output from main is 121.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-return--break">#21 <code>return &amp; break</code><a class="hash-link" href="#21-return--break" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-20">题目<a class="hash-link" href="#题目-20" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;F: FnOnce() -&gt; bool&gt; Trait for F {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = || { (return) || true; };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x().f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = loop { (break) || true; };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = || { return (|| true); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x().f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = loop { break (|| true); };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = || { return || true; };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x().f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x = loop { break || true; };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-20">提示<a class="hash-link" href="#提示-20" title="标题的直接链接">​</a></h3><p>在本题中，break 和 return 关键字的语法是一样的。</p><blockquote><p>The break and return keywords have the same grammar in this question.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-19">题解<a class="hash-link" href="#题解-19" title="标题的直接链接">​</a></h3><p>答案：221111</p><p>我们想知道 <code>return || true;</code> 和 <code>break || true;</code> 的每一个可能的括号是否评估为闭包 <code>|| true</code> 或单位值 ()。</p><blockquote><p>We want to know whether each possible parenthesization of return || true; and break || true; evaluates to the closure || true or to the unit value ().</p></blockquote><ul><li><p><code>let x = || { (return) || true; };</code></p><p>  在这一行，x 是一个返回 () 的闭包。等价于 <code>let x = || {}</code>.当我们调用 <code>x().f()</code> 时，方法 f 会被解析为 <code>impl Trait for ()</code>, 并打印 2.</p><blockquote><p>On this line, x is a closure that returns (). It is equivalent to let x = || {}. When we call x().f(), the method f resolves to impl Trait for () which prints 2.</p></blockquote><p>  表达式 <code>(treturn)</code> 的类型是原始的 never 类型，通常写成 <code>！</code>。计算 <code>! || true</code> 是合法的，因为 <code>!</code> 可以转为任何类型，在这里是 <code>bool</code>。表达式 <code>! || true</code> 是一个逻辑或，左侧和右侧都是 <code>bool</code>。</p><blockquote><p>The type of the expression (return) is the primitive never type, usually written as !. It is legal to compute ! || true because ! can fill in for any type, in this case bool. The expression ! || true is a logical-OR with bool on both the left-hand side and right-hand side.</p></blockquote><p>  <code>!</code> 可以转为任何类型的行为允许我们写出如下代码：</p><blockquote><p>The behavior of ! of filling in for any type is what allows us to write:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn f() -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unimplemented!()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  其中 <code>unimplemented!()</code> 的类型，因为它在没有求值的情况下直接 panic，它的返回值类型也是 <code>！</code>。</p><blockquote><p>in which the type of unimplemented!(), since it panics without evaluating to any value, is also !.</p></blockquote></li><li><p><code>let x = loop { (break) || true; };</code></p><p>  和 <code>(return)</code> 类似，<code>(break)</code> 的类型也是 <code>!</code>. 这行代码会打破循环，并返回 <code>()</code>, 所以 <code>x</code> 的类型是 <code>()</code>.调用 <code>x.f()</code> 会打印 2.</p><blockquote><p>Similar to (return), the type of (break) is the never type !. This code breaks out of the loop with the implicit value (), so x is of type (). Calling x.f() will print 2.</p></blockquote></li><li><p><code>let x = || { return (|| true); };</code></p><p>  在这一行，<code>x</code> 是一个闭包，它返回一个返回 true 的闭包。你可以写 <code>x()()</code>，它的值会是 true。</p><blockquote><p>On this line x is a closure that returns a closure that returns true. You could write x()() and that would be true.</p></blockquote><p>  Quiz 代码调用了 <code>x().f()</code>, 这会解析为 <code>impl&lt;F&gt; Trait for F where F: FnOnce() -&gt; bool</code>. 最终打印 1.</p><blockquote><p>The quiz code calls <code>x().f()</code> which resolves to <code>impl&lt;F&gt; Trait for F where F: FnOnce() -&gt; bool</code>. That trait impl prints 1.</p></blockquote></li><li><p><code>let x = loop { break (|| true); };</code></p><p>  这是一个包含 <code>break-with-value</code> 表达式的循环。<code>break</code> 的参数变成了循环的返回值。这段代码等同于 <code>let x = || true</code>。</p><blockquote><p>This is a loop containing a break-with-value expression. The argument of the break becomes the value of the enclosing loop. This code is equivalent to let <code>x = || true</code>.</p></blockquote><p>  当我们调用 <code>x.f()</code> 时，它使用了 FnOnce 的 Trait 实现，打印出 1。</p><blockquote><p>When we call <code>x.f()</code> it uses the FnOnce impl of Trait which prints 1.</p></blockquote></li><li><p><code>let x = || { return || true; };</code></p><p>  现在我们来到了这个问答问题的核心。<code>return || true</code> 的解析与 <code>(return) || true</code> 相同，还是与 <code>return (|| true)</code> 相同？</p><blockquote><p>Now we arrive at the meat of this quiz question. Is <code>return || true</code> parsed the same as <code>(return) || true</code> or as <code>return (|| true)</code>?</p></blockquote><p>  结果是后者，所以 x 是一个返回 true 的闭包。<code>x().f()</code> 打印 1。</p><blockquote><p>It turns out to be the latter, so x is a closure that returns a closure that returns true. <code>x().f()</code> prints 1.</p></blockquote></li><li><p><code>let x = loop { break || true; };</code></p><p>  这个也是类似的问题，这是 <code>(break) || true</code> 还是 <code>break (|| true)</code>？</p><blockquote><p>Similar question here, is this <code>(break) || true</code> or <code>break (|| true)</code>?</p></blockquote><p>  <code>break-with-value</code> 语言功能是在 1.0 之后的两年后 (Rust 1.19) 加入的。在 break-with-value 之前，<code>break || true</code> 是完全合法的 Rust 代码，解析为 <code>(break) || true</code>。</p><blockquote><p>The break-with-value language feature was added to Rust more than two years after 1.0, in Rust 1.19. Prior to break-with-value, <code>break || true</code> was perfectly legal Rust code that parsed as <code>(break) || true</code>.</p></blockquote><p>  在 Rust 1.19 中，这段代码的行为被语言无意中打破了，现在它被解析为 <code>break (|| true)</code>，打印出来的值是 1。</p><blockquote><p>In Rust 1.19 the behavior of this code was unintentionally broken by the language such that now it parses as <code>break (|| true)</code> and the printed value is 1.</p></blockquote><p>  如果我们在 Rust 1.19 的开发过程中注意到这种意义上的变化，我们可能会调整解析以保留现有代码的意义。不幸的是，这样做会导致语法在 return 和 break 之间有不同的表现，除了历史的意外，没有任何合理的理由。</p><blockquote><p>If we had noticed this change in meaning during the development of Rust 1.19, we may have adjusted the parsing to preserve the meaning of existing code. Unfortunately doing so would result in a grammar that behaves differently between return and break for no justifiable reason other than an accident of history.</p></blockquote><p>  或者，我们也有可能认为这是一个永远不会出现在真实代码中的语法边缘案例，用 Crater 来验证这一假设，并有意打破这一行为。</p><blockquote><p>Or it is possible we would have ruled this an edge case of syntax that would never appear in real code, used Crater to validate that hypothesis, and broken the behavior intentionally.</p></blockquote></li></ul><p>main 的完整输出是 221111.</p><blockquote><p>The total output from main is 221111.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="22---is-a-token">#22 <code>- is a token</code><a class="hash-link" href="#22---is-a-token" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-21">题目<a class="hash-link" href="#题目-21" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt) =&gt; { print!(&quot;1&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt) =&gt; { print!(&quot;2&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt $c:tt) =&gt; { print!(&quot;3&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt $c:tt $d:tt) =&gt; { print!(&quot;4&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt $c:tt $d:tt $e:tt) =&gt; { print!(&quot;5&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt) =&gt; { print!(&quot;6&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt $g:tt) =&gt; { print!(&quot;7&quot;) };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(-1.);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(-1.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(-1.0e1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!(-1.0e-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-21">提示<a class="hash-link" href="#提示-21" title="标题的直接链接">​</a></h3><p>macro 会计算输入的 &quot;token&quot; 的数量。</p><blockquote><p>The macro is counting how many &quot;tokens&quot; are in its input.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-20">题解<a class="hash-link" href="#题解-20" title="标题的直接链接">​</a></h3><p>答案：22222</p><p>所有的 m！调用都传递了两个标记作为输入：一个减号，然后是一个整数或浮点字样的标记。</p><blockquote><p>All five invocations of m! pass two tokens as input: a minus sign followed by an integer or floating point literal token.</p></blockquote><p>浮点字面符号 <code>1.</code>、<code>1.0</code>、<code>1.0e1</code>、<code>1.0e-1</code> 都是单一的原子符号。</p><blockquote><p>The floating point literals 1., 1.0, 1.0e1, 1.0e-1 are each a single atomic token.</p></blockquote><p>Rust 编译器内置的解析器总是将负号作为一个单独的标记，与数字进行区分。然而，在过程宏中，用户定义的解析器可以通过向 <code>proc_macro::Literal</code> 的构造器之一传递一个负的整数或负的浮点数来构造一个负数作为单个标记。如果这样的负数最终出现在随后的过程宏调用的输入中，则由编译器决定是重写成一对标记还是将其作为一个标记。</p><blockquote><p>The parser built into the Rust compiler always parses a negative sign as a separate token from the numeric literal that is being negating. However, it is possible for a user-defined parser within a procedural macro to construct a negative number as a single token by passing a negative integer or negative floating point value to one of the constructors of <code>proc_macro::Literal</code>. If such a negative literal ends up in the input of a subsequent procedural macro invocation, it is up to the compiler whether to rewrite into a pair of tokens or keep them as one.</p></blockquote><p>编译器的解析器的行为在语言表面也是可以观察到的，不仅仅是在宏中。例如，下面的代码打印出 -81，因为表达式被解析为 <code>-(3i32.pow(4))</code> 而不是 <code>(-3i32).pow(4)</code>。</p><blockquote><p>The behavior of the compiler&#x27;s parser is observable in the surface language as well, not only in macros. For example the following code prints -81 because the expression is parsed as -(3i32.pow(4)) rather than (-3i32).pow(4).</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let n = -3i32.pow(4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="23-method-lookup-order">#23 <code>method lookup order</code><a class="hash-link" href="#23-method-lookup-order" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-22">题目<a class="hash-link" href="#题目-22" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn g(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn g(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn g(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S.g();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-22">提示<a class="hash-link" href="#提示-22" title="标题的直接链接">​</a></h3><p>我不能帮助你解决这个问题。这是由语言本身做出的一个相当随意的选择。试试所有的可能吧！</p><blockquote><p>I can&#x27;t help you with this one. This is a pretty arbitrary choice made by the language. Try all the possibilities!</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-21">题解<a class="hash-link" href="#题解-21" title="标题的直接链接">​</a></h3><p>答案：12</p><p><code>S.f()</code> 会调用固有方法 f。如果一个固有方法和一个 Trait 方法同名，并且返回值相同，普通的方法调用总是会选择固有方法。调用这必须写 <code>Trait::f(&amp;s)</code> 或者 <code>&lt;S as Trait&gt;::f(&amp;s)</code> 去调用 Trait 方法。 </p><blockquote><p><code>S.f()</code> calls the inherent method f. If an inherent method and a trait method have the same name and receiver type, plain method call syntax will always prefer the inherent method. The caller would need to write <code>Trait::f(&amp;S)</code> or <code>&lt;S as Trait&gt;::f(&amp;S)</code> in order to call the trait method.</p></blockquote><p>对于宏的作者来说，意识到这一点很重要。宏生成的代码通常不应该使用普通的方法调用语法来调用用户定义的类型上的特征方法。这些调用可能会被与特质方法同名的固有方法无意中劫持。</p><blockquote><p>It is important for macro authors to be aware of this. Macro-generated code typically should not use method call syntax to invoke trait methods on types defined by the user. Those calls could get unintentially hijacked by inherent methods having the same name as the trait method.</p></blockquote><p>另一方面，<code>S.g()</code> 调用特质方法 <code>g</code>。在方法解析过程中，如果 <code>&amp;</code> 和 <code>＆mut</code> 都可以调用，自动引用总是倾向于将某样东西变成 <code>&amp;</code>，而不是将其变成 <code>&amp;mut</code>。</p><blockquote><p>On the other hand, S.g() calls the trait method g. Auto-ref during method resolution always prefers making something into &amp; over making it into &amp;mut where either one would work.</p></blockquote><p>请参阅 <a href="https://stackoverflow.com/a/28552082/6086311" target="_blank" rel="noopener noreferrer">Stack Overflow</a> 的答案，了解方法解析过程中自动引用的更详细解释。</p><blockquote><p>See this Stack Overflow answer for a more detailed explanation of auto-ref during method resolution.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="24-hygiene">#24 <code>Hygiene</code><a class="hash-link" href="#24-hygiene" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-23">题目<a class="hash-link" href="#题目-23" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let x: u8 = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const K: u8 = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            print!(&quot;{}{}&quot;, x, K);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let x: u8 = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const K: u8 = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m!();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-23">提示<a class="hash-link" href="#提示-23" title="标题的直接链接">​</a></h3><p>宏的卫生性只是用于局部变量。</p><blockquote><p>Hygiene in macro_rules! only applies to local variables.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-22">题解<a class="hash-link" href="#题解-22" title="标题的直接链接">​</a></h3><p>答案：14</p><p>这个程序打印出 14，因为宏的 &quot;卫生性&quot;(Hygiene) 只适用于局部变量。</p><blockquote><p>This program prints 14 because hygiene in macro_rules! only applies to local variables.</p></blockquote><p>你可以把 Hygiene 想象成：给每次提到的局部变量的名字分配一种颜色，允许在范围内有多个可区分的局部变量同时具有相同的名字。</p><blockquote><p>You can imagine hygiene as a way of assigning a color to each mention of the name of a local variable, allowing for there to be multiple distinguishable local variables in scope simultaneously with the same name.</p></blockquote><p>在 main 的顶端，假设我们认为局部变量 x 的名字是紫色的 x，常量 K 的名字只是普通的 K，因为常量被认为是项 (Item) 而不是局部变量（你可以把项放在函数体之外；但是不能把局部变量放在函数体之外）。</p><blockquote><p>At the top of main, suppose we consider the name of the local variable x to be a purple x. The name of the constant K is just plain K, as constants are considered items rather than local variables (you can place items outside of a function body; you cannot place local variables outside of a function body).</p></blockquote><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let   x: u8 = 1; // x 为紫色</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const K: u8 = 2; // K 为无色</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们继续往下看，在 macro m! 的声明中，有两个被用到的标识符。因为作用域内有一个变量 x，所以在 m! 内使用的标识符 x 的颜色与局部变量 x 相同。在作用域内没有局部变量 K，所以在宏的声明中的 K 被分配了一些新的颜色，例如橙色。</p><blockquote><p>Continuing down the body of main, within the declaration of the macro m! there are identifiers x and K being used. Since there is a local variable x in scope, the use of the identifier x within the macro body picks up the same color as the local variable x. There is no local variable K in scope so the K within the declaration of the macro is assigned some new color, say orange.</p></blockquote><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}{}&quot;, x, K); // x 为紫色，K 为橙色</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>接下来我们进入一个新的作用域（用大括号划定），包含另一个 x 和 K。每一个新的局部变量总是会引入一个新的颜色，所以我们把这个 x 叫做蓝色。const 依然不是一个局部变量，所以没有给 K 分配颜色。</p><blockquote><p>Next we enter a new scope (delimited by curly braces) containing another x and K. Every new local variable always introduces a new color so let&#x27;s call this x blue. The const again is not a local variable so no color is assigned to K.</p></blockquote><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let   x: u8 = 3; // x 为蓝色</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const K: u8 = 4; // K 为无色</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    m!();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当 <code>m!()</code> 展开时，展开的代码包含一个紫色的 x 和一个橙色的 K。紫色的 x 可以和蓝色的 x 区分开来，所以紫色的 x 的值被打印出来，是 1。至于 K，一个不卫生的（未着色的）K 被允许像任何颜色一样。第二个 K 会遮蔽第一个 K。当 m! 寻找一个橙色的 K 时，会识别到第二个 K，第二个 K 的值被打印出来，即 4。</p><blockquote><p>When m!() expands, the expanded code refers to a purple x and an orange K. The purple x is distinguishable from the blue x -- the value of the purple x is printed which is 1. As for the K, an unhygienic (uncolored) K is allowed to act like any color. The second K is shadowing the first one. It gets picked up when looking for an orange K and its value is printed, which is 4.</p></blockquote><p>所以输出是 14。</p><blockquote><p>So the output of the quiz code is 14.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="25-drop">#25 <code>drop</code><a class="hash-link" href="#25-drop" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-24">题目<a class="hash-link" href="#题目-24" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::fmt::{self, Display};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct S;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Display for S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        formatter.write_str(&quot;1&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn f() -&gt; S {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    S</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let S = f(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, S);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-24">提示<a class="hash-link" href="#提示-24" title="标题的直接链接">​</a></h3><p>弄清楚哪些值被哪些变量所拥有。当一个值不再有所有者时，它就被 drop 了。</p><blockquote><p>Figure out what values are owned by which variables where. A value is dropped when it no longer has an owner.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-23">题解<a class="hash-link" href="#题解-23" title="标题的直接链接">​</a></h3><p>答案：212</p><p>程序打印 212。</p><blockquote><p>This program prints 212.</p></blockquote><p>在函数 f 内，没有 S 会被 drop。f 函数内产生一个 S，然后把它的所有权返回给 f 的调用者；调用者会决定什么时候 drop 掉他拿到的 S。</p><blockquote><p>No value of type S gets dropped within the body of function f. The function f conjures an S and returns ownership of it to the caller of f; the caller determines when to drop the S of which it received ownership.</p></blockquote><p>在 main 的第一行，我们调用了 f(),但是并没有把它绑定到某一个变量上。所以 f() 返回的 S 会被立即 drop，打印了 2。<code>let S = f()</code> 中的 S 是一个单元结构体的模式匹配 (不是一个变量)，它能够通过解构匹配到 S 结构体里的字段，但是这里并没有将匹配到的字段绑定到某一变量。</p><blockquote><p>On the first line of main, we call f() and perform an infallible match that binds no new variables. As no variables are declared on this line, there is no variable that could be the owner of the S returned by f() so that S is dropped at that point, printing 2. The S in let S = f() is a unit struct pattern (not a variable name) that matches a value of type S via destructuring but does not bind the value to any variable.</p></blockquote><p>main 的第二行产生一个新的 S，并打印，最后在分号处 drop 它。</p><blockquote><p>The second line of main conjures a new S, prints it, and drops it at the semicolon.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="26-lazy-map">#26 <code>lazy map</code><a class="hash-link" href="#26-lazy-map" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-25">题目<a class="hash-link" href="#题目-25" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let input = vec![1, 2, 3];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let parity = input</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .iter()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map(|x| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            print!(&quot;{}&quot;, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            x % 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for p in parity {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-25">提示<a class="hash-link" href="#提示-25" title="标题的直接链接">​</a></h3><p>请查阅 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html" target="_blank" rel="noopener noreferrer">Iterator</a> Trait 的文档</p><blockquote><p>Refer to the documentation of the Iterator trait.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-24">题解<a class="hash-link" href="#题解-24" title="标题的直接链接">​</a></h3><p>答案：112031</p><p>正如 <code>Iterator::map</code> 方法的文档中所描述的，map 操作是惰性执行的。作为参数提供给 map 的闭包只有在值从结果迭代器中被消耗时才会被调用。闭包并不会立即应用于整个输入流。</p><blockquote><p>As described in the documentation of the Iterator::map method, the map operation is performed lazily. The closure provided as an argument to map is only invoked as values are consumed from the resulting iterator. The closure is not applied eagerly to the entire input stream up front.</p></blockquote><p>在这段代码中，for 循环是驱动迭代的因素。对于从奇偶性迭代器中消耗的每个元素，我们的闭包都需要被执行一次。因此，输出将在由闭包打印的数字和由循环体打印的数字之间交替进行。</p><blockquote><p>In this code, the for loop is what drives the iteration. For each element consumed from the parity iterator, our closure needs to be evaluated one time. Thus the output will alternate between numbers printed by the closure and numbers printed by the loop body.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="27-dyn-trait">#27 <code>dyn Trait</code><a class="hash-link" href="#27-dyn-trait" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-26">题目<a class="hash-link" href="#题目-26" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Base {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Derived: Base {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct BothTraits;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Base for BothTraits {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Derived for BothTraits {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn dynamic_dispatch(x: &amp;dyn Base) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.method();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn static_dispatch&lt;T: Base&gt;(x: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.method();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dynamic_dispatch(&amp;BothTraits);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static_dispatch(BothTraits);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-26">提示<a class="hash-link" href="#提示-26" title="标题的直接链接">​</a></h3><p><code>Base::method</code> 和 <code>Derived::method</code> 碰巧有相同的名字，但是是毫不相关的两个方法。不会互相覆盖。</p><blockquote><p>Base::method and <code>Derived::method</code> happen to have the same name but are otherwise unrelated methods. One does not override the other.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-25">题解<a class="hash-link" href="#题解-25" title="标题的直接链接">​</a></h3><p>答案：11</p><p>这两个 Trait，<code>Base</code> 和 <code>Derived</code> 各自定义了一个名为 method 的 Trait 方法。这两个方法只是碰巧拥有相同的名称，但在其他方面并不相关，如下文所解释。</p><blockquote><p>The two traits Base and Derived each define a trait method called method. These methods happen to have the same name but are otherwise unrelated methods as explained below.</p></blockquote><p>两个 Trait 都为 method 提供了一个默认的实现。如果某个具体实现没有定义方法，那么默认的实现在概念上会被复制到具体的实现中。</p><p>默认实现在概念上被复制到每个没有明确定义相同方法的 trait impl 中。例如，在这种情况下，BothTraits 的 impl Base 没有提供自己的 Base::method 的实现，这意味着 BothTraits 的 Base 的实现将使用该 trait 定义的默认行为，即 print!</p><blockquote><p>Both traits provide a default implementation of their trait method. Default implementations are conceptually copied into each trait impl that does not explicitly define the same method. In this case for example impl Base for BothTraits does not provide its own implementation of <code>Base::method</code>, which means the implementation of Base for BothTraits will use the default behavior defined by the trait i.e. print!(&quot;1&quot;).</p></blockquote><p>此外，Derived 将 Base 作为一个 supertrait，这意味着每个实现 Derived 的类型也都需要实现 Base。这两个 trait 方法尽管名字相同，但却没有关系 -- 因此任何实现 Derived 的类型都会有 Derived::method 和 Base::method 的实现，而且这两个方法可以自由地有不同的行为。Supertraits 不是继承！Supertraits 是一种特征约束，如果要实现 Derived，那么 Base 也必须被实现。</p><blockquote><p>Additionally, Derived has Base as a supertrait which means that every type that implements Derived is also required to implement Base. The two trait methods are unrelated despite having the same name -- thus any type that implements Derived will have an implementation of Derived::method as well as an implementation of <code>Base::method</code> and the two are free to have different behavior. Supertraits are not inheritance! Supertraits are a constraint that if some trait is implemented, some other trait must also be implemented.</p></blockquote><p>让我们看一下从 main 调用的两个方法的具体过程。</p><blockquote><p>Let&#x27;s consider what happens in each of the two methods called from main.</p></blockquote><ul><li><p><code>dynamic_dispatch(&amp;BothTraits)</code></p><p>  参数 x 是一个对特征对象 <code>dyn Base</code> 的引用。特征对象是由编译器生成的一个 &quot;小垫片&quot;，它具有和 Trait 相同的名称 (如下所示)，可以通过将所有特质方法的调用，转发到原始类型的特质方法。转发是通过读取特征对象里包含的函数指针表来完成的。</p><blockquote><p>The argument x is a reference to the trait object type dyn Base. A trait object is a little shim generated by the compiler that implements the trait with the same name by forwarding all trait method calls to trait methods of whatever type the trait object was created from. The forwarding is done by reading from a table of function pointers contained within the trait object.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Generated by the compiler.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// This is an implementation of the trait `Base` for the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// trait object type `dyn Base`, which you can think of as</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// a struct containing function pointers.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Base for (dyn Base) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Some automatically generated implementation detail</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        that ends up calling the right type&#x27;s impl of the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        trait method Base::method.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  在 quiz 代码里，<code>x.method()</code> 实际上是调用由编译器自动生成的方法，它的名字是 <code>&lt;dyn Base as Base&gt;::method</code>。由于 x 是通过将 <code>BothTraits</code> 转换为 <code>dyn Base</code> 得到的，自动生成的实现将转发到 <code>&lt;BothTraits as Base&gt;::method</code>，最后打印出 1。</p><blockquote><p>In the quiz code, <code>x.method()</code> is a call to this automatically generated method whose fully qualified name is <code>&lt;dyn Base as Base&gt;::method</code>. Since x was obtained by converting a BothTraits to dyn Base, the automatically generated implementation detail will wind up forwarding to <code>&lt;BothTraits as Base&gt;::method</code> which prints 1.</p></blockquote><p>  希望从这一切可以看出，这里没有任何东西与 <code>BothTraits</code> 定义的 <code>Derived::method</code> 有关。特别要注意的是，<code>x.method()</code> 不可能是对 <code>Derived::method</code> 的调用，因为 x 是 <code>dyn Base</code> 类型，而 <code>dyn Base</code> 并没有 <code>Derived</code> 的实现。</p><blockquote><p>Hopefully it&#x27;s clear from all of this that nothing here has anything to do with the unrelated trait method Derived::method defined by BothTraits. Especially notice that <code>x.method()</code> cannot be a call to Derived::method because x is of type dyn Base and there is no implementation of Derived for dyn Base.</p></blockquote></li><li><p>static_dispatch(BothTraits)</p><p>  在编译时我们知道 <code>x.method()</code> 是对 <code>&lt;T as Base&gt;::method</code> 的调用。Rust 中对泛型函数的类型推断是独立于泛型函数的任何具体实例而发生的，也就是说，在我们知道 T 可能是什么之前，只知道它实现了 Base 这一事实。因此，具体类型 T 上的任何固有方法或任何其他特征方法都不可能影响 <code>x.method()</code> 的调用。在决定 T 的时候，已经确定 <code>x.method()</code> 会调用 <code>&lt;T as Base&gt;::method</code>。</p><blockquote><p>At compile time we know that <code>x.method()</code> is a call to <code>&lt;T as Base&gt;::method</code>. Type inference within generic functions in Rust happens independently of any concrete instantiation of the generic function i.e. before we know what T may be, other than the fact that it implements Base. Thus no inherent method on the concrete type T or any other trait method may affect what method <code>x.method()</code> is calling. By the time that T is decided, it has already been determined that <code>x.method()</code> is calling <code>&lt;T as Base&gt;::method</code>.</p></blockquote><p>  泛型函数在实例化时，T 等于 BothTraits，所以这将会调用 <code>&lt;BothTraits as Base&gt;::method</code>，打印出 1。</p><blockquote><p>The generic function is instantiated with T equal to BothTraits so this is going to call <code>&lt;BothTraits as Base&gt;::method</code> which prints 1.</p></blockquote></li></ul><blockquote><p>If you are familiar with C++, the behavior of this code in Rust is different from the behavior of superficially analogous C++ code. In C++ the output would be 22 as seen in the following implementation. This highlights the difference between Rust&#x27;s traits and supertraits vs C++&#x27;s inheritance.</p></blockquote><p>如果你熟悉 C++，这段代码在 Rust 中的行为与表面上类似的 C++代码的行为是不同的。在 <code>C++</code> 中，输出将是 22，正如在下面的实现中看到的那样。这突出了 Rust 的 traits 和 supertraits 与 C++ 的继承之间的区别。</p><div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">include</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property string" style="color:#e3116c">&lt;iostream&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">Base</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">virtual</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">method</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        std</span><span class="token double-colon punctuation" style="color:#393A34">::</span><span class="token plain">cout </span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;1&quot;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">Derived</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token base-clause class-name">Base</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">method</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        std</span><span class="token double-colon punctuation" style="color:#393A34">::</span><span class="token plain">cout </span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;2&quot;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">dynamic_dispatch</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> Base </span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">x</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">method</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">template</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token keyword" style="color:#00009f">typename</span><span class="token plain"> </span><span class="token class-name">T</span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">static_dispatch</span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> T x</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x</span><span class="token punctuation" style="color:#393A34">.</span><span class="token function" style="color:#d73a49">method</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">main</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">dynamic_dispatch</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">Derived</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">static_dispatch</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">Derived</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="28-_guard--_">#28 <code>_guard &amp; _</code><a class="hash-link" href="#28-_guard--_" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-27">题目<a class="hash-link" href="#题目-27" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct Guard;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for Guard {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _guard = Guard;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;3&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _ = Guard;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-27">提示<a class="hash-link" href="#提示-27" title="标题的直接链接">​</a></h3><p>当一个值不再有所有者时，它就被 drop 了。</p><blockquote><p>A value is dropped when it no longer has an owner.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-26">题解<a class="hash-link" href="#题解-26" title="标题的直接链接">​</a></h3><p>答案：3121</p><p>该程序打印出 3121。也就是说，<code>let _guard = Guard</code> 的 <code>Drop</code> 在 main 的末尾运行，但是 <code>let _ = Guard</code> 的 <code>Drop</code> 却立即运行。</p><blockquote><p>The program prints 3121. That is, the Drop impl for let <em>guard = Guard runs at the end of main but the Drop impl for let </em> = Guard runs right away.</p></blockquote><p>一般来说，当一个值不再有所有者时，它就会被放弃。变量 <code>_guard</code> 拥有 Guard 类型的第一个值，并且在 main 结束前一直处于作用域中。<code>_</code> 不是一个变量，而是一个通配符模式，它没有绑定任何东西；因为这一行没有绑定任何变量，所以没有变量成为 Guard 类型的第二个值的所有者，该值在同一行被丢弃。</p><blockquote><p>In general, a value is dropped when it no longer has an owner. The variable <em>guard owns the first value of type Guard and remains in scope until the end of main. The </em> is not a variable but a wildcard pattern that binds nothing; since no variables are bound on this line, there is no variable to be the owner of the second value of type Guard and that value is dropped on the same line.</p></blockquote><p>下划线模式与带下划线的变量之间的区别在某些情况下很重要，特别是当在 unsafe 代码中使用锁时，</p><blockquote><p>This distinction between the underscore pattern vs variables with a leading underscore is incredibly important to remember when working with lock guards in unsafe code.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::sync::Mutex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static MUTEX: Mutex&lt;()&gt; = Mutex::new(());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/// MUTEX must be held when accessing this value.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static mut VALUE: usize = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let _guard = MUTEX.lock().unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        VALUE += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果这段代码使用 <code>let _ = MUTEX.lock().unwrap()</code>，则会立即释放互斥锁，无法对 <code>VALUE</code> 的访问进行限制。</p><blockquote><p>If this code were to use <code>let _ = MUTEX.lock().unwrap()</code> then the mutex guard would be dropped immediately, releasing the mutex and failing to guard the access of VALUE.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="29-t--t">#29 <code>(T) &amp; (T,)</code><a class="hash-link" href="#29-t--t" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-28">题目<a class="hash-link" href="#题目-28" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(&amp;self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for (u32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(&amp;self) { print!(&quot;1&quot;); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for (i32,) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(&amp;self) { print!(&quot;2&quot;); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for (u32, u32) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(&amp;self) { print!(&quot;3&quot;); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for (i32, i32,) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn p(&amp;self) { print!(&quot;4&quot;); }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0).p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0,).p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0, 0).p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (0, 0,).p();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-28">提示<a class="hash-link" href="#提示-28" title="标题的直接链接">​</a></h3><p>括号内的值与只有一个元素的元组的类型不一样。</p><blockquote><p>A value in parentheses does not have the same type as a 1-tuple.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-27">题解<a class="hash-link" href="#题解-27" title="标题的直接链接">​</a></h3><p>答案：1244</p><p>在单元素元组的情况下，尾部的逗号是必须的，因为它可以将其与与 <code>(0)</code> 区分开来 (<code>(0)</code> 和 <code>0</code> 相同)。然而，对于更大的元组，它是完全可选的：<code>(i32)</code> 与 <code>(i32,)</code> 是不同的类型，但是 <code>(i32, i32)</code> 和 <code>(i32, i32, )</code> 是相同的。</p><blockquote><p>The trailing comma is required in the case of a 1-tuple, (0,), because it disambiguates it from (0) which is identical to 0. However, for larger tuples, it is entirely optional: (i32) is a distinct type from (i32,), but (i32, i32) and (i32, i32,) are the same.</p></blockquote><p>一个整形 0 可以被推断为任何整数类型，但如果没有足够的类型信息，则默认推断为 i32。<code>(0)</code> 被推断为 <code>u32</code>，<code>(0,)</code> 被推断为 <code>(i32,)</code>，因为它们分别具有唯一的 Trait 实现。</p><blockquote><p>An integral literal 0 can be inferred to be any integer type, but defaults to i32 if insufficient type information is available. (0) is inferred to be a u32 and (0,) is inferred to be a (i32,) because those are respectively the only integral and 1-tuple types with an implementation for Trait.</p></blockquote><p>由于 <code>(0, 0)</code> 和 <code>(0, 0,)</code> 具有相同的类型，它们的 <code>p</code> 方法的输出也是相同的，但是 Rust 需要在 Trait 的两种可能的实现中进行选择，即 <code>(u32, u32)</code> 和 <code>(i32, i32)</code>。由于 <code>i32</code> 是默认的整形类型，所以在这两种情况下都会选择 <code>(i32, i32)</code>。</p><blockquote><p>Since (0, 0) and (0, 0,) have the same type, the output of their p methods must be the same, but Rust needs to somehow choose between the two possible implementations of Trait, namely (u32, u32) and (i32, i32). Since i32 is the default integral type, (i32, i32) is chosen in both cases.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="30-clone">#30 <code>clone</code><a class="hash-link" href="#30-clone" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-29">题目<a class="hash-link" href="#题目-29" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::rc::Rc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn p&lt;X&gt;(x: X) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match std::mem::size_of::&lt;X&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0 =&gt; print!(&quot;0&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = &amp;A;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(a);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(a.clone());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let b = &amp;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(b.clone());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let c = Rc::new(());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(Rc::clone(&amp;c));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    p(c.clone());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-29">提示<a class="hash-link" href="#提示-29" title="标题的直接链接">​</a></h3><p>不可变的指针 <code>&amp;T</code> 和 <code>Rc&lt;T&gt;</code> 实现了 <code>Clone</code>，即使 <code>T</code> 并没有实现。</p><blockquote><p>Immutable pointers <code>&amp;T</code> and <code>Rc&lt;T&gt;</code> implement Clone even if T doesn&#x27;t.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-28">题解<a class="hash-link" href="#题解-28" title="标题的直接链接">​</a></h3><p>答案：111011</p><p>这里出现的两个非引用类型，<code>()</code> 和 <code>A</code> 都是零大小类型 (ZST)。如果你向函数 <code>p&lt;X&gt;</code> 传一个 <code>X = ()</code> 或者 <code>X = A</code>，那么会打印 0。如果传的是 <code>X = ＆()</code> 或者 <code>X = &amp;A</code>，无论指针有多大，总会打印 1。</p><blockquote><p>Both of our non-reference types, <code>()</code> and <code>A</code>, are zero-sized types (ZST). The function <code>p&lt;X&gt;</code> will print 0 if it is passed a value of type <code>X = ()</code> or <code>X = A</code>, and it will print 1 if passed a reference <code>X = &amp;()</code> or <code>X = &amp;A</code> regardless of exactly how big pointers happen to be.</p></blockquote><p><code>p(a)</code> 用 <code>X = &amp;A</code> 调用 p，因为参数 a 是 <code>&amp;A</code> 类型的；打印出 1。</p><blockquote><p>p(a) invokes p with X = &amp;A because the argument a is of type <code>&amp;A</code>; this prints 1.</p></blockquote><p>在下一行 <code>p(a.clone())</code>，如果 A 实现了 Clone，那么 <code>a.clone()</code> 会调用对应的实现。但是它没有，编译器发现 <code>&amp;T</code> 实现了 Clone，所以这里会调用 <code>&amp;A</code> 实现的 Clone，它会通过简单地重复引用，将一个 <code>&amp;&amp;A</code> 转为 <code>&amp;A</code>。对 p 的调用中，<code>X = &amp;A</code>，也会打印 1。在实践中，当包含引用的结构想要派生出 Clone 时，Clone 对引用的影响是非常有用的，但正如这里所看到的，它有时会意外地启动。</p><blockquote><p>On the next line, if A implemented Clone then a.clone() would be a call to that impl. But since it doesn&#x27;t, the compiler finds another applicable impl which is the implementation of Clone for references &amp;T -- so concretely the clone call is calling the impl of Clone for &amp;A which turns a &amp;&amp;A into a &amp;A by simply duplicating the reference. We get another call to p with X = &amp;A printing 1. The impl of Clone for references is useful in practice when a struct containing a reference wants to derive Clone, but as seen here it can sometimes kick in unexpectedly.</p></blockquote><p>类型 <code>()</code> 确实实现了 Clone，所以 <code>b.clone()</code> 调用了该实现，产生了 <code>()</code>。对 <code>&amp;()</code>的 Clone 实现也适用于 A 的情况，但是编译器更喜欢调用 trait impl for ()，将 <code>&amp;()</code> 转换为 <code>()</code> ，而不是 trait impl for &amp;()，将 <code>&amp;&amp;()</code> 转换为 <code>&amp;()</code>，因为前者对 trait solver 插入的隐式引用或取消引用的要求更少。在对 <code>b.clone()</code> 的调用中，<code>b</code> 的类型是 <code>&amp;()</code>，与 <code>impl Clone for ()</code> 的参数完全匹配，而为了拿到 <code>&amp;&amp;()</code> 作为参数传递给 <code>impl Clone for &amp;()</code>，特征求解器还需要插入额外的隐式引用层 -- 有效地计算 <code>(&amp;b).clone()</code>。</p><blockquote><p>The type () does implement Clone so b.clone() invokes that impl and produces (). The implementation of Clone for &amp;() would also be applicable as happened in the case of A, but the compiler prefers calling the trait impl for () which converts &amp;() to () over the trait impl for &amp;() which converts &amp;&amp;() to &amp;() because the former is the one that requires fewer implicit references or dereferences inserted by the trait solver. In the call to b.clone(), b is of type &amp;() which exactly matches the argument of the impl Clone for (), while in order to obtain a &amp;&amp;() to pass as argument to the impl Clone for &amp;() the trait solver would need to insert an additional layer of referencing implicitly -- effectively computing (&amp;b).clone().</p></blockquote><p>我们在调用 <code>p(b)</code> 时实际传入的 <code>X = ＆()</code>，调用 <code>p(b.clone())</code> 时则是 <code>X = ()</code>。</p><blockquote><p>What we get is p(b) calling p with X = &amp;() and p(b.clone()) calling p with X = (). Together these print 10.</p></blockquote><p>最后是 Rc，两次对 b 的调用都是 <code>X = Rc&lt;()&gt;</code>，大小不为零。使用 <code>Rc::clone(&amp;c)</code> 而不是 <code>c.clone()</code> 来克隆一个 Rc 被认为是习惯性的，因为 <code>Rc::clone()</code> 使人明显感觉到这是一个引用计数的增加，而不是克隆底层数据，但最终两者指的是同一个函数。要在 Rc 内部调用一个值的克隆，你需要先对它解引用：<code>(*c).clone()</code>。</p><blockquote><p>Finally in the Rc case, both calls to p are with <code>X = Rc&lt;()&gt;</code> which is non-zero sized. It is considered idiomatic to clone a Rc using <code>Rc::clone(&amp;c)</code> instead of <code>c.clone()</code> because it makes it apparent that this is a reference count bump rather than cloning underlying data, but ultimately both refer to the same function. To call the clone method of a value inside a Rc, you would need to dereference it first: <code>(*c).clone()</code>.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="31-method-lookup-order">#31 <code>method lookup order</code><a class="hash-link" href="#31-method-lookup-order" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-30">题目<a class="hash-link" href="#题目-30" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait Or {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(self);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Or for &amp;T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Or for &amp;&amp;&amp;&amp;T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn f(self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let t = T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let wt = &amp;T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let wwt = &amp;&amp;T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let wwwt = &amp;&amp;&amp;T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let wwwwt = &amp;&amp;&amp;&amp;T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let wwwwwt = &amp;&amp;&amp;&amp;&amp;T;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    t.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wt.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wwt.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wwwt.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wwwwt.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wwwwwt.f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-30">提示<a class="hash-link" href="#提示-30" title="标题的直接链接">​</a></h3><p>在方法查找过程中，Rust 会自动解引用，并以明确的顺序借用接收器，直到找到第一个有合适签名的函数。这个顺序是什么呢？</p><blockquote><p>During a method lookup, Rust automatically derefences and borrows the receiver in a well-defined order until it finds the first function with a suitable signature. What is that order?</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-29">题解<a class="hash-link" href="#题解-29" title="标题的直接链接">​</a></h3><p>答案：111222</p><p>这篇 <a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html" target="_blank" rel="noopener noreferrer">引用</a> 描述了 Rust 的方法查找顺序。相关的段落如下： </p><p>获得 <!-- -->[候选接收方类型]<!-- --> 的方法是：反复解引用接受者表达式的类型，将遇到的每个类型添加到列表中，最后尝试在最后进行非大小胁迫，如果成功，则添加结果类型。然后，对于每个候选的T，将 <code>&amp;T</code> 和 <code>&amp;mut T</code> 添加到紧跟 <code>T</code> 的列表中。</p><blockquote><p>The <a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html" target="_blank" rel="noopener noreferrer">Reference</a> describes Rust&#x27;s method lookup order. The relevant paragraph is:</p></blockquote><blockquote><p>Obtain <!-- -->[the candidate receiver type]<!-- --> by repeatedly dereferencing the receiver expression&#x27;s type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, and adding the result type if that is successful. Then, for each candidate T, add &amp;T and &amp;mut T to the list immediately after T.</p></blockquote><p>把这些规则添加到所给的例子里：</p><blockquote><p>Applying these rules to the given examples, we have:</p></blockquote><ul><li><p><code>t.f()</code>: 我们试图找到一个定义在类型 <code>T</code> 上的函数 f，但是没有。接下来，我们搜索类型 <code>&amp;T</code>，并找到 <code>Or</code> 特征的第一个实现，然后我们就完成了。在调用时，找到的调用会打印出 1。</p><blockquote><p>t.f(): We try to find a function f defined on the type T, but there is none. Next, we search the type &amp;T, and find the first implemenation of the Or trait, and we are done. Upon invocation, the resolved call prints 1.</p></blockquote></li><li><p><code>wt.f()</code>: 我们搜索一个定义在 <code>&amp;T</code> 上的函数 f，立刻就成功了。调用后，该函数打印出 1。</p><blockquote><p>We search for a function f defined on &amp;T, which immediately succeeds. Upon invocation, the function prints 1.</p></blockquote></li><li><p><code>wwt.f()</code>: 搜索顺序是 <code>&amp;&amp;T -&gt; &amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;T -&gt; &amp;T</code>，结果打印 1。</p><blockquote><p>The search order is <code>&amp;&amp;T -&gt; &amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;T -&gt; &amp;T</code>, and we&#x27;re done. Upon invocation, the function prints 1.</p></blockquote></li><li><p><code>wwwt.f()</code>: <code>&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code> 这个打印 2。</p><blockquote><p><code>&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code>. This prints 2.</p></blockquote></li><li><p><code>wwwwt.f()</code>: <code>&amp;&amp;&amp;&amp;T</code> 这个打印 2。 </p><blockquote><p><code>&amp;&amp;&amp;&amp;T</code>. This prints 2.</p></blockquote></li><li><p><code>wwwwwt.f()</code>: <code>&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code> 这个打印 2。</p><blockquote><p><code>&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code>. This prints 2.</p></blockquote></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="32-march-arm--if-guard">#32 <code>march arm &amp; if guard</code><a class="hash-link" href="#32-march-arm--if-guard" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-31">题目<a class="hash-link" href="#题目-31" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn check(x: i32) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, x);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match (1, 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (x, _) | (_, x) if check(x) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            print!(&quot;3&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; print!(&quot;4&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-31">提示<a class="hash-link" href="#提示-31" title="标题的直接链接">​</a></h3><p>无论哪种方式，在不同的情况下都会令人困惑；没有一个明确的正确行为，提示可以帮助识别。猜测两者都是。</p><blockquote><p>Either way would be confusing in different situations; there isn&#x27;t a clear right behavior that a hint could help identify. Guess both. :/</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-30">题解<a class="hash-link" href="#题解-30" title="标题的直接链接">​</a></h3><p>答案：124</p><p>这个问题覆盖了 match 分支和 guards 的行为。</p><blockquote><p>This question covers two behaviors of match arms and guards.</p></blockquote><p>首先，包含 <code>|</code> 的匹配臂上的 if guard 是适用于匹配臂中的所有备选方案，还是只适用于它相邻的方案。在测验代码中，<code>check(x)</code> 是同时对 <code>(x, _)</code> 和 <code>(_, x)</code> 执行，还是只覆盖了 <code>(_, x)</code>？我们希望只有在前者的情况下，1 才会被打印出来。事实上，1 确实被打印出来了。一个匹配臂最多只能有一个 if guard，而且这个 guard 适用于匹配臂中所有的由 <code>|</code> 分隔的备选方案。</p><blockquote><p>First, whether an if guard on a match-arm containing <code>|</code> applies to all alternatives in the match-arm or just to the one it is adjacent to. In the quiz code, does <code>check(x)</code> execute at all for <code>(x, _)</code> or does it only cover the <code>(_, x)</code> case? We would expect 1 would get printed if and only if the former is the case. In fact 1 does get printed. A match-arm gets to have at most one if guard and that guard applies to all the <code>|</code>-separated alternatives in the arm.</p></blockquote><p>其次，这个问题还包括匹配臂的一种 &quot;回溯&quot; 行为。当 <code>check(x)</code> 在 <code>(x, _)</code> 上返回 false 时，整个匹配臂是在这里匹配失败，还是 Rust 继续前进到 <code>(_, x)</code> 并第二次执行 guard？我们期望当且仅当后一种情况出现时 2 会被打印出来。事实上，2 确实被打印出来了；if guard 被运行了多次，在匹配臂中的每一个 <code>|</code> 分隔的选项中都有一次。</p><blockquote><p>But second, this question also covers a kind of &quot;backtracking&quot; behavior of match-arms. After <code>check(x)</code> returns false on <code>(x, _)</code>, does the whole match-arm fail to match at that point or does Rust move on to <code>(_, x)</code> and execute the guard a second time? We would expect 2 to be printed if and only if the latter is the case. In fact 2 does get printed; the guard is being run multiple times, once per <code>|</code>-separated alternative in the match-arm.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="33-ranges-method">#33 <code>Range&#x27;s method</code><a class="hash-link" href="#33-ranges-method" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-32">题目<a class="hash-link" href="#题目-32" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::ops::RangeFull;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait Trait {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) -&gt; fn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Trait for RangeFull {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) -&gt; fn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        || print!(&quot;3&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;F: FnOnce() -&gt; T, T&gt; Trait for F {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn method(&amp;self) -&gt; fn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        || print!(&quot;4&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (|| .. .method())();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-32">提示<a class="hash-link" href="#提示-32" title="标题的直接链接">​</a></h3><p><code>||</code> 是一个闭包。<code>..</code> 是 range 的语法，通常会在切片中看到，例如 <code>&amp;s[1..4]</code> 或者 <code>&amp;s[..s.len() - 1]</code>。</p><blockquote><p><code>||</code> is a closure introducer. <code>..</code> is range syntax, normally seen in slicing operations like <code>&amp;s[1..4]</code> or <code>&amp;s[..s.len() - 1]</code>.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-31">题解<a class="hash-link" href="#题解-31" title="标题的直接链接">​</a></h3><p>答案：24</p><p>两个合理的可能是 1 或 24，取决于如何区分 <code>|| .. .method()</code> 的优先级。</p><blockquote><p>The two rational possibilities are 1 or 24, depending on how the precedence of <code>|| .. .method()</code> is disambiguated.</p></blockquote><p>如 <code>|| ((..).method())</code>，这是一个闭包，其主体调用了我们对 <code>RangeFull</code> 的实现的 Trait 方法。在这种情况下，main 会打印 1。它不会打印 13，因为从 <code>(..).method()</code> 返回的 <code>fn()</code> 从未被 main 调用。</p><blockquote><p>As <code>|| ((..).method())</code>, which is a closure whose body invokes our impl of Trait on <code>RangeFull</code>. In this case main would print 1. It would not print 13 because the <code>fn()</code> returned from <code>(..).method()</code> is never invoked by main.</p></blockquote><p>如 <code>(|| ..).method()</code>，它是我们对 <code>FnOnce()-&gt;T</code> 实现的 Trait 的调用，其中 <code>T</code> 被推断为 <code>RangeFull</code>。在这种情况下，main 会打印 24。</p><blockquote><p>As <code>(|| ..).method()</code>, which is an invocation of our impl of Trait on <code>FnOnce() -&gt; T</code> where T is inferred to be <code>RangeFull</code>. In this case main would print 24.</p></blockquote><p>后者才是正确的答案。</p><blockquote><p>The latter of those is the correct answer.</p></blockquote><p>我们可以通过显式的括号来实现前者的行为，如上文中所示。</p><blockquote><p>We can achieve the former behavior by explicitly parenthesizing as shown in the bullet above.</p></blockquote><p>只有部分括号如 <code>|| (.. .method())</code> 是不够的。这会导致一个解析错误。</p><blockquote><p>Partially parenthesizing as <code>|| (.. .method())</code> is not sufficient. This results in a parse error.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error: expected one of `)` or `,`, found `.`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; src/main.rs:22:13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 |     (|| (.. .method()))();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |            -^ expected one of `)` or `,`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |            |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |            help: missing `,`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>正确处理像 <code>|| .. .method()</code> 这样相当模糊的表达式对 Rust tooling 来说是一个挑战，从 Rustfmt (<a href="https://github.com/rust-lang/rustfmt/issues/4808" target="_blank" rel="noopener noreferrer">rust-lang/rustfmt#4808</a>) 和 Syn (<a href="https://github.com/dtolnay/syn/issues/1019" target="_blank" rel="noopener noreferrer">dtolnay/syn#1019</a>) 的相关错误中可以看出。</p><blockquote><p>Correctly handling a quite ambiguous expression like || .. .method() is a challenge for tooling, as seen by the associated bugs in Rustfmt (<a href="https://github.com/rust-lang/rustfmt/issues/4808" target="_blank" rel="noopener noreferrer">rust-lang/rustfmt#4808</a>) and Syn (<a href="https://github.com/dtolnay/syn/issues/1019" target="_blank" rel="noopener noreferrer">dtolnay/syn#1019</a>).</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="34-size-of-fn">#34 <code>size of fn</code><a class="hash-link" href="#34-size-of-fn" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-33">题目<a class="hash-link" href="#题目-33" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn d&lt;T&gt;(_f: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    match std::mem::size_of::&lt;T&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        0 =&gt; print!(&quot;0&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        1 =&gt; print!(&quot;1&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _ =&gt; print!(&quot;2&quot;),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn a&lt;T&gt;(f: fn(T)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    d(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    a(a::&lt;u8&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    d(a::&lt;u8&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-33">提示<a class="hash-link" href="#提示-33" title="标题的直接链接">​</a></h3><p>用任何其他整数类型代替 u8，答案都是一样的。</p><blockquote><p>The answer would be the same with any other integer type in place of u8.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-32">题解<a class="hash-link" href="#题解-32" title="标题的直接链接">​</a></h3><p>答案：20</p><p>表达式 <code>a::&lt;u8&gt;</code> 的类型是一个零大小类型（ZST）。</p><blockquote><p>The expression <code>a::&lt;u8&gt;</code>&#x27;s type is a zero-sized type (ZST).</p></blockquote><p>Rust 围绕函数类型的作出的选择和具体实现与几乎所有其他语言都不同，但它是 Rust 许多零开销抽象的重要促成因素。在 Rust 中，每个函数（或泛型函数的每个不同实例）都有自己的独特类型。特别是，即使是具有相同函数签名的两个函数也会有不同的类型。</p><blockquote><p>Rust&#x27;s implementation choices around function types are different from nearly all other languages, but are an important enabler of many of Rust&#x27;s zero-overhead abstractions. In Rust, every function (or every distinct instantiation of a generic function) has its own unique type. In particular, even two functions with the same function signature would have different types.</p></blockquote><p>每个函数都有一个独特的类型，这种特性允许类型本身携带将被调用的函数的信息，不需要任何运行时状态，如指针。</p><blockquote><p>Having a unique type for each function allows the type itself to carry the information of what function will be called, not needing any runtime state such as a pointer.</p></blockquote><p>为了理解这种优化方法的优势，考虑 <code>Iterator::map</code> 和两个调用 <code>iter.map(f)</code> 和 <code>iter.map(g)</code>，其中 <code>f</code> 和 <code>g</code> 是具有相同签名的不同函数。因为 <code>f</code> 和 <code>g</code> 有不同的类型，这两个 map 调用会产生两个不同的泛型函数的单态实例，其中一个静态地调用 <code>f</code>，另一个静态地调用 <code>g</code>，就像你直接为每个函数写了一个特殊的 map 实现，而没有 map 提供的抽象。因此，泛型 map 是一个零成本的抽象。传统上，在其他语言如 C++ 或 Go 中，f 和 g 会被作为一个函数指针传递给 map，并且只有一个 map 的实例，包含一个执行函数调用的动态分发，这通常会比静态调用函数更慢。这种性能缺陷使得这些语言中的 map 不是一个零成本的抽象。</p><blockquote><p>To understand the optimization advantages of this approach, consider <code>Iterator::map</code> and the two calls <code>iter.map(f)</code> and iter.map(g) where f and g are different functions with the same signature. Because f and g have distinct types, the two map calls would produce two different monomorphic instantiations of the generic map function, one of which statically calls f and the other statically calls g, as if you had directly written a special-purpose map implementation specific to each function without the abstraction provided by map. The generic map is thus a zero-overhead abstraction. Traditionally in other languages such as C++ or Go, in this situation f and g would be passed to map as a function pointer and there would be just one instantiation of map, containing a dynamic dispatch to execute the function call, which is usually going to be slower than statically calling the right function. This performance penalty makes map in those languages not a zero-overhead abstraction.</p></blockquote><p>目前在 Rust 中，没有语法来表达特定的函数类型，所以它们总是作为一个通用的类型参数与 <code>FnOnce</code>、<code>Fn</code> 或 <code>FnMut</code> 绑定传递。在错误信息中，你可能会看到函数类型以 <code>fn(T) -&gt; U {fn_name}</code> 的形式出现，但你不能在代码中使用这种语法。</p><blockquote><p>Currently in Rust there is no syntax to express the type of a specific function, so they are always passed as a generic type parameter with a FnOnce, Fn or FnMut bound. In error messages you might see function types appear in the form fn(T) -&gt; U {fn_name}, but you can&#x27;t use this syntax in code.</p></blockquote><p>另一方面，一个函数指针，<code>fn(T) -&gt; U</code>，在运行时是指针大小。函数类型可以被胁迫为函数指针，这一点在你需要将 &quot;选择调用那个函数&quot; 推迟到运行时很有用。</p><blockquote><p>On the other hand, a function pointer, fn(T) -&gt; U, is pointer-sized at runtime. Function types can be coerced into function pointers, which can be useful in case you need to defer the choice of function to call until runtime.</p></blockquote><p>在测验代码中，main 中的第一个调用在调用 d 之前将 <code>a::&lt;u8&gt;</code> 从一个函数胁迫为一个函数指针<code>(fn(fn(u8)) {a::&lt;u8&gt;}</code> 到 <code>fn(fn(u8)))</code>，因此在一个具有 64 位函数指针的系统中，它的大小为 8。main 中的第二个调用不涉及函数指针；d 被直接调用，T 是 <code>a::&lt;u8&gt;</code> 的不可表达的类型，它的大小为零。</p><blockquote><p>In the quiz code, the first call in main coerces <code>a::&lt;u8&gt;</code> from a function to a function pointer <code>(fn(fn(u8)) {a::&lt;u8&gt;}</code> to <code>fn(fn(u8)))</code> prior to calling d, so its size would be 8 on a system with 64-bit function pointers. The second call in main does not involve function pointers; d is directly called with T being the inexpressible type of <code>a::&lt;u8&gt;</code>, which is zero-sized.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="35-hygiene-2">#35 <code>Hygiene 2</code><a class="hash-link" href="#35-hygiene-2" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-34">题目<a class="hash-link" href="#题目-34" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! x {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($n:expr) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let a = X($n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct X(u64);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Drop for X {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn drop(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, self.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = X(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x!(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, a.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-34">提示<a class="hash-link" href="#提示-34" title="标题的直接链接">​</a></h3><p>有一些程序，cargo expand 产生的展开后的代码可以编译，但其行为与原始代性码的原始宏卫生不同。</p><blockquote><p>There are some programs for which cargo expand produces expanded code that compiles, but behaves differently than the original code with the original macro hygiene.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-33">题解<a class="hash-link" href="#题解-33" title="标题的直接链接">​</a></h3><p>答案：121</p><p>根据你对 macro 展开的假设，本题有两条看似合理的错误答案：</p><blockquote><p>There are two reasonable paths to an incorrect answer on this question, based on your assumptions around how this macro gets expanded:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1. let a = X(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. { let a = X(2); }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果第一种展开方式是正确的，这个宏会引入一个新的绑定，a，它将遮蔽 main 中已经直接分配的 a。因此，main 中的 print 语句将首先执行，打印 2，然后变量将按引入的顺序倒序 drop，先打印 2，再打印 1，最后输出 221。</p><blockquote><p>If the first expansion were right, the macro would introduce a new binding, a, which shadows the a already directly assigned in main. So the print statement in main would execute first, printing 2, then the variables would drop in reverse order of introduction, printing 2 then 1, with a final output of 221.</p></blockquote><p>如果第二种展开方式是正确的，这个宏会在一个嵌套的作用域中引入 a，只在这个作用域中遮蔽已经存在的 a，而不是在它之外。由于新的 a 的作用域在打印语句之前就结束了，所以当它超出作用域时，它的 Drop impl 将是第一个执行的打印，打印 2。接下来，main 中的打印将打印 1，也就是第一个 a 的值，最后，当这个值在 main 结束时，再打印 1，最终输出 211。</p><blockquote><p>If the second expansion were right, the macro would introduce a in a nested scope, shadowing the already existing a only inside of that scope and not beyond it. Since the new a&#x27;s scope ends before the print statement, its Drop impl when going out of scope would be the first print to execute, printing 2. Next the print in main would print 1 which is the value of the first a, and finally 1 again when that value drops at the end of main, with final output 211.</p></blockquote><p>如果你读过关于宏卫生性的文章，那么你可能已经猜到它的实现方式与第二个选项类似。重要的是，宏的内部结构不会与调用地点范围内的变量发生冲突，而且 Rust 宏在防止意外的名称冲突方面做得很好。然而，这并不是卫生性的实现方式；在宏扩展周围引入人为的作用域会使它们的作用更加有限，而且不会解决很多其他的卫生性问题。</p><blockquote><p>If you&#x27;ve read about macro hygiene then you might have guessed it would be implemented something like this second option. It&#x27;s important that internals of a macro don&#x27;t interfere coincidentally with variables in scope at the call site, and Rust macros mostly do a good job of preventing unintended name collisions. However, this is not how hygiene is implemented; introducing artificial scopes around macro expansions would make them more limited in their usefulness, and wouldn&#x27;t solve a lot of other hygiene problems.</p></blockquote><p>你可以把 lazily calcalute 想象成给每个提到的局部变量的名字分配一个颜色，允许在作用域内有多个可区分的局部变量同时拥有相同的文本名称。</p><blockquote><p>You can instead imagine hygiene as a way of assigning a color to each mention of the name of a local variable, allowing for there to be multiple distinguishable local variables in scope simultaneously with the same textual name.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = X(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let a = X(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(&quot;{}&quot;, a.0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>所以打印出来的是 main 的标识符 a 的值，也就是 1，然后两个值按照引入的相反顺序丢掉，先打印 2 再打印 1，程序的输出是 121。</p><blockquote><p>So what&#x27;s printed is the value of main&#x27;s identifier a which is 1, then the two values are dropped in reverse order of introduction printing 2 then 1, and the output of the program is 121.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="36-move--fn">＃36 <code>move &amp; Fn</code><a class="hash-link" href="#36-move--fn" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-35">题目<a class="hash-link" href="#题目-35" title="标题的直接链接">​</a></h3><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn call(mut f: impl FnMut() + Copy) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn g(mut f: impl FnMut() + Copy) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    call(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    f();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    call(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut i = 0i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    g(move || {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>未定义的行为</li><li>编译失败</li><li>程序确定会输出：<!-- -->[ ]</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提示-35">提示<a class="hash-link" href="#提示-35" title="标题的直接链接">​</a></h3><p>变量 <code>i</code> 被编译器生成的闭包对象所捕获。</p><blockquote><p>The variable <code>i</code> is captured by value in the compiler-generated closure object.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="题解-34">题解<a class="hash-link" href="#题解-34" title="标题的直接链接">​</a></h3><p>答案：1223</p><p>传入 g 的对象是一个 <code>FnMut</code> 闭包，它捕获了一个整数。实际上，它是一个不可命名的结构体，包含一个类型为 i32 的字段，并有一个函数调用操作符，该操作符接收 <code>&amp;mut self</code>。</p><blockquote><p>The object passed into g is a FnMut closure which captures an integer by value. Effectively it&#x27;s an unnameable struct containing a single field whose type is i32, with a function call operator that takes &amp;mut self:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Copy, Clone)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct UnnameableClosure {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i: i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl UnnameableClosure {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn unnameable_call_operator(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.i += 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        print!(&quot;{}&quot;, self.i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut i = 0i32;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">g(UnnameableClosure { i });</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>g 里面的 4 个调用的行为如下。</p><blockquote><p>The behavior of the 4 calls inside g is as follows:</p></blockquote><ul><li><p><code>f()</code> 运行闭包，其通过值捕获的 <code>i</code> 的值变为 1。</p><blockquote><p>f() runs the closure and its by-value captured value of i becomes 1.</p></blockquote></li><li><p><code>call(f)</code> 制造一个 <code>f</code> 的副本，作为 call 的参数。这个副本被执行，它的 <code>i</code> 变成了 2，但是原始闭包仍然保持着它捕获的 <code>i</code> 的值为 1。<code>f</code> 的副本在调用主体的末尾超出了作用域被 drop。</p><blockquote><p>call(f) makes a copy of f to become the argument of call. The copy gets executed and its i becomes 2, but the original closure still holds a value of 1 for its captured i. The copy of the closure gets dropped as it goes out of scope at the end of the body of call.</p></blockquote></li><li><p><code>f()</code> 第二次运行原始闭包，其 i 变为 2。</p><blockquote><p>f() runs the original closure a second time and its i becomes 2.</p></blockquote></li><li><p><code>call(f)</code> 第二次复制 f 并执行副本，它的 i 变成了 3。</p><blockquote><p>call(f) copies f a second time and executes the copy, its i becomes 3.</p></blockquote></li></ul><p>从 Rust 1.26 开始，如果闭包的所有捕获都实现了 Clone，则闭包自动实现了 Clone；如果所有捕获都实现了 Copy，则闭包自动实现了 Copy。</p><blockquote><p>Since Rust 1.26, closures automatically implement Clone if all their captures implement Clone, and Copy if all the captures implement Copy.</p></blockquote><p>如果 quiz 代码中省略了 move 关键字，编译器生成的闭包将通过可变引用而不是通过值捕获 i。</p><blockquote><p>If the move keyword were omitted from the quiz code, the compiler-generated closure would capture i by mutable reference instead of by value:</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pub struct UnnameableClosure&lt;&#x27;a&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    i: &amp;&#x27;a mut i32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>并且不再有 Copy impl，因为将一个可变引用复制成多个副本是不正确的（aliasing xor mutation；这是借用检查器的重点）。</p><blockquote><p>and there would no longer be a Copy impl, because it&#x27;s incorrect to duplicate a mutable reference into multiple copies (aliasing xor mutation; this is the point of the borrow checker).</p></blockquote><p>对于 Rust 的初学者来说，一个经常出现的困惑是 move, non-move 闭包与 Fn、FnMut 和 FnOnce 闭包之间的关系。这是两个几乎完全不同的东西。正如上面的 <code>UnnameableClosure</code> 伪代码所示，move 与 non-move 是指编译器生成的闭包结构的字段是否与原始被捕获变量的类型相同，或者是对原始捕获变量类型的引用（例如，<code>i32</code> 与 <code>&amp;mut i32</code>）。相比之下，<code>Fn</code> vs <code>FnMut</code> vs <code>FnOnce</code> 是关于编译器生成的闭包结构的调用方法是否有一个接收器，该接收器是 <code>&amp;self</code> vs <code>&amp;mut self</code> vs <code>self</code>。</p><blockquote><p>One recurring source of confusion for Rust beginners is the relationship between move and non-move closures vs Fn and FnMut and FnOnce closures. These are two nearly-orthogonal things. As illustrated in the UnnameableClosure pseudocode above, move vs non-move is about whether the fields of the compiler-generated closure struct have the same type as the original captured variable&#x27;s type, vs are references to the original captured variable&#x27;s type (i32 vs &amp;mut i32, for example). In contrast, Fn vs FnMut vs FnOnce is about whether the call method of the compiler-generated closure struct has a receiver which is &amp;self vs &amp;mut self vs self.</p></blockquote></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/rust/rs_channel"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Channel 源码剖析</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/rust/wasm"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Wasm 实现生命游戏</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-statement-boundry" class="table-of-contents__link toc-highlight">#1 <code>statement boundry</code></a><ul><li><a href="#题目" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#解答" class="table-of-contents__link toc-highlight">解答</a></li></ul></li><li><a href="#2-impl-bitand" class="table-of-contents__link toc-highlight">#2 <code>impl BitAnd</code></a><ul><li><a href="#题目-1" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-1" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#3-const-initializer" class="table-of-contents__link toc-highlight">#3 <code>const initializer</code></a><ul><li><a href="#题目-2" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-2" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-1" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#4-" class="table-of-contents__link toc-highlight">#4 <code>..</code></a><ul><li><a href="#题目-3" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-3" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-2" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#5-t-or-t" class="table-of-contents__link toc-highlight">#5 <code>T or &amp;T</code></a><ul><li><a href="#题目-4" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-4" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-3" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#6-size-of-" class="table-of-contents__link toc-highlight">#6 <code>size of ()</code></a><ul><li><a href="#题目-5" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-5" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-4" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#7-match" class="table-of-contents__link toc-highlight">#7 <code>match</code></a><ul><li><a href="#题目-6" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-6" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-5" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#8---" class="table-of-contents__link toc-highlight">#8 <code>= = &gt;</code></a><ul><li><a href="#题目-7" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-7" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-6" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#9-tttt" class="table-of-contents__link toc-highlight">#9 <code>$tt:tt</code></a><ul><li><a href="#题目-8" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-8" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-7" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#10-traitf" class="table-of-contents__link toc-highlight">#10 <code>Trait::f</code></a><ul><li><a href="#题目-9" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-9" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-8" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#11-early--late-bound" class="table-of-contents__link toc-highlight">#11 <code>early &amp; late bound</code></a><ul><li><a href="#题目-10" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-10" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-9" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#12-let-s--x----s" class="table-of-contents__link toc-highlight">#12 <code>let S { x, .. } = S</code></a><ul><li><a href="#题目-11" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-11" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-10" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#13-eq" class="table-of-contents__link toc-highlight">#13 <code>eq</code></a><ul><li><a href="#题目-12" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-12" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-11" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#14-trait-scope" class="table-of-contents__link toc-highlight">#14 <code>trait scope</code></a><ul><li><a href="#题目-13" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-13" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-12" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#15-type-inference" class="table-of-contents__link toc-highlight">#15 <code>type inference</code></a><ul><li><a href="#题目-14" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-14" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-13" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#16---i" class="table-of-contents__link toc-highlight">#16 <code>--i</code></a><ul><li><a href="#题目-15" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-15" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-14" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#17--------" class="table-of-contents__link toc-highlight">#17 <code>-- - --</code></a><ul><li><a href="#题目-16" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-16" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-15" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#18-f-and-f" class="table-of-contents__link toc-highlight">#18 <code>f() and f()</code></a><ul><li><a href="#题目-17" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-17" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-16" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#19-move-or-drop" class="table-of-contents__link toc-highlight">#19 <code>move or drop</code></a><ul><li><a href="#题目-18" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-18" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-17" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#20-return-and-return" class="table-of-contents__link toc-highlight">#20 <code>return and return</code></a><ul><li><a href="#题目-19" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-19" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-18" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#21-return--break" class="table-of-contents__link toc-highlight">#21 <code>return &amp; break</code></a><ul><li><a href="#题目-20" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-20" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-19" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#22---is-a-token" class="table-of-contents__link toc-highlight">#22 <code>- is a token</code></a><ul><li><a href="#题目-21" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-21" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-20" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#23-method-lookup-order" class="table-of-contents__link toc-highlight">#23 <code>method lookup order</code></a><ul><li><a href="#题目-22" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-22" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-21" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#24-hygiene" class="table-of-contents__link toc-highlight">#24 <code>Hygiene</code></a><ul><li><a href="#题目-23" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-23" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-22" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#25-drop" class="table-of-contents__link toc-highlight">#25 <code>drop</code></a><ul><li><a href="#题目-24" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-24" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-23" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#26-lazy-map" class="table-of-contents__link toc-highlight">#26 <code>lazy map</code></a><ul><li><a href="#题目-25" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-25" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-24" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#27-dyn-trait" class="table-of-contents__link toc-highlight">#27 <code>dyn Trait</code></a><ul><li><a href="#题目-26" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-26" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-25" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#28-_guard--_" class="table-of-contents__link toc-highlight">#28 <code>_guard &amp; _</code></a><ul><li><a href="#题目-27" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-27" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-26" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#29-t--t" class="table-of-contents__link toc-highlight">#29 <code>(T) &amp; (T,)</code></a><ul><li><a href="#题目-28" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-28" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-27" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#30-clone" class="table-of-contents__link toc-highlight">#30 <code>clone</code></a><ul><li><a href="#题目-29" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-29" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-28" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#31-method-lookup-order" class="table-of-contents__link toc-highlight">#31 <code>method lookup order</code></a><ul><li><a href="#题目-30" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-30" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-29" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#32-march-arm--if-guard" class="table-of-contents__link toc-highlight">#32 <code>march arm &amp; if guard</code></a><ul><li><a href="#题目-31" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-31" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-30" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#33-ranges-method" class="table-of-contents__link toc-highlight">#33 <code>Range&#39;s method</code></a><ul><li><a href="#题目-32" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-32" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-31" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#34-size-of-fn" class="table-of-contents__link toc-highlight">#34 <code>size of fn</code></a><ul><li><a href="#题目-33" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-33" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-32" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#35-hygiene-2" class="table-of-contents__link toc-highlight">#35 <code>Hygiene 2</code></a><ul><li><a href="#题目-34" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-34" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-33" class="table-of-contents__link toc-highlight">题解</a></li></ul></li><li><a href="#36-move--fn" class="table-of-contents__link toc-highlight">＃36 <code>move &amp; Fn</code></a><ul><li><a href="#题目-35" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#提示-35" class="table-of-contents__link toc-highlight">提示</a></li><li><a href="#题解-34" class="table-of-contents__link toc-highlight">题解</a></li></ul></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.097b9c32.js"></script>
<script src="/assets/js/main.916d2c7b.js"></script>
</body>
</html>