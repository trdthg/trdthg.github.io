<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Trdthg&#x27;s Self</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">trans</li><li class="chapter-item expanded "><a href="trans/2022-04-20-译-使用-Tokio-处理-CPU-密集型任务.html"><strong aria-hidden="true">1.</strong> 2022-04-20-译-使用-Tokio-处理-CPU-密集型任务</a></li><li class="chapter-item expanded "><a href="trans/2023-01-03-译-Rust冒险:-滥用-Serde.html"><strong aria-hidden="true">2.</strong> 2023-01-03-译-Rust冒险:-滥用-Serde</a></li><li class="chapter-item expanded "><a href="trans/2023-01-01-译-拓展-Rust-中的-Map.html"><strong aria-hidden="true">3.</strong> 2023-01-01-译-拓展-Rust-中的-Map</a></li><li class="chapter-item expanded "><a href="trans/2022-04-01-译-search_engine.html"><strong aria-hidden="true">4.</strong> 2022-04-01-译-search_engine</a></li><li class="chapter-item expanded "><a href="trans/2022-05-04-译-可视化-Rust-各数据类型的内存布局.html"><strong aria-hidden="true">5.</strong> 2022-05-04-译-可视化-Rust-各数据类型的内存布局</a></li><li class="chapter-item expanded "><a href="trans/2022-04-13-译-tail_latency.html"><strong aria-hidden="true">6.</strong> 2022-04-13-译-tail_latency</a></li><li class="chapter-item expanded "><a href="trans/2022-04-30-译-什么时候不应该使用-Rust-？.html"><strong aria-hidden="true">7.</strong> 2022-04-30-译-什么时候不应该使用-Rust-？</a></li><li class="chapter-item expanded "><a href="trans/2022-04-11-译-异步-Rust：协作与抢占式调度.html"><strong aria-hidden="true">8.</strong> 2022-04-11-译-异步-Rust：协作与抢占式调度</a></li><li class="chapter-item expanded "><a href="trans/2023-01-02-译-未初始化内存:-unsafe-Rust太难了.html"><strong aria-hidden="true">9.</strong> 2023-01-02-译-未初始化内存:-unsafe-Rust太难了</a></li><li class="chapter-item expanded "><a href="trans/2022-04-03-译-Rust-六边形架构/index.html"><strong aria-hidden="true">10.</strong> 2022-04-03-译-Rust-六边形架构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-4-重构.html"><strong aria-hidden="true">10.1.</strong> Rust-六边形架构-4-重构</a></li><li class="chapter-item expanded "><a href="trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-2-内存存储库.html"><strong aria-hidden="true">10.2.</strong> Rust-六边形架构-2-内存存储库</a></li><li class="chapter-item expanded "><a href="trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-7-长期存储库.html"><strong aria-hidden="true">10.3.</strong> Rust-六边形架构-7-长期存储库</a></li><li class="chapter-item expanded "><a href="trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-1-域.html"><strong aria-hidden="true">10.4.</strong> Rust-六边形架构-1-域</a></li><li class="chapter-item expanded "><a href="trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-5-其他用例.html"><strong aria-hidden="true">10.5.</strong> Rust-六边形架构-5-其他用例</a></li><li class="chapter-item expanded "><a href="trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-6-CLI.html"><strong aria-hidden="true">10.6.</strong> Rust-六边形架构-6-CLI</a></li><li class="chapter-item expanded "><a href="trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-3-HTTP-API.html"><strong aria-hidden="true">10.7.</strong> Rust-六边形架构-3-HTTP-API</a></li><li class="chapter-item expanded "><a href="trans/2022-04-03-译-Rust-六边形架构/index.html"><strong aria-hidden="true">10.8.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">note</li><li class="chapter-item expanded "><a href="note/java/index.html"><strong aria-hidden="true">11.</strong> java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="note/java/java.html"><strong aria-hidden="true">11.1.</strong> java</a></li><li class="chapter-item expanded "><a href="note/java/springboot.html"><strong aria-hidden="true">11.2.</strong> springboot</a></li><li class="chapter-item expanded "><a href="note/java/spring.html"><strong aria-hidden="true">11.3.</strong> spring</a></li><li class="chapter-item expanded "><a href="note/java/sourceread.html"><strong aria-hidden="true">11.4.</strong> sourceread</a></li><li class="chapter-item expanded "><a href="note/java/index.html"><strong aria-hidden="true">11.5.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="note/frontend/index.html"><strong aria-hidden="true">12.</strong> frontend</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="note/frontend/mini_bundle.html"><strong aria-hidden="true">12.1.</strong> mini_bundle</a></li><li class="chapter-item expanded "><a href="note/frontend/js_advanced.html"><strong aria-hidden="true">12.2.</strong> js_advanced</a></li><li class="chapter-item expanded "><a href="note/frontend/mini_vue.html"><strong aria-hidden="true">12.3.</strong> mini_vue</a></li><li class="chapter-item expanded "><a href="note/frontend/vue.html"><strong aria-hidden="true">12.4.</strong> vue</a></li><li class="chapter-item expanded "><a href="note/frontend/list.html"><strong aria-hidden="true">12.5.</strong> list</a></li><li class="chapter-item expanded "><a href="note/frontend/http.html"><strong aria-hidden="true">12.6.</strong> http</a></li><li class="chapter-item expanded "><a href="note/frontend/flutter.html"><strong aria-hidden="true">12.7.</strong> flutter</a></li><li class="chapter-item expanded "><a href="note/frontend/css.html"><strong aria-hidden="true">12.8.</strong> css</a></li><li class="chapter-item expanded "><a href="note/frontend/vdom.html"><strong aria-hidden="true">12.9.</strong> vdom</a></li><li class="chapter-item expanded "><a href="note/frontend/index.html"><strong aria-hidden="true">12.10.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">blog</li><li class="chapter-item expanded "><a href="blog/index.html"><strong aria-hidden="true">13.</strong> README</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">docs</li><li class="chapter-item expanded "><a href="docs/log.html"><strong aria-hidden="true">14.</strong> log</a></li><li class="chapter-item expanded "><a href="docs/intro.html"><strong aria-hidden="true">15.</strong> intro</a></li><li class="chapter-item expanded "><a href="docs/magic/index.html"><strong aria-hidden="true">16.</strong> magic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/magic/riscv.html"><strong aria-hidden="true">16.1.</strong> riscv</a></li><li class="chapter-item expanded "><a href="docs/magic/haskell.html"><strong aria-hidden="true">16.2.</strong> haskell</a></li><li class="chapter-item expanded "><a href="docs/magic/bash.html"><strong aria-hidden="true">16.3.</strong> bash</a></li><li class="chapter-item expanded "><a href="docs/magic/memory_ordering.html"><strong aria-hidden="true">16.4.</strong> memory_ordering</a></li><li class="chapter-item expanded "><a href="docs/magic/linuxIO.html"><strong aria-hidden="true">16.5.</strong> linuxIO</a></li><li class="chapter-item expanded "><a href="docs/magic/cicd.html"><strong aria-hidden="true">16.6.</strong> cicd</a></li><li class="chapter-item expanded "><a href="docs/magic/fd.html"><strong aria-hidden="true">16.7.</strong> fd</a></li><li class="chapter-item expanded "><a href="docs/magic/hadoop.html"><strong aria-hidden="true">16.8.</strong> hadoop</a></li><li class="chapter-item expanded "><a href="docs/magic/go.html"><strong aria-hidden="true">16.9.</strong> go</a></li><li class="chapter-item expanded "><a href="docs/magic/async.html"><strong aria-hidden="true">16.10.</strong> async</a></li><li class="chapter-item expanded "><a href="docs/magic/index.html"><strong aria-hidden="true">16.11.</strong> README</a></li><li class="chapter-item expanded "><a href="docs/magic/software_arch.html"><strong aria-hidden="true">16.12.</strong> software_arch</a></li></ol></li><li class="chapter-item expanded "><a href="docs/riscv/index.html"><strong aria-hidden="true">17.</strong> riscv</a></li><li class="chapter-item expanded "><a href="docs/common/index.html"><strong aria-hidden="true">18.</strong> common</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/common/pgsql.html"><strong aria-hidden="true">18.1.</strong> pgsql</a></li><li class="chapter-item expanded "><a href="docs/common/git.html"><strong aria-hidden="true">18.2.</strong> git</a></li><li class="chapter-item expanded "><a href="docs/common/linux.html"><strong aria-hidden="true">18.3.</strong> linux</a></li><li class="chapter-item expanded "><a href="docs/common/datastructure.html"><strong aria-hidden="true">18.4.</strong> datastructure</a></li><li class="chapter-item expanded "><a href="docs/common/docker.html"><strong aria-hidden="true">18.5.</strong> docker</a></li><li class="chapter-item expanded "><a href="docs/common/analyze.html"><strong aria-hidden="true">18.6.</strong> analyze</a></li><li class="chapter-item expanded "><a href="docs/common/oci.html"><strong aria-hidden="true">18.7.</strong> oci</a></li><li class="chapter-item expanded "><a href="docs/common/unsorted.html"><strong aria-hidden="true">18.8.</strong> unsorted</a></li><li class="chapter-item expanded "><a href="docs/common/oauth2.html"><strong aria-hidden="true">18.9.</strong> oauth2</a></li><li class="chapter-item expanded "><a href="docs/common/vim.html"><strong aria-hidden="true">18.10.</strong> vim</a></li><li class="chapter-item expanded "><a href="docs/common/python.html"><strong aria-hidden="true">18.11.</strong> python</a></li><li class="chapter-item expanded "><a href="docs/common/index.html"><strong aria-hidden="true">18.12.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="docs/rust/index.html"><strong aria-hidden="true">19.</strong> rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/rust/mini_tokio.html"><strong aria-hidden="true">19.1.</strong> mini_tokio</a></li><li class="chapter-item expanded "><a href="docs/rust/wasm.html"><strong aria-hidden="true">19.2.</strong> wasm</a></li><li class="chapter-item expanded "><a href="docs/rust/rust_quiz.html"><strong aria-hidden="true">19.3.</strong> rust_quiz</a></li><li class="chapter-item expanded "><a href="docs/rust/rust.html"><strong aria-hidden="true">19.4.</strong> rust</a></li><li class="chapter-item expanded "><a href="docs/rust/print_into_detail.html"><strong aria-hidden="true">19.5.</strong> print_into_detail</a></li><li class="chapter-item expanded "><a href="docs/rust/net-piercer.html"><strong aria-hidden="true">19.6.</strong> net-piercer</a></li><li class="chapter-item expanded "><a href="docs/rust/rs_channel.html"><strong aria-hidden="true">19.7.</strong> rs_channel</a></li><li class="chapter-item expanded "><a href="docs/rust/lists.html"><strong aria-hidden="true">19.8.</strong> lists</a></li><li class="chapter-item expanded "><a href="docs/rust/index.html"><strong aria-hidden="true">19.9.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="docs/riscv/index.html"><strong aria-hidden="true">20.</strong> riscv</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/riscv/index.html"><strong aria-hidden="true">20.1.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">other</li><li class="chapter-item expanded "><a href="other/2023-04-12-remote-usb.html"><strong aria-hidden="true">21.</strong> 2023-04-12-remote-usb</a></li><li class="chapter-item expanded "><a href="other/resources.html"><strong aria-hidden="true">22.</strong> resources</a></li><li class="chapter-item expanded "><a href="other/i3wm.html"><strong aria-hidden="true">23.</strong> i3wm</a></li><li class="chapter-item expanded "><a href="other/lsm.html"><strong aria-hidden="true">24.</strong> lsm</a></li><li class="chapter-item expanded "><a href="other/site_update_log.html"><strong aria-hidden="true">25.</strong> site_update_log</a></li><li class="chapter-item expanded "><a href="other/ioclub/index.html"><strong aria-hidden="true">26.</strong> ioclub</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="other/ioclub/share_1.html"><strong aria-hidden="true">26.1.</strong> share_1</a></li><li class="chapter-item expanded "><a href="other/ioclub/index.html"><strong aria-hidden="true">26.2.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="other/2021-后端/index.html"><strong aria-hidden="true">27.</strong> 2021-后端</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="other/2021-后端/backend_1.html"><strong aria-hidden="true">27.1.</strong> backend_1</a></li><li class="chapter-item expanded "><a href="other/2021-后端/backend_2.html"><strong aria-hidden="true">27.2.</strong> backend_2</a></li><li class="chapter-item expanded "><a href="other/2021-后端/backend_3.html"><strong aria-hidden="true">27.3.</strong> backend_3</a></li><li class="chapter-item expanded "><a href="other/2021-后端/backend_4.html"><strong aria-hidden="true">27.4.</strong> backend_4</a></li></ol></li><li class="chapter-item expanded "><a href="other/2021-后端/index.html"><strong aria-hidden="true">28.</strong> 2021-后端</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="other/2021-后端/backend_1.html"><strong aria-hidden="true">28.1.</strong> backend_1</a></li><li class="chapter-item expanded "><a href="other/2021-后端/backend_2.html"><strong aria-hidden="true">28.2.</strong> backend_2</a></li><li class="chapter-item expanded "><a href="other/2021-后端/backend_3.html"><strong aria-hidden="true">28.3.</strong> backend_3</a></li><li class="chapter-item expanded "><a href="other/2021-后端/backend_4.html"><strong aria-hidden="true">28.4.</strong> backend_4</a></li><li class="chapter-item expanded "><a href="other/2021-后端/index.html"><strong aria-hidden="true">28.5.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">draft</li><li class="chapter-item expanded "><a href="draft/组成原理.html"><strong aria-hidden="true">29.</strong> 组成原理</a></li><li class="chapter-item expanded "><a href="draft/计算机网络.html"><strong aria-hidden="true">30.</strong> 计算机网络</a></li><li class="chapter-item expanded "><a href="draft/译-pkg_mng.html"><strong aria-hidden="true">31.</strong> 译-pkg_mng</a></li><li class="chapter-item expanded "><a href="draft/DistributedSystem.html"><strong aria-hidden="true">32.</strong> DistributedSystem</a></li><li class="chapter-item expanded "><a href="draft/oscamp2022.html"><strong aria-hidden="true">33.</strong> oscamp2022</a></li><li class="chapter-item expanded "><a href="draft/compile.html"><strong aria-hidden="true">34.</strong> compile</a></li><li class="chapter-item expanded "><a href="draft/test.html"><strong aria-hidden="true">35.</strong> test</a></li><li class="chapter-item expanded "><a href="draft/ld.html"><strong aria-hidden="true">36.</strong> ld</a></li><li class="chapter-item expanded "><a href="draft/数据库设计.html"><strong aria-hidden="true">37.</strong> 数据库设计</a></li><li class="chapter-item expanded "><a href="draft/index.html"><strong aria-hidden="true">38.</strong> README</a></li><li class="chapter-item expanded "><a href="draft/computer_network/index.html"><strong aria-hidden="true">39.</strong> computer_network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="draft/computer_network/index.html"><strong aria-hidden="true">39.1.</strong> README</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Trdthg&#x27;s Self</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://thenewstack.io/using-rustlangs-async-tokio-runtime-for-cpu-bound-tasks/</p>
<p><strong>翻译：<a href="https://github.com/trdthg">trdthg</a></strong></p>
<p>选题：<a href="https://github.com/Akagi201">Akagi201</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="使用-tokio-处理-cpu-密集型任务"><a class="header" href="#使用-tokio-处理-cpu-密集型任务">使用 Tokio 处理 CPU 密集型任务</a></h1>
<p>尽管 async 通常都被应用于异步网络 I/O，但是在这篇文章里，我会像你介绍为什么使用 Tokio 处理 CPU
密集型任务（比如数据分析引擎等）也是一个不错的选择。</p>
<h2 id="tokio-是什么"><a class="header" href="#tokio-是什么">Tokio 是什么？</a></h2>
<p>Rust 本身提供了一个类似于 JavaScript 的异步编程模型。</p>
<p>为了充分利用多核和异步 I/O。一个运行时是必须的，尽管社区有很多异步运行时的选择，但是 Tokio 是事实上的标准。尽管 Tokio 在官网上描述到它是
Rust 语言的一个异步运行时，并且提供了编写网络服务所需要的模块，它也可以被用在其它场景。</p>
<h2 id="为什么使用-tokio-处理-cpu-密集型任务"><a class="header" href="#为什么使用-tokio-处理-cpu-密集型任务">为什么使用 Tokio 处理 CPU 密集型任务</a></h2>
<p>现代化的数据分析引擎总是不可避免的要处理来自客户端的网络请求，以及通过网络和对象存储系统（比如 ASW S3、GCP Cloud、Azure
等）进行通信。因此，任何使用 Rust 实现的系统，大多都会用 Tokio 去处理这部分网络相关的服务，或者是一部分文件 I/O 服务。</p>
<p>除了应对网络外，数据分析引擎还需要做大量繁重的的 CPU 计算，消耗大量 CPU
资源去进行诸如：重新组织数据存储、提前计算各种索引、或者是直接回复客户端请求等工作。这些复杂计算通常会被切成许多单独的块（我把它们称为
&quot;任务&quot;），然后被并行的处理，以利用到现代 CPU 的多核特性。</p>
<p>任务调度器会决定哪个任务应该在什么时候运行，它会将任务映射到合适的 CPU 内核或者是线程上。</p>
<p>学术界和工业界对于各种任务调度器、工作池、线程池等已经积累了很多年的研究。</p>
<p>我自己已经实现并且使用过几个自定义的任务调度器。他们在大多数时间 (99.9%)
都工作的很好，但是在处理边缘情况（比如快速停机、任务取消、清理等）时，他们的效果非常不尽人意。由于这些任务调度器使用了较低级别的线程原语，出现线程间竞争的情况比比皆是，所以我不建议这样做。</p>
<p>因此，当我在 Rust 生态中寻找一个任务调度器时，你会很自然的选择 Tokio。Tokio 有很多优势：</p>
<ol>
<li>你只需要 Tokio，并不需要添加其他依赖项。</li>
<li>Tokio 实现了一个复杂的 <a href="https://tokio.rs/blog/2019-10-scheduler">支持任务窃取的调度器</a>。</li>
<li>Tokio 内部实现了对 async/await 的支持。并且有许多相对成熟的库去处理流、异步锁、管道、异步取消等。</li>
<li>Tokio 在 Rust 生态系统中经过了良好测试，并且有着大量使用案例。</li>
<li>Tokio 通常会将正在运行的任务和 <code>Future</code> 放在同一个执行器内，这有利于实现局部缓存。</li>
<li>Tokio 的 <a href="https://tokio.rs/tokio/tutorial">文档</a> 很完善，并且在积极更新维护。</li>
</ol>
<p>因此，选择 Tokio 作为 CPU 密集型任务的任务调度程序是理所应当的，对吧？WROOOOOOOONG！</p>
<h2 id="使用-tokio-的反对意见"><a class="header" href="#使用-tokio-的反对意见">使用 Tokio 的反对意见</a></h2>
<p>选择 Tokio 在我们团队中变成了一个热门话题，到现在依然不是所有人都认可这个决定。在我们做 DataFusion 和 InfluxDB IOx
的早期，我们很担心这个问题。以下是一些反对意见：</p>
<h3 id="tokio-文档的警告"><a class="header" href="#tokio-文档的警告">Tokio 文档的警告：</a></h3>
<p>老版本的 Tokio 文档（比如 1.10 版）里面有一条著名的警告：</p>
<blockquote>
<p>If your code is CPU-bound and you wish to limit the number of threads used to
run it, you should run it on another thread pool such as Rayon.</p>
</blockquote>
<p>如果你的代码要处理 CPU 密集型任务，并且想要尽量减少使用到的线程数，你应该将这些任务分配到另一个线程池比如 Rayon。</p>
<p>这个警告对我们团队和社区都造成了很大的困惑。很多人读了之后都以为 Tokio 永远不应该用来处理 CPU
密集型任务。但是文档的关键其实是说，一个运行时实例（同一个线程池）不应该同时用于 I/O 和 CPU
计算，我们之后澄清了<a href="https://docs.rs/tokio/1.14.0/tokio/#cpu-bound-tasks-and-blocking-code">文档</a>
的意图。</p>
<blockquote>
<p>顺便说一句，Tokio 文档建议用 Rayon 处理 CPU 密集型任务。Rayon
对于很多程序都是很好的解决方案，但是它并不支持异步。如果你的代码中哪怕只有一点需要使用异步，那你就不得不跨过同步和异步的痛苦边界。我还发现实现一个
<a href="http://justinjaffray.com/query-engines-push-vs.-pull/">基于拉取的执行器模型</a>
会更困难，这种模型要求某个任务必须等待所有的输入都准备好在能在 Rayon 中运行</p>
</blockquote>
<h3 id="尾部延迟会拖累你"><a class="header" href="#尾部延迟会拖累你">尾部延迟会拖累你</a></h3>
<p>聪明的人会说：使用 Tokio 处理 CPU
密集型任务会增加请求的<a href="https://medium.com/swlh/hedged-requests-tackling-tail-latency-9cea0a05f577">尾部延迟</a>，这是难以令人接受的。</p>
<p>尾部延迟？🙄</p>
<p>你可能认为：我正在编写一个数据库，尾部延迟听起来像是对于高负载的 Web 服务器的一个学术问题……”</p>
<p>但其实，这也是需要考虑的：思考一下健康检查，健康检查对于使用容器编排系统（比如 Kubernetes）部署的服务是必不可少的。检查的方式通常是发送一个 HTTP
请求到某个 API，例如 <code>/health</code>。如果该请求已经被分派到某一个任务队列中，但是 Tokio 正在忙于使用 CPU 进行大量数据处理任务，那么
Kubernetes 将不能及时得到“系统正常”的响应，你的进程就会被 K8s 杀死。因此得到结论：由于尾部延迟，你不能将 Tokio 用于 CPU
密集型任务。</p>
<p>但是，就像 Tokio 在文档中阐述的，想要防止你的程序在 CPU 完全饱和的情况下被 K8s
误杀，你应该使用两个独立的线程池。一个用来执行对尾部延迟敏感的任务，就比如响应 <code>/health</code> 接口。另一个用来执行 CPU
密集型任务。这些线程池的的最佳线程数需要根据具体需求去调整。</p>
<p>如果你将 Tokio 运行时只是视为一个复杂点的线程池，那么使用多个运行时实例的想法可能更容易接受，我们将在最后使用专用的执行器演示如何实现这个想法。</p>
<h3 id="单任务开销很高"><a class="header" href="#单任务开销很高">单任务开销很高</a></h3>
<p>Tokio 的每个任务开销很高。</p>
<p>对于这点，我一点也不惊讶。人们总是可以实现比 Tokio 运行速度更快的线程池。但是，这些线程池并不是足够稳定，难以应对生产环境的负载，并且他们也不具备像
Tokio 一样的庞大生态系统。</p>
<p>在许多场景下，单任务的开销可以使用“矢量化处理”
来分摊。意思是每个任务回同时处理几千行数据而不是单单一行，你需要将任务分成合理大小的块。你也不能分摊所有工作场景下的开销。但是，对于我们的程序关心的实例来说，Tokio
的任务开销已经微乎其微了</p>
<h2 id="实践"><a class="header" href="#实践">实践</a></h2>
<p>假设你已经被说服了使用 Tokio 去处理 CPU 密集型任务是可行的。现在你应该怎么做？</p>
<p>首先，至关重要的一点是，你的代码应该符合以下原则：异步代码永远不应该花费很长时间才能完成，这一点请参考 Alice Ryhl 的
<a href="https://ryhl.io/blog/async-what-is-blocking/">Async: What is blocking?</a>。这是为了让调度器有机会安排其他事情，比如任务窃取等。</p>
<p>当然了，这个“很长时间”取决于你的程序；Ryhl 建议在优化响应的尾部延迟时，单个异步任务完成时间应该在 10 ~ 100 微秒。我认为在针对 CPU
进行优化时 10~100 毫秒也能有不错的效果。但是在我的测试
<a href="https://github.com/alamb/rust_tokio_overhead">estimated per-task Tokio overhead</a>
中，Tokio 单任务的开销在约 10 纳秒范围内，因此几乎不可能用 10 毫秒的任务来测量 Tokio 运行时开销。</p>
<p>其次，将任务分派到一个单独的执行器</p>
<h3 id="专用的执行器"><a class="header" href="#专用的执行器">专用的执行器</a></h3>
<p>这里是一个简单的例子，演示了我们如何在 InfluxDB IOx 上将任务分配到一个单独的 Tokio
运行时上（完整代码可以在我们的<a href="https://github.com/influxdata/influxdb_iox/blob/fe155e15fb2ad166aee66b0458e63c24a8128dd4/query/src/exec/task.rs#L101-L118">仓库</a>里查看，里面还有关于清理、停机、合并的内容）</p>
<pre><code class="language-rs">pub struct DedicatedExecutor {
    state: Arc&lt;Mutex&lt;State&gt;&gt;,
}

/// Runs futures (and any `tasks` that are `tokio::task::spawned` by
/// them) on a separate Tokio Executor
struct State {
    /// Channel for requests -- the dedicated executor takes requests
    /// from here and runs them.
    requests: Option&lt;std::sync::mpsc::Sender&lt;Task&gt;&gt;,

    /// Thread which has a different Tokio runtime
    /// installed and spawns tasks there
    thread: Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;,
}

impl DedicatedExecutor {
    /// Creates a new `DedicatedExecutor` with a dedicated Tokio
    /// executor that is separate from the threadpool created via
    /// `[tokio::main]`.
    pub fn new(thread_name: &amp;str, num_threads: usize) -&gt; Self {
        let thread_name = thread_name.to_string();

        let (tx, rx) = std::sync::mpsc::channel::&lt;Task&gt;();

        let thread = std::thread::spawn(move || {
            // Create a new Runtime to run tasks
            let runtime = Tokio::runtime::Builder::new_multi_thread()
                .enable_all()
                .thread_name(&amp;thread_name)
                .worker_threads(num_threads)
                // Lower OS priority of worker threads to prioritize main runtime
                .on_thread_start(move || set_current_thread_priority_low())
                .build()
                .expect(&quot;Creating Tokio runtime&quot;);

         // Pull task requests off the channel and send them to the executor
         runtime.block_on(async move {
                while let Ok(task) = rx.recv() {
                    Tokio::task::spawn(async move {
                        task.run().await;
                    });
                }

        let state = State {
            requests: Some(tx),
            thread: Some(thread),
        };

        Self {
            state: Arc::new(Mutex::new(state)),
        }
    }
</code></pre>
<p>这段代码会在一个新线程 <code>std::thread</code>，并在这个线程里创建了一个新的 Tokio 运行时。运行时会从 <code>channel</code> 获取任务并运行。</p>
<p>注意：这个新的线程很关键，如果你尝试在主线程里或者是任何已经创建过 Tokio 运行时的线程里再次创建新的运行时，程序就会报错，因为已经有一个运行时了。</p>
<p>下面的代码将任务分派到第二个运行时。</p>
<pre><code class="language-rs">impl DedicatedExecutor {

    /// Runs the specified Future (and any tasks it spawns) on the
    /// `DedicatedExecutor`.
    pub fn spawn&lt;T&gt;(&amp;self, task: T) -&gt; Job&lt;T::Output&gt;
    where
        T: Future + Send + 'static,
        T::Output: Send + 'static,
    {
        let (tx, rx) = tokio::sync::oneshot::channel();

        let fut = Box::pin(async move {
            let task_output = task.await;
            tx.send(task_output).ok()
        });
        let mut state = self.state.lock();
        let task = Task {
            fut,
        };

        if let Some(requests) = &amp;mut state.requests {
            // would fail if someone has started shutdown
            requests.send(task).ok();
        } else {
            warn!(&quot;tried to schedule task on an executor that was shutdown&quot;);
        }

        Job { rx, cancel }
    }
}
</code></pre>
<p>上面的代码使用了一个名为 Job 的结构体，它是一个对 Future 的简单包装，Job 能够将 Future
的执行结果从单独的执行器内传输回主线程。相关代码如下。</p>
<pre><code class="language-rs">#[pin_project(PinnedDrop)]
pub struct Job&lt;T&gt; {
    #[pin]
    rx: Receiver&lt;T&gt;,
}

impl&lt;T&gt; Future for Job&lt;T&gt; {
    type Output = Result&lt;T, Error&gt;;

    fn poll(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut std::task::Context&lt;'_&gt;,
    ) -&gt; std::task::Poll&lt;Self::Output&gt; {
        let this = self.project();
        this.rx.poll(cx)
    }
}
</code></pre>
<p>就是这样！你可以在
<a href="https://gist.github.com/alamb/bd0e086448ef9b438aeebd6f550e23ed">Github gist</a>
中找到所有代码。</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://lucumr.pocoo.org/2021/11/14/abusing-serde/</p>
<p><strong>翻译：<a href="https://github.com/trdthg">trdthg</a></strong></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="rust-冒险滥用-serde"><a class="header" href="#rust-冒险滥用-serde">Rust 冒险：滥用 Serde</a></h1>
<p>当你让一个 Rust 程序员指出自己最喜欢的东西时，他们会很快的指出 serde 是一个让工作愉快好帮手。serde 是一个 Rust
的序列化和反序列化框架。它的格式相对独立，可以让你处理 JSON，YAML 以及一系列不同的格式。</p>
<p>除了上面的之外，还有很多东西可以用 serve 完成。我认为有一些用例相当有趣，值得分享。</p>
<h2 id="滥用序列化"><a class="header" href="#滥用序列化">滥用序列化</a></h2>
<p><em>Abusing Serialization</em></p>
<p>其中一个有趣的用例是用 serde 作为某种形式的反射框架，将结构体暴露给其他的不能原生支持 Rust
结构体的环境。在这些情况下，作为一个开发者，你序列化了一个可以被序列化的对象，接着立即以某种稍微不同的格式再次反序列化它。相比于反序列化，我们也可以自定义一个序列化器用来
'捕获' 序列化的调用。这是在 IPC，模板引擎上下文、格式转换中常用的模式。</p>
<p>这在实践中大概是什么样呢？让我们从用户的角度看一下我写的 <a href="https://github.com/mitsuhiko/minijinja">MiniJinja</a>
模板引擎。MiniJinja 使用 serde 作为核心数据模型，将结构化的数据传递给模板，以便它们可以在运行时进行评估。下面是一些给开发者的示例代码：</p>
<pre><code class="language-rs">#[derive(Serialize, Debug)]
pub struct User {
    name: String,
}

fn main() {
    let mut env = Environment::new();
    env.add_template(&quot;hello.txt&quot;, &quot;Hello {{ user.name }}!&quot;)
        .unwrap();
    let template = env.get_template(&quot;hello.txt&quot;).unwrap();
    let user = User {
        name: &quot;John&quot;.into(),
    };
    println!(&quot;{}&quot;, template.render(context!(user)).unwrap());
}
</code></pre>
<p>如你所见，我们定义了一个叫 User 的结构体，可以使用默认的 Serialize 实现将它序列化。这个对象接着被传递到
<code>context!()</code>。<code>context!()</code> 所做的就是创建了一个 map，然后将一个键设为
user，接着设置为该变量的值。这样做的目的是允许模板引擎访问到 user 的 '属性'，例如 name。Rust
不是动态语言，这意味着通常在运行时做这样的事情是不可能的。但是由于 serde 为 User 实现了
Seralize，我们可以这样做。具体的实现大致如下（伪代码）：</p>
<pre><code class="language-rs">impl Serialize for User {
    fn serialize(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
        where S: Serializer
    {
        let s = serializer.serialize_struct(&quot;User&quot;, 1);
        s.serialize_field(&quot;name&quot;, &amp;self.name)?;
        s.end()
    }
}
</code></pre>
<p>正常情况下，serializer 是一个类似于 JSON 序列化器的东西，它可以将结构体写入到一个字符串或者是文件，在这个过程中把它编码为 JSON。但是
serde 提供的接口并不要求用户必须这样。实际上，MiniJinja 直接将结构体编码为一个内存中的结构，模板引擎可以解析它。</p>
<p>这种模式并不新颖，serde 本身其实也有使用。当你使用 serde 的 flatter 功能时，serde 会启用一个内部缓冲模式，数据会被存储在一个内部的
Context 类型中，Context 类型可以表示 serde 数据模型的全部内容。然后这个 context 可以被传递给另一个序列化器中。</p>
<p>我不仅在 MiniJinja，同时也在 <a href="https://insta.rs/">insta</a>
（一个快照测试工具）使用到这种模式。为了避免由于非确定性数据导致的测试快照的不稳定性，我首先将其序列化为一种内部的格式，接着在该格式上进行一个再加工，最后再将其序列化为最终的格式（例如
YAML）。</p>
<h2 id="tls-恶作剧"><a class="header" href="#tls-恶作剧">TLS 恶作剧</a></h2>
<p><em>TLS Shenanigans</em></p>
<blockquote>
<p>TLS：Thread Local Storage，Shenanigans：恶作剧</p>
</blockquote>
<p>然而，MiniJinja 在此处使用 serde 的有趣之处在于，它允许在序列化和序列化器之间传递不兼容的数据。如前所述，serde
有一个特定的数据模型，不符合该数据模型的东西都会遇到这个问题。例如，serde 可以编码的最大整型是
i128。如果你需要一个任意精度的整型，那就不走运了。但是还是有办法的，你可以使用
<a href="https://en.wikipedia.org/wiki/In-band_signaling">带内信令（in-band signalling）</a>传递额外数据。例如，serde
JSON 序列化器能够表示任意精度整型，因为它在单值对象中保留了一个特殊的键，并用它去指示 JSON 序列化 /
反序列化器组合，决定这个任意精度的整型是否要被序列化。它看起来像这样：</p>
<pre><code class="language-json">{ &quot;$serde_json::private::Number&quot;: &quot;value&quot; }
</code></pre>
<p>但是你应该能发现，如果一个人给出了这样的 JSON 文档，serde JSON 会把它当作任意精度的整形去解析，这意味着 'value' 部分本身也需要于
serde 兼容。对于任意精度的整型，这没有问题，因为它可以用字符串表示。但是假如你想在序列化和反序列化中传递的东西根本不能序列化呢？</p>
<p>这时，巧妙地利用 <strong>thread local</strong> 就是一种变通方法。</p>
<p>在 MiniJinja 中，运行时值的内部表示是一个叫做 <code>Value</code>
的结构体。正如你所期望的，它可以容纳整型，浮点数，字符串，列表，对象等等。然而，他也可以容纳一些 serde
完全无法解析的类型。特别是它可以保存一种特殊类型的字符串，称为 <code>'safe' string</code>, 它是一个存储了安全的 HTML
代码的字符串，不需要转义，也不需要所谓的 '动态值'。后者特别有趣，因为它不能被序列化。</p>
<p>什么是动态值？它实际上是具有状态的对象的句柄，应该直接传递给模板。这里的一个例子是 MiniJinja 中的 loop 变量：</p>
<pre><code class="language-rs">&lt;ul&gt;
{% for item in seq %}
    &lt;li&gt;{{ loop.index }}: {{ item }}&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</code></pre>
<p>MiniJinja（类似于 Jinja2）提供了一个特殊的 loop 变量可以访问循环的状态。例如，你可以通过 <code>loop.index</code>
来获取当前循环的迭代次数。在 MiniJinja 的工作原理中，'循环控制器' 本身会被直接传递给模板，并且把值本身当作引用计数存进去。</p>
<pre><code class="language-rs">pub struct LoopState {
    len: AtomicUsize,
    idx: AtomicUsize,
}

let controller = Rc::new(LoopState {
    idx: AtomicUsize::new(!0usize),
    len: AtomicUsize::new(len),
});
</code></pre>
<p>当循环迭代时，控制器上的索引会 +1。</p>
<pre><code class="language-rs">controller.idx.fetch_add(1, Ordering::Relaxed);
</code></pre>
<p>控制器本身会被直接添加到上下文中：</p>
<pre><code class="language-rs">let template_side_controller = Value::from_object(controller);
</code></pre>
<p>为了达到这个目的，控制器需要实现 MiniJinja 内部的 <code>Object</code> 特征，下面是一个最小实现：</p>
<pre><code class="language-rs">impl Object for LoopState {
    fn attributes(&amp;self) -&gt; &amp;[&amp;str] {
        &amp;[&quot;index&quot;, &quot;length&quot;][..]
    }

    fn get_attr(&amp;self, name: &amp;str) -&gt; Option&lt;Value&gt; {
        let idx = self.idx.load(Ordering::Relaxed) as u64;
        let len = self.len.load(Ordering::Relaxed) as u64;
        match name {
            &quot;index&quot; =&gt; Some(Value::from(idx + 1)),
            &quot;length&quot; =&gt; Some(Value::from(len)),
            _ =&gt; None,
        }
    }
}
</code></pre>
<p>在模板引擎那一边，系统知道当 <code>index</code> 属性被使用时，需要调用 <code>get_attr()</code> 方法。</p>
<p>到目前为止我们所说的都是理论，serde 究竟是如何做的呢？当 <code>Value::from_object</code> 调用时，传入的值会被 <code>move</code> 到 value
对象里。这样做不需要特殊处理，特别是由于已经使用了引用计数。但是现在的问题是，对于像 <code>LoopState</code> 这样本身没有实现 <code>Serialize</code>
的东西，它的值是如何被序列化的？答案是线程本地存储（thread local storage）和一个合作的（co-operating）序列化和反序列化器。</p>
<h2 id="越过边界的-state"><a class="header" href="#越过边界的-state">越过边界的 State</a></h2>
<p><em>Out of Bound State</em></p>
<p>隐藏在 MiniJinja 的 Value 实现有这样一段代码：</p>
<pre><code class="language-rs">const VALUE_HANDLE_MARKER: &amp;str = &quot;\x01__minijinja_ValueHandle&quot;;
thread_local! {
     static INTERNAL_SERIALIZATION: AtomicBool = AtomicBool::new(false);
     static LAST_VALUE_HANDLE: AtomicUsize = AtomicUsize::new(0);
     static VALUE_HANDLES: RefCell&lt;BTreeMap&lt;usize, Value&gt;&gt; = RefCell::new(BTreeMap::new());
 }

fn in_internal_serialization() -&gt; bool {
    INTERNAL_SERIALIZATION.with(|flag| flag.load(atomic::Ordering::Relaxed))
}
</code></pre>
<p>它们的用处是，Value
自身能够感知到什么时候使用内部序列化的特殊形式。这种内部序列化是一种特殊形式的序列化，我们明确知道我们的序列化数据的接收者是一个可以理解该数据的反序列化器。我们没有直接对数据进行序列化，而是将其存入到
TLS 中，然后把数据的句柄序列化到 serde 序列化器中。反序列化器会先反序列化句柄，接着再从 TLS 中提取值。</p>
<p>因此，我们的循环控制器序列化的实现大致如下：</p>
<pre><code class="language-rs">impl Serialize for Value {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: Serializer,
    {
        // enable round tripping of values
        if in_internal_serialization() {
            use serde::ser::SerializeStruct;
            let handle = LAST_VALUE_HANDLE.with(|x| x.fetch_add(1, atomic::Ordering::Relaxed));
            VALUE_HANDLES.with(|handles| handles.borrow_mut().insert(handle, self.clone()));
            let mut s = serializer.serialize_struct(VALUE_HANDLE_MARKER, 1)?;
            s.serialize_field(&quot;handle&quot;, &amp;handle)?;
            return s.end();
        }

        // ... here follows implementation for serializing to JSON etc.
    }
}
</code></pre>
<p>如果它被序列化为 JSON，我们大致能看到这样的东西：</p>
<pre><code class="language-json">{ &quot;\u0001__minijinja_ValueHandle&quot;: 1 }
</code></pre>
<p>而真正的循环控制器将被存储在 <code>VALUE_HANDLES</code> 中句柄为 1 处。现在我们如何从里面的到数值呢？在 MiniJinja
中，反序列化其实从未发生，只有序列化。而且序列化也只是将内存中的对象组装起来。因此，我们只需要让序列化器理解带内信令如何处理，并以此找到带外的值。</p>
<pre><code class="language-rs">impl ser::SerializeStruct for SerializeStruct {
    type Ok = Value;
    type Error = Error;

    fn serialize_field&lt;T: ?Sized&gt;(&amp;mut self, key: &amp;'static str, value: &amp;T) -&gt; Result&lt;(), Error&gt;
    where
        T: Serialize,
    {
        let value = value.serialize(ValueSerializer)?;
        self.fields.insert(key, value);
        Ok(())
    }

    fn end(self) -&gt; Result&lt;Value, Error&gt; {
        match self.name {
            VALUE_HANDLE_MARKER =&gt; {
                let handle_id = self.fields[&quot;handle&quot;].as_usize();
                Ok(VALUE_HANDLES.with(|handles| {
                    let mut handles = handles.borrow_mut();
                    handles
                        .remove(&amp;handle_id)
                        .expect(&quot;value handle not in registry&quot;)
                }))
            }
            _ =&gt; /* regular struct code */
        }
    }
}
</code></pre>
<h2 id="ser-to-de"><a class="header" href="#ser-to-de">Ser-to-De</a></h2>
<p>上面的例子是你可以滥用的一种方式，但是同样的模式在真实的序列化和反序列化中也可以用到。在 MiniJinja
中，我可以不使用序列化，因为我有效地利用了序列化代码，从一种内存格式转换到另一种内存格式。如果你想在进程间传递数据，情况就会变得棘手一些，实际的序列化就是必要的。例如，你想建立一个
IPC
系统，在进程之间交换数据，这里的挑战是，出于性能的考虑，对于比较大的内存段，你必须使用共享内存，或者是以文件描述符的形式传递打开的文件（因为这些文件有可能是
socket）。在我的实验性 <a href="https://github.com/mitsuhiko/unix-ipc">unix-ipc</a> crate
中，我就是这样做的。</p>
<p>我在这里建立了一个二级缓冲区，它可以放置文件描述符。同样，这里必须使用 TLS。</p>
<p>API 大致如下：</p>
<pre><code class="language-rs">pub fn serialize&lt;S: Serialize&gt;(s: S) -&gt; io::Result&lt;(Vec&lt;u8&gt;, Vec&lt;RawFd&gt;)&gt; {
    let mut fds = Vec::new();
    let mut out = Vec::new();
    enter_ipc_mode(|| bincode::serialize_into(&amp;mut out, &amp;s), &amp;mut fds)
        .map_err(bincode_to_io_error)?;
    Ok((out, fds))
}
</code></pre>
<p>从用户的角度来看，这些都是透明的。当一个 Serailize 实现遇到了一个文件对象时，它可以检查是否应该使用 IPC 的序列化，如果是，它可以把 FD
存起来，<code>enter_ipc_mode</code> 基本上将 fds 绑定到了一个线程局部变量里，接着调用 <code>register_fd</code>
注册它。例如，下面展示了内部句柄的序列化方式：</p>
<pre><code class="language-rs">impl&lt;F: IntoRawFd&gt; Serialize for Handle&lt;F&gt; {
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: ser::Serializer,
    {
        if is_ipc_mode() {
            // effectively a weird version of `into_raw_fd` that does
            // consume
            let fd = self.extract_raw_fd();
            let idx = register_fd(fd);
            idx.serialize(serializer)
        } else {
            Err(ser::Error::custom(&quot;can only serialize in ipc mode&quot;))
        }
    }
}
</code></pre>
<p>然后是反序列化：</p>
<pre><code class="language-rs">impl&lt;'de, F: FromRawFd + IntoRawFd&gt; Deserialize&lt;'de&gt; for Handle&lt;F&gt; {
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Handle&lt;F&gt;, D::Error&gt;
    where
        D: de::Deserializer&lt;'de&gt;,
    {
        if is_ipc_mode() {
            let idx = u32::deserialize(deserializer)?;
            let fd = lookup_fd(idx).ok_or_else(|| de::Error::custom(&quot;fd not found in mapping&quot;))?;
            unsafe { Ok(Handle(Mutex::new(Some(FromRawFd::from_raw_fd(fd))))) }
        } else {
            Err(de::Error::custom(&quot;can only deserialize in ipc mode&quot;))
        }
    }
}
</code></pre>
<p>从用户的角度来看，他只需要通过 IPC channel 传递一个 <code>Handle::new(my_file)</code> 就能实现。</p>
<h2 id="serde-的现状"><a class="header" href="#serde-的现状">Serde 的现状</a></h2>
<p><em>State of Serde</em></p>
<p>不幸的是，上面所有的东西都依赖线程本地变量和对内信令。整体上都不是很好，如果有一天出了 serde 2.0，我希望有更好的方法实现上面的内容。</p>
<p>实际上，现在的 serde 仍然有不少问题和上述的 Hack 行为相关。</p>
<ul>
<li><a href="https://github.com/serde-rs/serde/issues/1463">serde requires in-band signalling</a></li>
<li><a href="https://github.com/serde-rs/serde/issues/1183">Internal buffering disrupts format-specific deserialization features</a></li>
<li><a href="https://github.com/serde-rs/json/issues/721">serde_json's arbitrary precision feature incompatible with flatten</a></li>
</ul>
<p>说到这里，在我们需要重写 serde 之前，肯定还有进一步可以被滥用的地方。但是现在是时候应该慢慢考虑 serve
未来版本的设想了它应该对数据模型的支持更友好，可以用更少的 Hack 来脱离规定框架。</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://lucumr.pocoo.org/2022/1/6/rust-extension-map/</p>
<p><strong>翻译：<a href="https://github.com/trdthg">trdthg</a></strong></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="拓展-rust-中的-map"><a class="header" href="#拓展-rust-中的-map">拓展 Rust 中的 Map</a></h1>
<p>在 Rust 中，如果你想为用户提供一个灵活的 API，一般可以引入泛型参数。以一个 web
框架为例，它可能需要一个程序类型，并且需要传递给很多函数。这个程序类型需要能够以配置的形式被参数化。</p>
<h2 id="引入-any-特征"><a class="header" href="#引入-any-特征">引入 Any 特征</a></h2>
<p>一个解决方法是使用 <code>Any</code> 特征。它需要一个 <code>'static</code> 的生命周期，当你之后使用它时，还需要用 <code>Box</code>
进行装箱。比如我们可能对它进行向下转型，即转换为原始的类型。这意味着你可以在某个地方（比如我们的 App）中存储和获取任意类型。</p>
<p>我们期望的 API 大致如下：</p>
<pre><code class="language-rs">let app = App::new();

// place in extension map
app.extensions().insert(Config { ... });
app.extensions().insert(Database { ... });

// retrieve from extension map
let config = app.extensions().get::&lt;Config&gt;();
</code></pre>
<p>我们的 app 需要容纳其他拓展的类型，以便之后使用。</p>
<p>现在，让我们试试最简单的实现方式：准备一个 <code>Extensions</code> 对象，让它实现插入和获取的方法。如果一个拓展还不存在，我们就自动插入一个默认的（需要实现
<code>Default</code> 特征）。</p>
<pre><code class="language-rs">use std::collections::HashMap;
use std::any::{Any, TypeId};

#[derive(Default)]
pub struct Extensions {
    map: HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;,
}

impl Extensions {
    pub fn insert&lt;T: 'static&gt;(&amp;mut self, value: T) {
        self.map.insert(TypeId::of::&lt;T&gt;(), Box::new(value));
    }

    pub fn get&lt;T: 'static&gt;(&amp;self) -&gt; &amp;T {
        self.map.get(&amp;TypeId::of::&lt;T&gt;())
            .and_then(|b| b.downcast_ref())
            .unwrap()
    }

    pub fn get_mut&lt;T: Default + 'static&gt;(&amp;mut self) -&gt; &amp;mut T {
        self.ensure::&lt;T&gt;();
        self.map.get_mut(&amp;TypeId::of::&lt;T&gt;())
            .and_then(|b| b.downcast_mut())
            .unwrap()
    }

    fn ensure&lt;T: Default + 'static&gt;(&amp;mut self) {
        if self.map.get(&amp;TypeId::of::&lt;T&gt;()).is_none() {
            self.insert(T::default());
        }
    }
}
</code></pre>
<p>上面的代码非常直接，但是存在两个问题：首先，只有 <code>get_mut</code> 能够调用 <code>ensure</code> 去插入默认值，如果有人直接调用 <code>get</code> 就会导致
panic。第二个问题是，借用检查器会让之后的编写非常困难。上面的 map 对于解决经典的问题（例如 app）是很有用的，你只需要配置一次，自那之后 map
就像是被冻结了一样，因为有太多的引用在飞来分飞去，以至于没有人能够得到 <code>&amp;mut</code> 的引用。</p>
<p>how does it work？</p>
<p>上面的代码是如何做到的呢，Rust 中的每一种类型都会有一个 type ID，你可以使用 <code>TypeId::of::&lt;T&gt;()</code>
获取。他是唯一的，你可以用它进行比较，或者是作为 map 的键来使用。每种类型只允许有一个值。接着我们把 T 作为 <code>dyn Any</code> 存储在 map
里，<code>Any</code> 特征允许我们使用 <code>downcast_ref</code> 和 <code>downcast_mut</code> 方法拿到原始类型。由于我们使用了 ensure
方法确保这里的类型存在，因此可以安全的 unwrap。</p>
<h2 id="内部可变性"><a class="header" href="#内部可变性">内部可变性</a></h2>
<p>让我们看一个 web 框架或者是模板引擎的常见案例。以
<a href="https://github.com/mitsuhiko/minijinja">MiniJinja</a>（模板引擎）为例，它里面有一个 State
对象，每次模板初始化时都会创建一次，State 没有实现 Send 和 Sync，MiniJinja 在评估时需要 State。如果你想让用户能够放入自定义的
State 呢？在这种情况下，我们可以通过在内部使用 <code>RefCell</code> 来调整上面的类型。</p>
<pre><code class="language-rs">use std::collections::HashMap;
use std::any::{Any, TypeId};
use std::cell::{Ref, RefCell, RefMut};

#[derive(Default)]
pub struct Extensions {
    map: RefCell&lt;HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;&gt;,
}

impl Extensions {
    pub fn insert&lt;T: 'static&gt;(&amp;self, value: T) {
        self.map.borrow_mut().insert(TypeId::of::&lt;T&gt;(), Box::new(value));
    }

    pub fn get&lt;T: Default + 'static&gt;(&amp;self) -&gt; Ref&lt;'_, T&gt; {
        self.ensure::&lt;T&gt;();
        Ref::map(self.map.borrow(), |m| {
            m.get(&amp;TypeId::of::&lt;T&gt;())
                .and_then(|b| b.downcast_ref())
                .unwrap()
        })
    }

    pub fn get_mut&lt;T: Default + 'static&gt;(&amp;self) -&gt; RefMut&lt;'_, T&gt; {
        self.ensure::&lt;T&gt;();
        RefMut::map(self.map.borrow_mut(), |m| {
            m.get_mut(&amp;TypeId::of::&lt;T&gt;())
                .and_then(|b| b.downcast_mut())
                .unwrap()
        })
    }

    fn ensure&lt;T: Default + 'static&gt;(&amp;self) {
        if self.map.borrow().get(&amp;TypeId::of::&lt;T&gt;()).is_none() {
            self.insert(T::default());
        }
    }
}
</code></pre>
<p>从用户的角度来看，几乎没有变化。主要的区别是你不需要一个可变引用就能调用 <code>get_mut</code>，这一壮举是由 <code>RefCell</code> 实现的，Refcell
能够将检查移动到运行时。当一个 <code>RefMut</code> 被给出时，如果已经存在任何的可变或不可变引用，就会发生
panic。对于这里的用户来说，这并不是一个很大的问题，因为我们可以很容易地确保只有一个可变的引用在使用。特别棒的是，Ref 和 RefMut
类型提供了一个静态的 map 方法，让你可以轻松派生出另一个 Ref 或 RefMut，并保持原来的引用，但对值进行转换。</p>
<h2 id="同步支持"><a class="header" href="#同步支持">同步支持</a></h2>
<p>如果我们想要用 Send 和 Sync 来实现和上面相同的效果呢？我们需要一个锁。可惜的是标准库提供的 Mutex 和 RwLock 不能让你在拿到锁的同时
map，你可以使用 <code>parking_lot</code> 替代，它实现了必要的一些方法。</p>
<pre><code class="language-rs">use parking_lot::{
    MappedRwLockReadGuard,
    MappedRwLockWriteGuard,
    RwLock,
    RwLockReadGuard,
    RwLockWriteGuard,
};
use std::any::{Any, TypeId};
use std::collections::HashMap;

#[derive(Default)]
pub struct Extensions {
    map: RwLock&lt;HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;&gt;,
}

impl Extensions {
    pub fn insert&lt;T: Send + Sync + 'static&gt;(&amp;self, value: T) {
        self.map.write().insert(TypeId::of::&lt;T&gt;(), Box::new(value));
    }

    pub fn get&lt;T: Send + Sync + Default + 'static&gt;(&amp;self) -&gt; MappedRwLockReadGuard&lt;'_, T&gt; {
        self.ensure::&lt;T&gt;();
        RwLockReadGuard::map(self.map.read(), |m| {
            m.get(&amp;TypeId::of::&lt;T&gt;())
                .and_then(|b| b.downcast_ref())
                .unwrap()
        })
    }

    pub fn get_mut&lt;T: Send + Sync + Default + 'static&gt;(&amp;self) -&gt; MappedRwLockWriteGuard&lt;'_, T&gt; {
        self.ensure::&lt;T&gt;();
        RwLockWriteGuard::map(self.map.write(), |m| {
            m.get_mut(&amp;TypeId::of::&lt;T&gt;())
                .and_then(|b| b.downcast_mut())
                .unwrap()
        })
    }

    fn ensure&lt;T: Default + Send + Sync + 'static&gt;(&amp;self) {
        if self.map.read().get(&amp;TypeId::of::&lt;T&gt;()).is_none() {
            self.insert(T::default());
        }
    }
}
</code></pre>
<p>注意：由于 Any 并没有实现 Debug，所以我们很难为我们的 map 实现 Debug 特征，一些简单的改变并不能解决目前的问题。下半部分我们将介绍
<code>as-any</code> 模式</p>
<p>我们面临的挑战是，在 Rust 里，你不能使用 <code>Box&lt;Any + Debug&gt;</code>，然而还是有一些方法解决这个问题。</p>
<h2 id="为-map-实现-debug"><a class="header" href="#为-map-实现-debug">为 map 实现 Debug</a></h2>
<h3 id="简化问题"><a class="header" href="#简化问题">简化问题</a></h3>
<p>我们的目标是对 <code>Box&lt;dyn Any&gt;</code> 做一个包装，并让 Wrapper 实现 Debug。</p>
<pre><code class="language-rs">#[derive(Debug)]
struct AnyBox(Box&lt;dyn Any + Debug&gt;);
</code></pre>
<p>如果你尝试编译，编译器应该会很不高兴的抛出错误：</p>
<pre><code class="language-rs">error[E0225]: only auto traits can be used as additional traits in a trait object
 --&gt; src/main.rs:9:29
  |
9 | struct AnyBox(Box&lt;dyn Any + Debug&gt;);
  |                       ---   ^^^^^ additional non-auto trait
  |                       |
  |                       first non-auto trait
  |
  = help: consider creating a new trait with all of these as supertraits and
    using that trait here instead: `trait NewTrait: Any + Debug {}`
</code></pre>
<h3 id="超级特征"><a class="header" href="#超级特征">超级特征</a></h3>
<p>幸运的是，编译器再次为我们指明了解决之道，我们需要创建一个父特征，并利用特征约束。同时，我们为所有实现了 Any 和 Debug
的类型实现我们的超级特征。就像下面这样：</p>
<pre><code class="language-rs">#[derive(Debug)]
struct AnyBox(Box&lt;dyn DebugAny&gt;);

trait DebugAny: Any + Debug {}

impl&lt;T: Any + Debug + 'static&gt; DebugAny for T {}
</code></pre>
<p>你可以想这样构建一个 Box，但是真正不能通过编译的是向下转型</p>
<pre><code class="language-rs">fn main() {
    let any_box = AnyBox(Box::new(42i32));
    dbg!(any_box.0.downcast_ref::&lt;i32&gt;());
}
</code></pre>
<p>编译器会告诉我们，AnyBox 中的值并没有 <code>downcast_ref</code> 方法</p>
<pre><code class="language-rs">error[E0599]: no method named `downcast_ref` found for struct
  `Box&lt;(dyn DebugAny + 'static)&gt;` in the current scope
  --&gt; src/main.rs:15:20
   |
15 |     dbg!(any_box.0.downcast_ref::&lt;i32&gt;());
   |                    ^^^^^^^^^^^^ method not found in `Box&lt;(dyn DebugAny + 'static)&gt;`
</code></pre>
<p>原因是 <code>Box&lt;dyn DebugAny&gt;</code> 并不是 <code>Box&lt;dyn Any&gt;</code>，因此我们不能那里得到 Any
特征拥有的方法。那么我们如何解决这个问题呢？最简单的方法是 <strong>&quot;as any&quot;</strong> 模式，我们在我们的 DebugAny
特征上实现一个方法，将其向上转换为一个 Any。看起来像这样：</p>
<pre><code class="language-rs">trait DebugAny: Any + Debug {
    fn as_any(&amp;self) -&gt; &amp;dyn Any;
    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any;
}

impl&lt;T: Any + Debug + 'static&gt; DebugAny for T {
    fn as_any(&amp;self) -&gt; &amp;dyn Any { self }
    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any { self }
}
</code></pre>
<p>现在虽然我们依然不能在 DebugAny 上调用 <code>downcast_ref</code>，但是我们可以拿走它的值，并调用 <code>as_any</code> 得到一个
<code>&amp;dyn Any</code>：</p>
<pre><code class="language-rs">fn main() {
    let any_box = AnyBox(Box::new(42i32));
    dbg!(any_box.0.as_any().downcast_ref::&lt;i32&gt;());
    dbg!(&amp;any_box);
}
</code></pre>
<p>但是当我们运行后，却得到了一个 None。发生什么事了？？？</p>
<pre><code class="language-rs">[src/main.rs:23] any_box.0.as_any().downcast_ref::&lt;i32&gt;() = None
</code></pre>
<p>这个谜题的答案与方法解析的工作方式和空白实现有关。当我们在 <code>Box&lt;dyn DebugAny&gt;</code> 上调用 <code>as_any</code> 时，Box
并没有发生自动解引用，事实上调用的是 <code>Box&lt;dyn DebugAny&gt;</code> 的 as_any，因为 Box 现在也实现了我们的
DebugAny。那么，我们如何穿过这个 Box 呢？通过手动解引用。</p>
<pre><code class="language-rs">fn main() {
    let any_box = AnyBox(Box::new(42i32));
    dbg!((*any_box.0).as_any().downcast_ref::&lt;i32&gt;());
    dbg!(&amp;any_box);
}
</code></pre>
<p>这样就是我们预期的值了</p>
<pre><code class="language-rs">[src/main.rs:23] (*any_box.0).as_any().downcast_ref::&lt;i32&gt;() = Some(
    42,
)
[src/main.rs:24] &amp;any_box = AnyBox(
    42,
)
</code></pre>
<h2 id="可调试的-extension-map"><a class="header" href="#可调试的-extension-map">可调试的 Extension Map</a></h2>
<p>有了上面的经验，我们现在可以拿出之前的非同步 map，稍加改造就能为其实现 Debug。</p>
<pre><code class="language-rs">use std::any::{Any, TypeId};
use std::cell::{Ref, RefCell, RefMut};
use std::collections::HashMap;
use std::fmt::Debug;

trait DebugAny: Any + Debug {
    fn as_any(&amp;self) -&gt; &amp;dyn Any;
    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any;
}

impl&lt;T: Any + Debug + 'static&gt; DebugAny for T {
    fn as_any(&amp;self) -&gt; &amp;dyn Any { self }
    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any { self }
}

#[derive(Default, Debug)]
pub struct Extensions {
    map: RefCell&lt;HashMap&lt;TypeId, Box&lt;dyn DebugAny&gt;&gt;&gt;,
}

impl Extensions {
    pub fn insert&lt;T: Debug + 'static&gt;(&amp;self, value: T) {
        self.map
            .borrow_mut()
            .insert(TypeId::of::&lt;T&gt;(), Box::new(value));
    }

    pub fn get&lt;T: Default + Debug + 'static&gt;(&amp;self) -&gt; Ref&lt;'_, T&gt; {
        self.ensure::&lt;T&gt;();
        Ref::map(self.map.borrow(), |m| {
            m.get(&amp;TypeId::of::&lt;T&gt;())
                .and_then(|b| (**b).as_any().downcast_ref())
                .unwrap()
        })
    }

    pub fn get_mut&lt;T: Default + Debug + 'static&gt;(&amp;self) -&gt; RefMut&lt;'_, T&gt; {
        self.ensure::&lt;T&gt;();
        RefMut::map(self.map.borrow_mut(), |m| {
            m.get_mut(&amp;TypeId::of::&lt;T&gt;())
                .and_then(|b| (**b).as_any_mut().downcast_mut())
                .unwrap()
        })
    }

    fn ensure&lt;T: Default + Debug + 'static&gt;(&amp;self) {
        if self.map.borrow().get(&amp;TypeId::of::&lt;T&gt;()).is_none() {
            self.insert(T::default());
        }
    }
}
</code></pre>
<p>向 map 里面添加点东西，打印一下：</p>
<pre><code class="language-rs">[src/main.rs:63] &amp;extensions = Extensions {
    map: RefCell {
        value: {
            TypeId {
                t: 13431306602944299956,
            }: 42,
        },
    },
}
</code></pre>
<p>在这个例子中，我在 map 中放置了一个 32 位的整数 42，它打印出了作为键的 TypeId，和作为值的 42。</p>
<h2 id="保留类型名称"><a class="header" href="#保留类型名称">保留类型名称</a></h2>
<p>如果你想保留原来的类型名称，而不仅仅是类型的 ID，我们可以使用一个自定义的类型作为 map 的键。通过对 TypeId 和 TypeName
做一次简单的包装就能轻松实现：</p>
<pre><code class="language-rs">use std::any::{TypeId, type_name};
use std::hash::{Hash, Hasher};
use std::fmt::{self, Debug};

pub struct TypeKey(TypeId, &amp;'static str);

impl TypeKey {
    pub fn of&lt;T: 'static&gt;() -&gt; TypeKey {
        TypeKey(TypeId::of::&lt;T&gt;(), type_name::&lt;T&gt;())
    }
}

impl Hash for TypeKey {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.0.hash(state);
    }
}

impl PartialEq for TypeKey {
    fn eq(&amp;self, other: &amp;Self) -&gt; bool {
        self.0 == other.0
    }
}

impl Eq for TypeKey {}

impl Debug for TypeKey {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.1)
    }
}
</code></pre>
<p>接着用它替换掉原来的键，调试一下：</p>
<pre><code class="language-rs">[src/main.rs:90] &amp;extensions = Extensions {
    map: RefCell {
        value: {
            i32: 42,
            alloc::vec::Vec&lt;i32&gt;: [
                1,
                2,
                3,
            ],
        },
    },
}
</code></pre>
<p>注意，我在 map 中额外插入了一个 <code>Vec&lt;i32&gt;</code>，以获得更明显的输出。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="查询引擎推送与拉取"><a class="header" href="#查询引擎推送与拉取">查询引擎：推送与拉取</a></h1>
<p><a href="http://justinjaffray.com/query-engines-push-vs.-pull/">Query Engines: Push vs. Pull</a></p>
<p>考虑以下的 SQL 语句</p>
<pre><code class="language-sql">SELECT DISTINCT customer_first_name
FROM customer
WHERE customer_balance &gt; 0
</code></pre>
<p>查询优化器通常将这样的 SQL 查询编译成一系列离散运算符：
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204202254060.png" alt="" /></p>
<pre><code>Distinct
&lt;- Map(customer_first_name)
&lt;- Select(customer_balance &gt; 0)
&lt;- customer
</code></pre>
<p>在基于 Pull 的系统中，消费者 <code>customers</code> 驱动系统。每个运算符运算后都会产生一个新行：用户将向根节点（Distinct）请求一行，这一行回向
Map 询问一行，接着向 Select 询问一行，依此类推。</p>
<p>在基于 Push 的系统中，生产者 <code>producers</code> 驱动系统。每个运算符，当他接收到数据时，就会告知下游的运算符，<code>customer</code>
作为查询基表回告诉 Select 自己的信息，接着是 Map、Distinct。</p>
<h3 id="pull-based-查询引擎"><a class="header" href="#pull-based-查询引擎">Pull-Based 查询引擎</a></h3>
<p>基于拉取的查询引擎一般也被称为使用 Volcano 或 Iterator 模型。这是最古老和最著名的查询执行模型，并以 1994 年标准化其约定的论文命名。</p>
<p>首先我们有一个关系，我们通过 Scan 把它专为一个迭代器</p>
<pre><code class="language-js">let customer = [
  { id: 1, firstName: &quot;justin&quot;, balance: 10 },
  { id: 2, firstName: &quot;sissel&quot;, balance: 0 },
  { id: 3, firstName: &quot;justin&quot;, balance: -3 },
  { id: 4, firstName: &quot;smudge&quot;, balance: 2 },
  { id: 5, firstName: &quot;smudge&quot;, balance: 0 },
];

function* Scan(coll) {
  for (let x of coll) {
    yield x;
  }
}
</code></pre>
<p>接下来为他实现一些操作符</p>
<pre><code class="language-js">function* Select(p, iter) {
  for (let x of iter) {
    if (p(x)) {
      yield x;
    }
  }
}

function* Map(f, iter) {
  for (let x of iter) {
    yield f(x);
  }
}

function* Distinct(iter) {
  let seen = new Set();
  for (let x of iter) {
    if (!seen.has(x)) {
      yield x;
      seen.add(x);
    }
  }
}
</code></pre>
<p>翻译我们的查询语句</p>
<pre><code class="language-sql">SELECT DISTINCT customer_first_name FROM customer WHERE customer_balance &gt; 0
</code></pre>
<pre><code class="language-js">Distinct(
    Map(
        (c) =&gt; c.firstName,
        Select((c) =&gt; c.balance &gt; 0, Scan(customer))
    )
),
</code></pre>
<h2 id="push-based-查询引擎"><a class="header" href="#push-based-查询引擎">Push-Based 查询引擎</a></h2>
<p>基于推送的查询引擎，有时也称为 Reactive、Observer、Stream 或回调地狱模型，如您所料，与我们之前的示例类似，但它颠覆了它。让我们从定义
Scan 开始</p>
<pre><code class="language-js">let customer = [
  { id: 1, firstName: &quot;justin&quot;, balance: 10 },
  { id: 2, firstName: &quot;sissel&quot;, balance: 0 },
  { id: 3, firstName: &quot;justin&quot;, balance: -3 },
  { id: 4, firstName: &quot;smudge&quot;, balance: 2 },
  { id: 5, firstName: &quot;smudge&quot;, balance: 0 },
];

function Scan(relation, out) {
  for (r of relation) {
    out(r);
  }
}
</code></pre>
<p>我们将“此运算符告诉下游运算符”构建为它需要调用的闭包。</p>
<p>剩下的运算符也是如此</p>
<pre><code class="language-js">function Select(p, out) {
  return (x) =&gt; {
    if (p(x)) out(x);
  };
}

function Map(f, out) {
  return (x) =&gt; {
    out(f(x));
  };
}

function Distinct(out) {
  let seen = new Set();
  return (x) =&gt; {
    if (!seen.has(x)) {
      seen.add(x);
      out(x);
    }
  };
}
</code></pre>
<p>查询语句建模：</p>
<pre><code class="language-js">let result = [];
Scan(
  customer,
  Select(
    (c) =&gt; c.balance &gt; 0,
    Map(
      (c) =&gt; c.firstName,
      Distinct((r) =&gt; result.push(r)),
    ),
  ),
);
</code></pre>
<h2 id="区别"><a class="header" href="#区别">区别</a></h2>
<p>在基于 Pull 的系统中，所有的操作符都是惰性的，只有当数据需要时，操作符才会开始计算（yield）。这也意味着系统的行为和用户的行为紧密耦合。</p>
<p>再基于 Push 的系统中，系统开始处于空闲状态，直到他接受到一行数据。因此系统的工作和消费者是解耦的。</p>
<p>基于 Push 的系统还需要创建一个缓冲区，并将查询结果放到里面。这就是基于 Push 的系统给人的感觉。它会假设消费者不存在，当被请求时，能够立即作出响应。</p>
<h2 id="dag-yo"><a class="header" href="#dag-yo">DAG, yo</a></h2>
<p>SQL 中有一个 With 结构，它允许在查询中多次引用同一个结果集：</p>
<pre><code class="language-sql">WITH foo as (&lt;some complex query&gt;)
SELECT * FROM
    (SELECT * FROM foo WHERE c) AS foo1
  JOIN
    foo AS foo2
  ON foo1.a = foo2.b
</code></pre>
<p>基于 Push 的系统能够优化查询结构，复用结果集，而基于 Pull 的系统无法做到这一点。</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://www.youtube.com/watch?v=rDoqT-a6UFg</p>
<p><strong>翻译：<a href="https://github.com/trdthg">trdthg</a></strong></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://hirust.cn">RustCn</a> 荣誉推出</p>
</blockquote>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205051415470.png?raw=true"  />
<h1 id="可视化-rust-各数据类型的内存布局"><a class="header" href="#可视化-rust-各数据类型的内存布局">可视化 Rust 各数据类型的内存布局</a></h1>
<blockquote>
<p>本文已获得作者翻译许可。由于译者个人能力有限，如有翻译错误，希望读者加以指正。
视频版翻译：<a href="https://www.bilibili.com/video/BV1KT4y167f1/">B 站视频链接</a></p>
</blockquote>
<pre><code class="language-rs">// file: main.rs
fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre>
<p>当我们使用 Rust 中编写程序时，由于 Rust 的 生命周期和所有权模型，你最好为程序可能用到的数据结构做一些前期设计，不然 Rust
编译器可能让你十分痛苦。了解每个数据类型的内存布局有助于锻炼你的直觉，可以提前规避一些编译错误和性能问题。</p>
<p>在这个文章里，我们会讨论</p>
<ul>
<li>在计算机运行二进制文件时发生了什么？</li>
<li>常见数据类型的内存布局 (包括：整形，元组，切片，向量，字符串，结构体，枚举，智能指针，特征对象，还有各种 <code>Fn</code> 特征)</li>
</ul>
<h2 id="二进制数据段"><a class="header" href="#二进制数据段">二进制数据段</a></h2>
<p>当你编写一个 Rust 程序时，要么直接调用 rustc，要不就是通过 cargo 去生成一个可执行文件。</p>
<pre><code class="language-shell">$ rustc main.rs
$ cargo build
</code></pre>
<p>这个二进制文件以一种特定的格式存储数据。对于 linux 系统，最常见的格式是 <code>elf64</code> 。不同的操作系统比如 linux, mac, windows
使用不同的格式。虽然二进制文件的格式不尽相同，但是它在各种的操作系统中的运行方式几乎相同。</p>
<p>常见的二进制文件一般由 <strong>文件头 + 分区</strong> 组成。对于 <code>elf</code> 格式的二进制文件，它的结构大致如下图所示：</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205031746097.png?raw=true"  height = "250"  />
<blockquote>
<p>段的数量根据编译器而不同。这里只展示了一些重要的一些段。</p>
</blockquote>
<p>当你运行二进制文件时</p>
<p>以 <code>elf64</code> 格式的二进制文件为例，在程序运行时，内核会为程序分配一段连续的内存地址，并将这些分区映射到内存中去。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205031816710.png?raw=true"  height = "400" />
<p><strong>注意</strong>：这里的内存地址并不是内存条里实际的内存地址。但是当程序开始使用内存时，内核和硬件会把它们映射到真正的物理内存地址。这被称为
<strong>虚拟地址空间</strong>。一个正在运行的程序被称为一个进程。从进程的角度来看，它只能看到一段连续的内存，从 0 到地址高位的最大值。</p>
<p>下面我们会介绍进程地址空间中各个区域的作用：</p>
<ol>
<li>
<p>代码段 (text)</p>
<p>代码段包含了可执行指令的集合。</p>
<p>编译器能把我们用高级语言写的程序转换为 CPU 可以执行的机器指令，代码段就包含了这些指令。这些指令根据 CPU 架构而有所不同。编译给 x86-64
架构 CPU 运行的二进制文件不能在 ARM 架构的 CPU 上运行。</p>
<p>代码段是 <strong>只读</strong> 的，运行的程序不能更改它。</p>
</li>
<li>
<p>数据段 (data)</p>
<p>数据段包含 <strong>已经初始化</strong> 过的数据。比如全局变量，全局静态变量，局部静态变量。</p>
</li>
<li>
<p>BSS 段 (bss)</p>
<p>bss 代表 <code>Block started by symbol</code>, 这里保存着 <strong>未被初始化</strong> 过的全局变量。由于 bss
段的变量未被初始化，这一段并不会直接占据二进制文件的体积，它只负责记录数据所需空间的大小</p>
</li>
<li>
<p>地址高位</p>
<p>内核会把一些额外的数据，比如环境变量，传递给程序的参数和参数的数量映射到地址高位。</p>
</li>
</ol>
<h2 id="堆--栈"><a class="header" href="#堆--栈">堆 &amp; 栈</a></h2>
<h3 id="堆栈简介"><a class="header" href="#堆栈简介">堆栈简介</a></h3>
<p>当程序运行时（运行态），还需要需要另外两个域：堆和栈</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205031946093.png?raw=true"  height = "400" />
<p><strong>栈</strong>：</p>
<ul>
<li>
<p>操作系统使用栈存储一个进程的抽象细节，包括 (进程名字，进程 ID 等)。</p>
</li>
<li>
<p>一个进程至少有一个执行线程，每一个线程都有自己的栈内存。</p>
</li>
<li>
<p>在 64 位的 linux 系统上，Rust 程序为主线程分配 8MB 的栈内存。对于用户创建的其他线程，rust 标准库支持自定义大小，默认的大小是
2MB。</p>
</li>
<li>
<p>栈内存的空间会从地址高位向低位增长，但是不会超过线程可以拥有的最大值。对于主线程来说就是 8MB。如果它使用的栈内存超过了
8MB，程序就会被内核终止，并返回一个 <code>stackoverflow</code> 错误。</p>
</li>
<li>
<p>栈内存被用于执行函数 (见下方对栈的具体讲解)。</p>
</li>
</ul>
<blockquote>
<p>虽然主线程的栈内存大小有 8MB，但是这 8MB 也不会被立即分配，只有当程序开始使用时，内核才会开始为它分配内存。</p>
</blockquote>
<p><strong>堆</strong>：</p>
<ul>
<li>所有线程共享一块堆内存</li>
<li>堆内存从地址低位向高位增长。</li>
</ul>
<p>操作系统通常会提供一些接口让我们检查程序运行时的内存映射状态，对于 linux 系统，你可以在 <em>/proc/PID/maps</em> 文件中查看</p>
<p>下面展示了一个进程的映射状态（部分）：</p>
<pre><code>$ cat /proc/844154/maps
55e6c3f44000-55e6c412c000 r-xp 00000000 103:03 22331679                  /usr/bin/fish
55e6c412c000-55e6c4133000 r--p 001e7000 103:03 22331679                  /usr/bin/fish
55e6c4133000-55e6c4134000 rw-p 001ee000 103:03 22331679                  /usr/bin/fish
55e6c4134000-55e6c4135000 rw-p 00000000 00:00 0
55e6c4faa000-55e6c5103000 rw-p 00000000 00:00 0                          [heap]
7fd62326d000-7fd62326f000 r--p 00034000 103:03 22285665                  /usr/lib/ld-linux-x86-64.so.2
7fd62326f000-7fd623271000 rw-p 00036000 103:03 22285665                  /usr/lib/ld-linux-x86-64.so.2
7ffecf8c5000-7ffecf8f5000 rw-p 00000000 00:00 0                          [stack]
</code></pre>
<p>你可能会想问：堆内存和栈内存是否会相互覆盖？因为他们两个向对方的方向增长。</p>
<p>通过用 stack 的低位减去 heap 的高位</p>
<pre><code class="language-py">&gt;&gt;&gt; (0x7ffecf8c5000 - 0x55e6c5103000) / (10 ** 12)
46.282743488512
</code></pre>
<p>差距为 47TB，所以栈堆冲突的情况几乎不可能出现</p>
<p>如果确实发生了，内核会提供守卫去终止程序。注意，这里的内存是指虚拟内存，并非电脑的真实内存大小。</p>
<h3 id="cpu-字长"><a class="header" href="#cpu-字长">CPU 字长</a></h3>
<p>虚拟内存地址的范围由 CPU 字长 (word size) 决定，字长是指 CPU 一次可以并行处理的二进制位数，对于 64 位的 CPU 来说，它的字长为
64 位 (8 字节)。CPU 中大多数或者全部寄存器一般都是一样大。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205031946032.png?raw=true" />
<p>因此可以得出：64 位 CPU 的寻址空间为 0 ~ 2^64-1。而对于 32 位的 CPU 来说，它的寻址空间只有从 0 到 2^32，大概 4GB。</p>
<p>目前，在 64 位 CPU 上，我们一般只使用前 48 位用于寻址，大小大概是 282TB 的内存</p>
<pre><code>&gt;&gt;&gt; 2**48 / (10**12)
281.474976710656
</code></pre>
<p>这其中，只有前 47 位是分配给用户空间使用，这意味着大概有 141TB 的虚拟内存空间是为我们的程序分配的，剩下的位于地址高位的 141TB
是为保留给内核使用的。如果你去查看程序的虚拟内存映射，你能使用的最大内存地址应该是 <code>0x7fffffffffff</code></p>
<pre><code>&gt;&gt;&gt; hex(2**47-1)
'0x7fffffffffff'
</code></pre>
<h3 id="栈内存"><a class="header" href="#栈内存">栈内存</a></h3>
<p>接下来让我们深入了解栈内存的用途</p>
<p>在这个例子中，整个程序只有一个主线程在运行，我们在 <code>main</code> 里调用了 <code>add1</code> 函数。</p>
<pre><code class="language-rs">fn main() {
    let a = 22;
    let b = add_one(a);
}

fn add_one(i: i32) -&gt; i32 {
    i + 1
}
</code></pre>
<p>栈主要用来保存正在调用的函数的数据 (包括函数参数，函数的局部变量，和它的返回地址)。为一个运行中的函数分配的总内存被称为一个 <strong>栈帧</strong>。</p>
<ol>
<li>
<p><code>main</code> 函数是程序的入口，首先 <code>main</code> 函数的栈帧被创建。</p>
<p><code>main</code> 函数内部有一个两个 <code>i32</code> 类型的局部变量 <code>a</code> 和 <code>b</code>，大小都是 4 个字节，其中 <code>a</code> 的值为 22。<code>main</code>
函数的栈帧会确保有足够的空间去保存这些局部变量。</p>
<p>ESP 和 EBP 寄存器内分别保存着栈顶指针和栈底指针，用来追踪当前的栈的顶部和底部。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205032036717.png?raw=true"  alt="图片名称"  />
</li>
<li>
<p>当 <code>main</code> 函数调用 <code>add1</code> 时，一个新的栈帧被创建用来保存 <code>add1</code> 函数的数据。栈顶指针被修改为新栈的顶部。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205032039168.png?raw=true"  alt="图片名称"  />
<ol>
<li><code>add1</code> 函数要接受一个 <code>i32</code> 类型的参数，因此 4 字节的空间会被保留在 <code>add1</code> 函数的栈帧上。</li>
<li><code>add1</code> 函数并没有局部变量</li>
<li>栈帧还会保存一个返回地址，当函数运行结束后，会根据该返回地址回到之前的指令。</li>
</ol>
</li>
<li>
<p>函数调用结束</p>
<p>当函数调用结束后，就会把返回值 23 赋值给局部变量 <code>b</code>。同时栈顶指针也被修改。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205032040616.png?raw=true"  alt="图片名称"  />
<blockquote>
<p>注意：函数运行结束后，add1
的栈帧并没有被释放。当你的程序开始调用下一个函数时，新的栈帧会直接将其覆盖。对于栈来说，开辟和释放内存只需要修改栈指针即可。</p>
</blockquote>
</li>
</ol>
<p>由此可见，因为在栈上开辟和释放内存只需要移动指针，不需要进行任何系统调用，它的效率是很高的。</p>
<p>当然栈也有一些限制：</p>
<ul>
<li>只有在编译时已知大小的变量才能被存储在栈上。</li>
<li>函数不能返回一个位于函数内部的局部变量的引用</li>
</ul>
<p>如果你把 add_one 改成下面的样子，就会编译失败：</p>
<pre><code class="language-rs">fn add_one(i: i32) -&gt; &amp;'static i32 {
    let result = i + 1;
    &amp;result
}
</code></pre>
<pre><code>error[E0515]: cannot return reference to local variable `result`
 --&gt; src/main.rs:8:5
  |
8 |     &amp;result
  |     ^^^^^^^ returns a reference to data owned by the current function
</code></pre>
<p>根据我们之前介绍过栈的工作原理，假设你现在返回了一个函数内局部变量的引用，但是当函数返回时，本质上函数的内存就被释放了。当下一个函数被调用时，它的栈帧就会重写这块内存空间。</p>
<p>在一个带有 GC 的语言里，编译器能够检测到这种覆盖，并在会为这个变量在堆上分配一块空间，并返回它的引用。但是在堆上分配会带来部分额外开销。因为 Rust 没有
GC，而且不会强制你去显式的分配堆内存，所以这里会编译失败。</p>
<h3 id="堆内存"><a class="header" href="#堆内存">堆内存</a></h3>
<p>在这个例子里，我们在 <code>main</code> 函数中调用了 <code>heap</code> 函数。</p>
<pre><code class="language-rs">fn main() {
    let result = heap();
}

fn heap() -&gt; Box&lt;i32&gt; {
    let b = Box::new(23);
    b
}
</code></pre>
<p>首先会为两个函数再栈上创建栈帧。接着使用 <code>box</code> 将 23 分配在堆上。然后把 23 在堆上的地址赋值给了变量 <code>b</code>。<code>box</code>
只是一个指针，所以栈上有足够的空间去保存 <code>box</code>。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205032154186.png?raw=true"  alt="图片名称"  />
<blockquote>
<p>在 64 位系统上，指针的大小是 8 字节，所以在栈上的变量 b 的大小是 8 字节。而 b 指向的变量 23 是 <code>i32</code> 类型，它在堆上只需要占用 4
字节。</p>
</blockquote>
<p>当函数调用结束后，<code>heap</code> 函数返回的 <code>box</code> 指针就会被保存在 main 函数的局部变量里。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205032155624.png?raw=true"  alt="图片名称"  />
<p>当你对栈上的数据进行赋值操作时，它的栈内存就会被直接 <code>copy</code> 过去。在这个例子里，用来保存 <code>box</code> 的 8 个字节就是从 <code>heap</code>
函数的栈帧直接复制到 <code>main</code> 的局部变量 <code>result</code>。现在即使 <code>heap</code> 函数的栈帧被释放，<code>result</code>
变量依然保存着数据的地址。堆允许你共享变量。</p>
<h3 id="内存分配器"><a class="header" href="#内存分配器">内存分配器</a></h3>
<p>我们之前提到过每个线程都有各自的栈内存，他们共享一块堆内存。</p>
<p>假设你的程序不断在堆上分配新的数据，现在堆内存几乎耗尽了，需要对堆内存进行扩容。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205032243927.png?raw=true"  alt="图片名称"  />
<p>程序的内存分配器一般会使用系统调用请求操作系统分配更多内存。对于 linux 系统来说，一般是 <code>brk</code> 或者 <code>sbrk</code> 系统调用。</p>
<p>在 Rust 里，堆内存分配器需要实现 <code>GlobalAlloc</code> 特征。你几乎不会直接用到它，编译器会在需要时插入合适的系统调用。</p>
<pre><code class="language-rs">// /rust/library/std/src/sys/unix/alloc.rs
#[stable(feature = &quot;alloc_system_type&quot;, since = &quot;1.28.0&quot;)]
unsafe impl GlobalAlloc for System {
    #[inline]
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
        if layout.align() &lt;= MIN_ALIGN &amp;&amp; layout.align() &lt;= layout.size() {
            libc::malloc(layout.size()) as *mut u8
        }
        ...
    }
    ...
}
</code></pre>
<p>你可能很熟悉 C 语言里的 <code>malloc</code> 函数，但是它并不是系统调用，<code>malloc</code> 依然会调用 <code>brk</code> 或者 <code>sbrk</code> 去请求内核。Rust
的内存分配器依靠 C 标准库里提供的 <code>malloc</code> 函数，如果你使用像 <code>ldd</code> 这样的工具去检查二进制文件依赖的动态链接库，你应该会看到 <code>libc</code></p>
<pre><code class="language-shell">$ ldd target/debug/demo
    linux-vdso.so.1 (0x00007fff60bd8000)
    libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007f08d0c21000)
    /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007f08d0ebf000)
</code></pre>
<blockquote>
<p>Linux 下 Rust 默认使用 GNU 作为链接器，因此 Rust 二进制文件依赖于操作系统上的 C 标准库或者 <code>libc</code> 库。<code>libc</code>
更像是操作系统的一部分，使用像 <code>libc</code> 这样的动态链接库有助于减少二进制文件体积。</p>
</blockquote>
<p>同时，内存分配器也不总是依赖于系统调用在堆上分配内存：</p>
<ol>
<li>
<p>每次程序使用 box 等把数据分配在堆上时，程序的内存分配器都会成块的请求内存去减少系统调用的次数。</p>
</li>
<li>
<p>堆和栈不一样，内存不一定总是在堆的末尾被释放。当一些地方的内存被释放后，它并没有立即返还给操作系统，内存分配器会追踪内存分页，知道那些页正在使用，那些页被释放了。所以当需要更多堆内存时，它可以直接使用这些已经释放但还未归还的内存分页。</p>
</li>
</ol>
<p>现在你应该知道为什么分配堆内存比栈内存更消耗性能了。分配堆内存可能使用到系统调用，而且内存分配器每一次分配内前，都必须从堆上找到一个空闲内存块。</p>
<h2 id="rust-各数据类型的内存布局"><a class="header" href="#rust-各数据类型的内存布局">Rust 各数据类型的内存布局</a></h2>
<h3 id="整形"><a class="header" href="#整形">整形</a></h3>
<table><thead><tr><th>长度 (byte)</th><th>长度 (bit)</th><th>有符号</th><th>无符号</th></tr></thead><tbody>
<tr><td>1 字节</td><td>8 位</td><td>i8</td><td>u8</td></tr>
<tr><td>2 字节</td><td>16 位</td><td>i16</td><td>u16</td></tr>
<tr><td>4 字节</td><td>32 位</td><td>i32</td><td>u32</td></tr>
<tr><td>8 字节</td><td>64 位</td><td>i64</td><td>u64</td></tr>
<tr><td>16 字节</td><td>128 位</td><td>i128</td><td>u128</td></tr>
</tbody></table>
<p>有符号和无符号整形的名字已经展示了它所占的位数，比如 <code>i16</code> 和 <code>u16</code> 在内存都是 16 位 (2 字节)。它们都被完整的分配在函数的栈帧上。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041123992.png?raw=true" />
<p><code>isize</code> 和 <code>usize</code> 的大小则取决于你的系统，32 位系统就占用 4 字节，64 位系统就占用 8 字节。</p>
<h3 id="字符型"><a class="header" href="#字符型">字符型</a></h3>
<p><code>char</code> Rust 的字符不仅仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符。例如
<code>a</code>、<code>\u{CA0}</code>、<code>*</code>、<code>字</code>、<code>\n</code>、<code>🦀</code></p>
<p>char 类型长度是 4 字节，直接分配在栈上</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041113512.png?raw=true"  />
<h3 id="元组"><a class="header" href="#元组">元组</a></h3>
<p>元组是一些类型的集合</p>
<pre><code class="language-rs">let a: (char, u8, i32) = ('a', 7, 354);
</code></pre>
<p>比如这里，变量 a 包含了 char, u8, i32 三种数据类型，它的内存布局就是将各个成员依次排列。</p>
<p>在这里 char 占用 4 字节，u8 占用 1 字节，i32 占用 4 字节。因为这三种类型都是只在栈上分配的，所以整个元组也全在栈上分配。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041124139.png?raw=true"  />
<p>虽然看起来这个元组只会占用 9 字节的空间，但是其实并不是这样，你可以用 <code>size_of</code> 去查看这个元组占用的真正字节数</p>
<pre><code class="language-rs">std::mem::size_of::&lt;T&gt;()
</code></pre>
<h3 id="size_of-和-align_of"><a class="header" href="#size_of-和-align_of">size_of 和 align_of</a></h3>
<pre><code class="language-rs">use std::mem::{size_of, align_of};

size_of::&lt;(char, u8, i32)&gt;(); // 12 字节

align_of::&lt;(char, u8, i32)&gt;(); // 4 字节
</code></pre>
<p>所有的数据类型还有一个对齐属性，你可以通过 <code>align_of</code> 查看。</p>
<p>数据类型的大小必须是对齐属性的整数倍。这一点不仅仅是 Rust，所有的编译器都是这样。数据对齐对 CPU 操作及缓存都有较大的好处，有助于 CPU
更快的读取数据。</p>
<p>对于这个元组，它的对齐属性值是 4，因此它占用的字节数是 12。剩下的 3 字节会被编译器填充空白数据</p>
<h3 id="引用"><a class="header" href="#引用">引用</a></h3>
<p>接下来是引用类型 <code>&amp;T</code></p>
<pre><code class="language-rs">let a: i32 = 25;

let b: &amp;i32 = &amp;a;
</code></pre>
<p><code>a</code> 是 i32 类型，<code>b</code> 是对 <code>a</code> 的引用。</p>
<blockquote>
<p>接下来，我不会在详细展示每个数据的字节大小，我们将重点去关注整体，关注他们是存储在堆上还是栈上。</p>
</blockquote>
<p>在这里，<code>a</code> 存储在栈上，它占据 4 个字节。<code>b</code> 也存储在栈上，里面保存了变量 <code>a</code> 的地址。引用类型的大小取决于你的机器位数，所以 64 位系统上它占
8 字节。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041147802.png?raw=true"  />
<p>如果我们再用 <code>c</code> 保存 <code>b</code> 的引用，c 的类型就是 <code>&amp;&amp;i32</code></p>
<pre><code class="language-rs">let c: &amp;&amp;i32 = &amp;b;
</code></pre>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041147049.png?raw=true"  />
<p>引用也能指向堆上的数据。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041147762.png?raw=true"  />
<p>可变引用也有相同的内存布局。</p>
<p>可变引用和不可变引用的区别是他们的使用方式，以及编译器为可变引用添加的额外限制。</p>
<h3 id="数组"><a class="header" href="#数组">数组</a></h3>
<pre><code class="language-rs">let a: [i32; 3] = [55, 66, 77];
</code></pre>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041201858.png?raw=true"  />
<p>一个数组的大小是固定的，而且它的大小是数据类型的一部分。数组中的每个元素都会在栈上相邻排放。但是当数组创建后，它的大小就不能再改变。</p>
<blockquote>
<p>注意：只有大小固定而且在编译时已知的数据类型才能存储在栈上。</p>
</blockquote>
<h3 id="vec"><a class="header" href="#vec">Vec</a></h3>
<p>Vec 类型是可扩容的，它的大小能够改变，你可以用它代替数组。</p>
<pre><code class="language-rs">let v: Vec&lt;i32&gt; = vec![55, 66, 77];
</code></pre>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041443929.png?raw=true"  />
<p>这里我们的变量 <code>v</code> 存储了和数组相同的数据，但是它是在堆上分配的。</p>
<p>变量 <code>v</code> 在栈上占用的大小是固定的，包含 3 个 <code>usize</code>：</p>
<ul>
<li>第一个表示数据在堆上的地址，</li>
<li>剩下的两个表示 Vec 的容量和长度。</li>
</ul>
<p>容量表示 Vec 的最大空间。当我们向 Vec 中添加更多数据时，如果元素个数还没有达到容量大小，Rust 就不必为堆内存分配更多空间。</p>
<p>如果长度和容量已经相等了，我们还要向 Vec 添加更多数据，Rust 就会在堆中重新分配出一块更大的内存，将原数据复制到新的内存区域，并更新栈中的指针。</p>
<h3 id="切片"><a class="header" href="#切片">切片</a></h3>
<pre><code class="language-rs">let s1: [i32] = a[0..2];

let s2: [i32] = v[0..2];
</code></pre>
<p>切片 <code>[T]</code> 和数组非常相似，但是不用指定大小。切片就像是底层数组的一个视图，s1 表示数组 a 的前两个元素，s2 表示向量的前两个元素。</p>
<p>由于切片没有指定元素数量，编译时 Rust
编译器不知道它具体占了多少字节。同时，你也不能将切片存在变量中，因为它没有已知大小，所以不能被分配在栈上，这样的类型被称为 <strong>DST 动态大小类型</strong> 。</p>
<blockquote>
<p>还有其他的 DST 类型，比如字符串切片和特征对象。</p>
</blockquote>
<p>如果你尝试运行上面的代码，应该会编译失败：</p>
<pre><code class="language-rs">error[E0277]: the size for values of type `[i32]` cannot be known at compilation time
 --&gt; examples/vec.rs:8:9
  |
8 |     let s1: [i32] = a[0..2];
  |         ^^ doesn't have a size known at compile-time
  |
help: consider borrowing here
  |
8 |     let s1: [i32] = &amp;a[0..2];
  |                     +
</code></pre>
<p>因此，几乎在任何情况下，我们只会使用到切片的引用 <strong><code>&amp;[T]</code></strong>。被引用的数据既能在栈上，也能在堆上：</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205042149818.png?raw=true"  />
<p>我们之前说过，引用只是一个指针，它占据一个 <code>usize</code> 去存储它所指向的数据的地址。</p>
<p>但是当你用指针去指向一个动态大小类型时 (比如切片)，Rust 会使用一个额外的 <code>usize</code> 去存储数据的长度。这种引用也叫做 <strong>胖指针</strong>
(将一些附加信息和指针一起存储)。</p>
<p>切片引用可以用两个 <code>usize</code> 表示，所以它可以存在栈上。</p>
<h3 id="字符串"><a class="header" href="#字符串">字符串</a></h3>
<p>与字符串相关的有三种类型：<code>String</code>, <code>str</code>, <code>&amp;str</code>，他们分别对应 <code>Vec</code>, <code>[T]</code>， <code>&amp;[T}</code></p>
<p>字符串类型 <code>String</code> 的内存布局和向量相同，唯一的区别是，字符串类型必须是 UTF-8 编码。</p>
<p>以下面的代码为例：</p>
<pre><code class="language-rs">let s1: String = String::from(&quot;hello&quot;);
</code></pre>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041444837.png?raw=true"  />
<p>但是，如果你把一个字符串直接保存在变量中：</p>
<pre><code class="language-rs">let s2: &amp;str = &quot;hello&quot;;
</code></pre>
<p><code>s2</code> 的类型就会变成字符串切片的引用，这个字符串的数据不会在堆上，而是直接存储在编译好的二进制文件中。这种字符串有 <code>'static</code>
的生命周期，它永远不会被释放，在程序运行时都是可用的。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041445745.png?raw=true"  />
<blockquote>
<p>据我所知，Rust 不会指定字符串被保存在文件的那个部分，但是很可能就在代码段 (text segment)</p>
</blockquote>
<p>和切片引用一样，对字符串的切片的引用也是一个胖指针，包含两个 <code>usize</code>，一个用来存储字符串的内存起始地址，另一个存储字符串长度。</p>
<p>你不能直接使用字符串切片 <code>str</code>:</p>
<pre><code class="language-rs">// error: size can not be known at compile time
let s: str = s1[1..3];
</code></pre>
<p>对字符串的切片引用是可行的：</p>
<pre><code class="language-rs">let s: &amp;str = &amp;s1[1..3];
</code></pre>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205042150544.png?raw=true"  />
<h3 id="结构体"><a class="header" href="#结构体">结构体</a></h3>
<p>Rust 有三种结构体类型：结构体，元组结构体 (Tuple Struct) 和单元结构体 (Unit-like Struct)。</p>
<p>普通结构体：</p>
<pre><code class="language-rs">struct Data {
    nums: Vec&lt;usize&gt;,
    dimension: (usize, usize),
}
</code></pre>
<p>元组结构体：</p>
<pre><code class="language-rs">struct Data(Vec&lt;usize&gt;);
</code></pre>
<p>单元结构体：</p>
<pre><code class="language-rs">struct Data;
</code></pre>
<p>单元结构体不保存任何数据，所以 Rust 编译器甚至不会为他分配内存。</p>
<p>另外两种结构体的内存排布非常类似于之前所说的元组，我们以普通的结构体为例：</p>
<pre><code class="language-rs">struct Data {
    nums: Vec&lt;usize&gt;,
    dimension: (usize, usize),
}
</code></pre>
<p>它有两个字段，一个 Vec 和一个元组，结构体的各个成员会在栈上依次相邻排列。</p>
<ul>
<li>Vec 需要占用 3 个 <code>usize</code>，nums 的成员会被分配在堆上。</li>
<li>元组需要占用 2 个 <code>usize</code>。</li>
</ul>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041441096.png?raw=true"  />
<blockquote>
<p>注意：我们在这里忽视了内存对齐和编译器填充的 padding。</p>
</blockquote>
<h3 id="枚举"><a class="header" href="#枚举">枚举</a></h3>
<p>像结构体一样，Rust 支持用不同的语法表示枚举。</p>
<p>下面展示的是一个 C 风格的枚举，在内存中他们被保存为从零开始的整数，Rust 编译器会自动选择最短的整数类型。</p>
<pre><code class="language-rs">enum HTTPStatus {
    Ok,
    NotFound,
}
</code></pre>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041451028.png?raw=true"  />
<p>在这里最大值为 1，因此该枚举可以使用 1 字节存储。</p>
<p>你也可以手动为枚举的每个变体指定它的值：</p>
<pre><code class="language-rs">enum HTTPStatus {
    Ok = 200,
    NotFound = 404,
}
</code></pre>
<p>这个例子里最大的数是 404，需要至少 2 字节存储。所以这个枚举的每种变体都需要 2 字节。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041452340.png?raw=true"  />
<p>枚举值也可以选择具体的类型</p>
<pre><code class="language-rs">enum Data {
    Empty,
    Number(i32),
    Array(Vec&lt;i32&gt;)
}
</code></pre>
<p>在这个例子中</p>
<ul>
<li><code>Empty</code> 变体不存储任何数据</li>
<li><code>Number</code> 内部有一个 <code>i32</code></li>
<li><code>Array</code> 里面有个 <code>Vec</code></li>
</ul>
<p>它们的内存布局如下图所示：</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041511443.png?raw=true"  />
<p>首先我们看 <code>Array</code> 变体：</p>
<p>首先是一个整数标记 2 占用 1 字节，接着就是 <code>Vec</code> 所需的三个 <code>usize</code> ，编译器还会填充一些空白区域让他们内存对齐，所以这个变体需要 32
字节 (1 + 7 + 3 * 8)。</p>
<p>接着是 <code>Number</code> 变体，首先是整数标记 1，接着是 Number 里存储的 i32，占用 4
字节。因为所有变体的大小应该是一致的，所以编译器会为它们两个都添加 Padding 达到 32 字节</p>
<p>对于 <code>Empty</code>，它只需要一个字节去存储整数标记，但是编译器也必须添加 31 字节的 Padding</p>
<p>所以，枚举占用的空间取决于最大变体占用的空间。</p>
<p>减少内存使用的一个技巧就是降低枚举最大变体占用的内存：</p>
<pre><code class="language-rs">enum Data {
    Empty,
    Number(i32),
    Array(Box&lt;Vec&lt;i32&gt;&gt;) // 使用 Box 代替
}
</code></pre>
<p>在这个例子里，我们存除了 Vec 的指针，此时 Array 变体需要的内存只有 16 字节：</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041523525.png?raw=true"  />
<h3 id="box"><a class="header" href="#box">Box</a></h3>
<p>Box 是一个指针指向堆上的数据，所以 Box 在栈上只需要 1 个 <code>usize</code> 去存储地址。</p>
<p>在上个例子中，Box 指向了一个在堆上分配的 Vec。</p>
<blockquote>
<p>如果向量里面有值，这些值也会被存储在堆上。指向数据的指针将保存在 Vec 的指针字段里</p>
</blockquote>
<h3 id="对-option-的优化"><a class="header" href="#对-option-的优化">对 Option 的优化</a></h3>
<pre><code class="language-rs">pub enum Option&lt;T&gt; {
    None,
    Some(T)
}
</code></pre>
<p>由于 Rust 不允许出现空指针，想要实现同样的效果，你需要使用</p>
<pre><code class="language-rs">Option&lt;Box&lt;i32&gt;&gt;
</code></pre>
<p>这能够让 Rust 编译器确保不会出现空指针异常。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041541105.png?raw=true"  />
<p>在其他语言里，使用一个指针就能表示这两种状态。但是 Rust 却需要一个额外的整数标记和随之带来的 padding，这会造成内存浪费。</p>
<p>编译器能对此做出一些优化，如果 <code>Option</code> 里是 <code>Box</code> 或者是类似的指针类型，编译器就会省略掉整数标记，并使用值为 0 的指针表示 None。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041703687.png?raw=true"  />
<p>这种特性使得 Rust 中被包装在 <code>Option</code> 内的智能指针像其他语言里的指针一样，不会占用多余的内存。同时还能够提前找到并消除空指针异常</p>
<h3 id="copy-和-move"><a class="header" href="#copy-和-move">Copy 和 Move</a></h3>
<p>在继续向下讨论之前，让我们先了解一下 Copy 和 Move</p>
<pre><code class="language-rs">let num：i32 = 42;
let num_copy = num;
</code></pre>
<p>对于原始类型数据，他们的大小是在编译时已知的，会被存储在栈上。如果你将一个变量赋值给另一个变量，它得到的实际上是原始数据的一份拷，Rust 会逐位进行复制。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041713211.png?raw=true"  />
<p>这两个变量之后能同时使用</p>
<p>对于在堆上存储的数据来说：</p>
<pre><code class="language-rs">let v: Vec&lt;String&gt; = vec![
    &quot;Odin&quot;.to_String(),
    &quot;Thor&quot;.to_String(),
    &quot;Loki&quot;.to_String(),
]
</code></pre>
<p>在这个例子里，我们有一个在堆上分配的字符串向量。</p>
<p>变量 v 被保存在栈上，它需要 3 个 <code>usize</code> 去存储 Vec 的信息，并指向数据在堆中的地址。</p>
<p>每个字符串也需要 3 个 <code>usize</code> 来存储实际字符串的信息。</p>
<p>真正的字符串会被分配到堆上的其他地方。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041728077.png?raw=true"  />
<p>从所有权角度来说，变量 v 拥有所有在堆上分配的内存。因为 Rust 没有 GC，当变量 v 自己超出作用域后，它需要自己释放自己拥有的堆内存。</p>
<p>接下来我们将 v 赋值给了 v2：</p>
<pre><code class="language-rs">let v2 = v;
</code></pre>
<p>对于有 GC 的语言来说，程序会对变量 <code>v</code> 在栈上的数据进行了按位复制，最后 <code>v2</code> 也将拥有指向堆上数据的指针。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041741726.png?raw=true"  />
<p>这种方案很节省内存，无论在堆中的数据有多大，我们只需要复制栈上的数据。垃圾回收器会追踪堆内存的引用数量，当引用计数归零，垃圾回收器会帮我们释放堆内存。</p>
<p>但是 Rust 没有 GC，它只有所有权模型。我们不清楚到底哪个变量需要对释放内存负责。</p>
<p>另一种方案是：在赋值时为堆内存也创建一个副本。但是这会导致内存使用量升高，降低性能。</p>
<p>Rust 的选择是让用户必须做出选择：如果你在对变量赋值时想让它拥有一份属于自己的堆内存，你应该使用 <code>clone</code> 方法。如果你不使用 <code>clone</code>
方法，Rust 编译器就不允许你再使用之前的变量。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041754565.png?raw=true"  />
<p>我们把它称为：变量 v 已经被 move 了，现在 v2 是数据的拥有者。当 v2 超出作用域时，它会负责释放堆上的数据。</p>
<h3 id="rc"><a class="header" href="#rc">Rc</a></h3>
<p>有时候我们想让一个值拥有多个拥有者，大多数情况下，你可以用普通的引用去解决。但是这种方法的问题在于，当数据的拥有者超出作用域后，所有的引用也不能再继续使用。</p>
<p>我们想要的是所有变量都是数据的拥有者，只有所有变量都超出作用域后，数据才会被释放。Rc 智能指针通过引用计数能够实现这个功能：</p>
<pre><code class="language-rs">use std::rc::Rc;

let v: Rc&lt;Vec&lt;String&gt;&gt; = Rc::new(vec![
    &quot;Odin&quot;.to_String(),
    &quot;Thor&quot;.to_String(),
    &quot;Loki&quot;.to_String(),
]);

let v2 = v.clone();
println!(&quot;{}, {}&quot;, v.capacity(), v2.capacity())
</code></pre>
<p>当你使用 Rc 去包裹一个 Vec 时，Vec 的 3 个 <code>usize</code> 会和引用计数一起分配在堆上。变量 v 在栈只占用一个 <code>usize</code>，里面存储了
Rc 在堆上的地址。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041812961.png?raw=true"  />
<p>现在你能通过克隆 v 来创建 v2，这个克隆不会克隆任何位于堆上的数据，他只会克隆一份栈上的地址，然后将 Rc 的引用计数加 1，现在 v 和 v2
都持有相同的一份数据，这就是为什么它被称为引用技术指针。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041814163.png?raw=true"  />
<p>但是 Rc 也有限制，Rc 内部的数据是不可变的，你可以使用内部可变性可以解决这个问题。</p>
<p>每当有一个共享者超出作用域，引用计数就会减 1，让引用计数减到 0 时，整个堆内存就会被释放。</p>
<h3 id="send-和-sync"><a class="header" href="#send-和-sync">Send 和 Sync</a></h3>
<p>Rust 有一些特殊的标记特征，例如 Send 和 Sync。</p>
<p>如果一个类型实现了 Send，那就意味着数据可以从一个线程移动到另一个线程。</p>
<p>如果一个类型实现了 Sync，多个线程就可以使用引用去共享该数据。</p>
<p>Rc 没有实现 Send 和 Sync。假设两个线程在某个时间点同时拥有对某数据的引用，并且同时对该引用进行克隆。两个线程同时更新引用计数就会引发线程安全问题。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205041839368.png?raw=true"  />
<h3 id="arc"><a class="header" href="#arc">Arc</a></h3>
<p>如果你真的想要在线程间共享数据，你应该使用 <strong>原子</strong> 引用计数指针 <strong>Arc</strong>。</p>
<p>Arc 的工作方式几乎和 Rc 相同，只是引用计数的更新是原子性的，它是线程安全的。但是原子操作会带来一些微小的性能损耗。如果你只需要在单线程内共享数据，使用
Rc 就够了。</p>
<p>默认情况下 Arc 也是不变的，如果你想让数据是可变的，你可以使用 <code>Mutex</code>。</p>
<pre><code class="language-rs">// Arc&lt;Mutex&lt;T&gt;&gt;

let data: Arc&lt;Mutex&lt;i32&gt;&gt; = Arc::new(Mutex::new(0));
</code></pre>
<p>现在即使有两个线程尝试同时修改数据，他们需要首先获取锁，同时只有有一个线程能拿到锁，因此只能由一个线程修改数据。</p>
<h3 id="特征对象"><a class="header" href="#特征对象">特征对象</a></h3>
<p>实现了特征的实例被称为特征对象。</p>
<p>下面列举了将一种具体类型转化为特征对象的方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::Write;

let mur buffer: Vec&lt;u8&gt; = vec![];
let w: &amp;mut dyn Write = &amp;mut buffer;
<span class="boring">}
</span></code></pre></pre>
<p>第一个例子中，转化发生在为变量 <code>w</code> 赋值时</p>
<pre><code class="language-rs">fn main() {
    let mut buffer: Vec&lt;u8&gt; = vec![];
    writer(&amp;mut buffer);
}

fn writer(w: &amp;mut dyn Write) {
    // ...
}
</code></pre>
<p>第二个例子中，转化发生在将具体类型变量传递给接受特征对象的函数时</p>
<p>这两个例子里 <code>Vec&lt;u8&gt;</code> 类型的变量都被转化为实现了 <code>Write</code> 的特征对象。</p>
<p>Rust 用胖指针表示一个特征对象。该胖指针由两个普通指针组成，占用 2 个机器字长。</p>
<ul>
<li>第一个指针指向值，这里就是 <code>Vec&lt;u8&gt;</code></li>
<li>另一个指针指向 vtable (虚表)。</li>
</ul>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205042022927.png?raw=true"  />
<p><code>vtable</code> 在编译时生成，被所有相同类型的对象共享。<code>vtable</code> 包含了实现 <code>Writer</code>
必须实现的方法的指针。当你在调用特征对象的方法时，Rust 自动使用 <code>vtable</code> 找到对应的方法。</p>
<p>注意：<code>dyn Write</code> 也是动态大小类型，因此我们总是使用它的引用，即 <code>&amp;dyn Write</code>。</p>
<p>我们能把 <code>Vec&lt;u8&gt;</code> 转换成特征对象是因为标准库已经为它实现了 <code>Write</code> 特征。</p>
<pre><code class="language-rs">impl Write for Vec&lt;u8&gt;
</code></pre>
<p>Rust 不仅能将普通引用转化为特征对象，rust 也能将智能指针转换为特征对象：</p>
<pre><code class="language-rs">// Box
use std::io::Write;

let mut buffer: Vec&lt;u8&gt; = vec![];
let w: Box&lt;dyn Write&gt; = Box::new(buffer);
</code></pre>
<pre><code class="language-rs">// Rc
use std::io::Write;
use std::rc::Rc;

let mut buffer: Vec&lt;u8&gt; = vec![]

let mut w: Rc&lt;dyn Write&gt; = Rc::new(buffer);
</code></pre>
<p>无论是普通引用还是智能指针，在转换发生的时候，Rust 只是添加了适当的 <code>vtable</code> 指针，把原始指针转换为了一个胖指针。</p>
<h3 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h3>
<p>函数指针只需要一个 <code>usize</code> 去存储函数的地址。</p>
<p><code>test_func</code> 是一个会返回 bool 的函数，我们可以把它存在了一个变量里。</p>
<pre><code class="language-rs">fn main() {
    let f: fn() -&gt; bool = test_func;
}

fn test_func() -&gt; bool {
    true
}
</code></pre>
<p><img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205042044987.png" alt="" /></p>
<h3 id="闭包"><a class="header" href="#闭包">闭包</a></h3>
<p>Rust 没有具体的闭包类型，它制定了 3 个特征 <code>Fn</code>、<code>FnMut</code>、<code>FnOnce</code>。</p>
<h4 id="fnonce"><a class="header" href="#fnonce">FnOnce</a></h4>
<p>首先是 <code>FnOnce</code>，<code>create_closere</code> 函数返回了一个实现 <code>FnOnce</code> 的对象</p>
<pre><code class="language-rs">fn main() {
    let c = create_closure();
}

fn create_closure() -&gt; impl FnOnce() {
    let name = String::from(&quot;john&quot;);
    || {
        drop(name);
    }
}
</code></pre>
<p>在函数体内部我们创建了一个局部变量 <code>name</code>，它是字符串类型，在栈上占据 3 个 <code>usize</code>
，接着又创建了一个闭包，闭包可以捕获函数内的局部变量。在闭包内部，我们 drop 了 name。</p>
<p>FnOnce 只是一个特征，它只定义了一个对象的行为或方法。Rust
内部会使用结构体表示闭包，它会根据闭包捕获的变量创建对应的结构体，并为该结构体实现最合适的特征</p>
<pre><code class="language-rs">struct MyClosure {
    name: String
}

impl FnOnce for MyClosure {
    fn call_once(self) {
        drop(self.name)
    }
}
</code></pre>
<blockquote>
<p><code>FnOnce</code> 特征的真实函数签名比较复杂，这里只展示一个简化版本。</p>
</blockquote>
<p>结构体内部只有一个 name 字段，是闭包从 <code>create_closure</code> 函数内部捕获而来，<code>call_once</code> 是 <code>FnOnce</code>
特征必须实现的方法。因为闭包对应的结构体只有一个 String 类型字段，所以他的内存布局和 String 一样。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205042058375.png?raw=true" />
<p>注意 call_once 函数的参数，他需要一个 <code>self</code> ，这意味着 <code>call_once</code>
只能调用一次。原因也很简单，如果我们调用两次这个闭包，拿他就会 drop <code>name</code> 两次。</p>
<h4 id="fnmut"><a class="header" href="#fnmut">FnMut</a></h4>
<p>在这个例子里，我们创建了一个可变的闭包：</p>
<pre><code class="language-rs">let mut i: i32 = 0;

let mut f = || {
    i += 1;
};

f();
f();
println!(&quot;{}&quot;, i); // 2
</code></pre>
<p>这个闭包的类型是 <code>FnMut</code> ，因为我们在闭包里尝试修改变量 i。因此该闭包生成的结构体中将会有一个对变量 i 的可变引用，<code>call_mut</code>
方法也需要一个对 <code>self</code> 的可变引用：</p>
<pre><code class="language-rs">struct MyClosure {
    i: &amp;mut i32
}

impl FnMut for MyClosure {
    fn call_mut(&amp;mut self) {
        *self.i += 1;
    }
}
</code></pre>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205042118777.png?raw=true" />
<p>如果你在闭包 f 改为不可变的：</p>
<pre><code class="language-rs">let f = || {
    i += 1;
};
</code></pre>
<p>就会编译失败：</p>
<pre><code class="language-rs">error[E0596]: cannot borrow `f` as mutable, as it is not declared as mutable
  --&gt; src/main.rs:16:5
   |
12 |     let f = || {
   |         - help: consider changing this to be mutable: `mut f`
13 |         i += 1;
   |         - calling `f` requires mutable binding due to mutable borrow of `i`
...
16 |     f();
   |     ^ cannot borrow as mutable
For more information about this error, try `rustc --explain E0596`.
</code></pre>
<p>错误信息提示我们，该闭包需要设为可变的</p>
<h4 id="fn"><a class="header" href="#fn">Fn</a></h4>
<p>最后是 <code>Fn</code> 特征：</p>
<pre><code class="language-rs">fn create_closure() {
    let msg = String::from(&quot;hello&quot;);

    let my_print = || {
        println!(&quot;{}&quot;, msg);
    };

    my_print();
    my_print();
}
</code></pre>
<p>在这个例子里，我们的闭包只是打印了一下它捕获到的 msg 变量，<code>print</code> 宏接受的是变量的引用，所以 Rust 会自动为闭包实现 Fn 特征：</p>
<pre><code class="language-rs">struct MyClosure {
    msg: &amp;String,
}

impl Fn for MyClosure {
    fn call(&amp;self) {
        println!(&quot;{}&quot;, self.msg);
    }
}
</code></pre>
<p>生成的结构体内部只有一个对 <code>msg</code> 的引用。<code>call</code> 方法只需要一个 <code>self</code> 的引用，因此这个闭包能够被多次调用。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205042118165.png?raw=true" />
<h4 id="move"><a class="header" href="#move">move</a></h4>
<p>这个例子中我们将使用和刚刚相同的闭包，只不过是用一个函数去返回：</p>
<pre><code class="language-rs">fn create_closure() -&gt; impl Fn() {
    let msg = String::from(&quot;hello&quot;);

    || {
        println!(&quot;{}&quot;, msg);
    }
}
</code></pre>
<p>但是这样会编译错误：</p>
<pre><code class="language-rs">error[E0597]: `msg` does not live long enough
  --&gt; src/main.rs:30:24
   |
29 |     || {
   |     -- value captured here
30 |         println!(&quot;{}&quot;, msg);
   |                        ^^^ borrowed value does not live long enough
31 |     }
32 | }
   | -- borrow later used here
   | |
   | `msg` dropped here while still borrowed

For more information about this error, try `rustc --explain E0597`.
</code></pre>
<p>错误信息提示我们，变量 <code>msg</code> 的生命周期可能比闭包短。</p>
<p>现在回想一下闭包的内存布局，闭包的结构体内部只有一个对 <code>msg</code> 的引用。所以当函数调用结束后，它的栈帧将被释放，闭包就不能再引用到该函数栈帧里的局部变量。</p>
<p>Rust 希望我们使用 <code>move</code> 关键字去明确表示我们想让闭包拿走闭包捕获到的变量的所有权</p>
<pre><code class="language-rs">fn create_closure() -&gt; impl Fn() {
    let msg = String::from(&quot;hello&quot;);

    move || {
        println!(&quot;{}&quot;, msg);
    }
}
</code></pre>
<p>当我们使用 move 之后，闭包的结构体就不再是引用，而是字符串本身。</p>
<pre><code class="language-rs">struct MyClosure {
    msg: String,
}

impl Fn for MyClosure {
    fn call(&amp;self) {
        println!(&quot;{}&quot;, self.msg);
    }
}
</code></pre>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205042120583.png?raw=true"  />
<h4 id="捕获多个变量"><a class="header" href="#捕获多个变量">捕获多个变量</a></h4>
<p>到目前为止，我们的闭包还只是捕获一个变量，在这个例子里闭包捕获了两个对象，一个字符串和一个 Vec：</p>
<pre><code class="language-rs">fn create_closure() -&gt; impl Fn() {
    let msg = String::from(&quot;hello&quot;);
    let v: Vec&lt;i32&gt; = vec![1, 2];

    move || {
        println!(&quot;{}&quot;, msg);
        println!(&quot;{:?}&quot;, v);
    }
}
</code></pre>
<p>它的结构体大致如下：</p>
<pre><code class="language-rs">struct MyClosure {
    msg: String,
    v: Vec&lt;i32&gt;,
}

impl Fn for MyClosure {
    fn call(&amp;self) {
        println!(&quot;{}&quot;, self.msg);
        println!(&quot;{:?}&quot;, self.v);
    }
}
</code></pre>
<p>它的内存布局和结构体的一样，并没有什么特殊的。</p>
<img src="https://gitee.com/rustcn/rustt-assets/raw/main/20220504-Visualizing-memory-layout-of-Rust-data-types/202205042120232.png?raw=true" />
<p>这个模式在其他地方也遵循，比如 异步生态中大量使用的 Future 特征。在内存中编译器会使用枚举表示实际的对象，并为这个枚举实现 Future
特征。这里不会详细讲解 Future 的实现细节，我提供了一个链接，视频里详细的解释了异步函数的实现细节。</p>
<h2 id="资料"><a class="header" href="#资料">资料</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=ZHP9sUqB3Qs">异步函数的一生 RustFest Barcelona - Tyler Mandry: Life of an async fn</a></li>
<li><a href="https://lwn.net/Articles/738975/">堆栈 KAISER: hiding the kernel from user space</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/gettingstarted/virtual-address-spaces">虚拟地址空间 Virtual address spaces</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对重请求---应对尾部延迟"><a class="header" href="#对重请求---应对尾部延迟">对重请求 - 应对尾部延迟</a></h1>
<p><a href="https://medium.com/swlh/hedged-requests-tackling-tail-latency-9cea0a05f577">Hedged requests — Tackling tail latency</a></p>
<p>通常出现在出现在分布式系统中，实现分布式系统有很多优缺点</p>
<p>使用分布式系统的常见原因：</p>
<ul>
<li>可用性</li>
<li>可扩展性</li>
<li>分区容错</li>
<li>独立部署</li>
<li>为不同目的使用不同的技术</li>
</ul>
<p>这些可能是分布式系统的问题：</p>
<ul>
<li>成本</li>
<li>复杂</li>
<li>一致性</li>
<li><strong>延迟</strong></li>
</ul>
<p>我们将重点关注延迟，更具体地说是尾部延迟。</p>
<h2 id="延迟"><a class="header" href="#延迟">延迟</a></h2>
<p>当我们使用分布式系统时，延迟会不可避免的增加。分布式系统中的每一跳都不是免费的，除了网络延迟还有其他成本，如果使用 HTTP
通信，我们还要处理消息、解析消息、验证身份令牌、以及我们想要添加到管道中的任何数据。这些是在设计分布式系统时需要考虑的问题。我们必须考虑是否有必要分发新的系统。</p>
<p>要回答这个问题，我们需要了解如何测量延迟。最简单的答案之一是使用百分比。</p>
<h2 id="百分比"><a class="header" href="#百分比">百分比</a></h2>
<p>首先是定义我们的观察组。对于延迟，最常见的观察组是给定请求类别的响应时间。计算的方式如下：</p>
<ol>
<li>获取请求的所有响应时间并排序。</li>
<li>取前 x% 的元素。</li>
<li>获取集合的最大（最长）值。</li>
</ol>
<p>以请求 <code>/hello-world</code> 接口为例</p>
<ol>
<li>获取请求的所有响应时间并排序。
<ul>
<li>获取响应时间：23, 20, 21, 20, 23, 20, 45, 21, 25, 25</li>
<li>排序：20, 20, 20, 21, 21, 23, 23, 25, 25, 45</li>
</ul>
</li>
<li>取前 50% 元素：20, 20, 20, 21, 21</li>
<li>得到最大值：21</li>
</ol>
<p>所以 P50 就是 21 ms，如果取前 90 % 元素，P90 就是 25 ms</p>
<h2 id="尾部延迟"><a class="header" href="#尾部延迟">尾部延迟</a></h2>
<p>尾部延迟是百分位谱最末端的延迟。一般系统对 99% 的请求的响应都很快，但是对于剩下的 1% 可能非常差。
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204202210071.png" alt="" />
对于一个每分钟接受数百万请求的系统来说，这 1% 就不是微不足道了</p>
<p>2013 年 Google 发表的论文介绍了一些解决方法</p>
<ul>
<li>Hedged requests</li>
<li>Tied requests</li>
<li>Micro partitions</li>
<li>Selective replication</li>
<li>Latency-induced probation</li>
<li>Good enough responses</li>
<li>Canary requests</li>
</ul>
<p>P99 = 140ms P95 = 70ms</p>
<p>剩下的 5% 请求占了总请求一半的延迟</p>
<h2 id="对冲请求"><a class="header" href="#对冲请求">对冲请求</a></h2>
<p>如果请求的时长超过 P95 还没有结果，那么就重发</p>
<h2 id="模拟尾部延迟"><a class="header" href="#模拟尾部延迟">模拟尾部延迟</a></h2>
<p>下面的代码模拟了有 %4 的请求会等待 100ms</p>
<pre><code class="language-go">package main

import (
	&quot;math/rand&quot;
	&quot;net/http&quot;
	&quot;time&quot;

	&quot;github.com/gorilla/mux&quot;
)

func main() {
	router := mux.NewRouter()

	router.HandleFunc(&quot;/ishealthy&quot;, func(w http.ResponseWriter, r *http.Request) {
		rd := rand.New(rand.NewSource(time.Now().UnixNano()))
		requestPercentile := rd.Intn(100)
		waitTime := 0

		if requestPercentile &gt; 96 {
			waitTime = 100
		}

		time.Sleep(time.Duration(waitTime+15) * time.Millisecond)
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(&quot;Healthy&quot;))
	}).Methods(http.MethodGet)
	http.ListenAndServe(&quot;:8080&quot;, router)
}
</code></pre>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204202241384.png" alt="" />
从图中可以看到</p>
<ul>
<li>p50 小于 20ms</li>
<li>p95 20ms 左右</li>
<li>p99 超过 115ms</li>
</ul>
<h2 id="对重测试"><a class="header" href="#对重测试">对重测试</a></h2>
<p>新增两个接口</p>
<ul>
<li><code>/falout</code>：对于每个请求都转发出 3 个副本。应该能到达 P99 性能。但会发出 3 倍以上的请求。</li>
<li><code>/hedged</code>：在第一个未达到预期 P95 (21ms) 之后触发对冲请求。应该在 40 毫秒左右将尾部性能提高到 P99。最多只能多发出 5%
的请求。</li>
</ul>
<p><strong>falout</strong></p>
<pre><code class="language-go">func queryFanOut(urls []string) string {
	ch := make(chan string, len(urls))
	for _, url := range urls {
		go func(u string) {
			ch &lt;- executeQuery(u)
		}(url)
	}
	return &lt;-ch
}
</code></pre>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204202248476.png" alt="" /></p>
<p><strong>hedged</strong></p>
<pre><code class="language-go">func queryWithHedgedRequests(urls []string) string {
	ch := make(chan string, len(urls))
	for _, url := range urls {
		go func(u string, c chan string) {
			c &lt;- executeQuery(u)
		}(url, ch)

		select {
		case r := &lt;-ch:
			return r
		case &lt;-time.After(21 * time.Millisecond):
		}
	}

	return &lt;-ch
}
</code></pre>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204202248260.png" alt="" /></p>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>仅用几行代码，我们就可以大幅改善尾部延迟。在将其用作生产系统之前，该示例还有很多需要改进的地方，但核心实现与此没有太大区别。
该技术针对一个非常具体的问题，在用于实际生产应用之前应进行彻底分析。</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://kerkour.com/why-not-rust</p>
<p><strong>翻译：<a href="https://github.com/trdthg">trdthg</a></strong></p>
<p>选题：<a href="https://github.com/allenli178">子殊</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="什么时候不应该使用-rust"><a class="header" href="#什么时候不应该使用-rust">什么时候不应该使用 Rust？</a></h1>
<p>我非常相信 Rust 是提高软件性能和可靠性的一大步，这不仅能进一步加速软件开发，还能赚更多的 $$! Rust 的 Immutable
和较好的抽象能力能够极大的便利开发者。</p>
<p>但是任何事物总有两面性，Rust 不可能总是最优选择。我将在下面讨论一些不适合使用 Rust 的场景。</p>
<h2 id="原型设计--黑客松"><a class="header" href="#原型设计--黑客松">原型设计 &amp; 黑客松</a></h2>
<p>Rust 语言本身更倾向于可靠性而不是开发速度。因此，如果你只有 1～2
天的时间进行开发，你应该把宝贵的时间用在更有用的地方，而不是花在手动管理内存，处理每一个边缘情况上。</p>
<p>相反，如果你的项目要开发几周，Rust 的可靠性能帮你减轻后期的监控和调试的压力，省下大把的时间和金钱。</p>
<h2 id="独立开发者"><a class="header" href="#独立开发者">独立开发者</a></h2>
<p>Rust 的第三方库生态尚且年轻。如果你是一个独立开发者，你可能像要外包尽可能多的工作，因此 Rust
可能不是最适合的。你可能更喜欢使用生态完善的语言，他们有大量开箱即用的第三方库。</p>
<p>另一方面，Rust 的可靠性其实也降低了独立开发者对监控和调试的需求。</p>
<h2 id="与-saas-服务集成"><a class="header" href="#与-saas-服务集成">与 SaaS 服务集成</a></h2>
<p>如果你的应用需要与第三方 API 进行交互，你应该使用那些有官方 SDK 支持的语言，比如 TypeSript 或者 Python。</p>
<p>话虽这么说，现在 AWS 也有了许多官方的 Rust SDK，我希望更多的公司能够学习并提供 Rust SDK。</p>
<h2 id="只是想完成而不是做到完美"><a class="header" href="#只是想完成而不是做到完美">只是想完成而不是做到完美</a></h2>
<p>老实说，并非所有软件都需要 Rust 提供的可靠性和性能。有时候，一些 bug 是可以接受的，Rust 只会让你慢下来。在这些场景下，您应该会更喜欢像 Go
等更无聊的语言。</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://thenewstack.io/using-rustlangs-async-tokio-runtime-for-cpu-bound-tasks/</p>
<p><strong>翻译：<a href="https://github.com/trdthg">trdthg</a></strong></p>
<p>选题：<a href="https://github.com/Akagi201">Akagi201</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="使用-tokio-处理-cpu-密集型任务-1"><a class="header" href="#使用-tokio-处理-cpu-密集型任务-1">使用 Tokio 处理 CPU 密集型任务</a></h1>
<p>尽管 async 通常都被应用于异步网络 I/O，但是在这篇文章里，我会像你介绍为什么使用 Tokio 处理 CPU
密集型任务（比如数据分析引擎等）也是一个不错的选择。</p>
<h2 id="tokio-是什么-1"><a class="header" href="#tokio-是什么-1">Tokio 是什么？</a></h2>
<p>Rust 本身提供了一个类似于 JavaScript 的异步编程模型。</p>
<p>为了充分利用多核和异步 I/O。一个运行时是必须的，尽管社区有很多异步运行时的选择，但是 Tokio 是事实上的标准。尽管 Tokio 在官网上描述到它是
Rust 语言的一个异步运行时，并且提供了编写网络服务所需要的模块，它也可以被用在其它场景。</p>
<h2 id="为什么使用-tokio-处理-cpu-密集型任务-1"><a class="header" href="#为什么使用-tokio-处理-cpu-密集型任务-1">为什么使用 Tokio 处理 CPU 密集型任务</a></h2>
<p>现代化的数据分析引擎总是不可避免的要处理来自客户端的网络请求，以及通过网络和对象存储系统（比如 ASW S3、GCP Cloud、Azure
等）进行通信。因此，任何使用 Rust 实现的系统，大多都会用 Tokio 去处理这部分网络相关的服务，或者是一部分文件 I/O 服务。</p>
<p>除了应对网络外，数据分析引擎还需要做大量繁重的的 CPU 计算，消耗大量 CPU
资源去进行诸如：重新组织数据存储、提前计算各种索引、或者是直接回复客户端请求等工作。这些复杂计算通常会被切成许多单独的块（我把它们称为
&quot;任务&quot;），然后被并行的处理，以利用到现代 CPU 的多核特性。</p>
<p>任务调度器会决定哪个任务应该在什么时候运行，它会将任务映射到合适的 CPU 内核或者是线程上。</p>
<p>学术界和工业界对于各种任务调度器、工作池、线程池等已经积累了很多年的研究。</p>
<p>我自己已经实现并且使用过几个自定义的任务调度器。他们在大多数时间 (99.9%)
都工作的很好，但是在处理边缘情况（比如快速停机、任务取消、清理等）时，他们的效果非常不尽人意。由于这些任务调度器使用了较低级别的线程原语，出现线程间竞争的情况比比皆是，所以我不建议这样做。</p>
<p>因此，当我在 Rust 生态中寻找一个任务调度器时，你会很自然的选择 Tokio。Tokio 有很多优势：</p>
<ol>
<li>你只需要 Tokio，并不需要添加其他依赖项。</li>
<li>Tokio 实现了一个复杂的 <a href="https://tokio.rs/blog/2019-10-scheduler">支持任务窃取的调度器</a>。</li>
<li>Tokio 内部实现了对 async/await 的支持。并且有许多相对成熟的库去处理流、异步锁、管道、异步取消等。</li>
<li>Tokio 在 Rust 生态系统中经过了良好测试，并且有着大量使用案例。</li>
<li>Tokio 通常会将正在运行的任务和 <code>Future</code> 放在同一个执行器内，这有利于实现局部缓存。</li>
<li>Tokio 的 <a href="https://tokio.rs/tokio/tutorial">文档</a> 很完善，并且在积极更新维护。</li>
</ol>
<p>因此，选择 Tokio 作为 CPU 密集型任务的任务调度程序是理所应当的，对吧？WROOOOOOOONG！</p>
<h2 id="使用-tokio-的反对意见-1"><a class="header" href="#使用-tokio-的反对意见-1">使用 Tokio 的反对意见</a></h2>
<p>选择 Tokio 在我们团队中变成了一个热门话题，到现在依然不是所有人都认可这个决定。在我们做 DataFusion 和 InfluxDB IOx
的早期，我们很担心这个问题。以下是一些反对意见：</p>
<h3 id="tokio-文档的警告-1"><a class="header" href="#tokio-文档的警告-1">Tokio 文档的警告：</a></h3>
<p>老版本的 Tokio 文档（比如 1.10 版）里面有一条著名的警告：</p>
<blockquote>
<p>If your code is CPU-bound and you wish to limit the number of threads used to
run it, you should run it on another thread pool such as Rayon.</p>
</blockquote>
<p>如果你的代码要处理 CPU 密集型任务，并且想要尽量减少使用到的线程数，你应该将这些任务分配到另一个线程池比如 Rayon。</p>
<p>这个警告对我们团队和社区都造成了很大的困惑。很多人读了之后都以为 Tokio 永远不应该用来处理 CPU
密集型任务。但是文档的关键其实是说，一个运行时实例（同一个线程池）不应该同时用于 I/O 和 CPU
计算，我们之后澄清了<a href="https://docs.rs/tokio/1.14.0/tokio/#cpu-bound-tasks-and-blocking-code">文档</a>
的意图。</p>
<blockquote>
<p>顺便说一句，Tokio 文档建议用 Rayon 处理 CPU 密集型任务。Rayon
对于很多程序都是很好的解决方案，但是它并不支持异步。如果你的代码中哪怕只有一点需要使用异步，那你就不得不跨过同步和异步的痛苦边界。我还发现实现一个
<a href="http://justinjaffray.com/query-engines-push-vs.-pull/">基于拉取的执行器模型</a>
会更困难，这种模型要求某个任务必须等待所有的输入都准备好在能在 Rayon 中运行</p>
</blockquote>
<h3 id="尾部延迟会拖累你-1"><a class="header" href="#尾部延迟会拖累你-1">尾部延迟会拖累你</a></h3>
<p>聪明的人会说：使用 Tokio 处理 CPU
密集型任务会增加请求的<a href="https://medium.com/swlh/hedged-requests-tackling-tail-latency-9cea0a05f577">尾部延迟</a>，这是难以令人接受的。</p>
<p>尾部延迟？🙄</p>
<p>你可能认为：我正在编写一个数据库，尾部延迟听起来像是对于高负载的 Web 服务器的一个学术问题……”</p>
<p>但其实，这也是需要考虑的：思考一下健康检查，健康检查对于使用容器编排系统（比如 Kubernetes）部署的服务是必不可少的。检查的方式通常是发送一个 HTTP
请求到某个 API ，例如 <code>/health</code>。如果该请求已经被分派到某一个任务队列中，但是 Tokio 正在忙于使用 CPU 进行大量数据处理任务，那么
Kubernetes 将不能及时得到 “系统正常” 的响应，你的进程就会被 K8s 杀死。因此得到结论：由于尾部延迟，你不能将 Tokio 用于 CPU
密集型任务。</p>
<p>但是，就像 Tokio 在文档中阐述的，想要防止你的程序在 CPU 完全饱和的情况下被 K8s
误杀，你应该使用两个独立的线程池。一个用来执行对尾部延迟敏感的任务，就比如响应 <code>/health</code> 接口。另一个用来执行 CPU
密集型任务。这些线程池的的最佳线程数需要根据具体需求去调整。</p>
<p>如果你将 Tokio 运行时只是视为一个复杂点的线程池，那么使用多个运行时实例的想法可能更容易接受，我们将在最后使用专用的执行器演示如何实现这个想法。</p>
<h3 id="单任务开销很高-1"><a class="header" href="#单任务开销很高-1">单任务开销很高</a></h3>
<p>Tokio 的每个任务开销很高。</p>
<p>对于这点，我一点也不惊讶。人们总是可以实现比 Tokio 运行速度更快的线程池。但是，这些线程池并不是足够稳定，难以应对生产环境的负载，并且他们也不具备像
Tokio 一样的庞大生态系统。</p>
<p>在许多场景下，单任务的开销可以使用 “矢量化处理”
来分摊。意思是每个任务回同时处理几千行数据而不是单单一行，你需要将任务分成合理大小的块。你也不能分摊所有工作场景下的开销。但是，对于我们的程序关心的实例来说，Tokio
的任务开销已经微乎其微了</p>
<h2 id="实践-1"><a class="header" href="#实践-1">实践</a></h2>
<p>假设你已经被说服了使用 Tokio 去处理 CPU 密集型任务是可行的。现在你应该怎么做？</p>
<p>首先，至关重要的一点是，你的代码应该符合以下原则：异步代码永远不应该花费很长时间才能完成，这一点请参考 Alice Ryhl 的
<a href="https://ryhl.io/blog/async-what-is-blocking/">Async: What is blocking?</a>。这是为了让调度器有机会安排其他事情，比如任务窃取等。</p>
<p>当然了，这个 “很长时间” 取决于你的程序；Ryhl 建议在优化响应的尾部延迟时，单个异步任务完成时间应该在 10 ~ 100 微秒。我认为在针对 CPU
进行优化时 10~100 毫秒也能有不错的效果。但是在我的测试
<a href="https://github.com/alamb/rust_tokio_overhead">estimated per-task Tokio overhead</a>
中，Tokio 单任务的开销在约 10 纳秒范围内，因此几乎不可能用 10 毫秒的任务来测量 Tokio 运行时开销。</p>
<p>其次，将任务分派到一个单独的执行器</p>
<h3 id="专用的执行器-1"><a class="header" href="#专用的执行器-1">专用的执行器</a></h3>
<p>这里是一个简单的例子，演示了我们如何在 InfluxDB IOx 上将任务分配到一个单独的 Tokio
运行时上（完整代码可以在我们的<a href="https://github.com/influxdata/influxdb_iox/blob/fe155e15fb2ad166aee66b0458e63c24a8128dd4/query/src/exec/task.rs#L101-L118">仓库</a>里查看，里面还有关于清理、停机、合并的内容）</p>
<pre><code class="language-rs">pub struct DedicatedExecutor {
    state: Arc&lt;Mutex&lt;State&gt;&gt;,
}

/// Runs futures (and any `tasks` that are `tokio::task::spawned` by
/// them) on a separate Tokio Executor
struct State {
    /// Channel for requests -- the dedicated executor takes requests
    /// from here and runs them.
    requests: Option&lt;std::sync::mpsc::Sender&lt;Task&gt;&gt;,

    /// Thread which has a different Tokio runtime
    /// installed and spawns tasks there
    thread: Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;,
}

impl DedicatedExecutor {
    /// Creates a new `DedicatedExecutor` with a dedicated Tokio
    /// executor that is separate from the threadpool created via
    /// `[tokio::main]`.
    pub fn new(thread_name: &amp;str, num_threads: usize) -&gt; Self {
        let thread_name = thread_name.to_string();

        let (tx, rx) = std::sync::mpsc::channel::&lt;Task&gt;();

        let thread = std::thread::spawn(move || {
            // Create a new Runtime to run tasks
            let runtime = Tokio::runtime::Builder::new_multi_thread()
                .enable_all()
                .thread_name(&amp;thread_name)
                .worker_threads(num_threads)
                // Lower OS priority of worker threads to prioritize main runtime
                .on_thread_start(move || set_current_thread_priority_low())
                .build()
                .expect(&quot;Creating Tokio runtime&quot;);

         // Pull task requests off the channel and send them to the executor
         runtime.block_on(async move {
                while let Ok(task) = rx.recv() {
                    Tokio::task::spawn(async move {
                        task.run().await;
                    });
                }

        let state = State {
            requests: Some(tx),
            thread: Some(thread),
        };

        Self {
            state: Arc::new(Mutex::new(state)),
        }
    }
</code></pre>
<p>这段代码会在一个新线程 <code>std::thread</code>，并在这个线程里创建了一个新的 Tokio 运行时。运行时会从 <code>channel</code> 获取任务并运行。</p>
<p>注意：这个新的线程很关键，如果你尝试在主线程里或者是任何已经创建过 Tokio 运行时的线程里再次创建新的运行时，程序就会报错，因为已经有一个运行时了。</p>
<p>下面的代码将任务分派到第二个运行时。</p>
<pre><code class="language-rs">impl DedicatedExecutor {

    /// Runs the specified Future (and any tasks it spawns) on the
    /// `DedicatedExecutor`.
    pub fn spawn&lt;T&gt;(&amp;self, task: T) -&gt; Job&lt;T::Output&gt;
    where
        T: Future + Send + 'static,
        T::Output: Send + 'static,
    {
        let (tx, rx) = tokio::sync::oneshot::channel();

        let fut = Box::pin(async move {
            let task_output = task.await;
            tx.send(task_output).ok()
        });
        let mut state = self.state.lock();
        let task = Task {
            fut,
        };

        if let Some(requests) = &amp;mut state.requests {
            // would fail if someone has started shutdown
            requests.send(task).ok();
        } else {
            warn!(&quot;tried to schedule task on an executor that was shutdown&quot;);
        }

        Job { rx, cancel }
    }
}
</code></pre>
<p>上面的代码使用了一个名为 Job 的结构体，它是一个对 Future 的简单包装，Job 能够将 Future
的执行结果从单独的执行器内传输回主线程。相关代码如下。</p>
<pre><code class="language-rs">#[pin_project(PinnedDrop)]
pub struct Job&lt;T&gt; {
    #[pin]
    rx: Receiver&lt;T&gt;,
}

impl&lt;T&gt; Future for Job&lt;T&gt; {
    type Output = Result&lt;T, Error&gt;;

    fn poll(
        self: Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut std::task::Context&lt;'_&gt;,
    ) -&gt; std::task::Poll&lt;Self::Output&gt; {
        let this = self.project();
        this.rx.poll(cx)
    }
}
</code></pre>
<p>就是这样！ 你可以在
<a href="https://gist.github.com/alamb/bd0e086448ef9b438aeebd6f550e23ed">Github gist</a>
中找到所有代码。</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://lucumr.pocoo.org/2022/1/30/unsafe-rust/</p>
<p><strong>翻译：<a href="https://github.com/trdthg">trdthg</a></strong></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="未初始化内存unsafe-rust-太难了"><a class="header" href="#未初始化内存unsafe-rust-太难了">未初始化内存：unsafe Rust 太难了</a></h1>
<p>Rust
在很多意义上不仅仅是一个现代的系统编程语言，也是一个实用的语言。它承诺了自己的安全性，并且提供了一个完整的框架，使得创建安全的抽象成为可能，同时运行时开销很小甚至为
0。你可以使用 unsafe 来明确的脱离安全的 Rust。</p>
<p>如果你之前看过这篇文章，你会惊讶的发现，它和之前的版本大不相同。这篇文章的作者是被 unsafe
的规则所困惑的受害者。我在文章中增加了一个例子，用来更好的展示其中的陷阱。我之前在 Twitter 上说过，编写 unsafe Rust 比 C / C++
更困难，所以我想为我的观点作出一些解释。</p>
<h2 id="从-c-到-rust"><a class="header" href="#从-c-到-rust">从 C 到 Rust</a></h2>
<p>我们从下面的例子开始：我们有一个待初始化的结构体。比较有趣的字段是
<code>name</code>。它是一个指针，指向一个已经分配好的字符串。除此之外，分配到哪里对我们并不重要，因此我们可以将这个结构体自身分配在栈上。我们的想法是，当这个结构体被初始化之后，它就可以被安全的传递和打印。</p>
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;

struct role {
    char *name;
    bool disabled;
    int flag;
};

int main() {
    struct role r;
    r.name = strdup(&quot;basic&quot;);
    r.flag = 1;
    r.disabled = false;
    printf(&quot;%s (%d, %s)\n&quot;, r.name, r.flag, r.disabled ? &quot;true&quot; : &quot;false&quot;);
    free(r.name);
}
</code></pre>
<p>接下来我们用 Rust 去实现上面的代码。现在我们并不需要过多的关注 Rust
文档，只需要专注于一对一翻译即可。在你阅读下面的代码之前还有一点要注意：我们正在有意的创建一个对 Rust 程序员更熟悉的对象，并且可以被看作公共
API。所以我们在这里直接使用 String，而不是 C 语言的字符串。</p>
<pre><code class="language-rs">use std::mem;

struct Role {
    name: String,
    disabled: bool,
    flag: u32,
}

fn main() {
    let role = unsafe {
        let mut role: Role = mem::zeroed();
        role.name = &quot;basic&quot;.to_string();
        role.flag = 1;
        role.disabled = false;
        role
    };

    println!(&quot;{} ({}, {})&quot;, role.name, role.flag, role.disabled);
}
</code></pre>
<p>看到这里，立即就有人想问，这里为什么需要
unsafe？当然了，你的确不需要。但是这段代码使用了一个函数：<code>std::mem::zeroed</code>。如果你尝试在最近的 Rust
编译器运行，应该会的得到这个错误：</p>
<pre><code class="language-rs">thread 'main' panicked at 'attempted to zero-initialize type `Role`,
  which is invalid', src/main.rs:11:30
</code></pre>
<p>老版本的编译器能够正常运行，但是那其实也是错误的。怎么解决呢？编译器又一次告诉我们解决之法：</p>
<pre><code class="language-rs">warning: the type `Role` does not permit zero-initialization
  --&gt; src/main.rs:11:30
   |
11 | let mut role: Role = mem::zeroed();
   |                      ^^^^^^^^^^^^^
   |                      |
   |                      this code causes undefined behavior when executed
   |                      help: use `MaybeUninit&lt;T&gt;` instead, and only call
   |                         `assume_init` after initialization is done
   |
</code></pre>
<p>为什么 <code>Role</code> 类型不支持使用 0 初始化呢？我们需要改动那些代码？我们能不能不初始化？</p>
<p>有人可能会想，使用 <code>#[repr(C)]</code> 强制结构体使用 C 语言的内存布局，但是这不能解决问题。正如编译器给出的建议，我们需要
<code>MaybeUninit</code>。</p>
<pre><code class="language-rs">use std::mem::MaybeUninit;

struct Role {
    name: String,
    disabled: bool,
    flag: u32,
}

fn main() {
    let role = unsafe {
        let mut uninit = MaybeUninit::&lt;Role&gt;::zeroed();
        let role = uninit.as_mut_ptr();
        (*role).name = &quot;basic&quot;.to_string();
        (*role).flag = 1;
        (*role).disabled = false;
        uninit.assume_init()
    };

    println!(&quot;{} ({}, {})&quot;, role.name, role.flag, role.disabled);
}
</code></pre>
<p>将 <code>zeroed</code> 换为 <code>MaybeUninit::zeroed</code> 之后，一切都变了。现在我们不能直接使用结构体，而是要操作一个裸指针。由于裸指针没有实现
<code>deref</code>，并且 Rust 中没有 <code>-&gt;</code> 操作符，我们需要手动解引用，并用这种笨拙的语法分配每一个字段。</p>
<p>首先：这样做可行吗？答案是肯定的。但是它正确吗？不正确。</p>
<p>答案在于，任何像可变引用（&amp;mut）或者是栈上的值本身这样的构造，在 unsafe 代码之外仍然需要一直处于有效的状态。<code>zeroed</code> 返回一个值为 0
的结构，我们不能保证它可以有效的表示结构体或者任何其中的字段。在我们的例子中，我们的字符串在所有内容被清零的情况下是有效的，但是这并不能保证，而且是未定义行为。</p>
<p>需要注意的一点是，一个可变引用永远不能指向一个无效的对象，所以在对象的所有字段都被初始化之前，下面的操作是错误的：</p>
<pre><code class="language-rs">let role = &amp;mut *uninit.as_mut_ptr()
</code></pre>
<p>所以，让我们把 <code>zeroed</code> 改为 <code>uninit</code>。如果我们再次运行，程序就会崩溃。</p>
<pre><code class="language-rs">// let mut uninit = MaybeUninit::&lt;Role&gt;::uninit();
free(): invalid pointer
</code></pre>
<p>为什么会崩溃呢？答案是，通过给 name 赋值一个新的字符串，我们也 drop 了之前的旧字符串。我们之前只是碰巧没有遇到这种情况，因为 Drop
碰巧能够处理一个被清零的字符串。但现在，我们深入了未定义行为。我们如何解决这个问题呢？我们需要以某种方式直接将字符串写到那里的指针。</p>
<p>我们首先要接受 MaybeUninit 是必要的，现在我们要处理这里的裸指针。这有些麻烦，但是看起来不是特别难。现在我们有两个新问题：我们知道 <code>&amp;mut X</code>
是不允许的，但是 <code>*mut X</code> 是允许的。我们如何在不使用 <code>&amp;mut X</code> 的情况下得到一个 <code>*mut X</code>? 讽刺的是，在 Rust 1.51
之前，再不打破任何规则之前，这是不可能的，但是现在，你可以使用 <code>addr_of_mut!</code> 宏。</p>
<pre><code class="language-rs">let name_ptr = std::ptr::addr_of_mut!((*role).name);
</code></pre>
<p>太棒了，现在我们拿到了 name 的指针，如何写入呢？我们可以使用 <code>write</code> 方法。</p>
<pre><code class="language-rs">addr_of_mut!((*role).name).write(&quot;basic&quot;.to_string());
</code></pre>
<p>现在完成了吗？还记得我们是如何使用普通结构体的吗？如果阅读一下文档，你就会发现，结构体的内存布局没有任何保证。事实表明，<a href="https://github.com/rust-lang/reference/issues/1151">尽管目前的文档是这样说的</a>，但是我们可以依靠字段的对齐性。如果我们处理的是
<code>#[repr(packed)]</code>，我们就必须使用 <code>write_unaligned</code> 方法来代替。如果 Rust
选择的结构体的一个成员是不对齐的，这是合法的。</p>
<p>最终的代码：</p>
<pre><code class="language-rs">use std::mem::MaybeUninit;
use std::ptr::addr_of_mut;

struct Role {
    name: String,
    disabled: bool,
    flag: u32,
}

fn main() {
    let role = unsafe {
        let mut uninit = MaybeUninit::&lt;Role&gt;::uninit();
        let role = uninit.as_mut_ptr();
        addr_of_mut!((*role).name).write(&quot;basic&quot;.to_string());
        (*role).flag = 1;
        (*role).disabled = false;
        uninit.assume_init()
    };

    println!(&quot;{} ({}, {})&quot;, role.name, role.flag, role.disabled);
}
</code></pre>
<h2 id="什么时候用-addr_of_mut"><a class="header" href="#什么时候用-addr_of_mut">什么时候用 <code>addr_of_mut!</code></a></h2>
<p>一般有两种情况：未初始化的内存，未对齐的引用。Rust
不允许用户创建一个未对齐的引用（即时只是暂时的），同时也不允许创建一个对未初始化内存的引用。那么，这些引用是什么时候被创建的呢？</p>
<p>对于下面的代码：<code>(*flag).flag = 1</code>，根据 Rust 的规则，如果一个类型没有实现 Drop，这是可以的。如果该类型实现了
Drop，这行代码会产生很多问题：当 <code>Drop::drop</code> 被调用时，并且调用在未初始化的内存上，这时我们就需要
<code>addr_of_mut!</code>。这就是为什么我们可以直接为 flag 字段赋值，但是我们却需要通过 <code>addr_of_mut!</code> 来获取 name
字段，因为它是一个字符串。</p>
<h2 id="maybeuninit"><a class="header" href="#maybeuninit">MaybeUninit</a></h2>
<p>对安全的理解随着时间的推移而不断改变。曾经，<code>mem::uninitialized</code> 被认为是一个健全的 API，但是在后来，<code>MaybeUninit</code>
被引入去解决发现的缺点。但是，由于部分初始化的类型的存在，MaybeUninit 在实践中并不理想。虽然由于 <code>#[repr(transparent)]</code>，
MaybeUninit 和 T 是内存兼容的，但是在嵌套使用时的效果并不佳。</p>
<p>有时你需要结构体的某个字段上有一个 MaybeUninit，但是只后你又希望这个抽象不存在，这种情况并不罕见。实际上，在实践中使用 MaybeUninit
是一个充满挑战的体验，但是这篇文章并没有体现出来。</p>
<h2 id="我的-unsafe-代码正确吗"><a class="header" href="#我的-unsafe-代码正确吗">我的 unsafe 代码正确吗？</a></h2>
<p>在 2022 年，我承认，我不再对编写 Rust 代码感到自信。unsafe 的规则可能可能都是如此复杂，但是从我多年来阅读过的 unsafe 代码来说，大多数
unsafe 代码都不太关心这些规则，并且无视了它们。<code>addr_of_mut!</code>直到 1.53 才被添加到语言中是有原因的。即使到了今天，文档中都说它
Rust 结构体 repr 的对齐方式没有任何保证。</p>
<p>在过去的几年里，似乎发生了这样的事情：Rust 开发者在实践中编写 unsafe
越来越困难，现在的规则是如此复杂，以至于对一个随意的程序员来说非常难以理解，围绕他的文档也很容易被曲解。我在这篇文章的<a href="https://github.com/mitsuhiko/lucumr/blob/48440d3cf151f0d774bc9ad62f903034ca2b30ff/2022/1/30/unsafe-rust.rst">上一个版本</a>中认为
<code>addr_of_mut!</code> 的一些使用是必要的，但实际上并非如此。在有人指出这个错误之前，文章已经得到了大量关注。</p>
<p>这些规则使得 Rust 最好的功能之一越来越难以接近，同时也越来越难以理解。要求存在 MaybeUninit，而不仅仅是过去的
mem::uninitialized API 是显而易见的，但是却展示了语言规则是多么的复杂。</p>
<p>我不认为这是好的。事实上，我认为这根本不是一个好的趋势，好像越来越少的人了解 unsafe Rust。与 C 的互操作性是让 Rust
伟大的一个原因，但是我们现在正在创建巨大的屏障，这是不可取的。更重要的是：编译器在指出我的错误时没有什么帮助。</p>
<p>让 unsafe 变得更符合人体工程学是一个困难的问题，但是它值得被解决。因为有一点很明确：人们不会很快停止编写 unsafe 代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-六边形架构"><a class="header" href="#rust-六边形架构">Rust 六边形架构</a></h1>
<h2 id="六边形架构基本介绍"><a class="header" href="#六边形架构基本介绍">六边形架构基本介绍</a></h2>
<p>六边形架构，是一种软件设计模式。依照这种架构创建的程序，能够在没有 UI
或数据库的情况下正常工作。所以即使没有数据库你依然可以进行开发和运行自动化测试，而且无需其他用户参与。</p>
<h3 id="端口与适配器"><a class="header" href="#端口与适配器">端口与适配器</a></h3>
<p>六边形架构也叫做端口与适配器架构。</p>
<p><img src="https://alistair.cockburn.us/wp-content/uploads/2018/02/Hexagonal-architecture-complex-example.gif" alt="" /></p>
<p>什么是端口？</p>
<p>端口指的是六边形的边，属于应用程序的内部，是我们应用程序的入口和出口。它定义了一个接口，表示设备如何使用我们的用例。在 Rust 里就是由一个
Trait，以及一些 DTO 组成</p>
<p>什么是适配器？</p>
<p>适配器围绕着端口编写，能够将输入转化为符合端口的类型，并把输入转化为用用程序内部的方法调用。换句话说就是 <code>controller</code> 或者是命令行一条命令处理器。</p>
<p>当任何外部设备 (比如：WEB，APP，终端，测试...)
想要访问输入端口时，首先这个输入会被该设备对应的输入适配器，转化为符合要求的可用的方法调用，或者是消息，然后再传递给我们的应用程序。</p>
<p>当我们的应用程序需要向外发送数据时，首先它会把数据通过输出端口传递给输出适配器，然后再传递给输出对象 (比如：数据库，mock，API，邮件，消息队列...)</p>
<p>因此我们的应用程序外部是完全隔离的。</p>
<h3 id="应用程序核心"><a class="header" href="#应用程序核心">应用程序核心</a></h3>
<p>使用六边形架构之后，我们应用程序的核心部分通常被称作域，域中有三个核概念：</p>
<ul>
<li>实体 (Entities)：只是简单的定义了对象。</li>
<li>交互器 (Interactors)：实现复杂的业务逻辑，在本文里我们会将其称为用例 Usecase。</li>
<li>存储库 (Repositories)：只定义了操作实体的方法。</li>
</ul>
<h3 id="优点"><a class="header" href="#优点">优点</a></h3>
<p>在传统的分层架构中，只能从上往下调用。</p>
<p>而现在我们把接口保留在域中，域不再依赖外部的外部实现。保证了外部设备是可替换的。当业务逻辑需要用到数据存储时，直接调用抽象接口即可。</p>
<h2 id="将要做些什么"><a class="header" href="#将要做些什么">将要做些什么？</a></h2>
<p>在接下来的文章里，我们将会实现一个 pokemon 服务。主要功能是增加、删除和查询。</p>
<p>为了体现六边形架构的优点，我们将会实现两套用户接口，包括 HTTP API 和 CLI。三套存储库，包括内存，SQLite 数据库和 Airtable
(一个在线表格应用)。</p>
<p>六边形架构的核心不需要依赖于具体的存储库或者是用户接口，为了我们的程序能够稳定运行，我们也会非常注重于单元测试。一旦我们的域稳定下来，实现用户接口，替换存储库都会是非常简单快速的。</p>
<h2 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h2>
<pre><code>src/
├── api
│   ├── fetch_pokemon.rs
│   └── mod.rs
├── cli
│   ├── fetch_pokemon.rs
│   └── mod.rs
├── domain
│   ├── entities.rs
│   ├── fetch_pokemon.rs
│   └── mod.rs
├── main.rs
└── repositories
    ├── mod.rs
    └── pokemon.rs
</code></pre>
<p>六边形架构的核心部分通常被称作域，就是下面的 <code>domain</code> 模块，里面包括实体的定义和用例的实现。<code>api</code> 和 <code>cli</code>
是两套用户接口。<code>repositories</code> 中则是存储库的定义与实现</p>
<h2 id="延申阅读"><a class="header" href="#延申阅读">延申阅读</a></h2>
<ul>
<li><a href="https://alistair.cockburn.us/hexagonal-architecture/">六边形架构 ( hexagonal-architecture )</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">干净架构 ( the-clean-architecture )</a></li>
<li><a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/">洋葱架构 ( The Onion Architecture )</a></li>
<li><a href="https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/">软件架构编年史 ( The Software Architecture Chronicles )</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://alexis-lozano.com/hexagonal-architecture-in-rust-4/</p>
<p>翻译：<a href="https://github.com/trdthg">trdthg</a></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="2021-09-02---rust-六边形架构-4---重构"><a class="header" href="#2021-09-02---rust-六边形架构-4---重构">2021-09-02 - Rust 六边形架构 #4 - 重构</a></h1>
<p>这篇文章是下面系列的一部分</p>
<ul>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-1/">Hexagonal architecture in Rust #1 - Domain</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-2/">Hexagonal architecture in Rust #2 - In-memory repository</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-3/">Hexagonal architecture in Rust #3 - HTTP API</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-4/">Hexagonal architecture in Rust #4 - Refactoring</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-5/">Hexagonal architecture in Rust #5 - Remaining use-cases</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-6/">Hexagonal architecture in Rust #6 - CLI</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-7/">Hexagonal architecture in Rust #7 - Long-lived repositories</a></li>
</ul>
<p>嗨，又是我！起初，我想实现我们仍然需要处理的剩余的用例。但这将会是下一次的内容。今天我们将做一些重构 :)</p>
<h2 id="开始之前"><a class="header" href="#开始之前">开始之前</a></h2>
<p>我做了两个我在第一篇文章中没有看到的更改。在 <code>domain/entities.rs</code> 中，我用 Self 替换了 u16：</p>
<pre><code class="language-rs">impl From&lt;PokemonNumber&gt; for u16 {
    fn from(n: PokemonNumber) -&gt; Self {
        n.0
    }
}
</code></pre>
<p>在 <code>repositories/pokemons.rs</code> 中，我在 <code>with_error</code> 上添加了一个测试注释：</p>
<pre><code class="language-rs">impl InMemoryRepository {
    #[cfg(test)]
    pub fn with_error(self) -&gt; Self {
        Self {
            error: true,
            ..self
        }
    }
}
</code></pre>
<p>让我们现在进行重构 :)</p>
<h2 id="使用-result-替换自定义枚举"><a class="header" href="#使用-result-替换自定义枚举">使用 <code>Result</code> 替换自定义枚举</a></h2>
<p>之前我们使用自定义枚举作为用例和 存储库 的返回值，现在把他们重构为 Result。</p>
<h3 id="更改用例的返回值类型"><a class="header" href="#更改用例的返回值类型">更改用例的返回值类型</a></h3>
<p>首先，我们将用例的返回值暂时设置为 500 以方便测试、</p>
<pre><code class="language-rs">pub fn serve(repo: Arc&lt;dyn Repository&gt;, req: &amp;rouille::Request) -&gt; rouille::Response {
    let req = ...
    rouille::Response::from(Status::InternalServerError)
    // match create_pokemon::execute(repo, req) {
    //     create_pokemon::Response::Ok(number) =&gt; rouille::Response::json(&amp;Response { number }),
    //     create_pokemon::Response::BadRequest =&gt; rouille::Response::from(Status::BadRequest),
    //     create_pokemon::Response::Conflict =&gt; rouille::Response::from(Status::Conflict),
    //     create_pokemon::Response::Error =&gt; rouille::Response::from(Status::InternalServerError),
    // }
}
</code></pre>
<p>现在我们将测试的返回值修改为 Result 类型：</p>
<pre><code class="language-rs">    #[test]
    fn it_should_return_a_bad_request_error_when_request_is_invalid() {
        ...
        match res {
            Err(Error::BadRequest) =&gt; {}
            _ =&gt; unreachable!(),
        };
    }

    #[test]
    fn it_should_return_a_conflict_error_when_pokemon_number_already_exists() {
        ...
        match res {
            Err(Error::Conflict) =&gt; {}
            _ =&gt; unreachable!(),
        }
    }

    #[test]
    fn it_should_return_an_unknown_error_when_an_unexpected_error_happens() {
        ...
        match res {
            Err(Error::Unknown) =&gt; {}
            _ =&gt; unreachable!(),
        };
    }

    #[test]
    fn it_should_return_the_pokemon_number_otherwise() {
        ...
        match res {
            Ok(res_number) =&gt; assert_eq!(res_number, number),
            _ =&gt; unreachable!(),
        };
    }
}
</code></pre>
<p>接着再修改用例，把它的返回值修改为 Result：</p>
<pre><code class="language-rs">pub fn execute(repo: Arc&lt;dyn Repository&gt;, req: Request) -&gt; Result&lt;u16, Error&gt; {
    ...
        (Ok(number), Ok(name), Ok(types)) =&gt; match repo.insert(number, name, types) {
            Insert::Ok(number) =&gt; Ok(u16::from(number)),
            Insert::Conflict =&gt; Err(Error::Conflict),
            Insert::Error =&gt; Err(Error::Unknown),
        },
        _ =&gt; Err(Error::BadRequest),
    }
}
</code></pre>
<p>测试现在应该通过了！</p>
<pre><code>cargo test
running 4 tests
test it_should_return_a_conflict_error_when_pokemon_number_already_exists ... ok
test it_should_return_a_bad_request_error_when_request_is_invalid ... ok
test it_should_return_an_unknown_error_when_an_unexpected_error_happens ... ok
test it_should_return_the_pokemon_number_otherwise ... ok
</code></pre>
<p>最后再去修改我们的 API：</p>
<pre><code class="language-rs">pub fn serve(repo: Arc&lt;dyn Repository&gt;, req: &amp;rouille::Request) -&gt; rouille::Response {
    let req = ...
    match create_pokemon::execute(repo, req) {
        Ok(number) =&gt; rouille::Response::json(&amp;Response { number }),
        Err(create_pokemon::Error::BadRequest) =&gt; rouille::Response::from(Status::BadRequest),
        Err(create_pokemon::Error::Conflict) =&gt; rouille::Response::from(Status::Conflict),
        Err(create_pokemon::Error::Unknown) =&gt; rouille::Response::from(Status::InternalServerError),
    }
}
</code></pre>
<p>Usecase 修改完成，接下来我们去处理 Reposity</p>
<h3 id="更改-repository-的返回类型"><a class="header" href="#更改-repository-的返回类型">更改 Repository 的返回类型</a></h3>
<p>Repository 没有测试，所以我们从修改用例调用 repo 的返回值开始：</p>
<pre><code class="language-rs">use crate::repositories::pokemon::{InsertError, ...};

...
pub fn execute(repo: Arc&lt;dyn Repository&gt;, req: Request) -&gt; Result&lt;u16, Error&gt; {
    ...
        (Ok(number), Ok(name), Ok(types)) =&gt; match repo.insert(number, name, types) {
            Ok(number) =&gt; Ok(u16::from(number)),
            Err(InsertError::Conflict) =&gt; Err(Error::Conflict),
            Err(InsertError::Unknown) =&gt; Err(Error::Unknown),
        },
        _ =&gt; Err(Error::BadRequest),
    }
}
</code></pre>
<p>在宝可梦编号冲突的测试时，您应该将 <code>.ok()</code> 添加到存储库 insert 操作之后。现在让我们在 <em>repositories/pokemon.rs</em>
中删除 <code>Insert</code> 并创建 <code>InsertError</code>：</p>
<pre><code class="language-rs">pub enum InsertError {
    Conflict,
    Unknown,
}
</code></pre>
<p>最后在更改 <code>Repository</code> Trait 和 <code>InMemoryRepository</code> 的返回值类型即可：</p>
<pre><code class="language-rs">pub trait Repository: Send + Sync {
    fn insert(&amp;self,
        number: PokemonNumber,
        name: PokemonName,
        types: PokemonTypes,
    ) -&gt; Result&lt;PokemonNumber, InsertError&gt;;
}

impl Repository for InMemoryRepository {
    fn insert(
        &amp;self,
        number: PokemonNumber,
        name: PokemonName,
        types: PokemonTypes,
    ) -&gt; Result&lt;PokemonNumber, InsertError&gt; {
        if self.error {
            return Err(InsertError::Unknown);
        }

        let mut lock = match self.pokemons.lock() {
            Ok(lock) =&gt; lock,
            _ =&gt; return Err(InsertError::Unknown),
        };

        if lock.iter().any(|pokemon| pokemon.number == number) {
            return Err(InsertError::Conflict);
        }

        let number_clone = number.clone();
        lock.push(Pokemon::new(number_clone, name, types));
        Ok(number)
    }
}
</code></pre>
<h2 id="填加一个新的用例"><a class="header" href="#填加一个新的用例">填加一个新的用例</a></h2>
<p>在常规的 HTTP API 中，每次创建一个新的对象，我通常会把这个对象在返回回去。特别是当返回的对象中包含一切前端没有传来的字段。比如 <code>create_at</code>
等由存储库添加的字段。</p>
<p>首先，我需要你像我们一开始那样暂时注释掉 <code>api/create_pokemon.rs</code>。以便于我们专注于测试。</p>
<p>在 <em>domain/create_pokemon.rs</em> 中添加一个新的测试：</p>
<pre><code class="language-rs">#[test]
fn it_should_return_the_pokemon_number_otherwise() {
    let repo = Arc::new(InMemoryRepository::new());
    let req = Request {
        number: 25,
        name: String::from(&quot;Pikachu&quot;),
        types: vec![String::from(&quot;Electric&quot;)],
    };

    let res = execute(repo, req);

    match res {
        Ok(Response {
            number,
            name,
            types,
        }) =&gt; {
            assert_eq!(number, 25);
            assert_eq!(name, String::from(&quot;Pikachu&quot;));
            assert_eq!(types, vec![String::from(&quot;Electric&quot;)]);
        }
        _ =&gt; unreachable!(),
    };
}
</code></pre>
<p>同时创建一个 <code>Response</code> 结构体</p>
<pre><code class="language-rs">pub struct Response {
    pub number: u16,
    pub name: String,
    pub types: Vec&lt;String&gt;,
}
</code></pre>
<p>接下来，我们将修改 <code>execute</code> 函数，在插入成功时应该返回 <code>Pokemon</code> 的所有字段：</p>
<pre><code class="language-rs">use crate::domain::entities::{Pokemon, ...};

pub fn execute(repo: Arc&lt;dyn Repository&gt;, req: Request) -&gt; Result&lt;Response, Error&gt; {
    ...
        (Ok(number), Ok(name), Ok(types)) =&gt; match repo.insert(number, name, types) {
            Ok(Pokemon {
                number,
                name,
                types,
            }) =&gt; Ok(Response {
                number: u16::from(number),
                name: String::from(name),
                types: Vec::&lt;String&gt;::from(types),
            }),
            Err(InsertError::Conflict) =&gt; Err(Error::Conflict),
            Err(InsertError::Unknown) =&gt; Err(Error::Unknown),
        },
        _ =&gt; Err(Error::BadRequest),
    }
}
</code></pre>
<p>在 <code>insert</code> 执行成功后，直接返回一个 <code>Pokemon</code> 结构体：</p>
<pre><code class="language-rs">pub trait Repository: Send + Sync {
    fn insert(
        &amp;self,
        number: PokemonNumber,
        name: PokemonName,
        types: PokemonTypes,
    ) -&gt; Result&lt;Pokemon, InsertError&gt;;
}

impl Repository for InMemoryRepository {
    fn insert(
        &amp;self,
        number: PokemonNumber,
        name: PokemonName,
        types: PokemonTypes,
    ) -&gt; Result&lt;Pokemon, InsertError&gt; {
        ...
        let pokemon = Pokemon::new(number, name, types);
        lock.push(pokemon.clone());
        Ok(pokemon)
    }
}
</code></pre>
<p>为了使 <code>pokemon.clone()</code> 能够正常工作，我们需要为 <code>Pokemon</code> 实现 <code>Clone</code> Trait：</p>
<pre><code class="language-rs">#[derive(Clone)]
pub struct PokemonName(String);

#[derive(Clone)]
pub struct PokemonTypes(Vec&lt;PokemonType&gt;);

#[derive(Clone)]
enum PokemonType {

#[derive(Clone)]
pub struct Pokemon {
</code></pre>
<p>现在存储库的插入逻辑已经完成，用例希望能够直接拿到 <code>Pokemon</code> 的 <code>name</code> 和 <code>types</code> 字段，我们需要把这两个字端也转为公开的：</p>
<pre><code class="language-rs">pub struct Pokemon {
    pub number: PokemonNumber,
    pub name: PokemonName,
    pub types: PokemonTypes,
}
</code></pre>
<p>接着，我们需要为 <code>Response</code> 实现类型转换，从 <code>PokemonNumber</code> 转换为 <code>u16</code>、从 <code>PokemonName</code> 转换为
<code>String</code>、从 <code>PokemonTypes</code> 转换为 <code>Vec&lt;String&gt;</code>:</p>
<pre><code class="language-rs">impl From&lt;PokemonName&gt; for String {
    fn from(n: PokemonName) -&gt; Self {
        n.0
    }
}

impl From&lt;PokemonTypes&gt; for Vec&lt;String&gt; {
    fn from(pts: PokemonTypes) -&gt; Self {
        let mut ts = vec![];
        for pt in pts.0.into_iter() {
            ts.push(String::from(pt));
        }
        ts
    }
}

impl From&lt;PokemonType&gt; for String {
    fn from(t: PokemonType) -&gt; Self {
        String::from(match t {
            PokemonType::Electric =&gt; &quot;Electric&quot;,
            PokemonType::Fire =&gt; &quot;Fire&quot;,
        })
    }
}
</code></pre>
<p>现在测试应该能够通过了：</p>
<pre><code>cargo test
running 4 tests
test it_should_return_a_conflict_error_when_pokemon_number_already_exists ... ok
test it_should_return_a_bad_request_error_when_request_is_invalid ... ok
test it_should_return_an_unknown_error_when_an_unexpected_error_happens ... ok
test it_should_return_the_pokemon_number_otherwise ... ok
</code></pre>
<p>最后，我们去更新 api 的内容：</p>
<pre><code class="language-rs">#[derive(Serialize)]
struct Response {
    number: u16,
    name: String,
    types: Vec&lt;String&gt;,
}

pub fn serve(repo: Arc&lt;dyn Repository&gt;, req: &amp;rouille::Request) -&gt; rouille::Response {
    let req = ...
    match create_pokemon::execute(repo, req) {
        Ok(create_pokemon::Response {
            number,
            name,
            types,
        }) =&gt; rouille::Response::json(&amp;Response {
            number,
            name,
            types,
        }),
        Err(create_pokemon::Error::BadRequest) =&gt; rouille::Response::from(Status::BadRequest),
        Err(create_pokemon::Error::Conflict) =&gt; rouille::Response::from(Status::Conflict),
        Err(create_pokemon::Error::Unknown) =&gt; rouille::Response::from(Status::InternalServerError),
    }
}
</code></pre>
<p><code>cargo run</code> 之后，再次向 server 发送数据：</p>
<pre><code class="language-json">{
  &quot;number&quot;: 17,
  &quot;name&quot;: &quot;Charmander&quot;,
  &quot;types&quot;: [
    &quot;Fire&quot;
  ]
}
</code></pre>
<h2 id="创建一些测试值"><a class="header" href="#创建一些测试值">创建一些测试值</a></h2>
<p>你喜欢在测试过程中使用 <code>PokemonName::try_from(String::from(&quot;Pikachu&quot;)).unwrap()</code>
之类的东西吗？让我们在 <em>domain/entities.rs</em> 中创建一些函数：</p>
<h3 id="宝可梦编号"><a class="header" href="#宝可梦编号">宝可梦编号</a></h3>
<pre><code class="language-rs">#[cfg(test)]
impl PokemonNumber {
    pub fn pikachu() -&gt; Self {
        Self(25)
    }

    pub fn charmander() -&gt; Self {
        Self(4)
    }
}
</code></pre>
<h3 id="宝可梦名字"><a class="header" href="#宝可梦名字">宝可梦名字</a></h3>
<pre><code class="language-rs">#[cfg(test)]
impl PokemonName {
    pub fn pikachu() -&gt; Self {
        Self(String::from(&quot;Pikachu&quot;))
    }

    pub fn charmander() -&gt; Self {
        Self(String::from(&quot;Charmander&quot;))
    }

    pub fn bad() -&gt; Self {
        Self(String::from(&quot;&quot;))
    }
}
</code></pre>
<h3 id="宝可梦类型"><a class="header" href="#宝可梦类型">宝可梦类型</a></h3>
<pre><code class="language-rs">#[cfg(test)]
impl PokemonTypes {
    pub fn pikachu() -&gt; Self {
        Self(vec![PokemonType::Electric])
    }

    pub fn charmander() -&gt; Self {
        Self(vec![PokemonType::Fire])
    }
}
</code></pre>
<p>接下来让我们在用例测试中使用这些测试值。首先为 <code>Request</code> 添加一个测试用的 <code>new</code> 方法，以便我们更轻松的模拟一个请求：</p>
<pre><code class="language-rs">#[cfg(test)]
mod tests {
    ...

    impl Request {
        fn new(number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; Self {
            Self {
                number: u16::from(number),
                name: String::from(name),
                types: Vec::&lt;String&gt;::from(types),
            }
        }
    }
}
</code></pre>
<p>接下来就是各种的测试：</p>
<pre><code class="language-rs">#[test]
fn it_should_return_a_bad_request_error_when_request_is_invalid() {
    ...
    let req = Request::new(
        PokemonNumber::pikachu(),
        PokemonName::bad(),
        PokemonTypes::pikachu(),
    );
    ...
}

#[test]
fn it_should_return_a_conflict_error_when_pokemon_number_already_exists() {
    ...
    repo.insert(
        PokemonNumber::pikachu(),
        PokemonName::pikachu(),
        PokemonTypes::pikachu(),
    )
    .ok();
    let req = Request::new(
        PokemonNumber::pikachu(),
        PokemonName::charmander(),
        PokemonTypes::charmander(),
    );
    ...
}

#[test]
fn it_should_return_an_unknown_error_when_an_unexpected_error_happens() {
    ...
    let req = Request::new(
        PokemonNumber::pikachu(),
        PokemonName::pikachu(),
        PokemonTypes::pikachu(),
    );
    ...
}

#[test]
fn it_should_return_the_pokemon_otherwise() {
    ...
    let req = Request::new(
        PokemonNumber::pikachu(),
        PokemonName::pikachu(),
        PokemonTypes::pikachu(),
    );
    ...
    match res {
        Ok(res) =&gt; {
            assert_eq!(res.number, u16::from(PokemonNumber::pikachu()));
            assert_eq!(res.name, String::from(PokemonName::pikachu()));
            assert_eq!(res.types, Vec::&lt;String&gt;::from(PokemonTypes::pikachu()));
        }
        _ =&gt; unreachable!(),
    };
}
</code></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>我们终于完成了这个漫长的重构，希望一切顺利 :) 我保证，下次我们将去实现一些新的用例！</p>
<p>代码可以在 <a href="https://github.com/alexislozano/pokedex/tree/article-4">Github</a> 上查看</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://alexis-lozano.com/hexagonal-architecture-in-rust-2/</p>
<p>翻译：<a href="https://github.com/trdthg">trdthg</a></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="2021-08-24---rust-六边形架构-2---内存中的存储库"><a class="header" href="#2021-08-24---rust-六边形架构-2---内存中的存储库">2021-08-24 - Rust 六边形架构 #2 - 内存中的存储库</a></h1>
<p>这篇文章是下面系列的一部分</p>
<ul>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-1/">Hexagonal architecture in Rust #1 - Domain</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-2/">Hexagonal architecture in Rust #2 - In-memory repository</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-3/">Hexagonal architecture in Rust #3 - HTTP API</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-4/">Hexagonal architecture in Rust #4 - Refactoring</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-5/">Hexagonal architecture in Rust #5 - Remaining use-cases</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-6/">Hexagonal architecture in Rust #6 - CLI</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-7/">Hexagonal architecture in Rust #7 - Long-lived repositories</a></li>
</ul>
<blockquote>
<p>免责声明：在本文中，我对存储库会使用到一个简单的可变引用，因为现在我们只是在测试中使用它。在下一篇文章，我会进行一些优化 : )</p>
</blockquote>
<p>在上一篇文章中，我们已经开始搭建基本的项目架构。我们已经有了域模块，里面包含一个用例和一些实体：</p>
<pre><code>src
├── domain
│   ├── create_pokemon.rs
│   ├── entities.rs
│   └── mod.rs
└── main.rs
</code></pre>
<h2 id="内存存储库"><a class="header" href="#内存存储库">内存存储库</a></h2>
<p>让我们回到我们的 <code>create_pokemon</code> 用例。
目前，它可以在成功时返回宝可梦的数量，当请求参数不符合业务规则时会返回一个错误。现在我们并没有一个实际存储宝可梦的地方。让我们来解决这个问题！你应该知道我喜欢从什么开始：一个测试
: )。这个测试将检查我们不能有两个相同编号的宝可梦。</p>
<pre><code class="language-rs">use crate::repositories::pokemon::InMemoryRepository;

#[test]
fn it_should_return_a_conflict_error_when_pokemon_number_already_exists() {
    let number = PokemonNumber::try_from(25).unwrap();
    let name = PokemonName::try_from(String::from(&quot;Pikachu&quot;)).unwrap();
    let types = PokemonTypes::try_from(vec![String::from(&quot;Electric&quot;)]).unwrap();
    let mut repo = InMemoryRepository::new();
    repo.insert(number, name, types);
    let req = Request {
        number: 25,
        name: String::from(&quot;Charmander&quot;),
        types: vec![String::from(&quot;Fire&quot;)],
    };

    let res = execute(&amp;mut repo, req);

    match res {
        Response::Conflict =&gt; {}
        _ =&gt; unreachable!(),
    }
}
</code></pre>
<p>在个用例的测试中，我们直接在存储库中插入一个宝可梦。然后我们尝试使用用例再次插入一个具有相同编号的宝可梦。用例应该返回一个冲突错误。</p>
<p>像之前一样，它现在还不能通过编译，因为这里的很多代码都没有实现。让我们首先将 <code>Conflict</code> 错误添加到 <code>Response</code> 枚举中：</p>
<pre><code class="language-rs">enum Response {
    ...
    Conflict,
}
</code></pre>
<p>接着，在宝可梦类型中增加一个火属性</p>
<pre><code class="language-rs">enum PokemonType {
    Electric,
    Fire,
}

impl TryFrom&lt;String&gt; for PokemonType {
    type Error = ();

    fn try_from(t: String) -&gt; Result&lt;Self, Self::Error&gt; {
        match t.as_str() {
            &quot;Electric&quot; =&gt; Ok(Self::Electric),
            &quot;Fire&quot; =&gt; Ok(Self::Fire),
            _ =&gt; Err(()),
        }
    }
}
</code></pre>
<p>您可能想知道内存中的存储库是什么。它是在我们不知道客户将要使用什么作为存储库时，暂时使用的存储库。这是我们的第一个实现，它主要用于测试。因为它可以像真正的存储库一样工作，所以我们能够使用它去向客户展示我们的进度并要求他提供反馈。如你所见，存储库
<code>repo</code> 被当作参数传递给用例：</p>
<pre><code class="language-rs">use crate::repositories::pokemon::Repository;

fn execute(repo: &amp;mut dyn Repository, req: Request) -&gt; Response {
</code></pre>
<p>这里需要注意的一点是，<code>execute</code> 函数并不会得到具体的存储库实现，而是任何实现了 <code>Reposity</code> 特征的结构体。让我们在之前的两个测试用例中也补充
repo 参数：</p>
<pre><code class="language-rs">#[test]
fn it_should_return_a_bad_request_error_when_request_is_invalid() {
    let mut repo = InMemoryRepository::new();
    let req = Request {
    ...
    let res = execute(&amp;mut repo, req);
    ...
}

#[test]
fn it_should_return_the_pokemon_number_otherwise() {
    let mut repo = InMemoryRepository::new();
    let number = 25;
    ...
    let res = execute(&amp;mut repo, req);
    ...
}
</code></pre>
<p>接下来，我们将在新模块 <em>repositories/pokemon.rs</em> 中去定义 <code>InMemoryRepository</code> 结构体 和
<code>Repository</code> 特征：</p>
<pre><code>src
├── domain
│   ├── create_pokemon.rs
│   ├── entities.rs
│   └── mod.rs
├── repositories
│   ├── mod.rs
│   └── pokemon.rs
└── main.rs
</code></pre>
<pre><code class="language-rs">pub trait Repository {}

pub struct InMemoryRepository;

impl Repository for InMemoryRepository {}
</code></pre>
<p>不要忘了引用模块</p>
<pre><code class="language-rs">// main.rs
mod repositories;

// repositories/mod.rs
pub mod pokemon;
</code></pre>
<p>接下来，让我们实现 <code>InMemoryRepository</code> 的 <code>new</code> 方法。在这里，<code>InMemoryRepository</code>
内部只是简单的存储了一个宝可梦列表</p>
<pre><code class="language-rs">use crate::domain::entities::Pokemon;

pub struct InMemoryRepository {
    pokemons: Vec&lt;Pokemon&gt;,
}

impl InMemoryRepository {
    pub fn new() -&gt; Self {
        let pokemons: Vec&lt;Pokemon&gt; = vec![];
        Self { pokemons }
    }
}
</code></pre>
<p>现在，终于是实现 <code>Pokemon</code> 实体的时候了：</p>
<pre><code class="language-rs">pub struct Pokemon {
    pub number: PokemonNumber,
    name: PokemonName,
    types: PokemonTypes,
}

impl Pokemon {
    pub fn new(number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; Self {
        Self {
            number,
            name,
            types
        }
    }
}
</code></pre>
<p>同时，我们需要将 <code>entities.rs</code> 转为公开的：</p>
<pre><code class="language-rs">// domain/mod.rs
pub mod entities;
</code></pre>
<p>现在唯一没有被实现的就剩下 <code>insert</code> 方法了，我们希望能够在任何实现了 <code>Repository</code> 特征的存储库上都能调用该方法，所以需要在 Trait
上添加一个函数签名，并为 <code>InMemoryRepository</code> 结构体实现 <code>insert</code> 方法：</p>
<pre><code class="language-rs">use crate::domain::entities::{Pokemon, PokemonName, PokemonNumber, PokemonTypes};

pub trait Repository {
    fn insert(&amp;self, number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; PokemonNumber;
}

impl Repository for InMemoryRepository {
    fn insert(&amp;self, number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; PokemonNumber {
        number
    }
}
</code></pre>
<p>让我们尝试运行测试：</p>
<pre><code>cargo test
running 3 tests
test it_should_return_a_bad_request_error_when_request_is_invalid ... ok
test it_should_return_the_pokemon_number_otherwise ... ok
test it_should_return_a_conflict_error_when_pokemon_number_already_exists ... FAILED
</code></pre>
<p>第三个测试失败了，插入成功时，insert 应该返回一个宝可梦的编号，如果对应的编号已经存在，需要返回一个冲突的错误。所以我们现在要填加一个 <code>Insert</code>
结构体表示这两种结果，同时要将原本的不可边借用变为可变借用：</p>
<pre><code class="language-rs">pub enum Insert {
    Ok(PokemonNumber),
    Conflict,
}

pub trait Repository {
    fn insert(&amp;mut self, number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; Insert;
}
</code></pre>
<p>接下来实现 InMemoryRepository 的 insert 方法：</p>
<pre><code class="language-rs">impl Repository for InMemoryRepository {
    fn insert(&amp;mut self, number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; Insert {
        if self.pokemons.iter().any(|pokemon| pokemon.number == number) {
            return Insert::Conflict;
        }

        let number_clone = number.clone();
        self.pokemons.push(Pokemon::new(number_clone, name, types));
        Insert::Ok(number)
    }
}
</code></pre>
<p>为了让 <code>clone</code> 和 <code>==</code> 通过编译，我们还要为 <code>PokemonNumber</code> 实现 <code>PartialEq</code> 和 <code>Clone</code> 两个特征：</p>
<pre><code class="language-rs">use std::cmp::PartialEq;

#[derive(PartialEq, Clone)]
pub struct PokemonNumber(u16);
</code></pre>
<p>最后，让 <code>execute</code> 函数调用 insert 方法</p>
<pre><code class="language-rs">fn execute(repo: &amp;mut dyn Repository, req: Request) -&gt; Response {
    match (
        PokemonNumber::try_from(req.number),
        PokemonName::try_from(req.name),
        PokemonTypes::try_from(req.types),
    ) {
        (Ok(number), Ok(name), Ok(types)) =&gt; match repo.insert(number, name, types) {
            Insert::Ok(number) =&gt; Response::Ok(u16::from(number)),
            Insert::Conflict =&gt; Response::Conflict,
        },
        _ =&gt; Response::BadRequest,
    }
}
</code></pre>
<p>再次运行测试</p>
<pre><code>cargo test
running 3 tests
test it_should_return_a_bad_request_error_when_request_is_invalid ... ok
test it_should_return_the_pokemon_number_otherwise ... ok
test it_should_return_a_conflict_error_when_pokemon_number_already_exists ... ok
</code></pre>
<p>太棒了，冲突测试也通过了！</p>
<h2 id="以为已经结束了吗"><a class="header" href="#以为已经结束了吗">以为已经结束了吗？</a></h2>
<p>没有。在存储库中还有一种问题会发生。假设由于某些意外，存储库无法正常工作。如果是数据库，那就是连接错误，如果是 API，那就是网络错误。我们也应该处理这种情况。</p>
<p>你知道我现在要做什么：写一个测试！</p>
<pre><code class="language-rs">#[test]
fn it_should_return_an_error_when_an_unexpected_error_happens() {
    let mut repo = InMemoryRepository::new().with_error();
    let number = 25;
    let req = Request {
        number,
        name: String::from(&quot;Pikachu&quot;),
        types: vec![String::from(&quot;Electric&quot;)],
    };

    let res = execute(&amp;mut repo, req);

    match res {
        Response::Error =&gt; {}
        _ =&gt; unreachable!(),
    };
}
</code></pre>
<p>这个测试有两个不同点。第一，我们添加了 <code>with_error</code> 方法表示存储库连接异常。第二，我们需要检查 Respnse 是否发生异常。</p>
<p>首先为 Response 添加一个新的类型</p>
<pre><code class="language-rs">enum Response {
    ...
    Error,
}
</code></pre>
<p>现在我们要实现 <code>with_error</code> 方法，我的想法是在 <code>InMemoryRepository</code> 中增加一个 <code>error</code>
字段，表示是否会在连接存储库时进行检查。如果 <code>error</code> 为 <code>true</code> 我们就返回一个错误，否则返回正常结果：</p>
<pre><code class="language-rs">pub enum Insert {
    ...
    Error,
}

pub struct InMemoryRepository {
    error: bool,
    pokemons: Vec&lt;Pokemon&gt;,
}

impl InMemoryRepository {
    pub fn new() -&gt; Self {
        let pokemons: Vec&lt;Pokemon&gt; = vec![];
        Self {
            error: false,
            pokemons,
        }
    }

    pub fn with_error(self) -&gt; Self {
        Self {
            error: true,
            ..self
        }
    }
}

impl Repository for InMemoryRepository {
    fn insert(&amp;mut self, number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; Insert {
        if self.error {
            return Insert::Error;
        }

        if self.pokemons.iter().any(|pokemon| pokemon.number == number) {
            return Insert::Conflict;
        }

        let number_clone = number.clone();
        self.pokemons.push(Pokemon::new(number_clone, name, types));
        Insert::Ok(number)
    }
}
</code></pre>
<p>同样的，在 <code>execute</code> 中处理这种情况</p>
<pre><code class="language-rs">fn execute(repo: &amp;mut dyn Repository, req: Request) -&gt; Response {
    match (
        PokemonNumber::try_from(req.number),
        PokemonName::try_from(req.name),
        PokemonTypes::try_from(req.types),
    ) {
        (Ok(number), Ok(name), Ok(types)) =&gt; match repo.insert(number, name, types) {
            Insert::Ok(number) =&gt; Response::Ok(u16::from(number)),
            Insert::Conflict =&gt; Response::Conflict,
            Insert::Error =&gt; Response::Error,
        },
        _ =&gt; Response::BadRequest,
    }
}
</code></pre>
<p>让我们运行测试</p>
<pre><code>cargo test
running 4 tests
test it_should_return_a_bad_request_error_when_request_is_invalid ... ok
test it_should_return_a_conflict_error_when_pokemon_number_already_exists ... ok
test it_should_return_an_error_when_an_unexpected_error_happens ... ok
test it_should_return_the_pokemon_number_otherwise ... ok
</code></pre>
<p>\o/</p>
<h2 id="下一步"><a class="header" href="#下一步">下一步</a></h2>
<p>这篇文章的长度已经足够了，让我们暂时停到这里。下一次，我将为前端部分先实现 HTTP
API。之后我会处理其他的用例。我们之后还会实现更多的存储库和前端接口，这些功能会通过添加不同的命令行参数进行开启。</p>
<p>和以前一样，我会在 <a href="https://github.com/alexislozano/pokedex/tree/article-2">github</a>
上创建一个包含所有更改的分支。</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://alexis-lozano.com/hexagonal-architecture-in-rust-7/</p>
<p>翻译：<a href="https://github.com/trdthg">trdthg</a></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="2021-10-17---rust-六边形架构-7---长期存储库"><a class="header" href="#2021-10-17---rust-六边形架构-7---长期存储库">2021-10-17 - Rust 六边形架构 #7 - 长期存储库</a></h1>
<p>这里是本系列的最后一篇文章了。非常感谢你，在七篇文章之后仍然在这里的匿名读者。我们已经介绍了很多东西：我们有一个域，我们能够存储数据，我们可以使用 CLI 和
HTTP 服务器来操作我们的程序。那么我们还需要做什么呢？哦，我看到客户了，我们问问他吧。</p>
<ul>
<li>嘿，最近好吗？</li>
<li>我很好，但你的软件不是很好。</li>
<li>哦... 有什么问题吗？</li>
<li>当我重启程序时，所有的数据都丢失了。</li>
<li>啊，对，那很正常。我们现在依然是在直接操作内存。</li>
<li>你能让这些数据得以长期保存吗？</li>
<li>这些数据？当然可以。您能给我们提供保存的地方吗？</li>
<li>嗯，我不知道。我要去找人问问。你能不能让程序暂时把数据存储再硬盘上？</li>
<li>马上完成！</li>
</ul>
<p>好的，我们想要把数据保存在一个地方，当程序重启后也不会被删除。我们需要使用文件，同时因为我们想要使用一种可靠的方式去查询数据，我们将使用 SQL。文件和
SQL... 有东西在我脑海里尖叫者 <strong>SQLite</strong></p>
<p>有一点好处是，我们现在已经实现了一个存储库系统，我们只需要填加一个新的存储库，以及一个命令行开关去决定使用那种存储库即可。因为有六边形架构，我们的域完全不用修改
: D</p>
<h2 id="使用-sqlite-作为本地存储"><a class="header" href="#使用-sqlite-作为本地存储">使用 SQLite 作为本地存储</a></h2>
<h3 id="创建数据库"><a class="header" href="#创建数据库">创建数据库</a></h3>
<p>首先我们要使用 sqlite3 提供的命令行工具创建一个数据库：</p>
<pre><code>sqlite3 path/to/the/database.sqlite
</code></pre>
<p>你应该已经得到了 SQLite 的提示。现在我们要创建两张表。为什么是两张？因为一个宝可梦有很多种类型。所以我们不能再一列中存储所有的类型。</p>
<p>实际上，宝可梦表与类型表是多对多的关系：</p>
<ul>
<li>一只宝可梦有多种类型</li>
<li>一个类型可以对应多个宝可梦</li>
</ul>
<p>所以完整的数据库应该是下面的样子，它一共有 3 张表：</p>
<pre><code>pokemons           | number          | name     |

types              | id              | name     |

pokemons_to_types  | pokemons.number | types.id |
</code></pre>
<p>但是在这个例子里，因为我们有类型的 <code>id</code>，暂时我们只需要两张表：</p>
<pre><code>pokemons | number          | name |

types    | pokemons.number | name |
</code></pre>
<p>让我们回到 SQLite 的命令行中。首先我们要激活外键 (默认是关闭的)。</p>
<blockquote>
<p>注意：这个操作只会在本次连接中生效，</p>
</blockquote>
<pre><code class="language-sql">pragma foreign_keys = 1;
</code></pre>
<p>现在我们开始创建数据表：</p>
<pre><code class="language-sql">create table pokemons (
    number integer primary key,
    name text
);

create table types (
    pokemon_number integer,
    name text,
    foreign key (pokemon_number) references pokemons (number) on delete cascade,
    primary key (pokemon_number, name)
);
</code></pre>
<p><code>on delete cascade</code> 的效果是当一个宝可梦被删除时，类型表中所有 <code>pokemon_number</code> 和 <code>number</code>
相同的行也会被删除。这样我们在程序中就不用在关心了：) 现在你可以使用 Ctrl-D 退出 SQLite 了。</p>
<h2 id="添加选择存储库的开关"><a class="header" href="#添加选择存储库的开关">添加选择存储库的开关</a></h2>
<p>现在我们有 SQLite 作为数据库，我们要再添加一个命令行参数告诉程序我们想使用 SQLite。大概效果是这样</p>
<pre><code>pokedex --sqlite path/to/the/database.sqlite
</code></pre>
<p>当你使用 cargo run 时需要改为这样：</p>
<pre><code>cargo run -- --sqlite path/to/the/database.sqlite
</code></pre>
<pre><code class="language-rs">fn main() { let repo = Arc::new(InMemoryRepository::new());

    let matches = App::new(crate_name!())
        .version(crate_version!())
        .author(crate_authors!())
        .arg(Arg::with_name(&quot;cli&quot;).long(&quot;cli&quot;).help(&quot;Runs in CLI mode&quot;))
        .arg(Arg::with_name(&quot;sqlite&quot;).long(&quot;sqlite&quot;).value_name(&quot;PATH&quot;))
        .get_matches();

    match matches.occurrences_of(&quot;cli&quot;) {
        0 =&gt; api::serve(&quot;localhost:8000&quot;, repo),
        _ =&gt; cli::run(repo),
    }
}
</code></pre>
<p>现在数据库开关已经加上了，通过 <code>--help</code> 查看：</p>
<pre><code>OPTIONS: --sqlite &lt;PATH&gt;
</code></pre>
<p>接下来我们去初始化一个暂时还没有实现的 <code>SqliteRepository</code>：</p>
<pre><code class="language-rs">use repositories::pokemon::{..., SqliteRepository};

fn main() {
    let matches = ...

    let repo = build_repo(matches.value_of(&quot;sqlite&quot;));

    match matches.occurrences_of(&quot;cli&quot;) {
        0 =&gt; api::serve(&quot;localhost:8000&quot;, repo),
        _ =&gt; cli::run(repo),
    }

}

fn build_repo(sqlite_value: Option&lt;&amp;str&gt;) -&gt; Arc&lt;dyn Repository&gt; {
    if let Some(path) = sqlite_value {
        match SqliteRepository::try_new(path) {
            Ok(repo) =&gt; return Arc::new(repo),
            _ =&gt; panic!(&quot;Error while creating sqlite repo&quot;),
        }
    }

    Arc::new(InMemoryRepository::new())
}
</code></pre>
<p>当 <code>--sqlite</code> 打开时，程序会尝试初始化 SQLite 存储库。如果初始化失败，程序就会崩溃并打印错误信息。如果没有开启 <code>--sqlite</code>
就会使用默认的内存存储库。</p>
<h2 id="实现-sqlite-存储库"><a class="header" href="#实现-sqlite-存储库">实现 SQlite 存储库</a></h2>
<p>我从文章一开始就在谈论 SQLite。现在我们需要一种从 Rust 调用数据库的方法。我们将使用 <code>rusqlite</code> 去实现。让我们在
<code>Cargo.toml</code> 中导入它：</p>
<pre><code class="language-toml">[dependencies]
rusqlite = &quot;0.26.0&quot;
</code></pre>
<p>现在我们要实现 <code>SQLiteRepository</code>，我要在 <code>InMemoryRepository</code> 所在的文加中创建
<code>SQLiteRepository</code>。当然，这不是强制的，你也可以根据去要把它放在一个新文件中：</p>
<pre><code class="language-rs">use rusqlite::Connection;

pub struct SqliteRepository { connection: Mutex&lt;Connection&gt;, }
</code></pre>
<p><em>main.rs</em> 中的 <code>use</code> 现在应该不会报错了，接着实现 <code>try_new</code> 方法：</p>
<pre><code class="language-rs">use rusqlite::{..., OpenFlags};

impl SqliteRepository {
    pub fn try_new(path: &amp;str) -&gt; Result&lt;Self, ()&gt; {
        let connection = match Connection::open_with_flags(path, OpenFlags::SQLITE_OPEN_READ_WRITE)
        {
            Ok(connection) =&gt; connection,
            _ =&gt; return Err(()),
        };

        match connection.execute(&quot;pragma foreign_keys = 1&quot;, []) {
            Ok(_) =&gt; Ok(Self {
                connection: Mutex::new(connection),
            }),
            _ =&gt; Err(()),
        }
    }

}
</code></pre>
<p>首先，我们调用 <code>rusqlite</code> 去新建一个对数据文件的连接。而且我们通过 <code>OpenFlags</code> 去明确禁止当文件不存在时 <code>rusqulite</code>
去自动创建数据文件。如果连接成功，我们就会执行只前提到的命令，确保外键开启。最后我们去返回这个存储库。</p>
<p>如果你现在尝试运行程序，还不能通过编译，为什么？因为我们还没有实现 <code>Repository</code> Trait 定义的的所有方法：</p>
<pre><code class="language-rs">impl Repository for SqliteRepository {
    fn insert(
        &amp;self,
        number: PokemonNumber,
        name: PokemonName,
        types: PokemonTypes,
    ) -&gt; Result&lt;Pokemon, InsertError&gt; {
        Err(InsertError::Unknown)
    }

    fn fetch_all(&amp;self) -&gt; Result&lt;Vec&lt;Pokemon&gt;, FetchAllError&gt;{
        Err(FetchAllError::Unknown)
    }

    fn fetch_one(&amp;self, number: PokemonNumber) -&gt; Result&lt;Pokemon, FetchOneError&gt; {
        Err(FetchOneError::Unknown)
    }

    fn delete(&amp;self, number: PokemonNumber) -&gt; Result&lt;(), DeleteError&gt; {
        Err(DeleteError::Unknown)
    }
}
</code></pre>
<p>编译通过了，但是我们的存储库依然没什么用现在。接下来我们要实现那些方法 :)</p>
<h2 id="辅助函数"><a class="header" href="#辅助函数">辅助函数</a></h2>
<p>在我们实现存储库需要的函数之前，让我们先定义两个辅助函数。我们想要查询一个或者是所有宝可梦，用 SQL 语句描述就是一个
<code>select</code>。我们创建的辅助函数能够把这两个查询逻辑整合到一起。</p>
<p>首先，我们编写一个能够拿到所有宝可梦编号和名字的函数。这个函数接受一个已经拿到锁的存储库，也可能会需要一个宝可梦的编号。如果函数接收到了编号，那么就会在 SQL
语句上添加 <code>where</code> 子句。这个函数会被添加到 <code>impl SqliteRepository</code> 块内，因为它不是 <code>Repository Trait</code>
的一部分。另外，我们将直接返回原始数据 ( <code>u16</code> 和 <code>String</code> )，而且这个函数应该是私有的。</p>
<pre><code class="language-rs">use std::sync::{..., MutexGuard};

fn fetch_pokemon_rows(
    lock: &amp;MutexGuard&lt;'_, Connection&gt;,
    number: Option&lt;u16&gt;,
) -&gt; Result&lt;Vec&lt;(u16, String)&gt;, ()&gt; {
    // code will go here
}
</code></pre>
<p>让我们开始吧。首先，我们要根据数字是否存在来定义查询语句和查询参数：</p>
<pre><code class="language-rs">let (query, params) = match number {
    Some(number) =&gt; (
        &quot;select number, name from pokemons where number = ?&quot;,
        vec![number],
    ),
    _ =&gt; (&quot;select number, name from pokemons&quot;, vec![]),
};
</code></pre>
<p>相当简单吧？现在我们必须准备一个 <code>statment</code> 并传递我们的参数：</p>
<pre><code class="language-rs">use rusqlite::{..., params_from_iter};

...
let mut stmt = match lock.prepare(query) {
    Ok(stmt) =&gt; stmt,
    _ =&gt; return Err(()),
};

let mut rows = match stmt.query(params_from_iter(params)) {
    Ok(rows) =&gt; rows,
    _ =&gt; return Err(()),
};
</code></pre>
<p>我们已经得到查询结果，现在需要把结果转换为一个 <code>(u16, String)</code> 类型的元组 再把他们汇集到一个向量里返回</p>
<pre><code class="language-rs">...
let mut pokemon_rows = vec![];

while let Ok(Some(row)) = rows.next() {
    match (row.get::&lt;usize, u16&gt;(0), row.get::&lt;usize, String&gt;(1)) {
        (Ok(number), Ok(name)) =&gt; pokemon_rows.push((number, name)),
        _ =&gt; return Err(()),
    };
}

Ok(pokemon_rows)
</code></pre>
<p>对 <code>types</code> 表也一样，这个辅助函数接收一个数据库连接和一个 <code>number</code>，查询成功会返回一个字符串向量，表示某一只宝可梦的类型：</p>
<pre><code class="language-rs">fn fetch_type_rows(lock: &amp;MutexGuard&lt;'_, Connection&gt;, number: u16) -&gt; Result&lt;Vec&lt;String&gt;, ()&gt; {
    // code will go here
}
</code></pre>
<p>准备查询语句，带着参数进行查询：</p>
<pre><code class="language-rs">let mut stmt = match lock.prepare(&quot;select name from types where pokemon_number = ?&quot;) {
    Ok(stmt) =&gt; stmt,
    _ =&gt; return Err(()),
};

let mut rows = match stmt.query([number]) {
    Ok(rows) =&gt; rows,
    _ =&gt; return Err(()),
};
</code></pre>
<p>依次从结果中提取出类型：</p>
<pre><code class="language-rs">let mut type_rows = vec![];

while let Ok(Some(row)) = rows.next() {
    match row.get::&lt;usize, String&gt;(0) {
        Ok(name) =&gt; type_rows.push(name),
        _ =&gt; return Err(()),
    };
}
Ok(type_rows)
</code></pre>
<p>Aaaand，顺利完成！这两个功能现在都实现了。使用它们去实现 <code>fetch_one</code> 和 <code>fetch_all</code> 会更容易:)</p>
<h2 id="查询一只宝可梦"><a class="header" href="#查询一只宝可梦">查询一只宝可梦</a></h2>
<p>我们会一步一步来，首先处理下面的方法：</p>
<pre><code class="language-rs">fn fetch_one(&amp;self, number: PokemonNumber) -&gt; Result&lt;Pokemon, FetchOneError&gt; {
    // code will go here
}
</code></pre>
<p>首先，我们要先拿到锁，并通过调用之前的辅助函数去查询宝可梦：</p>
<pre><code class="language-rs">let lock = match self.connection.lock() {
    Ok(lock) =&gt; lock,
    _ =&gt; return Err(FetchOneError::Unknown),
};

let mut pokemon_rows = match Self::fetch_pokemon_rows(&amp;lock, Some(u16::from(number.clone()))) {
    Ok(pokemon_rows) =&gt; pokemon_rows,
    _ =&gt; return Err(FetchOneError::Unknown),
};
</code></pre>
<p>当查询结果为空时，我们就返回 <code>NotFound</code>，否则返回查询结果的第一个：</p>
<pre><code class="language-rs">...
if pokemon_rows.is_empty() {
    return Err(FetchOneError::NotFound);
}

let pokemon_row = pokemon_rows.remove(0);
</code></pre>
<p>不错。现在我们去查询宝可梦类型：</p>
<pre><code class="language-rs">let type_rows = match Self::fetch_type_rows(&amp;lock, pokemon_row.0) {
    Ok(type_rows) =&gt; type_rows,
    _ =&gt; return Err(FetchOneError::Unknown),
};
</code></pre>
<p>我们已经有宝可梦的编号、名称和类型。总是时候把他们封装为 <code>Response</code> 了：</p>
<pre><code class="language-rs">...
match (
    PokemonNumber::try_from(pokemon_row.0),
    PokemonName::try_from(pokemon_row.1),
    PokemonTypes::try_from(type_rows),
) {
    (Ok(number), Ok(name), Ok(types)) =&gt; Ok(Pokemon::new(number, name, types)),
    _ =&gt; Err(FetchOneError::Unknown),
}
</code></pre>
<h2 id="查询所有宝可梦"><a class="header" href="#查询所有宝可梦">查询所有宝可梦</a></h2>
<pre><code class="language-rs">fn fetch_all(&amp;self) -&gt; Result&lt;Vec&lt;Pokemon&gt;, FetchAllError&gt; {
    // code will go here
}
</code></pre>
<p>首先获取锁并查询所有宝可梦：</p>
<pre><code class="language-rs">let lock = match self.connection.lock() {
    Ok(lock) =&gt; lock,
    _ =&gt; return Err(FetchAllError::Unknown),
};

let pokemon_rows = match Self::fetch_pokemon_rows(&amp;lock, None) {
    Ok(pokemon_rows) =&gt; pokemon_rows,
    _ =&gt; return Err(FetchAllError::Unknown),
};
</code></pre>
<p>你可以注意到，我们把 <code>number</code> 参数设置为了 <code>None</code>，对每个宝可梦，我们会单独查询它的类型，最终封装为一个列表：</p>
<pre><code class="language-rs">...
let mut pokemons = vec![];

for pokemon_row in pokemon_rows {
    let type_rows = match Self::fetch_type_rows(&amp;lock, pokemon_row.0) {
        Ok(type_rows) =&gt; type_rows,
        _ =&gt; return Err(FetchAllError::Unknown),
    };

    let pokemon = match (
        PokemonNumber::try_from(pokemon_row.0),
        PokemonName::try_from(pokemon_row.1),
        PokemonTypes::try_from(type_rows),
    ) {
        (Ok(number), Ok(name), Ok(types)) =&gt; Pokemon::new(number, name, types),
        _ =&gt; return Err(FetchAllError::Unknown),
    };

    pokemons.push(pokemon);
}

Ok(pokemons)
</code></pre>
<h2 id="插入一只宝可梦"><a class="header" href="#插入一只宝可梦">插入一只宝可梦</a></h2>
<pre><code class="language-rs">fn insert(
    &amp;self,
    number: PokemonNumber,
    name: PokemonName,
    types: PokemonTypes,
) -&gt; Result&lt;Pokemon, InsertError&gt; {
    // code will go here
}
</code></pre>
<p>首先，我们从连接中获取锁：</p>
<pre><code class="language-rs">let mut lock = match self.connection.lock() {
    Ok(lock) =&gt; lock,
    _ =&gt; return Err(InsertError::Unknown),
};
</code></pre>
<p>接着我们创建了一个事务。为什么我们没有直接执行一条命令？因为我们需要向 <code>pokemons</code> 中插入一只宝可梦，同时要想 <code>types</code>
中插入它的类型。如果这两次插入有一个失败了，这次插入最好能回滚。使用事务时，你需要先创建 <code>SQL</code> 语句，之后提交。如果有错误发生，<code>rusqlite</code>
会自动完成回滚。</p>
<pre><code class="language-rs">let transaction = match lock.transaction() {
    Ok(transaction) =&gt; transaction,
    _ =&gt; return Err(InsertError::Unknown),
};
</code></pre>
<p>现在我们要向事务中添加第一条命令。我们要插入一只宝可梦。如果已经存在，我们希望函数执行失败并返回一个错误：</p>
<pre><code class="language-rs">use rusqlite::{..., Error::SqliteFailure, params};

...
match transaction.execute(
    &quot;insert into pokemons (number, name) values (?, ?)&quot;,
    params![u16::from(number.clone()), String::from(name.clone())],
) {
    Ok(_) =&gt; {}
    Err(SqliteFailure(_, Some(message))) =&gt; {
        if message == &quot;UNIQUE constraint failed: pokemons.number&quot; {
            return Err(InsertError::Conflict);
        } else {
            return Err(InsertError::Unknown);
        }
    }
    _ =&gt; return Err(InsertError::Unknown),
};
</code></pre>
<p>在这里，我们使用 <code>rusqlite</code> 返回的错误信息来检查错误是否是由于冲突引起的。现在宝可梦的插入逻辑完成了。</p>
<p>接下来要处理插入类型。我们需要为 <code>PokemonTypes</code> 参数中的每种类型都分别执行一次插入操作：</p>
<pre><code class="language-rs">...
for _type in Vec::&lt;String&gt;::from(types.clone()) {
    if let Err(_) = transaction.execute(
        &quot;insert into types (pokemon_number, name) values (?, ?)&quot;,
        params![u16::from(number.clone()), _type],
    ) {
        return Err(InsertError::Unknown);
    }
}
</code></pre>
<p>现在，我们可以提交这个事务，并返回结果。</p>
<pre><code class="language-rs">...
match transaction.commit() {
    Ok(_) =&gt; Ok(Pokemon::new(number, name, types)),
    _ =&gt; Err(InsertError::Unknown),
}
</code></pre>
<h2 id="删除一只宝可梦"><a class="header" href="#删除一只宝可梦">删除一只宝可梦</a></h2>
<pre><code class="language-rs">fn delete(&amp;self, number: PokemonNumber) -&gt; Result&lt;(), DeleteError&gt; {
    // code will go here
}
</code></pre>
<pre><code class="language-rs">let lock = match self.connection.lock() {
    Ok(lock) =&gt; lock,
    _ =&gt; return Err(DeleteError::Unknown),
};
</code></pre>
<pre><code class="language-rs">match lock.execute(
    &quot;delete from pokemons where number = ?&quot;,
    params![u16::from(number)],
) {
    Ok(0) =&gt; Err(DeleteError::NotFound),
    Ok(_) =&gt; Ok(()),
    _ =&gt; Err(DeleteError::Unknown),
}
</code></pre>
<p>这里需要注意两点：第一，我们不需要再关注删除宝可梦时记得删除类型信息，在创建数据表时我们已经设置了 <code>on delete cascade</code> 让 sqlite
去自动处理。第二，我们使用删除操作返回的行数去判断是否删除成功，如果数量是 0，就表示删除失败。</p>
<p>你现在应该能使用你的 SQLite 数据库作为存储库了，而且能通过 CLI 和 HTTP API 两种方式访问。你可以尝试从 CLI 创建一些新的宝可梦，并从
HTTP API 去获取他们 :)</p>
<h2 id="小插曲"><a class="header" href="#小插曲">小插曲</a></h2>
<p>🙀 我看到客户了，他正朝着我这边来。</p>
<ul>
<li>你好 Alexis！</li>
<li>你好 客户！我已经实现了一个持久化的存储库，它把数据存储在计算机的硬盘上。</li>
<li>哦，太好了！虽然现在我知道了我们将使用什么作为存储库。</li>
<li>不错，速度很快。是 PostgreSQL 吗？还是 Mysql？</li>
<li>都不是，我们的公司希望它是水平可拓展的。</li>
<li>嗯，这让我想起了一个<a href="https://www.youtube.com/watch?v=b2F-DItXtZs">恐怖故事</a>。那好吧，你们公司打算使用什么技术？</li>
<li>他们想使用 Airtable，一个类似于 Excel 的在线表格。</li>
<li>哦... 让我看看我能做的。</li>
</ul>
<h2 id="使用-airtable-实现弹性存储库"><a class="header" href="#使用-airtable-实现弹性存储库">使用 Airtable 实现弹性存储库</a></h2>
<p>好吧，现在我们必须创建另一个存储库了。生活就是如此。所以我们现在可以去 Airtable
网站看看它是怎么使用的。你必须创建一个账户，并且新建一个工作区。在这个工作区里，你应该有一个默认的工作表。把他重命名为
<code>pokemons</code>。你可以把表格的列改为下面的样子：</p>
<pre><code>number:
    选择 Number 类型
    选择 Integer 子类型
    关闭允许负数
name:
    选择 Single line text 类型
types:
    选择 Multiple select 类型
    再选项里添加 Electric 和 Fire
</code></pre>
<p>我们能用一张数据表去为我们的数据建模了 : )</p>
<p>现在我们需要知道我们的程序怎样和 Airtable 进行交互。让我们去阅读一下 API 文档。在那里你应该能看到 Airtable
现在支持的客户端，撰写本文时并没有提供 Rust 的，所以我们要尝试使用它们的 HTTP API。我们的程序现在需要一个 HTTP 客户端，这里我们使用
<code>ureq</code>:</p>
<pre><code class="language-toml">[dependencies]
ureq = { version = &quot;2.2.0&quot;, features = [&quot;json&quot;] }
</code></pre>
<p>开启 <code>json</code> 特性能够帮我们把 HTTP 响应转化为 结构体 ( 感谢 <code>serde</code> )。但是再我们实现存储库之前，我们要再程序开始前让用户能够选择使用
Airtable 作为存储库。</p>
<h3 id="添加启动开关"><a class="header" href="#添加启动开关">添加启动开关</a></h3>
<p>首先让我们看一下如何使用 API。这里是文档给出的一个请求示例：</p>
<pre><code>curl https://api.airtable.com/v0/&lt;WORKSPACE_ID&gt;/pokemons -H &quot;Authorization: Bearer &lt;API_KEY&gt;&quot;
</code></pre>
<p>好的，所以我们的程序需要两个参数 <code>api_key</code> 和 <code>workspace_id</code>：</p>
<pre><code class="language-rs">fn main() {
    let matches = App::new(crate_name!())
        .version(crate_version!())
        .author(crate_authors!())
        .arg(Arg::with_name(&quot;cli&quot;).long(&quot;cli&quot;).help(&quot;Runs in CLI mode&quot;))
        .arg(Arg::with_name(&quot;sqlite&quot;).long(&quot;sqlite&quot;).value_name(&quot;PATH&quot;))
        .arg(
            Arg::with_name(&quot;airtable&quot;)
                .long(&quot;airtable&quot;)
                .value_names(&amp;[&quot;API_KEY&quot;, &quot;WORKSPACE_ID&quot;]),
        )
        .get_matches();
}
</code></pre>
<p>现在，运行 <code>pokedex --airtable &lt;API_KEY&gt; &lt;WORKSPACE_ID&gt;</code> 就能设置 Airtable 作为存储库，使用 cargo
run 启动的话，你可以输入 <code>cargo run -- --airtable &lt;API_KEY&gt; &lt;WORKSPACE_ID&gt;</code>。可以使用 <code>--help</code>
检查是否生效：</p>
<pre><code>OPTIONS:
        --airtable &lt;API_KEY&gt; &lt;WORKSPACE_ID&gt;
</code></pre>
<p>接下来，让我们更新 build_repo 函数，使它能够创建一个 AirtableRepository：</p>
<pre><code class="language-rs">use clap::{..., Values};
use repositories::pokemon::{AirtableRepository, ...};

fn main() {
    ...
    let repo = build_repo(matches.value_of(&quot;sqlite&quot;), matches.values_of(&quot;airtable&quot;));
    ...
}

fn build_repo(sqlite_value: Option&lt;&amp;str&gt;, airtable_values: Option&lt;Values&gt;) -&gt; Arc&lt;dyn Repository&gt; {
    if let Some(values) = airtable_values {
        if let [api_key, workspace_id] = values.collect::&lt;Vec&lt;&amp;str&gt;&gt;()[..] {
            match AirtableRepository::try_new(api_key, workspace_id) {
                Ok(repo) =&gt; return Arc::new(repo),
                _ =&gt; panic!(&quot;Error while creating airtable repo&quot;),
            }
        }
    }
    ...
}
</code></pre>
<p>所以现在如果设置了 <code>--airtable</code> 标志，我们将使用 Airtable 作为存储库。如果设置了 <code>--sqlite</code> 标志，我们将使用
SQLite。否则我们使用内存存储库。现在让我们实现存储库；）</p>
<h3 id="实现存储库"><a class="header" href="#实现存储库">实现存储库</a></h3>
<blockquote>
<p>注意：网站的 API 经常发生变动，如果下面的测试失败了，请到<a href="https://airtable.com/api/meta">官网</a>查看最新的 API。</p>
</blockquote>
<p>我将在 <em>repositories/pokemon.rs</em> 中添加
<code>AirtableRepository</code>。像以前一样，您可以将其放在新的文件中。让我们首先创建结构体：</p>
<pre><code class="language-rs">pub struct AirtableRepository {
    url: String,
    auth_header: String,
}
</code></pre>
<p>我们依然需要实现 <code>try_new</code> 函数。我们将使用 <code>workspace_id</code> 创建 <code>url</code>，使用 <code>api_key</code> 创建
<code>auth_header</code>。接着还要发出请求以确保我们可以连接到我们的数据库：</p>
<pre><code class="language-rs">impl AirtableRepository {
    pub fn try_new(api_key: &amp;str, workspace_id: &amp;str) -&gt; Result&lt;Self, ()&gt; {
        let url = format!(&quot;https://api.airtable.com/v0/{}/pokemons&quot;, workspace_id);
        let auth_header = format!(&quot;Bearer {}&quot;, api_key);

        if let Err(_) = ureq::get(&amp;url).set(&quot;Authorization&quot;, &amp;auth_header).call() {
            return Err(());
        }

        Ok(Self { url, auth_header })
    }
}
</code></pre>
<p>接着我们要为它实现 <code>Repository</code> Trait：</p>
<pre><code class="language-rs">impl Repository for AirtableRepository {
    fn insert(
        &amp;self,
        number: PokemonNumber,
        name: PokemonName,
        types: PokemonTypes,
    ) -&gt; Result&lt;Pokemon, InsertError&gt; {
        Err(InsertError::Unknown)
    }

    fn fetch_all(&amp;self) -&gt; Result&lt;Vec&lt;Pokemon&gt;, FetchAllError&gt; {
        Err(FetchAllError::Unknown)
    }

    fn fetch_one(&amp;self, number: PokemonNumber) -&gt; Result&lt;Pokemon, FetchOneError&gt; {
        Err(FetchOneError::Unknown)
    }

    fn delete(&amp;self, number: PokemonNumber) -&gt; Result&lt;(), DeleteError&gt; {
        Err(DeleteError::Unknown)
    }
}
</code></pre>
<h4 id="辅助函数-1"><a class="header" href="#辅助函数-1">辅助函数</a></h4>
<p>你现在应该已经习惯了，这次我们只需要一个辅助函数。这个函数能让我们从 Airtable 中获取某一行或者多行数据。它的参数 <code>&amp;self</code> 和 一个可选的
<code>number</code>。它的返回值可能是个 <code>json</code> 或者是个 <code>Error</code>。它依然是个私有的方法，再 <code>impl AirtableRepository</code>
块中实现。有了 <code>serde</code> 我们能将 <code>json</code> 直接转化为结构体，首先我们需要定义对应的结构体：</p>
<pre><code class="language-rs">#[derive(Deserialize)]
struct AirtableJson {
    records: Vec&lt;AirtableRecord&gt;,
}

#[derive(Deserialize)]
struct AirtableRecord {
    id: String,
    fields: AirtableFields,
}

#[derive(Deserialize)]
struct AirtableFields {
    number: u16,
    name: String,
    types: Vec&lt;String&gt;,
}
</code></pre>
<p>接着是辅助函数：</p>
<pre><code class="language-rs">fn fetch_pokemon_rows(&amp;self, number: Option&lt;u16&gt;) -&gt; Result&lt;AirtableJson, ()&gt; {
    // code will go here
}
</code></pre>
<p>第一步要根据用户传来的 <code>number</code> 去创建请求链接：</p>
<pre><code class="language-rs">let url = match number {
    Some(number) =&gt; format!(&quot;{}?filterByFormula=number%3D{}&quot;, self.url, number),
    None =&gt; format!(&quot;{}?sort%5B0%5D%5Bfield%5D=number&quot;, self.url),
};
</code></pre>
<p>请求参数看起来稍微有一点奇怪。第一个是依靠 <code>number</code> 进行过滤，第二个是根据 <code>number</code> 对数据排序。现在我们能用 <code>ureq</code> 尝试发出请求了：</p>
<pre><code class="language-rs">let res = match ureq::get(&amp;url)
    .set(&quot;Authorization&quot;, &amp;self.auth_header)
    .call()
{
    Ok(res) =&gt; res,
    _ =&gt; return Err(()),
};
</code></pre>
<p>我们在返回值中接收到了 <code>json</code> ，接着我们把它转换为 <code>AirtableJson</code>:</p>
<pre><code class="language-rs">match res.into_json::&lt;AirtableJson&gt;() {
    Ok(json) =&gt; Ok(json),
    _ =&gt; Err(()),
}
</code></pre>
<p>辅助函数完成了 : )</p>
<h4 id="查询一个宝可梦"><a class="header" href="#查询一个宝可梦">查询一个宝可梦</a></h4>
<pre><code class="language-rs">fn fetch_one(&amp;self, number: PokemonNumber) -&gt; Result&lt;Pokemon, FetchOneError&gt; {
    // code will go here
}
</code></pre>
<p>首先，我们让使用我们之前实现的函数获取 <code>json</code> ：</p>
<pre><code class="language-rs">let mut json = match self.fetch_pokemon_rows(Some(u16::from(number.clone()))) {
    Ok(json) =&gt; json,
    _ =&gt; return Err(FetchOneError::Unknown),
};
</code></pre>
<p>现在，如果 <code>json</code> 记录为空，则意味着我们想要的宝可梦不存在。所以我们会返回一个错误。否则，我们取第一条记录：</p>
<pre><code class="language-rs">...
if json.records.is_empty() {
    return Err(FetchOneError::NotFound);
}

let record = json.records.remove(0);
</code></pre>
<p>最后，我们需要做的是把这条记录转换为宝可梦：</p>
<pre><code class="language-rs">...
match (
    PokemonNumber::try_from(record.fields.number),
    PokemonName::try_from(record.fields.name),
    PokemonTypes::try_from(record.fields.types),
) {
    (Ok(number), Ok(name), Ok(types)) =&gt; Ok(Pokemon::new(number, name, types)),
    _ =&gt; Err(FetchOneError::Unknown),
}
</code></pre>
<h4 id="获取所有宝可梦"><a class="header" href="#获取所有宝可梦">获取所有宝可梦</a></h4>
<pre><code class="language-rs">fn fetch_all(&amp;self) -&gt; Result&lt;Vec&lt;Pokemon&gt;, FetchAllError&gt; {
    // code will go here
}
</code></pre>
<p>首先，依然是使用辅助函数获取 <code>json</code> ：</p>
<pre><code class="language-rs">let json = match self.fetch_pokemon_rows(None) {
    Ok(json) =&gt; json,
    _ =&gt; return Err(FetchAllError::Unknown),
};
</code></pre>
<p>这一次，我没有给辅助函数提供 <code>number</code> 。现在让我们将这些记录转换为 <code>Pokemons</code> 并返回：</p>
<pre><code class="language-rs">...
let mut pokemons = vec![];

for record in json.records.into_iter() {
    match (
        PokemonNumber::try_from(record.fields.number),
        PokemonName::try_from(record.fields.name),
        PokemonTypes::try_from(record.fields.types),
    ) {
        (Ok(number), Ok(name), Ok(types)) =&gt; {
            pokemons.push(Pokemon::new(number, name, types))
        }
        _ =&gt; return Err(FetchAllError::Unknown),
    }
}

Ok(pokemons)
</code></pre>
<h4 id="插入一只宝可梦-1"><a class="header" href="#插入一只宝可梦-1">插入一只宝可梦</a></h4>
<pre><code class="language-rs">fn insert(
    &amp;self,
    number: PokemonNumber,
    name: PokemonName,
    types: PokemonTypes,
) -&gt; Result&lt;Pokemon, InsertError&gt; {
    // code will go here
}
</code></pre>
<p>Airtable 本身存在一个问题：<code>AirtableRecord</code> 的主键并不能保证数据的唯一性。或许你已经注意到了 <code>AirtableRecord</code> 中的
<code>id</code> 字段 :) 因此，我们不能尝试插入记录并等待返回错误，Airtable
只会负责在表中添加新行。然后我们要做的是首先尝试获取相同编号的宝可梦，如果此请求的结果不为空，则返回错误。</p>
<pre><code class="language-rs">let json = match self.fetch_pokemon_rows(Some(u16::from(number.clone()))) {
    Ok(json) =&gt; json,
    _ =&gt; return Err(InsertError::Unknown),
};

if !json.records.is_empty() {
    return Err(InsertError::Conflict);
}
</code></pre>
<p>现在我们已经做到了，我们能保证没有记录共享相同的 <code>number</code> ，所以我们可以插入我们的宝可梦。为此，我们需要创建一个 <code>json</code> 请求：</p>
<pre><code class="language-rs">...
let body = ureq::json!({
    &quot;records&quot;: [{
        &quot;fields&quot;: {
            &quot;number&quot;: u16::from(number.clone()),
            &quot;name&quot;: String::from(name.clone()),
            &quot;types&quot;: Vec::&lt;String&gt;::from(types.clone()),
        },
    }],
});
</code></pre>
<p>最后，我们要带上 <code>body</code> 发出请求，并在成功时返回 <code>Pokemon</code> ：</p>
<pre><code class="language-rs">...
if let Err(_) = ureq::post(&amp;self.url)
    .set(&quot;Authorization&quot;, &amp;self.auth_header)
    .send_json(body)
{
    return Err(InsertError::Unknown);
}

Ok(Pokemon::new(number, name, types))
</code></pre>
<h4 id="删除一只宝可梦-1"><a class="header" href="#删除一只宝可梦-1">删除一只宝可梦</a></h4>
<pre><code class="language-rs">fn delete(&amp;self, number: PokemonNumber) -&gt; Result&lt;(), DeleteError&gt; {
    // code will go here
}
</code></pre>
<p>和插入时一样，我们必须首先尝试查询与我们传递的 <code>number</code> 相同的记录。当记录为空时，我们会返回一个错误，我们不能删除不存在的记录 : )
否则，我们将拿到第一条记录。</p>
<pre><code class="language-rs">let mut json = match self.fetch_pokemon_rows(Some(u16::from(number.clone()))) {
    Ok(json) =&gt; json,
    _ =&gt; return Err(DeleteError::Unknown),
};

if json.records.is_empty() {
    return Err(DeleteError::NotFound);
}

let record = json.records.remove(0);
</code></pre>
<p>现在，我们将使用记录的 id 字段来删除记录：</p>
<pre><code class="language-rs">...
match ureq::delete(&amp;format!(&quot;{}/{}&quot;, self.url, record.id))
    .set(&quot;Authorization&quot;, &amp;self.auth_header)
    .call()
{
    Ok(_) =&gt; Ok(()),
    _ =&gt; Err(DeleteError::Unknown),
}
</code></pre>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>你现在应该能使用 内存，Airtable，或者是一个 SQLite 数据库作为程序的存储库。而且你能通过 CLI 和 HTTP API 两种方式去操作 :D</p>
<p>那是本系列的最后一篇文章。感谢您一直看到这里 :) 我希望这些文章对您有用。</p>
<p>该代码依然在 <a href="https://github.com/alexislozano/pokedex/tree/article-7">github</a> 上查看。</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://alexis-lozano.com/hexagonal-architecture-in-rust-1/</p>
<p>翻译：<a href="https://github.com/trdthg">trdthg</a></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="2021-08-21---rust-六边形架构-1-域"><a class="header" href="#2021-08-21---rust-六边形架构-1-域">2021-08-21 - Rust 六边形架构 #1 域</a></h1>
<p>一段时间以来，我一直在阅读很多关于<a href="https://alistair.cockburn.us/hexagonal-architecture/">六边形架构</a>、<a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">干净架构</a>等的文章和书籍。我也已经听过了很多演讲。在学习这些主题的这段时间里，我一直在想如何在
Rust 中实现它们，因为我知道 Rust 的所有权模型可能会让它实现起来相对困难一些。</p>
<p>这篇文章是我用来展示如何使用我提到的模式来实现软件的系列文章的第一篇。</p>
<h2 id="六边形架构"><a class="header" href="#六边形架构">六边形架构</a></h2>
<p>六边形架构、<a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/">洋葱架构</a>、干净架构……这些架构其实都是一回事，所以从现在开始我会主要介绍六边形架构。</p>
<p>六边形架构是让程序的核心部分独立于它的依赖项。核心部分通常称为 <strong>域
(Domain)</strong>，它是所有业务规则和实体的所在位置。依赖项基本上是程序的其余部分：数据库、框架、库、消息队列等等都包含在内。从本质上讲，这种架构是一种将业务部分与实现细节解耦的方法。</p>
<p>这种架构有以下一些优点：</p>
<ul>
<li>你可以更改域而不更改依赖项</li>
<li>你可以在不更改域的情况下更改依赖项</li>
<li>你可以更容易测试项</li>
<li>你可以在需要时考虑使用哪些依赖，而不是在一开始就去实现业务细节</li>
</ul>
<h2 id="一个疯狂的业务需求出现了"><a class="header" href="#一个疯狂的业务需求出现了">一个疯狂的业务需求出现了！</a></h2>
<p>一天早上，我们的客户来找我们：</p>
<ul>
<li>嗨，我需要一个软件来管理宝可梦。</li>
<li>好的，你想对这些宝可梦做些什么？</li>
<li>我需要创建新的宝可梦，删除它们，还有搜索它们。</li>
<li>大体了解了。您希望如何访问您的系统？使用浏览器还是使用终端？</li>
<li>呃，我真的不知道...</li>
<li>你想在哪里存放宝可梦？你们是否提供对象存储服务的数据库或帐号？</li>
<li>什么是数据库？</li>
</ul>
<p>在这里，可以说客户不知道他想要什么。但事实上，目前我们真的不需要知道这些问题的答案。重要的是 <strong>用例 (Usecase)</strong>。让我们把客户的需求重写一下：</p>
<ul>
<li>创建一只宝可梦</li>
<li>查询所有宝可梦</li>
<li>查询一只宝可梦</li>
<li>删除一只宝可梦</li>
</ul>
<h2 id="我们的第一个用例"><a class="header" href="#我们的第一个用例">我们的第一个用例</a></h2>
<p>我们的项目将用 Rust 实现，回收标题 : )，让我们首先新建一个项目</p>
<pre><code class="language-shell">cargo new pokedex
</code></pre>
<p>接着我们创建第一个用例 <em>domain/create_pokemon.rs</em>:</p>
<pre><code>src
├── domain
│   ├── create_pokemon.rs
│   └── mod.rs
└── main.rs
</code></pre>
<p>不要忘记加 <em>mod.rs</em></p>
<pre><code class="language-rs">// main.rs
mod domain;

// domain/mod.rs
mod create_pokemon;
</code></pre>
<p>我喜欢做的是首先编写测试，就好像代码已经编写好了一样。它能帮我们创建一个干净的 API。所以我们可以打开 <em>domain/create_pokemon.rs</em>
并添加我们的第一个测试：</p>
<pre><code class="language-rs">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_should_return_the_pokemon_number_otherwise() {
        let number = 25;
        let req = Request {
            number,
            name: String::from(&quot;Pikachu&quot;),
            types: vec![String::from(&quot;Electric&quot;)],
        };

        let res = execute(req);

        assert_eq!(res, number);
    }
}
</code></pre>
<p>当然，现在还不能通过编译。首先我们需要创建一个 <code>Request</code> 结构体：</p>
<pre><code class="language-rs">struct Request {
    number: u16,
    name: String,
    types: Vec&lt;String&gt;,
}
</code></pre>
<p>注意，我们没有在 <code>Request</code>
结构体中使用花哨的类型。为什么？因为我们不希望调用我们用例的代码知道域中具体的实体。正如我之前所说，我们的目标是拥有一个独立于依赖项的域。</p>
<p>现在，我们需要实现 <code>execute</code> 函数：</p>
<pre><code class="language-rs">fn execute(req: Request) -&gt; u16 {
    req.number
}
</code></pre>
<p>有用！让我们把它交给我们的客户！我不确定他拿到这个结果是否会高兴。实际上，我们还没有检查请求格式是否正确。如果 <code>number</code>
不在正确的范围内怎么办？如果给定的 <code>name</code> 是空字符串怎么办？如果宝可梦世界中不存在其中一种类型怎么办？让我们现在来解决这个问题 : )</p>
<h2 id="实体"><a class="header" href="#实体">实体</a></h2>
<p>让我们添加一个新测试用例，用来确保用例在请求格式错误时会返回一个错误：</p>
<pre><code class="language-rs">#[test]
fn it_should_return_a_bad_request_error_when_request_is_invalid() {
    let req = Request {
        number: 25,
        name: String::from(&quot;&quot;),
        types: vec![String::from(&quot;Electric&quot;)],
    };

    let res = execute(req);

    match res {
        Response::BadRequest =&gt; {}
        _ =&gt; unreachable!(),
    };
}
</code></pre>
<p>因为没有我们实现 <code>Response</code>结构体，所以现在还无法通过编译。因为现在我们的用例 (execute 函数) 调用后只会返回一个整形
<code>u16</code>，所以我们必须把它的返回值类型改为 <code>Response</code>：</p>
<pre><code class="language-rs">enum Response {
    Ok(u16),
    BadRequest,
}

fn execute(req: Request) -&gt; Response {
    Response::BadRequest
}
</code></pre>
<p>同时还应该更改上一个测试用例去检查当请求格式正确时，用例会返回 <code>Ok</code> ：</p>
<pre><code class="language-rs">match res {
    Response::Ok(res_number) =&gt; assert_eq!(res_number, number),
    _ =&gt; unreachable!(),
};
</code></pre>
<p>现在，代码编译成功了！但是检查 <code>Ok</code> 的测试失败了，因为现在 <code>execute</code> 只会返回 <code>Response::BadRequest</code>。
我们稍后会在来处理它。现在，我们要定义在请求中获得值的业务规则。让我们创建一个新文件 <code>domain/entities.rs</code> 来存储它们。</p>
<h3 id="宝可梦数量"><a class="header" href="#宝可梦数量">宝可梦数量</a></h3>
<p>这个数字的范围必须大于 0, 小于 899：</p>
<pre><code class="language-rs">pub struct PokemonNumber(u16);

impl TryFrom&lt;u16&gt; for PokemonNumber {
    type Error = ();

    fn try_from(n: u16) -&gt; Result&lt;Self, Self::Error&gt; {
        if n &gt; 0 &amp;&amp; n &lt; 899 {
            Ok(Self(n))
        } else {
            Err(())
        }
    }
}

impl From&lt;PokemonNumber&gt; for u16 {
    fn from(n: PokemonNumber) -&gt; u16 {
        n.0
    }
}
</code></pre>
<h3 id="宝可梦名称"><a class="header" href="#宝可梦名称">宝可梦名称</a></h3>
<p>名称不能是空字符串</p>
<pre><code class="language-rs">pub struct PokemonName(String);

impl TryFrom&lt;String&gt; for PokemonName {
    type Error = ();

    fn try_from(n: String) -&gt; Result&lt;Self, Self::Error&gt; {
        if n.is_empty() {
            Err(())
        } else {
            Ok(Self(n))
        }
    }
}
</code></pre>
<h3 id="宝可梦属性"><a class="header" href="#宝可梦属性">宝可梦属性</a></h3>
<p>属性不能是空列表，而且所有类型都必须是已经定义过的。现在我们暂时只定义一个电属性 <code>Electric</code>。</p>
<pre><code class="language-rs">pub struct PokemonTypes(Vec&lt;PokemonType&gt;);

impl TryFrom&lt;Vec&lt;String&gt;&gt; for PokemonTypes {
    type Error = ();

    fn try_from(ts: Vec&lt;String&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
        if ts.is_empty() {
            Err(())
        } else {
            let mut pts = vec![];
            for t in ts.iter() {
                match PokemonType::try_from(String::from(t)) {
                    Ok(pt) =&gt; pts.push(pt),
                    _ =&gt; return Err(()),
                }
            }
            Ok(Self(pts))
        }
    }
}

enum PokemonType {
    Electric,
}

impl TryFrom&lt;String&gt; for PokemonType {
    type Error = ();

    fn try_from(t: String) -&gt; Result&lt;Self, Self::Error&gt; {
        match t.as_str() {
            &quot;Electric&quot; =&gt; Ok(Self::Electric),
            _ =&gt; Err(()),
        }
    }
}
</code></pre>
<p>现在，我们去更新一下 <code>execute</code> 函数</p>
<pre><code class="language-rs">fn execute(req: Request) -&gt; Response {
    match (
        PokemonNumber::try_from(req.number),
        PokemonName::try_from(req.name),
        PokemonTypes::try_from(req.types),
    ) {
        (Ok(number), Ok(_), Ok(_)) =&gt; Response::Ok(u16::from(number)),
        _ =&gt; Response::BadRequest,
    }
}
</code></pre>
<p>干的好，所有测试都通过了！</p>
<h2 id="下一步-1"><a class="header" href="#下一步-1">下一步</a></h2>
<p>在下一篇文章中，我们将看到如何实现多个 <strong>存储库 (Reposity)</strong> 去存储宝可梦。所有的存储库都会实现同一个
<strong><code>Trait</code></strong>，因此这些存储库能够非常方便的进行拓展 (pluggable) 和更换 (exchangeable)，我们还将为用例给出多种前端实现，以便能够通过多种前端接口去访问我们的系统。</p>
<p>代码可以在 <a href="https://github.com/alexislozano/pokedex/tree/article-1">Github</a> 上查看</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://alexis-lozano.com/hexagonal-architecture-in-rust-5/</p>
<p>翻译：<a href="https://github.com/trdthg">trdthg</a></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="2021-09-12---rust-六边形架构-5---其他用例"><a class="header" href="#2021-09-12---rust-六边形架构-5---其他用例">2021-09-12 - Rust 六边形架构 #5 - 其他用例</a></h1>
<p>上次，我们做了一些重构。不知何故，我们的客户对我们很生气……我的意思是，他应该高兴，代码现在比以前更干净了。</p>
<p>在吃完一块蛋糕之后 (显然，这是我们应得的)，让我们继续实现剩下的用例。这篇文章可能会有点长，但是，嘿，如果你不想阅读整个过程，代码在 github 上 : )
我们将实现的用例是：</p>
<ul>
<li>获取所有宝可梦</li>
<li>查询一只宝可梦</li>
<li>删除一只宝可梦</li>
</ul>
<h2 id="获取所有宝可梦-1"><a class="header" href="#获取所有宝可梦-1">获取所有宝可梦</a></h2>
<p>像往常一样，我们将从测试开始。让我们首先创建一个新的用例 文件：<em>domain/fetch_all_pokemons.rs</em>：</p>
<pre><code class="language-rs">// domain/mod.rs
pub mod fetch_all_pokemons;
</code></pre>
<p>让我们考虑一下这个用例有哪些可能的结果？</p>
<ol>
<li>成功了，我们得到了宝可梦</li>
<li>存储库中发生了未知错误，我们无法得到我们的宝可梦</li>
</ol>
<p>让我们先从错误案例开始：</p>
<pre><code class="language-rs">#[cfg(test)]
mod tests {
    use super::*;
    use crate::repositories::pokemon::InMemoryRepository;

    #[test]
    fn it_should_return_an_unknown_error_when_an_unexpected_error_happens() {
        let repo = Arc::new(InMemoryRepository::new().with_error());

        let res = execute(repo);

        match res {
            Err(Error::Unknown) =&gt; {}
            _ =&gt; unreachable!(),
        };
    }
}
</code></pre>
<p>如您所见，我仍然没有写一行代码，只写了测试。当然，现在还不能通过编译。这里有两件事很有趣：</p>
<ul>
<li>这里的测试和创建宝可梦那里几乎一样</li>
<li>这里不需要 repo 之外的其他参数</li>
</ul>
<p>接下来让我们添加一些必要的代码让测试通过：</p>
<pre><code class="language-rs">use crate::repositories::pokemon::Repository;
use std::sync::Arc;

pub enum Error {
    Unknown,
}

pub fn execute(repo: Arc&lt;dyn Repository&gt;) -&gt; Result&lt;(), Error&gt; {
    Err(Error::Unknown)
}
</code></pre>
<p>接着继续添加下一个测试：</p>
<pre><code class="language-rs">#[test]
fn it_should_return_all_the_pokemons_ordered_by_increasing_number_otherwise() {
    let repo = Arc::new(InMemoryRepository::new());
    repo.insert(
        PokemonNumber::pikachu(),
        PokemonName::pikachu(),
        PokemonTypes::pikachu(),
    )
    .ok();
    repo.insert(
        PokemonNumber::charmander(),
        PokemonName::charmander(),
        PokemonTypes::charmander(),
    )
    .ok();

    let res = execute(repo);

    match res {
        Ok(res) =&gt; {
            assert_eq!(res[0].number, u16::from(PokemonNumber::charmander()));
            assert_eq!(res[0].name, String::from(PokemonName::charmander()));
            assert_eq!(res[0].types, Vec::&lt;String&gt;::from(PokemonTypes::charmander()));
            assert_eq!(res[1].number, u16::from(PokemonNumber::pikachu()));
            assert_eq!(res[1].name, String::from(PokemonName::pikachu()));
            assert_eq!(res[1].types, Vec::&lt;String&gt;::from(PokemonTypes::pikachu()));
        }
        _ =&gt; unreachable!(),
    };
}
</code></pre>
<p>在测试里，我按照 <code>number</code> 递减的顺序插入了宝可梦，所以存储库中宝可梦的排序应该是确定的。当存储库没有输出错误时，我们应该能从用例中得到一个
<code>Vec&lt;Response&gt;</code>。现在我们要为用例加入 <code>Response</code>，并编写一部分用例函数的内容：</p>
<pre><code class="language-rs">pub struct Response {
    pub number: u16,
    pub name: String,
    pub types: Vec&lt;String&gt;,
}

pub fn execute(repo: Arc&lt;dyn Repository&gt;) -&gt; Result&lt;Vec&lt;Response&gt;, Error&gt; {
    match repo.fetch_all() {
        Ok(pokemons) =&gt; Ok(pokemons
            .into_iter()
            .map(|p| Response {
                number: u16::from(p.number),
                name: String::from(p.name),
                types: Vec::&lt;String&gt;::from(p.types),
            })
            .collect::&lt;Vec&lt;Response&gt;&gt;()),
        Err(FetchAllError::Unknown) =&gt; Err(Error::Unknown),
    }
}
</code></pre>
<p>然后再为存储库添加并实现 <code>fetch_all</code> 方法：</p>
<pre><code class="language-rs">pub enum FetchAllError {
    Unknown,
}

pub trait Repository: Send + Sync {
    fn fetch_all(&amp;self) -&gt; Result&lt;Vec&lt;Pokemon&gt;, FetchAllError&gt;;
}

impl Repository for InMemoryRepository {
    fn fetch_all(&amp;self) -&gt; Result&lt;Vec&lt;Pokemon&gt;, FetchAllError&gt; {
        if self.error {
            return Err(FetchAllError::Unknown);
        }

        let lock = match self.pokemons.lock() {
            Ok(lock) =&gt; lock,
            _ =&gt; return Err(FetchAllError::Unknown),
        };

        let mut pokemons = lock.to_vec();
        pokemons.sort_by(|a, b| a.number.cmp(&amp;b.number));
        Ok(pokemons)
    }
}
</code></pre>
<p>为了实现宝可梦按照 <code>number</code> 排序，<code>PokemonNumber</code> 需要实现 <code>PartialEq</code>、 <code>Eq</code>、<code>PartialOrd</code>、<code>Ord</code>
这 4 个 Trait</p>
<pre><code class="language-rs">#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct PokemonNumber(u16);
</code></pre>
<p>运行 c<code>argo test</code>：</p>
<pre><code>cargo test
running 6 tests
...
it_should_return_an_unknown_error_when_an_unexpected_error_happens ... ok
it_should_return_all_the_pokemons_ordered_by_increasing_number_otherwise ... ok
</code></pre>
<p>我们已经完成了这个用例 :) 现在让我们快速实现 api。在 <em>api/mod.rs</em> 中，添加以下内容：</p>
<pre><code class="language-rs">mod fetch_all_pokemons;

// in the router macro
(GET) (/) =&gt; {
    fetch_all_pokemons::serve(repo.clone())
}
</code></pre>
<p>接着实现具体的 handler api/fetch_all_pokemons.rs：</p>
<pre><code class="language-rs">use crate::api::Status;
use crate::domain::fetch_all_pokemons;
use crate::repositories::pokemon::Repository;
use rouille;
use serde::Serialize;
use std::sync::Arc;

#[derive(Serialize)]
struct Response {
    number: u16,
    name: String,
    types: Vec&lt;String&gt;,
}

pub fn serve(repo: Arc&lt;dyn Repository&gt;) -&gt; rouille::Response {
    match fetch_all_pokemons::execute(repo) {
        Ok(res) =&gt; rouille::Response::json(
            &amp;res.into_iter()
                .map(|p| Response {
                    number: p.number,
                    name: p.name,
                    types: p.types,
                })
                .collect::&lt;Vec&lt;Response&gt;&gt;(),
        ),
        Err(fetch_all_pokemons::Error::Unknown) =&gt; {
            rouille::Response::from(Status::InternalServerError)
        }
    }
}
</code></pre>
<p>现在您可以运行 <code>cargo run</code>，并使用你最喜欢的 HTTP 客户端 (curl、postman、...)。通过在 <code>/</code> 上发送 POST
请求来创建一些宝可梦。然后您可以使用浏览器访问 http://localhost:8000。这是我得到的：</p>
<pre><code class="language-json">[
  {
    &quot;number&quot;: 4,
    &quot;name&quot;: &quot;Charmander&quot;,
    &quot;types&quot;: [
      &quot;Fire&quot;
    ]
  },
  {
    &quot;number&quot;: 25,
    &quot;name&quot;: &quot;Pikachu&quot;,
    &quot;types&quot;: [
      &quot;Electric&quot;
    ]
  }
]
</code></pre>
<h2 id="查询一只宝可梦-1"><a class="header" href="#查询一只宝可梦-1">查询一只宝可梦</a></h2>
<p>第二个用例！现在我们想通过给系统一个宝可梦的编号来获取一个宝可梦。让我们创建一个新的用例文件 <em>domain/fetch_pokemon.rs</em>：</p>
<pre><code class="language-rs">// domain/mod.rs
pub mod fetch_pokemon;
</code></pre>
<p>让我们思考一下用例运行时可能遇到什么情况。</p>
<ol>
<li>存储库可能会引发未知错误。</li>
<li>请求参数可能是不合法的。</li>
<li>用户给定的编号可能对应没有宝可梦。</li>
<li>获得宝可梦成功了</li>
</ol>
<p>让我们从未知错误的测试开始。新建 <em>domain/fetch_pokemon.rs</em> 并添加以下内容：</p>
<pre><code class="language-rs">use crate::domain::entities::PokemonNumber;
use std::sync::Arc;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::repositories::pokemon::InMemoryRepository;

    #[test]
    fn it_should_return_an_unknown_error_when_an_unexpected_error_happens() {
        let repo = Arc::new(InMemoryRepository::new().with_error());
        let req = Request::new(PokemonNumber::pikachu());

        let res = execute(repo, req);

        match res {
            Err(Error::Unknown) =&gt; {}
            _ =&gt; unreachable!(),
        };
    }
}
</code></pre>
<p>接着，为测试实现必要的类型和函数：</p>
<pre><code class="language-rs">pub struct Request {
    pub number: u16,
}

pub enum Error {
    Unknown
}
</code></pre>
<p>为了让测试更清晰，我们还为 <code>Request</code> 实现了一个 <code>new</code> 方法，当然只在测试时使用：</p>
<pre><code class="language-rs">#[cfg(test)]
mod tests {
    ...

    impl Request {
        fn new(number: PokemonNumber) -&gt; Self {
            Self {
                number: u16::from(number),
            }
        }
    }
}
</code></pre>
<p>最后，再实现一个只用满足这项测试的 <code>execute</code> 函数即可：</p>
<pre><code class="language-rs">use crate::repositories::pokemon::Repository;

pub fn execute(repo: Arc&lt;dyn Repository&gt;, req: Request) -&gt; Result&lt;(), Error&gt; {
    Err(Error::Unknown)
}
</code></pre>
<p>让我们运行 <code>cargo test fetch_pokemon</code>:</p>
<pre><code>test it_should_return_an_unknown_error_when_an_unexpected_error_happens ... ok
</code></pre>
<p>好的。我们可以开始下一个测试了。让我们来看一下请求格式错误的情况：</p>
<pre><code class="language-rs">#[test]
fn it_should_return_a_bad_request_error_when_request_is_invalid() {
    let repo = Arc::new(InMemoryRepository::new());
    let req = Request::new(PokemonNumber::bad());

    let res = execute(repo, req);

    match res {
        Err(Error::BadRequest) =&gt; {}
        _ =&gt; unreachable!(),
    };
}
</code></pre>
<p>首先，让我们在 <code>PokemonNumber</code> 中创建 <code>bad</code> 函数。在 <em>domain/entities.rs</em> 中添加以下内容：</p>
<pre><code class="language-rs">#[cfg(test)]
impl PokemonNumber {
    ...
    pub fn bad() -&gt; Self {
        Self(0)
    }
}
</code></pre>
<p>接着，在 <code>Error</code> 中添加 <code>Badrequest</code> 类型与之对应：</p>
<pre><code class="language-rs">pub enum Error {
    BadRequest,
    ...
}
</code></pre>
<p>现在已经能够通过编译，但是测试尚且不能通过，实际上，我们的 <code>execute</code> 函数暂时只能返回 <code>Unknown</code> 类型：</p>
<pre><code class="language-rs">use std::convert::TryFrom;

pub fn execute(repo: Arc&lt;dyn Repository&gt;, req: Request) -&gt; Result&lt;(), Error&gt; {
    match PokemonNumber::try_from(req.number) {
        Ok(number) =&gt; Err(Error::Unknown),
        _ =&gt; Err(Error::BadRequest),
    }
}
</code></pre>
<p>现在两个测试都通过了！我们现在可以进行第三个测试：在存储库中找不到宝可梦时，应该返回 <code>NotFound</code>:</p>
<pre><code class="language-rs">#[test]
fn it_should_return_a_not_found_error_when_the_repo_does_not_contain_the_pokemon() {
    let repo = Arc::new(InMemoryRepository::new());
    let req = Request::new(PokemonNumber::pikachu());

    let res = execute(repo, req);

    match res {
        Err(Error::NotFound) =&gt; {}
        _ =&gt; unreachable!(),
    };
}
</code></pre>
<p>同样，在 <code>Error</code> 中补充 <code>NotFound</code> 错误类型：</p>
<pre><code class="language-rs">pub enum Error {
    ...
    NotFound,
    ...
}
</code></pre>
<p>像之前一样，测试没有通过。我们需要在 <code>execute</code> 函数中处理对应的错误类型：</p>
<pre><code class="language-rs">use crate::repositories::pokemon::{FetchOneError, ...};

Ok(number) =&gt; match repo.fetch_one(number) {
    Ok(_) =&gt; Ok(()),
    Err(FetchOneError::NotFound) =&gt; Err(Error::NotFound),
    Err(FetchOneError::Unknown) =&gt; Err(Error::Unknown),
}
</code></pre>
<p>接着在 <em>repositories/pokemon.rs</em> 中补充对应的方法和错误类型：</p>
<pre><code class="language-rs">pub enum FetchOneError {
    NotFound,
    Unknown,
}

pub trait Repository: Send + Sync {
    ...
    fn fetch_one(&amp;self, number: PokemonNumber) -&gt; Result&lt;(), FetchOneError&gt;;
}

impl Repository for InMemoryRepository {
    ...
    fn fetch_one(&amp;self, number: PokemonNumber) -&gt; Result&lt;(), FetchOneError&gt; {
        if self.error {
            return Err(FetchOneError::Unknown);
        }

        Err(FetchOneError::NotFound)
    }
}
</code></pre>
<p>Et voilà，测试通过了！最后去处理获取成功的测试吧：</p>
<pre><code class="language-rs">#[cfg(test)]
mod tests {
    use crate::domain::entities::{PokemonName, PokemonTypes};

    #[test]
    fn it_should_return_the_pokemon_otherwise() {
        let repo = Arc::new(InMemoryRepository::new());
        repo.insert(
            PokemonNumber::pikachu(),
            PokemonName::pikachu(),
            PokemonTypes::pikachu(),
        )
        .ok();
        let req = Request::new(PokemonNumber::pikachu());

        let res = execute(repo, req);

        match res {
            Ok(res) =&gt; {
                assert_eq!(res.number, u16::from(PokemonNumber::pikachu()));
                assert_eq!(res.name, String::from(PokemonName::pikachu()));
                assert_eq!(res.types, Vec::&lt;String&gt;::from(PokemonTypes::pikachu()));
            }
            _ =&gt; unreachable!(),
        };
    }
}
</code></pre>
<p>首先创建 <code>Response</code> 类型，并改变 <code>execute</code> 的返回值类型：</p>
<pre><code class="language-rs">pub struct Response {
    pub number: u16,
    pub name: String,
    pub types: Vec&lt;String&gt;,
}

pub fn execute(repo: Arc&lt;dyn Repository&gt;, req: Request) -&gt; Result&lt;Response, Error&gt; {
</code></pre>
<p>现在，我们去处理 <code>Ok(_)</code> 的部分：</p>
<pre><code class="language-rs">use crate::domain::entities::{Pokemon, ...};

Ok(Pokemon {
    number,
    name,
    types,
}) =&gt; Ok(Response {
    number: u16::from(number),
    name: String::from(name),
    types: Vec::&lt;String&gt;::from(types),
})
</code></pre>
<p>最后修改存储库的 <code>fetch_one</code> 函数：</p>
<pre><code class="language-rs">pub trait Repository: Send + Sync {
    fn fetch_one(&amp;self, number: PokemonNumber) -&gt; Result&lt;Pokemon, FetchOneError&gt;;
}

impl Repository for InMemoryRepository {
    fn fetch_one(&amp;self, number: PokemonNumber) -&gt; Result&lt;Pokemon, FetchOneError&gt; {
        if self.error {
            return Err(FetchOneError::Unknown);
        }

        let lock = match self.pokemons.lock() {
            Ok(lock) =&gt; lock,
            _ =&gt; return Err(FetchOneError::Unknown),
        };

        match lock.iter().find(|p| p.number == number) {
            Some(pokemon) =&gt; Ok(pokemon.clone()),
            None =&gt; Err(FetchOneError::NotFound),
        }
    }
}
</code></pre>
<p>所有的测试都通过了现在：</p>
<pre><code>test it_should_return_a_not_found_error_when_the_repo_does_not_contain_the_pokemon ... ok
test it_should_return_the_pokemon_otherwise ... ok
test it_should_return_a_bad_request_error_when_request_is_invalid ... ok
test it_should_return_an_unknown_error_when_an_unexpected_error_happens ... ok
</code></pre>
<p>让我们现在向 API 中前加一个新路由：</p>
<pre><code class="language-rs">mod fetch_pokemon;

// in the router macro
(GET) (/{number: u16}) =&gt; {
    fetch_pokemon::serve(repo.clone(), number)
}
</code></pre>
<p>接着再 <em>api/fetch_pokemon.rs</em> 创建对应的 <code>serve</code> 函数：</p>
<pre><code class="language-rs">use crate::api::Status;
use crate::domain::fetch_pokemon;
use crate::repositories::pokemon::Repository;
use rouille;
use serde::Serialize;
use std::sync::Arc;

#[derive(Serialize)]
struct Response {
    number: u16,
    name: String,
    types: Vec&lt;String&gt;,
}

pub fn serve(repo: Arc&lt;dyn Repository&gt;, number: u16) -&gt; rouille::Response {
    let req = fetch_pokemon::Request { number };
    match fetch_pokemon::execute(repo, req) {
        Ok(fetch_pokemon::Response {
            number,
            name,
            types,
        }) =&gt; rouille::Response::json(&amp;Response {
            number,
            name,
            types,
        }),
        Err(fetch_pokemon::Error::BadRequest) =&gt; rouille::Response::from(Status::BadRequest),
        Err(fetch_pokemon::Error::NotFound) =&gt; rouille::Response::from(Status::NotFound),
        Err(fetch_pokemon::Error::Unknown) =&gt; rouille::Response::from(Status::InternalServerError),
    }
}
</code></pre>
<p>现在您可以运行应用程序，打开您的 HTTP 客户端并将一些宝可梦添加到存储库中。然后，您应该能够通过在网址末尾添加宝可梦的数量来一一获取它们。
例如，在我的计算机上，http://localhost:8000/25 上的 GET 请求返回了：</p>
<pre><code class="language-json">{
  &quot;number&quot;: 25,
  &quot;name&quot;: &quot;Pikachu&quot;,
  &quot;types&quot;: [
    &quot;Electric&quot;
  ]
}
</code></pre>
<h2 id="删除一只宝可梦-2"><a class="header" href="#删除一只宝可梦-2">删除一只宝可梦</a></h2>
<p>我保证，我们很快就会完成。删除宝可梦是我们的最后一个用例。这个用例的结果有四种可能：</p>
<ul>
<li>成功</li>
<li>请求格式错误</li>
<li>没有找到对应的宝可梦</li>
<li>未知错误</li>
</ul>
<p>您应该已经注意到，它们与获取 Pokemon 用例中的完全相同。我会解释更快一些。现在就开始了。让我们直接编写所有测试：</p>
<pre><code class="language-rs">// domain/mod.rs
pub mod delete_pokemon;

// domain/delete_pokemon.rs
#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::entities::{PokemonName, PokemonTypes};
    use crate::repositories::pokemon::InMemoryRepository;

    #[test]
    fn it_should_return_an_unknown_error_when_an_unexpected_error_happens() {
        let repo = Arc::new(InMemoryRepository::new().with_error());
        let req = Request::new(PokemonNumber::pikachu());

        let res = execute(repo, req);

        match res {
            Err(Error::Unknown) =&gt; {}
            _ =&gt; unreachable!(),
        };
    }

    #[test]
    fn it_should_return_a_bad_request_error_when_request_is_invalid() {
        let repo = Arc::new(InMemoryRepository::new());
        let req = Request::new(PokemonNumber::bad());

        let res = execute(repo, req);

        match res {
            Err(Error::BadRequest) =&gt; {}
            _ =&gt; unreachable!(),
        };
    }

    #[test]
    fn it_should_return_a_not_found_error_when_the_repo_does_not_contain_the_pokemon() {
        let repo = Arc::new(InMemoryRepository::new());
        let req = Request::new(PokemonNumber::pikachu());

        let res = execute(repo, req);

        match res {
            Err(Error::NotFound) =&gt; {}
            _ =&gt; unreachable!(),
        };
    }

    #[test]
    fn it_should_return_ok_otherwise() {
        let repo = Arc::new(InMemoryRepository::new());
        repo.insert(
            PokemonNumber::pikachu(),
            PokemonName::pikachu(),
            PokemonTypes::pikachu(),
        )
        .ok();
        let req = Request::new(PokemonNumber::pikachu());

        let res = execute(repo, req);

        match res {
            Ok(()) =&gt; {},
            _ =&gt; unreachable!(),
        };
    }

    impl Request {
        fn new(number: PokemonNumber) -&gt; Self {
            Self {
                number: u16::from(number),
            }
        }
    }
}
</code></pre>
<p>除了成功情况下的测试，其他的测试基本上是对 <em>domain/fetch_pokemon.rs</em> 的复制粘贴。接下来是类型：</p>
<pre><code class="language-rs">pub struct Request {
    pub number: u16,
}

pub enum Error {
    BadRequest,
    NotFound,
    Unknown,
}
</code></pre>
<p>我们不需要定义 <code>Response</code> 类型，因为在 <code>Ok</code> 情况下我们不会返回任何内容。让我们定义 <code>execute</code> 函数：</p>
<pre><code class="language-rs">use crate::domain::entities::PokemonNumber;
use crate::repositories::pokemon::{DeleteError, Repository};
use std::convert::TryFrom;
use std::sync::Arc;

pub fn execute(repo: Arc&lt;dyn Repository&gt;, req: Request) -&gt; Result&lt;(), Error&gt; {
    match PokemonNumber::try_from(req.number) {
        Ok(number) =&gt; match repo.delete(number) {
            Ok(()) =&gt; Ok(()),
            Err(DeleteError::NotFound) =&gt; Err(Error::NotFound),
            Err(DeleteError::Unknown) =&gt; Err(Error::Unknown),
        },
        _ =&gt; Err(Error::BadRequest),
    }
}
</code></pre>
<p>太好了！现在我们只剩下实现存储库了，我们很快就会完成：</p>
<pre><code class="language-rs">pub enum DeleteError {
    NotFound,
    Unknown,
}

pub trait Repository: Send + Sync {
    fn delete(&amp;self, number: PokemonNumber) -&gt; Result&lt;(), DeleteError&gt;;
}

impl Repository for InMemoryRepository {
    fn delete(&amp;self, number: PokemonNumber) -&gt; Result&lt;(), DeleteError&gt; {
        if self.error {
            return Err(DeleteError::Unknown);
        }

        let mut lock = match self.pokemons.lock() {
            Ok(lock) =&gt; lock,
            _ =&gt; return Err(DeleteError::Unknown),
        };

        let index = match lock.iter().position(|p| p.number == number) {
            Some(index) =&gt; index,
            None =&gt; return Err(DeleteError::NotFound),
        };

        lock.remove(index);
        Ok(())
    }
}
</code></pre>
<p>运行测试：</p>
<pre><code>test it_should_return_a_bad_request_error_when_request_is_invalid ... ok
test it_should_return_a_not_found_error_when_the_repo_does_not_contain_the_pokemon ... ok
test it_should_return_an_unknown_error_when_an_unexpected_error_happens ... ok
test it_should_return_ok_otherwise ... ok
We can now add the new route in our API. Let's add the following to api/mod.rs:
</code></pre>
<p>现在我们可以在 API 中添加新路由：</p>
<pre><code class="language-rs">mod delete_pokemon;

// in the router macro
(DELETE) (/{number: u16}) =&gt; {
    delete_pokemon::serve(repo.clone(), number)
}

enum Status {
    Ok,
    ...
}
impl From&lt;Status&gt; for rouille::Response {
    fn from(status: Status) -&gt; Self {
        let status_code = match status {
            Status::Ok =&gt; 200,
            ...
</code></pre>
<p>我在 <code>Status</code> 中补充一个 OK 类型用来表示没有相应体的 200 状态码，现在添加对应的 <code>serve</code> 函数：</p>
<pre><code class="language-rs">use crate::api::Status;
use crate::domain::delete_pokemon;
use crate::repositories::pokemon::Repository;
use rouille;
use std::sync::Arc;

pub fn serve(repo: Arc&lt;dyn Repository&gt;, number: u16) -&gt; rouille::Response {
    let req = delete_pokemon::Request { number };
    match delete_pokemon::execute(repo, req) {
        Ok(()) =&gt; rouille::Response::from(Status::Ok),
        Err(delete_pokemon::Error::BadRequest) =&gt; rouille::Response::from(Status::BadRequest),
        Err(delete_pokemon::Error::NotFound) =&gt; rouille::Response::from(Status::NotFound),
        Err(delete_pokemon::Error::Unknown) =&gt; rouille::Response::from(Status::InternalServerError),
    }
}
</code></pre>
<p>通过使用 HTTP 客户端，现在你应该能够删除宝可梦了 :)</p>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>我希望它不会太长......但现在我们的客户很高兴！耶！下一次，我们将为我们的用例实现另一个前端。现在我们只有一个 HTTP API，如果还能有一个 CLI
来管理我们的宝可梦就好了 :)</p>
<p>代码可以在 <a href="https://github.com/alexislozano/pokedex/tree/article-5">Github</a> 上查看</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://alexis-lozano.com/hexagonal-architecture-in-rust-6/</p>
<p>翻译：<a href="https://github.com/trdthg">trdthg</a></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="2021-10-09---rust-六边形架构-6---cli"><a class="header" href="#2021-10-09---rust-六边形架构-6---cli">2021-10-09 - Rust 六边形架构 #6 - CLI</a></h1>
<p>嘿，好久不见！上次，我们实现了剩余的用例，并将它们连接到我们的 API。现在，我想添加另一种方式来使用我们的程序。我们将使用 CLI。CLI 是
Command Line Interface (命令行接口) 的意思，它只是一个缩写词，意思是：“让我们通过终端使用这个程序”。</p>
<h2 id="搭建脚手架"><a class="header" href="#搭建脚手架">搭建脚手架</a></h2>
<p>构建 CLI 意味着我们需要在项目中添加新的依赖和一个新文件夹。让我们从添加依赖开始。我们需要一种方法，再运行之前需要提示用户是运行 CLI 还是 HTTP
API。我们将使用 <code>clap</code> 添加命令行开关让用户选择启动方式，同时还会使用 <code>dialoguer</code> 去创建提示信息。</p>
<p>打开 Cargo.toml，并添加：</p>
<pre><code class="language-toml">[dependencies]
...
clap = &quot;2.33.3&quot;
dialoguer = &quot;0.8.0&quot;
</code></pre>
<p>当你再读这篇文章时可以将依赖换为最新的。现在让我们添加一些命令行开关，打开 <em>main.rs</em>:</p>
<pre><code class="language-rs">#[macro_use]
extern crate clap;

use clap::{App, Arg};
And then we can use it:

fn main() {
    let repo = Arc::new(InMemoryRepository::new());

    let matches = App::new(crate_name!())
        .version(crate_version!())
        .author(crate_authors!())
        .arg(Arg::with_name(&quot;cli&quot;).long(&quot;cli&quot;).help(&quot;Runs in CLI mode&quot;))
        .get_matches();

    match matches.occurrences_of(&quot;cli&quot;) {
        0 =&gt; api::serve(&quot;localhost:8000&quot;, repo),
        _ =&gt; unreachable!(),
    }
}
</code></pre>
<p>所以，首先我们创建了存储库。然后我们创建一个处理 CLI 的 clap 应用程序。如果在运行程序时添加 <code>--cli</code> 标志，程序现在将
panic。如果没有添加，就会运行 API。正如我之前所说，<code>clap</code> 能让我们快速创建一个 CLI。您可以通过运行来尝试：</p>
<pre><code class="language-rs">cargo run -- --help

pokedex 0.1.0
Alexis Lozano &lt;alexis.pascal.lozano@gmail.com&gt;

USAGE:
    pokedex [FLAGS]

FLAGS:
        --cli        Runs in CLI mode
    -h, --help       Prints help information
    -V, --version    Prints version information
</code></pre>
<p>非常不错是吧 :)</p>
<p>现在我们要把 <code>unreachable!()</code> 替换为 <code>cli::run(repo)</code>。我们现在要创建一个 <code>cli</code> 模块，所有和 cli
相关的代码都会在该模块里。在 <em>main.rs</em> 里引入模块：</p>
<pre><code class="language-rs">mod cli;
</code></pre>
<p>接着让我们创建 <em>src/cli</em> 文件夹，并在其中添加一个 <em>mod.rs</em> 文件。在 <em>cli/mod.rs</em> 中添加以下代码：</p>
<pre><code class="language-rs">use crate::repositories::pokemon::Repository;
use std::sync::Arc;

pub fn run(repo: Arc&lt;dyn Repository&gt;) {}
</code></pre>
<p>现在运行 <code>cargo run -- --cli</code> 应该不会 panic 了。</p>
<p>接着让我们创建一个循环：</p>
<pre><code class="language-rs">use dialoguer::{theme::ColorfulTheme, Select};

pub fn run(repo: Arc&lt;dyn Repository&gt;) {
    loop {
        let choices = [
            &quot;Fetch all Pokemons&quot;,
            &quot;Fetch a Pokemon&quot;,
            &quot;Create a Pokemon&quot;,
            &quot;Delete a Pokemon&quot;,
            &quot;Exit&quot;,
        ];
        let index = match Select::with_theme(&amp;ColorfulTheme::default())
            .with_prompt(&quot;Make your choice&quot;)
            .items(&amp;choices)
            .default(0)
            .interact()
        {
            Ok(index) =&gt; index,
            _ =&gt; continue,
        };

        match index {
            4 =&gt; break,
            _ =&gt; continue,
        };
    }
}
</code></pre>
<p>我们列出了所有用户能够运行的命令。如果用户选择 <code>Exit</code>，程序就会退出。否则，程序暂时什么都不会做。别担心，我们马上就会实现其他的命令。</p>
<h2 id="创建一个宝可梦"><a class="header" href="#创建一个宝可梦">创建一个宝可梦</a></h2>
<p>让我们从创建开始。如果我们能够有方法向存储库中添加宝可梦，后面的测试就更容易做了：</p>
<pre><code class="language-rs">match index {
    2 =&gt; create_pokemon::run(repo.clone()),
    ...
};
</code></pre>
<p>现在我们需要创建一个新的模块：</p>
<pre><code class="language-rs">mod create_pokemon;
</code></pre>
<p>好了，在 <em>cli/create_pokemon.rs</em> 中填加上对应的函数签名：</p>
<pre><code class="language-rs">use crate::repositories::pokemon::Repository;
use std::sync::Arc;

pub fn run(repo: Arc&lt;dyn Repository&gt;) {}
</code></pre>
<p>为了创建一个宝可梦，CLI 需要向用户询问宝可梦的 编号、名称和类型。为了方便这个过程，并且提高提示信息的复用性，我们会为这些信息分别实现各自的提示函数：</p>
<pre><code class="language-rs">use crate::cli::{prompt_name, prompt_number, prompt_types};

pub fn run(repo: Arc&lt;dyn Repository&gt;) {
    let number = prompt_number();
    let name = prompt_name();
    let types = prompt_types();
}
</code></pre>
<p>接着在 <em>cli/mod.rs</em> 中实现：</p>
<pre><code class="language-rs">use dialoguer::{..., Input, MultiSelect};

pub fn prompt_number() -&gt; Result&lt;u16, ()&gt; {
    match Input::new().with_prompt(&quot;Pokemon number&quot;).interact_text() {
        Ok(number) =&gt; Ok(number),
        _ =&gt; Err(()),
    }
}

pub fn prompt_name() -&gt; Result&lt;String, ()&gt; {
    match Input::new().with_prompt(&quot;Pokemon name&quot;).interact_text() {
        Ok(name) =&gt; Ok(name),
        _ =&gt; Err(()),
    }
}

pub fn prompt_types() -&gt; Result&lt;Vec&lt;String&gt;, ()&gt; {
    let types = [&quot;Electric&quot;, &quot;Fire&quot;];
    match MultiSelect::new()
        .with_prompt(&quot;Pokemon types&quot;)
        .items(&amp;types)
        .interact()
    {
        Ok(indexes) =&gt; Ok(indexes
            .into_iter()
            .map(|index| String::from(types[index]))
            .collect::&lt;Vec&lt;String&gt;&gt;()),
        _ =&gt; Err(()),
    }
}
</code></pre>
<blockquote>
<p>提示：多选框按空格选中</p>
</blockquote>
<p>如你所见，所有的提示都可能失败，让我们回到 <em>cli/create_pokemon.rs</em>，有了用户的输入信息，我们可以将它封装为用例中需要的
<code>Request</code> 结构体：</p>
<pre><code class="language-rs">use crate::domain::create_pokemon;

pub fn run(repo: Arc&lt;dyn Repository&gt;) {
    ...
    let req = match (number, name, types) {
        (Ok(number), Ok(name), Ok(types)) =&gt; create_pokemon::Request {
            number,
            name,
            types,
        },
        _ =&gt; {
            println!(&quot;An error occurred during the prompt&quot;);
            return;
        }
    };
</code></pre>
<p>当发生输入错误时，我们会退回到主菜单。现在有了 <code>Request</code> 结构体，我们就能调用创建宝可梦的用例了：</p>
<pre><code class="language-rs">pub fn run(repo: Arc&lt;dyn Repository&gt;) {
    ...
    match create_pokemon::execute(repo, req) {
        Ok(res) =&gt; {},
        Err(create_pokemon::Error::BadRequest) =&gt; println!(&quot;The request is invalid&quot;),
        Err(create_pokemon::Error::Conflict) =&gt; println!(&quot;The Pokemon already exists&quot;),
        Err(create_pokemon::Error::Unknown) =&gt; println!(&quot;An unknown error occurred&quot;),
    };
}
</code></pre>
<p>我们处理了所有的错误类型，每种错误都会反馈到用户的终端上。当用例执行成功时，我们会返回一个 <code>Response</code>：</p>
<pre><code class="language-rs">#[derive(Debug)]
struct Response {
    number: u16,
    name: String,
    types: Vec&lt;String&gt;,
}

pub fn run(repo: Arc&lt;dyn Repository&gt;) {
    ...
    match create_pokemon::execute(repo, req) {
        Ok(res) =&gt; println!(
            &quot;{:?}&quot;,
            Response {
                number: res.number,
                name: res.name,
                types: res.types,
            }
        ),
        ...
    };
}
</code></pre>
<p>好了，让我们测试一下！打开终端，以命令行模式运行：</p>
<pre><code class="language-rs">✔ Make your choice · Create a Pokemon
Pokemon number: 25
Pokemon name: Pikachu
Pokemon types: Electric
Response { number: 25, name: &quot;Pikachu&quot;, types: [&quot;Electric&quot;] }
Great! First command implemented, let's do the next one!
</code></pre>
<h2 id="获取所有宝可梦-2"><a class="header" href="#获取所有宝可梦-2">获取所有宝可梦</a></h2>
<p>现在我们去实现获取所有宝可梦！首先我们在对应的 <code>index</code> 添加相应的处理函数：</p>
<pre><code class="language-rs">match index {
    0 =&gt; fetch_all_pokemons::run(repo.clone()),
    ...
};
</code></pre>
<p>创建模块</p>
<pre><code class="language-rs">mod fetch_all_pokemons;
</code></pre>
<p>现在实现具体的功能：</p>
<pre><code class="language-rs">use crate::domain::fetch_all_pokemons;
use crate::repositories::pokemon::Repository;
use std::sync::Arc;

#[derive(Debug)]
struct Response {
    number: u16,
    name: String,
    types: Vec&lt;String&gt;,
}

pub fn run(repo: Arc&lt;dyn Repository&gt;) {
    match fetch_all_pokemons::execute(repo) {
        Ok(res) =&gt; res.into_iter().for_each(|p| {
            println!(
                &quot;{:?}&quot;,
                Response {
                    number: p.number,
                    name: p.name,
                    types: p.types,
                }
            );
        }),
        Err(fetch_all_pokemons::Error::Unknown) =&gt; println!(&quot;An unknown error occurred&quot;),
    };
}
</code></pre>
<p>我已经详细的解释过第一个例子，这里就没必要一步一步说明了。这个命令不需要任何参赛，所以也不需要任何提示信息，我们只需要从存储库拿到结果，依次打印即可。</p>
<h2 id="查询一个宝可梦-1"><a class="header" href="#查询一个宝可梦-1">查询一个宝可梦</a></h2>
<p>和之前一样，创建一个模块：</p>
<pre><code class="language-rs">mod fetch_pokemon;

...

match index {
    ...
    1 =&gt; fetch_pokemon::run(repo.clone()),
    ...
};
</code></pre>
<p>创建对应的处理函数</p>
<pre><code class="language-rs">use crate::cli::prompt_number;
use crate::domain::fetch_pokemon;
use crate::repositories::pokemon::Repository;
use std::sync::Arc;

#[derive(Debug)]
struct Response {
    number: u16,
    name: String,
    types: Vec&lt;String&gt;,
}

pub fn run(repo: Arc&lt;dyn Repository&gt;) {
    let number = prompt_number();

    let req = match number {
        Ok(number) =&gt; fetch_pokemon::Request { number },
        _ =&gt; {
            println!(&quot;An error occurred during the prompt&quot;);
            return;
        }
    };
    match fetch_pokemon::execute(repo, req) {
        Ok(res) =&gt; println!(
            &quot;{:?}&quot;,
            Response {
                number: res.number,
                name: res.name,
                types: res.types,
            }
        ),
        Err(fetch_pokemon::Error::BadRequest) =&gt; println!(&quot;The request is invalid&quot;),
        Err(fetch_pokemon::Error::NotFound) =&gt; println!(&quot;The Pokemon does not exist&quot;),
        Err(fetch_pokemon::Error::Unknown) =&gt; println!(&quot;An unknown error occurred&quot;),
    }
}
</code></pre>
<p>这里，我们先向用户询问了编号，如果获取失败了就输出错误信息。接着构建 Request 结构体，调用用例，成功就打印结果，否则打印错误信息。</p>
<h1 id="删除一个宝可梦"><a class="header" href="#删除一个宝可梦">删除一个宝可梦</a></h1>
<p>最后一个命令！</p>
<pre><code class="language-rs">mod delete_pokemon;

...

match index {
    ...
    3 =&gt; delete_pokemon::run(repo.clone()),
    ...
};
</code></pre>
<p>创建新模块：</p>
<pre><code class="language-rs">use crate::cli::prompt_number;
use crate::domain::delete_pokemon;
use crate::repositories::pokemon::Repository;
use std::sync::Arc;

pub fn run(repo: Arc&lt;dyn Repository&gt;) {
    let number = prompt_number();

    let req = match number {
        Ok(number) =&gt; delete_pokemon::Request { number },
        _ =&gt; {
            println!(&quot;An error occurred during the prompt&quot;);
            return;
        }
    };
    match delete_pokemon::execute(repo, req) {
        Ok(()) =&gt; println!(&quot;The Pokemon has been deleted&quot;),
        Err(delete_pokemon::Error::BadRequest) =&gt; println!(&quot;The request is invalid&quot;),
        Err(delete_pokemon::Error::NotFound) =&gt; println!(&quot;The Pokemon does not exist&quot;),
        Err(delete_pokemon::Error::Unknown) =&gt; println!(&quot;An unknown error occurred&quot;),
    }
}
</code></pre>
<p>和查询一个宝可梦基本一样，只不过不需要返回信息。</p>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<p>现在您无需直接发送 HTTP 请求即可在终端中享受使用程序 : D
但是你知道我们缺少什么吗？一个真正存储我们的宝可梦的地方。目前，它们只存在于内存中，因此每次我们运行程序时存储库都是空的。从 CLI 创建我们的宝可梦然后从
API 获取它们会很酷 : ) 下一篇将是本系列的最后一篇文章：实现一个长期保存的存储库。</p>
<p>代码可以在 <a href="https://github.com/alexislozano/pokedex/tree/article-6">Github</a> 上查看</p>
<div style="break-before: page; page-break-before: always;"></div><blockquote>
<p>原文链接：https://alexis-lozano.com/hexagonal-architecture-in-rust-3/</p>
<p>翻译：<a href="https://github.com/trdthg">trdthg</a></p>
<p>选题：<a href="https://github.com/trdthg">trdthg</a></p>
<p>本文由 <a href="https://Rustt.org">Rustt</a> 翻译，<a href="https://studyrust.org">StudyRust</a> 荣誉推出</p>
</blockquote>
<h1 id="2021-08-26---rust-六边形架构-3---http-api"><a class="header" href="#2021-08-26---rust-六边形架构-3---http-api">2021-08-26 - Rust 六边形架构 #3 - HTTP API</a></h1>
<p>这篇文章是下面系列的一部分</p>
<ul>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-1/">Hexagonal architecture in Rust #1 - Domain</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-2/">Hexagonal architecture in Rust #2 - In-memory repository</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-3/">Hexagonal architecture in Rust #3 - HTTP API</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-4/">Hexagonal architecture in Rust #4 - Refactoring</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-5/">Hexagonal architecture in Rust #5 - Remaining use-cases</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-6/">Hexagonal architecture in Rust #6 - CLI</a></li>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-7/">Hexagonal architecture in Rust #7 - Long-lived repositories</a></li>
</ul>
<p>集结吧，我的战友们。今天我们将要战斗！谁？你问我。它是这片土地上不言而喻的恶魔：👿借用检查！</p>
<p>好了，让我们暂时停止这个指环王风格的印象，工作等待着我们 : )</p>
<p>在之前的文章中，我们定义了我们的域实体，并且实现了一个用例和一个存储库。</p>
<pre><code>src
├── domain
│   ├── create_pokemon.rs
│   ├── entities.rs
│   └── mod.rs
├── repositories
│   ├── mod.rs
│   └── pokemon.rs
└── main.rs
</code></pre>
<p>我们本可以把它交给我们的客户，但是除了运行测试能够通过之外，<em>main.rs</em> 文件仍然只输出一个 hello
world。今天，我们将把我们的项目转换成一个返回 JSON 的 HTTP API。</p>
<h2 id="http-api"><a class="header" href="#http-api">HTTP API</a></h2>
<p>如果你没记错的话，我没有在项目中使用异步。这是为了专注于考虑我们应用程序的架构。如果你真的想使用异步，那就去吧 : ) 非异步的 Web
框架并不多，但仍然有一些。我再本文中的选择是
<a href="https://github.com/tomaka/rouille">rouille</a>，它能很好地处理我们的用例。</p>
<p>所以首先，我们打开 <em>Cargo.toml</em> 并将其添加到我们的依赖项中：</p>
<pre><code class="language-toml">[dependencies]
rouille = &quot;3.2.1&quot;
</code></pre>
<p>现在让我们创建一个包含我们所有的 API 的文件夹。这里面包括 <em>mod.rs</em> 文件，我们将在其中添加基本的路由逻辑。我还将添加一个简单的
<em>health.rs</em> 文件来处理我们的第一个路由：</p>
<pre><code>src
└── api
    ├── health.rs
    └── mod.rs
</code></pre>
<p>我们只会在 <em>api</em> 文件夹中使用到 <code>rouille</code>，如果在以后，我们想用 <code>actix</code> 代替 <code>rouille</code>，我们只需要修改 <em>api</em>
的部分即可 (其实我们还要把一些函数转换为异步的，但是它与 Web 框架的选择并不相关)</p>
<p>现在让我们创建一个基本可用的 API，当我们在向 <code>/health</code> 上发送 GET 请求时，它应该返回一些文本。首先，我们要在 <em>main.rs</em> 中引入
<code>rutille</code>, 并使用之后会创建的 <code>serve</code> 函数：</p>
<pre><code class="language-rs">mod api;
mod domain;
mod repositories;

#[macro_use]
extern crate rouille;

fn main() {
    api::serve(&quot;localhost:8000&quot;);
}
</code></pre>
<p>接下来，在 <em>api/mod.rs</em> 里添加 <code>serve</code> 函数</p>
<pre><code class="language-rs">mod health;

pub fn serve(url: &amp;str) {
    rouille::start_server(url, move |req| {
        router!(req,
            (GET) (/health) =&gt; {
                health::serve()
            },
            _ =&gt; {
                rouille::Response::from(Status::NotFound)
            }
        )
    });
}
</code></pre>
<p>现在只需要编辑 <em>api/health.rs</em>：</p>
<pre><code class="language-rs">use rouille;

pub fn serve() -&gt; rouille::Response {
    rouille::Response::text(&quot;Gotta catch them all!&quot;)
}
</code></pre>
<p>现在您应该可以使用 <code>cargo run</code> 运行程序并使用浏览器访问 http://localhost:8000/health。
在那里，一条美丽的信息在等着你：</p>
<pre><code>Gotta catch them all!
</code></pre>
<p>太棒了！但我之前说过我们想要一个 JSON API。让我们将这个 API 接口转换为返回 JSON。我们将用到 <code>serde</code>。<code>rouille</code>
本身已经使用了一些 <code>serde</code> 的特征，你可以通过 <code>cargo tree | grep serde</code> 查看：</p>
<pre><code>├── serde v1.0.129
├── serde_derive v1.0.129 (proc-macro)
├── serde_json v1.0.66
│   └── serde v1.0.129
</code></pre>
<p>接着让我们在 <em>Cargo.toml</em> 中添加与 <code>rouille</code> 使用的版本相同的 <code>serde</code> 依赖。</p>
<pre><code class="language-toml">[dependencies]
rouille = &quot;3.2.1&quot;
serde = { version = &quot;1.0.129&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0.66&quot;
</code></pre>
<p>现在来修改 <em>api/health.rs</em>:</p>
<pre><code class="language-rs">use rouille;
use serde::Serialize;

#[derive(Serialize)]
struct Response {
    message: String,
}

pub fn serve() -&gt; rouille::Response {
    rouille::Response::json(&amp;Response {
        message: String::from(&quot;Gotta catch them all!&quot;),
    })
}
</code></pre>
<p>在次访问你的浏览器 🎉 :D</p>
<pre><code class="language-json">{
  &quot;message&quot;: &quot;Gotta catch them all!&quot;
}
</code></pre>
<h2 id="获取请求"><a class="header" href="#获取请求">获取请求</a></h2>
<p>我们的客户想要的是能够创造一个宝可梦。首先，由于我们的 API 将是 RESTful，下面是我们将使用的 HTTP 请求的示例：</p>
<pre><code>- POST http://localhost:8000
- Headers
    Content-Type: application/json
- Body
    {
        &quot;number&quot;: 4,
        &quot;name&quot;: &quot;Charmander&quot;,
        &quot;types&quot;: [&quot;Fire&quot;]
    }
</code></pre>
<p>现在，让我们回到 <em>api/mod.rs</em> 添加一个新的路由</p>
<pre><code class="language-rs">mod create_pokemon;
mod health;

pub fn serve(url: &amp;str) {
    rouille::start_server(url, move |req| {
        router!(req,
            ...
            (POST) (/) =&gt; {
                create_pokemon::serve(req)
            },
            ...
        )
    });
}
</code></pre>
<p>让我们创建一个新的文件 <em>api/create_pokemon.rs</em> 并写入下面的内容：</p>
<pre><code class="language-rs">use rouille;
use serde::Serialize;

#[derive(Serialize)]
struct Response {
    message: String,
}

pub fn serve(_req: &amp;rouille::Request) -&gt; rouille::Response {
    rouille::Response::json(&amp;Response {
        message: String::from(&quot;Pokemon created!&quot;),
    })
}
</code></pre>
<p>现在您可以使用 REST 客户端 (postman、curl、...) 在 http://localhost:8000 上发送 POST 请求，body
可以是任何东西。你应该会收到以下内容：</p>
<pre><code class="language-json">{
  &quot;message&quot;: &quot;Pokemon created!&quot;
}
</code></pre>
<p>但是当请求上下文不是我们想要的时，API 最好能返回 400 状态码。让我们稍微修改一下 <em>api/create_pokemon.rs</em>：</p>
<pre><code class="language-rs">use crate::api::Status;
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct Request {
    number: u16,
    name: String,
    types: Vec&lt;String&gt;,
}

pub fn serve(req: &amp;rouille::Request) -&gt; rouille::Response {
    match rouille::input::json_input::&lt;Request&gt;(req) {
        Ok(_) =&gt; {}
        _ =&gt; return rouille::Response::from(Status::BadRequest),
    };
    ...
}
</code></pre>
<p>现在，如果向 API 发送一个没有 <code>name</code> 值的请求，或者如果 <code>number</code> 为负数，用户将会收到 400 状态码。</p>
<h2 id="添加存储库"><a class="header" href="#添加存储库">添加存储库</a></h2>
<p>好的，但是实际上现在宝可梦既没有创建也没有添加到存储库中。而且 API 也不会调用用例！首先让我们在 <em>main.rs</em>
中创建一个内存存储库，并把它作为参数传递给 API：</p>
<pre><code class="language-rs">use repositories::pokemon::InMemoryRepository;

fn main() {
    let repo = InMemoryRepository::new();
    api::serve(&quot;localhost:8000&quot;, &amp;mut repo);
}
</code></pre>
<p>现在，我们必须相应地编辑 <em>api/mod.rs</em>：</p>
<pre><code class="language-rs">use crate::repositories::pokemon::Repository;

pub fn serve(url: &amp;str, repo: &amp;mut dyn Repository) {
    rouille::start_server(url, move |req| {
        router!(req,
            ...
            (POST) (/) =&gt; {
                create_pokemon::serve(repo, req)
            },
            ...
        )
    });
}
</code></pre>
<p>别忘了修改 <em>api/create_pokemon.rs</em>：</p>
<pre><code class="language-rs">use crate::repositories::pokemon::Repository;

pub fn serve(_repo: &amp;mut dyn Repository, req: &amp;rouille::Request) -&gt; rouille::Response {
</code></pre>
<p>你现在可以运行 <code>cargo run</code> 了，它应该 ...</p>
<pre><code>error[E0277]: `dyn Repository` cannot be sent between threads safely
= help: the trait `Send` is not implemented for `dyn Repository`
error[E0277]: `dyn Repository` cannot be shared between threads safely
= help: the trait `Sync` is not implemented for `dyn Repository`
error: aborting due to 2 previous errors
</code></pre>
<p>我只保留了最基础的错误日志。有些东西不起作用，这是因为......借用检查器。我的意思是这其实是我的错，但是借用检查器在罩着我们 : )</p>
<h2 id="打败借用检查器"><a class="header" href="#打败借用检查器">打败借用检查器</a></h2>
<p>像往常一样，编译器很有帮助：它告诉我们需要在 <code>Repository</code> 上实现 <code>Send</code> 和 <code>Sync</code>。让我们修改
<code>repositories/pokemon.rs</code> 来实现这一点：</p>
<pre><code class="language-rs">pub trait Repository: Send + Sync {
    fn insert(&amp;mut self, number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; Insert;
}
</code></pre>
<p>Rust 很容易，对吧？我们的修复将非常快，因为一旦运行 <code>cargo run</code>：</p>
<pre><code>error[E0621]: explicit lifetime required in the type of `repo`
 --&gt; src/api/mod.rs:7:5
  |
6 | pub fn serve(url: &amp;str, repo: &amp;mut dyn Repository) {
  |                               ------------------- help: add explicit lifetime `'static` to the type of `repo`: `&amp;'static mut (dyn Repository + 'static)`
</code></pre>
<p>现在，编译器告诉我们存储库上需要一个
“静态生命周期”。让我们思考一下，这里真正的问题是什么？我们希望将存储库的引用发送到为每个请求生成的线程中。现在我们使用我们的
<code>InMemoryRepository</code>
结构体创建了一个存储库。问题是，当我们的应用程序执行到主函数结束时，这个存储库的资源将被释放。但也许有些线程仍然会引用到它。最终导致编译器错误。</p>
<p>我们想要的是以某种方式告诉程序，只有在引用不再存在时再释放掉我们的存储库。这种方式称为引用计数器。我们很幸运，Rust
为此提供了两种类型，其中一种是专门为了在线程之间安全共享而创建的。它的名字是 <strong><code>Arc</code></strong>，这就是我们将要使用的。</p>
<p>因此，让我们在 <em>main.rs</em> 中用 <code>Arc</code> 包装我们的存储库：</p>
<pre><code class="language-rs">use std::sync::Arc;

fn main() {
    let repo = Arc::new(InMemoryRepository::new());
    api::serve(&quot;localhost:8000&quot;, repo);
}
</code></pre>
<p>你可以看到我们移除了两个东西：一个 <code>&amp;</code> 和一个 <code>mut</code>。 <code>Arc</code>
实际上是一个指针，因此它的大小在编译时是已知的。它指向位于堆中的存储库。因此我们不需要引用它。其次，Arc
是不可变的，所以我们必须使用内部可变性。这点我们稍后再谈。</p>
<p>现在让我们修改 <em>api/mod.rs</em>：</p>
<pre><code class="language-rs">use std::sync::Arc;

pub fn serve(url: &amp;str, repo: Arc&lt;dyn Repository&gt;) {
    rouille::start_server(url, move |req| {
        router!(req,
            ...
            (POST) (/) =&gt; {
                create_pokemon::serve(repo.clone(), req)
            },
            ...
        )
    });
}
</code></pre>
<p>最后再来修改 <em>api/create_pokemon.rs</em>:</p>
<pre><code class="language-rs">use std::sync::Arc;

pub fn serve(_repo: Arc&lt;dyn Repository&gt;, req: &amp;rouille::Request) -&gt; rouille::Response {
</code></pre>
<p>编译成功 \o/</p>
<h2 id="域也需要爱-"><a class="header" href="#域也需要爱-">域也需要爱 💓</a></h2>
<p>我们围绕着一个域设计了我们的程序，其中包含使用用例获取数据和一个存储库用来保存数据。像之前一样，我们也必须在用例中把存储库替换为 <code>Arc</code>
的可变引用。好在我现在只实现了一个用例 : ) 让我们在 <em>domain/create_pokemon.rs</em> 中修改函数签名：</p>
<pre><code class="language-rs">use std::sync::Arc;

fn execute(repo: Arc&lt;dyn Repository&gt;, req: Request) -&gt; Response {
</code></pre>
<p>不要忘记测试中也要修改！</p>
<pre><code class="language-rs">let repo = Arc::new(InMemoryRepository::new());
let res = execute(repo, req);
</code></pre>
<p>在运行 <code>cargo run</code> 之后，我们偶然发现了我之前讨论过的一个问题：<code>Arc</code> 是不可变的。</p>
<pre><code>25 |         (Ok(number), Ok(name), Ok(types)) =&gt; match repo.insert(number, name, types) {
   |                                                    ^^^^ cannot borrow as mutable
</code></pre>
<p>如果我们检查 <em>repositories/pokemon.rs</em> 中的 <code>Repository</code> Trait，我们可以看到 <code>insert</code>
方法希望存储库是可变的：</p>
<pre><code class="language-rs">pub trait Repository: Send + Sync {
    fn insert(&amp;mut self, number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; Insert;
}
</code></pre>
<p>所以我们将在 <code>Repository</code> Trait 和我们的实现中删除这个 <code>mut</code> : ) 让我们运行 <code>cargo run</code>：</p>
<pre><code class="language-rs">36 |     fn insert(&amp;self, number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; Insert {
   |               ----- help: consider changing this to be a mutable reference: `&amp;mut self`
...
46 |         self.pokemons.push(Pokemon::new(number_clone, name, types));
   |         ^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
</code></pre>
<p>哎呀，这个错误信息不是很有帮助。我们刚刚删除了 <code>mut</code>，现在编译器希望我们重新添加它。实际上这是合乎逻辑的，编译器不知道存储库在 <code>Arc</code> 中。</p>
<p>有趣的是，问题不再在于 <code>trait</code>，而在于我们的存储库实现。我们需要能够在 <code>self</code> 不可变的情况下改变内部的 <code>pokemons</code>。
这就是内部可变性。而且，Rust 再次为此提供了一些原语！我们将选择 <code>Mutex</code> 原语，因为它是为了在线程之间共享数据而设计的。因此，让我们将
<code>pokemons</code> 包装到 <code>Mutex</code> 中：</p>
<pre><code class="language-rs">use std::sync::Mutex;

pub struct InMemoryRepository {
    error: bool,
    pokemons: Mutex&lt;Vec&lt;Pokemon&gt;&gt;,
}

impl InMemoryRepository {
    pub fn new() -&gt; Self {
        let pokemons: Mutex&lt;Vec&lt;Pokemon&gt;&gt; = Mutex::new(vec![]);
        Self {
            error: false,
            pokemons,
        }
    }
}
</code></pre>
<p>现在，我们必须锁定 <code>Mutex</code> 才能读取或写入宝可梦。锁定 <code>Mutex</code>
意味着所有线程必须轮流等待读取或写入它所保存的数据，因此同时只有一个线程访问数据。</p>
<pre><code class="language-rs">impl Repository for InMemoryRepository {
    fn insert(&amp;self, number: PokemonNumber, name: PokemonName, types: PokemonTypes) -&gt; Insert {
        if self.error {
            return Insert::Error;
        }

        let mut lock = match self.pokemons.lock() {
            Ok(lock) =&gt; lock,
            _ =&gt; return Insert::Error,
        };

        if lock.iter().any(|pokemon| pokemon.number == number) {
            return Insert::Conflict;
        }

        let number_clone = number.clone();
        lock.push(Pokemon::new(number_clone, name, types));
        Insert::Ok(number)
    }
}
</code></pre>
<p>现在它编译通过，并且所有的测试也仍然通过！</p>
<h2 id="api--domain--3"><a class="header" href="#api--domain--3">API + domain =&lt; 3</a></h2>
<p>是时候将 API 连接到 Domain 了。让我们修改 <code>api/create_pokemon.rs</code>：</p>
<pre><code class="language-rs">use crate::domain::create_pokemon;

pub fn serve(repo: Arc&lt;dyn Repository&gt;, req: &amp;rouille::Request) -&gt; rouille::Response {
    let req = match rouille::input::json_input::&lt;Request&gt;(req) {
        Ok(req) =&gt; create_pokemon::Request {
            number: req.number,
            name: req.name,
            types: req.types,
        },
        _ =&gt; return rouille::Response::from(Status::BadRequest),
    };
    match create_pokemon::execute(repo, req) {
        create_pokemon::Response::Ok(number) =&gt; rouille::Response::json(&amp;Response { number }),
        create_pokemon::Response::BadRequest =&gt; rouille::Response::from(Status::BadRequest),
        create_pokemon::Response::Conflict =&gt; rouille::Response::from(Status::Conflict),
        create_pokemon::Response::Error =&gt; rouille::Response::from(Status::InternalServerError),
    }
}
</code></pre>
<p>记得把域中需要的代码改为 pub：</p>
<pre><code class="language-rs">// domain/mod.rs
pub mod create_pokemon;

// domain/create_pokemon.rs
pub struct Request {
    pub number: u16,
    pub name: String,
    pub types: Vec&lt;String&gt;,
}

pub enum Response {
    ...
}

pub fn execute(repo: Arc&lt;dyn Repository&gt;, req: Request) -&gt; Response {
    ...
}
</code></pre>
<p>在次运行 <code>cargo run</code> 并向 <code>create_pokemon</code> 路由发送有效请求：</p>
<pre><code class="language-json">{
  &quot;number&quot;: 30
}
</code></pre>
<p>\o/</p>
<h2 id="下一步-2"><a class="header" href="#下一步-2">下一步</a></h2>
<p>这篇文章比预期的要长，对此我感到抱歉。希望它对你有用 :) 在下一篇文章中，我将实现其他的用例 (客户厌倦了等待我解释一切，客户真糟糕 :p)
再之后，我将实现其他的前端和存储库，以更好地了解六边形架构的强大功能。</p>
<p>像往常一样，代码可以在 <a href="https://github.com/alexislozano/pokedex/tree/article-3">github</a>
上查看。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-六边形架构-1"><a class="header" href="#rust-六边形架构-1">Rust 六边形架构</a></h1>
<h2 id="六边形架构基本介绍-1"><a class="header" href="#六边形架构基本介绍-1">六边形架构基本介绍</a></h2>
<p>六边形架构，是一种软件设计模式。依照这种架构创建的程序，能够在没有 UI
或数据库的情况下正常工作。所以即使没有数据库你依然可以进行开发和运行自动化测试，而且无需其他用户参与。</p>
<h3 id="端口与适配器-1"><a class="header" href="#端口与适配器-1">端口与适配器</a></h3>
<p>六边形架构也叫做端口与适配器架构。</p>
<p><img src="https://alistair.cockburn.us/wp-content/uploads/2018/02/Hexagonal-architecture-complex-example.gif" alt="" /></p>
<p>什么是端口？</p>
<p>端口指的是六边形的边，属于应用程序的内部，是我们应用程序的入口和出口。它定义了一个接口，表示设备如何使用我们的用例。在 Rust 里就是由一个
Trait，以及一些 DTO 组成</p>
<p>什么是适配器？</p>
<p>适配器围绕着端口编写，能够将输入转化为符合端口的类型，并把输入转化为用用程序内部的方法调用。换句话说就是 <code>controller</code> 或者是命令行一条命令处理器。</p>
<p>当任何外部设备 (比如：WEB，APP，终端，测试...)
想要访问输入端口时，首先这个输入会被该设备对应的输入适配器，转化为符合要求的可用的方法调用，或者是消息，然后再传递给我们的应用程序。</p>
<p>当我们的应用程序需要向外发送数据时，首先它会把数据通过输出端口传递给输出适配器，然后再传递给输出对象 (比如：数据库，mock，API，邮件，消息队列...)</p>
<p>因此我们的应用程序外部是完全隔离的。</p>
<h3 id="应用程序核心-1"><a class="header" href="#应用程序核心-1">应用程序核心</a></h3>
<p>使用六边形架构之后，我们应用程序的核心部分通常被称作域，域中有三个核概念：</p>
<ul>
<li>实体 (Entities)：只是简单的定义了对象。</li>
<li>交互器 (Interactors)：实现复杂的业务逻辑，在本文里我们会将其称为用例 Usecase。</li>
<li>存储库 (Repositories)：只定义了操作实体的方法。</li>
</ul>
<h3 id="优点-1"><a class="header" href="#优点-1">优点</a></h3>
<p>在传统的分层架构中，只能从上往下调用。</p>
<p>而现在我们把接口保留在域中，域不再依赖外部的外部实现。保证了外部设备是可替换的。当业务逻辑需要用到数据存储时，直接调用抽象接口即可。</p>
<h2 id="将要做些什么-1"><a class="header" href="#将要做些什么-1">将要做些什么？</a></h2>
<p>在接下来的文章里，我们将会实现一个 pokemon 服务。主要功能是增加、删除和查询。</p>
<p>为了体现六边形架构的优点，我们将会实现两套用户接口，包括 HTTP API 和 CLI。三套存储库，包括内存，SQLite 数据库和 Airtable
(一个在线表格应用)。</p>
<p>六边形架构的核心不需要依赖于具体的存储库或者是用户接口，为了我们的程序能够稳定运行，我们也会非常注重于单元测试。一旦我们的域稳定下来，实现用户接口，替换存储库都会是非常简单快速的。</p>
<h2 id="项目结构-1"><a class="header" href="#项目结构-1">项目结构</a></h2>
<pre><code>src/
├── api
│   ├── fetch_pokemon.rs
│   └── mod.rs
├── cli
│   ├── fetch_pokemon.rs
│   └── mod.rs
├── domain
│   ├── entities.rs
│   ├── fetch_pokemon.rs
│   └── mod.rs
├── main.rs
└── repositories
    ├── mod.rs
    └── pokemon.rs
</code></pre>
<p>六边形架构的核心部分通常被称作域，就是下面的 <code>domain</code> 模块，里面包括实体的定义和用例的实现。<code>api</code> 和 <code>cli</code>
是两套用户接口。<code>repositories</code> 中则是存储库的定义与实现</p>
<h2 id="延申阅读-1"><a class="header" href="#延申阅读-1">延申阅读</a></h2>
<ul>
<li><a href="https://alistair.cockburn.us/hexagonal-architecture/">六边形架构 ( hexagonal-architecture )</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">干净架构 ( the-clean-architecture )</a></li>
<li><a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/">洋葱架构 ( The Onion Architecture )</a></li>
<li><a href="https://herbertograca.com/2017/07/03/the-software-architecture-chronicles/">软件架构编年史 ( The Software Architecture Chronicles )</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java"><a class="header" href="#java">java</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-1"><a class="header" href="#java-1">Java</a></h1>
<h2 id="基础知识"><a class="header" href="#基础知识">基础知识</a></h2>
<h3 id="for-和-whiletrue-的区别"><a class="header" href="#for-和-whiletrue-的区别">for(;;) 和 while(true) 的区别</a></h3>
<p>虽然两者都能实现死循环，但是源码中都是选择 for(;;) 原因：</p>
<pre><code>编译前              编译后
while (1)           mov eax,1
                    test eax,eax
                    je foo+23h
                    jmp foo+18h

编译前              编译后
for (;;)          jmp foo+23h
</code></pre>
<p>对比之下，for (;;) 指令少，不占用寄存器，而且没有判断跳转，比 while (1) 好。
也就是说两者在在宏观上完全一样的逻辑，但是底层完全不一样，for 相对于来说更加简洁明了。</p>
<h3 id="equal-与的区别"><a class="header" href="#equal-与的区别">equal 与==的区别</a></h3>
<ol>
<li>区别</li>
</ol>
<ul>
<li>==是运算符，equal 是方法，</li>
<li>比较基本类型：只能用==, 不能用 equal</li>
<li>比较包装类型：==比较的是内存地址，而 equal 比较的是值</li>
<li>比较对象：==和 equal 比较的都是内存地址，因为 equal 没有被重写，没有被重写的 equal 都是 object 的 equal 方法 ::: warning
注意 String（还有 Date，Integer）类型重写了 equals 方法，使其比较的是存储对象的内容是否相等，而不是堆内存地址。 :::</li>
</ul>
<h3 id="classthis-和-this-的区别"><a class="header" href="#classthis-和-this-的区别">Class.this 和 this 的区别</a></h3>
<p>当 inner class（内部类）必顺使用到 outer class（外部类）的 this instance（实例）时，或者匿名内部类要使用外部类的实例。</p>
<h3 id="待续"><a class="header" href="#待续">待续...</a></h3>
<h2 id="包装类"><a class="header" href="#包装类">包装类</a></h2>
<h3 id="int-vs-integer"><a class="header" href="#int-vs-integer">int VS Integer</a></h3>
<h5 id="初始化"><a class="header" href="#初始化">初始化</a></h5>
<ul>
<li>1 int 类的变量初始为 0. Integer 的变量则初始化为 null.</li>
<li>2 Integer 变量必须实例化后才能使用，int 变量不需要 .</li>
<li>3 在 Int 是将值直接存储，Integer 对象是生成指针指向此对象。</li>
</ul>
<h5 id="比较"><a class="header" href="#比较">比较</a></h5>
<ol>
<li>Integer ? int <code>&lt;br/&gt;</code> 只要两个变量的值是向等的，则结果为 true。
因为包装类 Integer 和基本数据类型 int 比较时，java 会自动拆包装为 int，然后进行比较，实际上就变为两个 int 变量的比较。</li>
<li>new Integer() ? !new Integer()，<code>&lt;br/&gt;</code> 结果为 false ! new
Integer() 当变量值在 -128~127 之间时，非 new 生成的 Integer 变量指向的是 java 常量池中 cache 数组中存储的指向了堆中的 Integer 对象，
而 new Integer() 生成的变量指向堆中新建的对象，两者在内存中的地址不同；</li>
<li>new Interger() ? new Integer() <code>&lt;br/&gt;</code> false</li>
<li>!new Integer() ? !new Integer() <code>&lt;br/&gt;</code> 如果两个值相等，且在区间 -128 到 127 之间则 true
只要不同或者有值在区间外就不相同</li>
</ol>
<h5 id="应用"><a class="header" href="#应用">应用</a></h5>
<pre><code class="language-java">Integer a = Integer.parseInt(&quot;1&quot;);
Integer b = Integer.parseInt(&quot;1&quot;);
synchronized(i)
</code></pre>
<h2 id="析构函数"><a class="header" href="#析构函数">&quot;析构函数&quot;</a></h2>
<p>java 提供 finalize() 方法，垃圾回收器准备释放内存的时候，会先调用 finalize()。</p>
<ul>
<li>特征</li>
</ul>
<ol>
<li>对象不一定会被回收。</li>
<li>垃圾回收不是析构函数。</li>
<li>垃圾回收只与内存有关。</li>
<li>垃圾回收和 finalize() 都是靠不住的，只要 JVM 还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。</li>
</ol>
<ul>
<li>应对方法</li>
</ul>
<ol>
<li>主动调用 System.gc() 方法强制垃圾回收器来释放这些对象的内存。</li>
<li>Java 1.1 通过提供一个 System.runFinalizersOnExit() 方法，不象 System.gc()
方法那样，System.runFinalizersOnExit() 方法并不立即试图启动垃圾回收器。而是当应用程序或 Applet
退出时，它调用每个对象的 finalize() 方法。</li>
<li>继承 finalize()</li>
</ol>
<h2 id="泛型"><a class="header" href="#泛型">泛型</a></h2>
<h3 id="t-的位置"><a class="header" href="#t-的位置">T 的位置</a></h3>
<ol>
<li>示例</li>
</ol>
<pre><code class="language-java">static &lt;T&gt; void show(Collection&lt;T&gt; C) {
    System.out.println(&quot;使用泛型 -------&gt;&quot; + C);
}
</code></pre>
<ol start="2">
<li>解释</li>
</ol>
<ul>
<li>第一处：静态方法不能直接引用类定义处的泛型，需要提前定义好泛型才能使用</li>
<li>第二处：指定 Collection 的元素类型为 T</li>
</ul>
<h3 id="边界通配符"><a class="header" href="#边界通配符">边界通配符</a></h3>
<pre><code class="language-java">&lt;? extends T&gt;和&lt;? super T&gt;
</code></pre>
<ol>
<li>引例</li>
</ol>
<ul>
<li>这种情况下是可行的</li>
</ul>
<pre><code class="language-java">Plate&lt;Fruit&gt; plate = new Plate&lt;&gt;(apple);
</code></pre>
<ul>
<li>这种情况下，虽然苹果和水果有继承关系，但盘子间没有继承关系会报错</li>
</ul>
<pre><code class="language-java">Plate&lt;Fruit&gt; plate = new Plate&lt;Apple&gt;(apple);
</code></pre>
<ol start="2">
<li>上下界通配符</li>
</ol>
<ul>
<li>Apple -&gt; Fruit -&gt; Food</li>
<li><code>&lt;? extends T&gt;</code> 可以是任何 T 的子类</li>
</ul>
<pre><code class="language-java">Plate&lt;? extends Food&gt; plate = new Plate&lt;Fruit&gt;(apple);
</code></pre>
<ul>
<li><code>&lt;? super T&gt;</code> 可以是任何 T 的父类</li>
</ul>
<pre><code class="language-java">Plate&lt;? super Apple&gt; plate = new Plate&lt;Food&gt;(fruit);
</code></pre>
<ol start="3">
<li>上下界通配符的副作用</li>
</ol>
<ul>
<li>上界<code>&lt;? extends T&gt;</code>不能往里存，只能往外取</li>
</ul>
<pre><code class="language-java">Plate&lt;? extends Food&gt; plate = new Plate&lt;Fruit&gt;(apple);
Food a = plate.getItem();
// plate.setItem(food);  失效
</code></pre>
<ul>
<li>下界&lt;? super T&gt;不影响往里存，但往外取只能放在 Object 对象里</li>
</ul>
<pre><code class="language-java">Plate&lt;? super Apple&gt; plate = new Plate&lt;Food&gt;(fruit);
plate2.setItem(apple);
// Apple b = plate2.getItem(); 失效
// 元素的类型信息全部丢失。
</code></pre>
<p>::: tip 补充</p>
<ul>
<li>?与 T 的区别</li>
<li>对编译器来说所有的 T 都代表同一种类型。比如下面这个泛型方法里，三个 T 都指代同一个类型，要么都是 String，要么都是 Integer。</li>
<li>但通配符<code>&lt;?&gt;没有这种约束，Plate&lt;?&gt;</code>单纯的就表示：盘子里放了一个东西，是什么我不知道。所以题主问题里的错误就在这里，Plate&lt;？
extends Fruit&gt;里什么都放不进去。 :::</li>
</ul>
<h2 id="注解"><a class="header" href="#注解">注解</a></h2>
<ol>
<li>注解会影响程序的编译和运行</li>
<li>注解本身只是一个标注，本身不用包含逻辑处理内容</li>
</ol>
<h3 id="作用范围"><a class="header" href="#作用范围">作用范围</a></h3>
<ul>
<li>RUNTIME：程序运行时起作用，例如：<code>@WebServlet</code></li>
<li>SOURCE：编译时期作用，例如 <code>@Override</code></li>
</ul>
<h3 id="target"><a class="header" href="#target">@Target</a></h3>
<p>指定注解针对的目标</p>
<ul>
<li>ElementType.Type 类、方法</li>
<li>ElementType.Field 成员变量</li>
<li>ElementType.METHOD 成员方法</li>
<li>ElementType.PARAMETER 方法参数</li>
<li>ElementType.CONSTRUCTOR 构造器</li>
<li>ElementType.PACKAGE 包</li>
<li>ElementType.ANNOTATION_TYPE 注解</li>
</ul>
<h3 id="retention"><a class="header" href="#retention">@Retention</a></h3>
<p>指定注解的保留域</p>
<ul>
<li>RetentionPolicy.SOURCE 源代码级别，由编译器处理，处理后不再保留</li>
<li>RetentionPolicy.CLASS 注解信息保留到 class 文件中</li>
<li>RetentionPolicy.RUNTION 由 jvm 读取，运行时使用</li>
</ul>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<ol>
<li>注解类</li>
</ol>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface InitAnno {

}
</code></pre>
<ol start="2">
<li>被注解类</li>
</ol>
<pre><code class="language-java">public class Foo {
    @InitAnno
    public void bar() {
        System.out.println(&quot;进入了 bar 方法&quot;);
    }
}
</code></pre>
<ol start="3">
<li>Main</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
    Class&lt;?&gt; clazz = Class.forName(&quot;Foo&quot;);
    Annotation annotation = clazz.getAnnotation(InitAnno.class);
    if (annotation == null) {
        System.out.println(&quot;类前没有 InitAnno 注解&quot;);
    }
    Method[] methods = clazz.getMethods();
    for (Method method : methods) {
        boolean isInitAnno = method.isAnnotationPresent(InitAnno.class);
        if (isInitAnno) {
            method.invoke(clazz.getConstructor(null).newInstance(null), null);
        }
    }
}
</code></pre>
<h2 id="多线程"><a class="header" href="#多线程">多线程</a></h2>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<ol>
<li>继承 Thread 类</li>
</ol>
<pre><code class="language-java">MyThread thread = new MyThread();
thread.start();
</code></pre>
<ol start="2">
<li>实现 Runnable 接口</li>
</ol>
<pre><code class="language-java">MyRunnable runnable = new MyRunnable();
Thread thread = new Thread(runnable);

Thread thread = new Thread(new MyRunnable() {
    @Override
    public void run() {
        for(int i = 0;i&lt;100;i++) {
            System.out.println(&quot;MyRunnable1&quot;);
        }
    }
});
thread.start();
</code></pre>
<p>::: tip 提示 Runnable 相比 Thread 耦合低，lambda 表达式更低 ::: 3. 实现 Callable 接口</p>
<pre><code class="language-java">Callable&lt;String&gt; callable = () -&gt; {
    System.out.println(&quot;进去了&quot;);
    return &quot;Hello&quot;;
};
FutureTask&lt;String&gt; featureTask = new FutureTask&lt;&gt;(callable);
Thread thread = new Thread(featureTask);
System.out.println(featureTask.get());
</code></pre>
<blockquote>
<p>注意！Callable 与 Thread 没有直接关系，需要间接实现</p>
</blockquote>
<pre><code class="language-java">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}

public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {
    private Callable&lt;V&gt; callable;
}
</code></pre>
<pre><code class="language-mermaid">graph LR
A[Callable] --&gt;B(FutureTask) --&gt; C(RunnableFuture) --&gt; D(Runnable) --&gt; E(Thread)
</code></pre>
<h3 id="常用方法"><a class="header" href="#常用方法">常用方法</a></h3>
<pre><code class="language-java">1. 休眠
thread.sleep(3000);
2. 合并
thread.join(3000);
3. 礼让
yield();
</code></pre>
<h3 id="线程同步"><a class="header" href="#线程同步">线程同步</a></h3>
<p>每个 java 对象都有一个内置锁，内置锁会保护使用 synchronized 关键字修饰的方法 要调用该方法必须先获取锁，否则就处于堵塞状态</p>
<ul>
<li>静态变量</li>
</ul>
<pre><code class="language-java">public class SameRunnable implements Runnable {
    private static int num = 0;
    @Override
    public synchronized void run() {
        ++num;
        Thread.sleep(10);
        System.out.println(&quot;第&quot; + Thread.currentThread().getName() + &quot;位访客是第&quot; + num + &quot;个&quot;);
    }
}
</code></pre>
<ul>
<li>静态代码块，锁定类 synchronized 关键字也能修饰代码块，以下例子也能有相同的效果</li>
</ul>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        for (int i = 0; i &lt; 5; i++) {
            Thread thread = new Thread(new Runnable() {
                public void run() {
                    Test test = new Test();
                    test.print();
                }
            }).start();
        }
    }
    public synchronized void print() {
        synchronized (Test.class) {    // 锁定类 (非静态可 this), 不能是类的实例
            System.out.println(&quot;开始&quot;);
            Thread.currentThread().sleep(1000);
            System.out.println(&quot;结束&quot;);
        }
    }
}
</code></pre>
<ul>
<li>锁定实例方法 ::: danger 注意 synchronized 关键字只是修饰共享的资源，下面的例子不能得到想要的效果 :::</li>
</ul>
<pre><code class="language-java">public synchronized void print() {
    System.out.println(&quot;开始&quot;);
    Thread.currentThread().sleep(1000);
    System.out.println(&quot;结束&quot;);
}
</code></pre>
<h3 id="线程安全的单例模式"><a class="header" href="#线程安全的单例模式">线程安全的单例模式</a></h3>
<ul>
<li>锁定类</li>
</ul>
<pre><code class="language-java">public volatile class Runner {
    private static Runner runner;
    // 记得加关键字，防止多个线程访问时还没创建过对象
    // 1. 🔒整个方法
    public synchronized static Runner getRunner() {
        if (runner == null) {
            runner = new Runner();
        }
        return runner;
    }
    // 只锁代码块，不影响该方法内的其他业务
    public static Runner getRunner() {
        synchronized(Runner.class) {
            if (runner == null) {
                runner = new Runner();
            }
        }
        return runner;
    }

}
</code></pre>
<p>::: tip 其他锁定对象</p>
<ol>
<li>synchronized(runner): n 个空指针异常，不能锁空对象</li>
<li>Integer i = Integer.parseInt(&quot;1&quot;); synchronized(i): 也可以</li>
<li>Integer a = Integer.parseInt(&quot;1&quot;); Integer b = Integer.parseInt(&quot;1&quot;);
synchronized(i) 开启两个线程，若 a,b 值 (详情见 Integer 包装类) 相同，则线程安全，否则不安全 :::</li>
</ol>
<h3 id="voletile-关键字"><a class="header" href="#voletile-关键字">voletile 关键字</a></h3>
<ol>
<li>引例</li>
</ol>
<pre><code class="language-java">public class exam {

    public static void main(String[] args) {
        int num = 0;
        int finalNum = num;
        new Thread(() -&gt; {
            while (finalNum == 0) {
            }
        }).start();
        TimeUnit.SECONDS.sleep(1);
        num = 1;
        System.out.println(num);
    }
}
</code></pre>
<ul>
<li>在该例子中，循环不会停止 new Thread 与 main 同时操作 num，他们分别从主内存复制到工作内存，对各自的工作内存中的数据进行操作，
main 线程对 num+1，同步到主线程，但 new Thread 的任务未停止，没有与主内存同步，循环不会终止</li>
<li>若循环中加一个执行语句，循环会终止，工作内存会即使与主内存进行同步</li>
</ul>
<p>当各个线程操作时，数据没有进行同步到主内存，产生错误 voletile 关键字使多个线程直接操作主内存，不在经过工作内存</p>
<h3 id="待续-1"><a class="header" href="#待续-1">待续...</a></h3>
<h2 id="juc"><a class="header" href="#juc">JUC</a></h2>
<h3 id="特征"><a class="header" href="#特征">特征</a></h3>
<p>synchronized 与 Lock 对比</p>
<ol>
<li>synchronized 自动上锁解锁，Lock 手动上锁解锁</li>
<li>synchronized 无法判断是否获取到锁，Lock 可以</li>
<li>synchronized 拿不到锁会一直等待，Lock 不会</li>
<li>synchronized 是关键字，jvm 实现，Lock 是接口，jdk 实现</li>
<li>synchronized 是非公平锁，Lock 自由设置</li>
</ol>
<blockquote>
<p>公平锁：多个线程排队加锁<code>&lt;br/&gt;</code> 非公平锁：不判断是否有其他等待线程，直接占用</p>
</blockquote>
<h3 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h3>
<pre><code class="language-java">private Lock lock = new ReentrantLock();
lock.lock();
    ...
lock.unlock();
</code></pre>
<h3 id="死锁"><a class="header" href="#死锁">死锁</a></h3>
<pre><code class="language-java">/*
* num = 1 的人拿到 chopsticks1，等待 chopsticks2
* num = 2 的人拿到 chopsticks2，等待 chopsticks1
* */
@Override
public void run() {
    if (num == 1) {
        synchronized (chopsticks1) {
            Thread.sleep(100);
            synchronized (chopsticks2) {
                System.out.println(&quot;1 吃完了&quot;);
            }
        }
    }
    if (num == 2) {
        synchronized (chopsticks2) {
            synchronized (chopsticks1) {
                System.out.println(&quot;2 吃完了&quot;);
            }
        }
    }
}
</code></pre>
<h3 id="生产者消费者"><a class="header" href="#生产者消费者">生产者消费者</a></h3>
<pre><code class="language-java">// 1. synchronize
class Container {
    private int num = 5;
    public synchronized void add() {
        while (num != 0) {
            this.wait();
        }
        num += 1;
        TimeUnit.SECONDS.sleep(1);
        System.out.println(Thread.currentThread().getName() + &quot;生产了 1 个，还有&quot; + num + &quot;个&quot;);
        this.notify();
    }
    public synchronized void pop(int i) {
        while (num == 0) {
            this.wait();
        }
        num -= 1;
        System.out.println(i + &quot;购买了 1 个，还有&quot; + num + &quot;个&quot;);
        this.notify();
    }
}
// 2. Lock 要以 condition.await 和 condition.singal 代替 wait 和 notify
class Container2 {
    private int num = 5;
    ReentrantLock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    public void add() {
        lock.lock();
        while (num != 0) {
            condition.await();
        }
        num += 1;
        TimeUnit.SECONDS.sleep(1);
        System.out.println(Thread.currentThread().getName() + &quot;生产了 1 个，还有&quot; + num + &quot;个&quot;);
        condition.signal();
        lock.unlock();
    }
}
</code></pre>
<h3 id="trylock"><a class="header" href="#trylock">tryLock</a></h3>
<pre><code class="language-java">class TimeLock {
    private final ReentrantLock lock = new ReentrantLock();
    public void tryLock() {
        try {
            if (lock.tryLock(3, TimeUnit.SECONDS)) {
                System.out.println(&quot;3 秒内拿到了锁&quot;);
                TimeUnit.SECONDS.sleep(5);
            } else {
                System.out.println(&quot;3 秒内没拿到锁&quot;);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();  // 只能由上锁者去解锁
            }
        }
    }
}
</code></pre>
<h3 id="同时读写"><a class="header" href="#同时读写">同时读写</a></h3>
<ol>
<li>对 ArrayList 读写操作同时存在会抛出异常</li>
</ol>
<pre><code class="language-java">public class ReadAndWrite {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        //List&lt;String&gt; list = new Vector&lt;&gt;();
        // List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());
        // List&lt;String&gt; list = new CopyOnWriteArrayList();
        for (int i = 0; i &lt; 10; i++) {
            new Thread(() -&gt; {
                try {
                    TimeUnit.MILLISECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                list.add(&quot;a&quot;);
                System.out.println(Thread.currentThread().getName() + list);
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre>
<ol start="2">
<li>原因 ArrayList 不是线程安全的</li>
</ol>
<pre><code class="language-java">public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
</code></pre>
<ol start="3">
<li>解决方法</li>
</ol>
<ul>
<li>更换为 Vector</li>
</ul>
<pre><code class="language-java">public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}
</code></pre>
<ul>
<li>
<p>更换为 Collections.synchronizedList()</p>
</li>
<li>
<p>JUC: CopyOnWriteList</p>
</li>
</ul>
<blockquote>
<p>CopyOnWrite 实现了读写分离，当我们往一个容器添加元素的时候，不是直接给容器添加，而是先将当前容器复制一
份，向新的容器中添加数据，添加完成之后，再将原容器的引用指向新的容器。</p>
</blockquote>
<pre><code class="language-java">public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
</code></pre>
<h3 id="计数器"><a class="header" href="#计数器">计数器</a></h3>
<ul>
<li>减法计数器 countDownLatch 可以确保某个线程优先执行，当计数器清零在唤醒其他线程</li>
</ul>
<pre><code class="language-java">public class CountDown {
    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(80);
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 100; i++) {
                countDownLatch.countDown();
                System.out.println(i);
            }
        }).start();

        countDownLatch.await();   // 必须唤醒，且计数器要清零

        for (int i = 0; i &lt; 10; i++) {
            System.out.println(&quot;main&quot;);
        }
    }
}
</code></pre>
<p>::: warning 注意 new CountDownLatch(80), countDownLatch.countDown(),
countDownLatch.await() 必须配合使用，只要计数器没有清零，计数器不会停止，其他线程也不能唤醒 :::</p>
<ul>
<li>加法计数器 试图唤醒当前线程，当加到一定数量成功唤醒，之后清零，再次累加循环</li>
</ul>
<pre><code class="language-java">// 构造器
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

// Test
public class CyclicBarrier_ {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(5, () -&gt; {
            System.out.println(&quot;放行&quot;);
        });
        for (int i = 0; i &lt; 10; i++) {
            final int temp = i;
            new Thread(() -&gt; {
                cyclicBarrier.await();
            }).start();
        }
    }
}
</code></pre>
<ul>
<li>计数线程限流 限制同时进入的线程数</li>
</ul>
<ol>
<li>初始化</li>
<li>获得许可</li>
<li>释放</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
    Semaphore semaphore = new Semaphore(5);   // 限制最多 5 人
    for (int i = 0; i &lt; 15; i++) {
        new Thread(() -&gt; {
            try {
                semaphore.acquire();
                System.out.println(Thread.currentThread().getName() + &quot;进去了&quot;);
                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName() + &quot;出去了&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                semaphore.release();
            }
        }).start();
    }
}
</code></pre>
<h3 id="读写锁"><a class="header" href="#读写锁">读写锁</a></h3>
<p>读写锁也是为了实现线程同步，只不过粒度更细，可以为读和写设置不同的锁</p>
<pre><code class="language-java">class Cache {
    private Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    public void write(Integer id, String value) {
        readWriteLock.writeLock().lock();
        System.out.println(&quot;开始写入 ID: &quot; + id);
        map.put(id, value);
        System.out.println(&quot;写入完成 ID: &quot; + id);
        readWriteLock.writeLock().unlock();
    }

    public String read(Integer id) {
        readWriteLock.readLock().lock();
        System.out.println(&quot;开始读取 ID: &quot; + id);
        String a = map.get(id);
        System.out.println(&quot;读取完成 ID: &quot; + id);
        readWriteLock.readLock().unlock();
        return a;
    }
}
</code></pre>
<p>::: tip 补充 写入锁也叫独占锁，只能被 1 个线程占用，读取锁也叫共享锁，多个线程可以同时占用。 :::</p>
<h3 id="线程池"><a class="header" href="#线程池">线程池</a></h3>
<ol>
<li>基本使用</li>
</ol>
<p>预先创建好一定数量的线程对象，存入缓冲池中，需要用的时候直接从缓冲池中取出，用完之后不要销毁，还回到缓冲池中，为了提高资源的利用率。优势：</p>
<ul>
<li>提高线程的利用率</li>
<li>提高响应速度</li>
<li>便于统一管理线程对象</li>
<li>可以控制最大的并发数</li>
</ul>
<pre><code class="language-java">public class ThreadPool_ {
    public static void main(String[] args) {
        // 单例
        //ExecutorService executorService = Executors.newSingleThreadExecutor();
        // 指定线程数量
        //ExecutorService executorService = Executors.newFixedThreadPool(5);
        // 缓冲线程池
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; 60; i++) {
            final int temp = i;
            executorService.execute(() -&gt; {
                System.out.println(Thread.currentThread().getName() + &quot; &quot; + temp);
            });
        }
        executorService.shutdown();
    }
}
</code></pre>
<!-- 2. 线程池分析 -->
<ol start="2">
<li>构造函数</li>
</ol>
<p>三个常用线程池都 return new ThreadPoolExecutor(); ThreadPoolExecutor 的构造函数如下</p>
<pre><code class="language-java">public ThreadPoolExecutor(  int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue&lt;Runnable&gt; workQueue,
                            ThreadFactory threadFactory,
                            RejectedExecutionHandler handler) {
</code></pre>
<ul>
<li>corePoolSize: 核心池数量</li>
<li>maximumPoolSize: 线程池容量上限，任务量增大时，线程池主动扩容</li>
<li>keepAliveTime: 线程对象存活时间</li>
<li>unit: 线程对象存活时间单位</li>
<li>workQueue: 线程队列 (新的任务在队列中等候获取线程对象)</li>
<li>threadFactory: 线程工厂创建线程对象</li>
<li>handler: 拒绝策略</li>
</ul>
<ol start="3">
<li>拒绝策略</li>
</ol>
<p>RejectedExecutionHandler 是一个接口，均在 ThreadPoolExecutor 中实现</p>
<ul>
<li>AbortPolicyz:直接抛出异常</li>
</ul>
<pre><code class="language-java">/**
    * A handler for rejected tasks that throws a
    * {@code RejectedExecutionException}.
    */
public static class AbortPolicy implements RejectedExecutionHandler {
</code></pre>
<ul>
<li>DiscardPolicy: 直接拒绝</li>
</ul>
<pre><code class="language-java">/**
    * A handler for rejected tasks that silently discards the
    * rejected task.
    */
public static class DiscardPolicy implements RejectedExecutionHandler {
</code></pre>
<ul>
<li>DiscardOldestPolicy: 尝试与等待队列中最开始的任务争夺，不抛出异常</li>
</ul>
<pre><code class="language-java">/**
     * A handler for rejected tasks that discards the oldest unhandled
     * request and then retries {@code execute}, unless the executor
     * is shut down, in which case the task is discarded.
     */
    public static class DiscardOldestPolicy implements RejectedExecutionHandler {
</code></pre>
<ul>
<li>CallerRunsPolicy 由发起请求线程处理</li>
</ul>
<pre><code class="language-java">/**
    * A handler for rejected tasks that runs the rejected task
    * directly in the calling thread of the {@code execute} method,
    * unless the executor has been shut down, in which case the task
    * is discarded.
    */
public static class CallerRunsPolicy implements RejectedExecutionHandler {
</code></pre>
<ol start="4">
<li>自定义线程池</li>
</ol>
<pre><code class="language-java">executorService = new ThreadPoolExecutor(
        4,
        10,
        2L,
        TimeUnit.SECONDS,
        new ArrayBlockingQueue&lt;&gt;(20),
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.AbortPolicy());
</code></pre>
<p>4 种 workQueue 堵塞队列，用来存储等待执行的任务</p>
<ul>
<li>ArrayBlockingQueue: 基于数组的先进先出队列，创建时必须指定大小。</li>
<li>LinkedBlockingQueue: 基于链表的先进先出队列，创建时可以不指定大小，默认值是 Integer.MAX VALUE。最大值。</li>
<li>SynchronousQueue: 它不会保持提交的任务，而是直接新建一个线程来执行新来的任务。</li>
<li>PriorityBlockingQueue: 具有优先级的阻塞队列。</li>
</ul>
<h3 id="forkjoin"><a class="header" href="#forkjoin">Forkjoin</a></h3>
<ol>
<li>概念</li>
</ol>
<ul>
<li>Forkjoin 是 JDK 1.7 后发布的多线程并发处理框架，功能上和 JUC 类似，
JUC 更多时候是使用单个类完成操作，Forkjoin 使用多个类同时完成某项工作，处理上比 JUC 更加丰富，</li>
<li>本质上是对线程池的一种的补充，对线程池功能的一种扩展，基于线程池，</li>
<li>它的核心思想就是将一个大型的任务拆分成很多个小任务，然后由多个线程并发执行，最终将小任务的结果进行汇总，生成最终的结果。</li>
</ul>
<ol start="2">
<li>基本使用 设置临界值，递归分配任务，知道任务不能被再分</li>
</ol>
<pre><code class="language-java">public class FolkJoin_ extends RecursiveTask&lt;Long&gt; {

    private Long start;
    private Long end;
    private Long temp = 200_0000L;

    public FolkJoin_(Long start, Long end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if ((end - start) &lt; temp) {
            Long sum = 0L;
            for (Long i = start; i &lt; end ; i++) {
                sum += i;
            }
            return sum;
        } else {
            Long avg = (start + end) / 2;
            FolkJoin_ tast1 = new FolkJoin_(start, avg);
            FolkJoin_ tast2 = new FolkJoin_(avg, end);
            tast1.fork();
            tast2.fork();
            return tast1.join()+tast2.join();
        }
    }
}
</code></pre>
<p>Main.java</p>
<pre><code class="language-java">Long start = System.currentTimeMillis();
ForkJoinPool folkJoinPool = new ForkJoinPool();
FolkJoin_ task = new FolkJoin_(0L, 10_0000_0000L);
folkJoinPool.execute(task);
System.out.println(task.get() + &quot; &quot; + (System.currentTimeMillis() - start) / 1000.0);
</code></pre>
<h3 id="待续-2"><a class="header" href="#待续-2">待续...</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sprintboot"><a class="header" href="#sprintboot">SprintBoot</a></h1>
<h2 id="统一参数校验"><a class="header" href="#统一参数校验">统一参数校验</a></h2>
<h3 id="增加对枚举的校验规则"><a class="header" href="#增加对枚举的校验规则">增加对枚举的校验规则</a></h3>
<p><a href="https://www.zhangshengrong.com/p/zAaOQQOrXd/">springboot validator 枚举值校验功能实现</a></p>
<h3 id="全局处理校验失败"><a class="header" href="#全局处理校验失败">全局处理校验失败</a></h3>
<p><a href="https://bbs.huaweicloud.com/blogs/188118">全局处理响应数据</a></p>
<h2 id="mybatisplus"><a class="header" href="#mybatisplus">MybatisPlus</a></h2>
<h3 id="1-配置引入"><a class="header" href="#1-配置引入">1. 配置引入</a></h3>
<p>1.1 pom.xml</p>
<pre><code class="language-xml">&lt;!--基础依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.4.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;!--生成器依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
    &lt;version&gt;3.3.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;  &lt;!--生成器模板 Velocity(默认) FreeMarker Beetl--&gt;
    &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt;
    &lt;artifactId&gt;velocity&lt;/artifactId&gt;
    &lt;version&gt;1.7&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>1.2 yml</p>
<pre><code class="language-yml">mybatis-plus:
  # 打印 sql 语句
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  # @EnumValue 配置
  type-enums-package: com.southwind.mybatis_plus.enums
  # @TableLogic
  global-config:
    db-config:
      logic-not-delete-value: 0
      logic-delete-value: 1
</code></pre>
<h3 id="2-源码"><a class="header" href="#2-源码">2. 源码</a></h3>
<p>META-INF/spring.factories</p>
<pre><code class="language-java">@ConfigurationProperties(
    prefix = &quot;spring.datasource&quot;
)
public class DataSourceProperties implements BeanClassLoaderAware, InitializingBean {
    private ClassLoader classLoader;
    private String name;
    private boolean generateUniqueName = true;
    private Class&lt;? extends DataSource&gt; type;
    private String driverClassName;
    private String url;
    ...
// mybatis_plus 舍弃了 xml 文档的配置方式，采用配置类读取 yml
</code></pre>
<h3 id="3-注解"><a class="header" href="#3-注解">3. 注解</a></h3>
<ul>
<li>
<p>基本注解</p>
<pre><code class="language-java">@TableName(value = &quot;mybatis_plus_user&quot;) //tablename=value
@TableId(value = &quot;id&quot;, type = IdType.NONE)  // 默认雪花 id, entity 要 Long，数据库要 bigint 类型才能存进去
@TableField(value = &quot;age&quot;, select = false, exist = false) // 是否查询，是否存在
</code></pre>
</li>
<li>
<p>自动填充</p>
<pre><code class="language-java">// (create_time, update_time 等),需要配置 MetaObjectHandler
@TableField(fill = FieldFill.INSERT_UPDATE)
private Date createTime;

    @Component
    public class MyMetaObjectHandler implements MetaObjectHandler {
        @Override
        public void insertFill(MetaObject metaObject) {
            this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject);
            this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);
        }
        @Override
        public void updateFill(MetaObject metaObject) {
            this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);
        }
    }
</code></pre>
</li>
<li>
<p>乐观锁</p>
<pre><code class="language-java">//  where version = 1..., 配置 OptimisticLockerConfig，增加 version 字段
@Version  // 每次 update 后，version 都会自增 1,
private int version;

    @Configuration
    public class MybatisPlusConfig {
        @Bean
        public MybatisPlusInterceptor optimisticLocerInceptor() {
            MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
            mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
            return mybatisPlusInterceptor;
        }
    }
</code></pre>
</li>
<li>
<p>枚举映射</p>
<pre><code class="language-java">@EnumValue
private StatusEnum statusEnum;
public enum StatusEnum {
    // 1. 实体类加注解，yml 需配置
    WORK(1, &quot;上班&quot;),
    REST(0, &quot;休息&quot;);
    StatusEnum(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }
    @EnumValue
    private Integer code;  // 状态
    private String msg;    // 描述
}
/* mybatis-plus:
*   type-enums-package: com.southwind.mybatis_plus.enums
*/
public enum StatusEnum2 implements IEnum {
    // 2. 实体类实现接口，yml 无需配置
    WORK(1, &quot;上班&quot;),
    REST(0, &quot;休息&quot;);
    StatusEnum2(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }
    // 不用加 @EnumValue 注解
    private Integer code;  // 状态
    private String msg;    // 描述
    // 需要重写方法
    @Override
    public Serializable getValue() {
        return this.code;
    }
}

// 5. 逻辑删除 where deleted=0
@TableLogic // 增加 deleted 字段
private Integer deleted;
</code></pre>
</li>
</ul>
<h3 id="4-crud"><a class="header" href="#4-crud">4. CRUD</a></h3>
<ul>
<li>
<p>条件查询</p>
<pre><code class="language-java">mapper.selectList(null);  // 查询全部
QueryWrapper wrapper = new QueryWrapper();

wrapper.eq(&quot;name&quot;, &quot;张三&quot;); // ==
wrapper.lt(&quot;age&quot;, 3); // &lt;
wrapper.gt(&quot;age&quot;, 3); // &gt;
wrapper.ge(&quot;age&quot;, 3); // &gt;=
wrapper.ne(&quot;age&quot;, 3); // &lt;&gt;

Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
map.put(&quot;name&quot;, &quot;张三&quot;);
map.put(&quot;age&quot;, 13);
wrapper.allEq(map);
</code></pre>
</li>
<li>
<p>模糊查询</p>
<pre><code class="language-java">wrapper.like(&quot;name&quot;, &quot;红&quot;); // 模糊查询 (name like 红)
wrapper.likeLeft(&quot;name&quot;, &quot;红&quot;); // 模糊查询 (name like %红) 以红开头
wrapper.likeRight(&quot;name&quot;, &quot;红&quot;); // 模糊查询 (name like 红%) 以红结尾

wrapper.inSql(&quot;age&quot;, &quot;sql 语句&quot;); // (where age in ResultSet)
wrapper.orderByAsc(&quot;age&quot;); //升序

wrapper.orderByDesc(&quot;age&quot;); //升序
wrapper.having(&quot;age &gt; 8&quot;); // 两句可以叠加
mapper.selectList(wrapper);

mapper.selectMaps(wrapper); // 结果以 Map 形式返回
</code></pre>
</li>
<li>
<p>分页查询 (配置拦截器)</p>
<pre><code class="language-java">Page&lt;Mybatis_plus_user&gt; page = new Page&lt;&gt;(1, 3); // 每一页取两条记录
Page&lt;Mybatis_plus_user&gt; result = mapper.selectPage(page, null);
result.getRecords().forEach(System.out::println);

@Bean
public PaginationInnerInterceptor paginationInnerInterceptor() {
    return new PaginationInnerInterceptor();
}
</code></pre>
</li>
</ul>
<h3 id="5-自定义-sql"><a class="header" href="#5-自定义-sql">5. 自定义 SQL</a></h3>
<pre><code>```java
@Select(&quot;Select p.*, u.id userId, u.name userName from mybatis_plus_product p, mybatis_plus_user u where p.id=#{id}&quot;)
List&lt;UserVO&gt; findVOsById(Integer id);
// 适用于 VO 且 u.id, u.name 没有被封装为一个对象，用 UserName 代替 user 与实体类对应
```
</code></pre>
<h3 id="6-generator"><a class="header" href="#6-generator">6. Generator</a></h3>
<pre><code>```java
public class MybatisPlusGenerator {
    public static void main(String[] args) {
        AutoGenerator autoGenerator = new AutoGenerator();
        // 数据源
        autoGenerator.setDataSource(new DataSourceConfig()
                .setDbType(DbType.MYSQL)
                .setUrl(&quot;jdbc:mysql://localhost:3306/library?serverTimezone=GMT&quot;)
                .setUsername(&quot;root&quot;)
                .setPassword(&quot;123&quot;)
                .setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;)
        );
        // 全局配置
        autoGenerator.setGlobalConfig(new GlobalConfig()
                .setOutputDir( &quot;src/main/java&quot;)
                .setOpen(false)
                .setAuthor(&quot;trdthg&quot;)
                .setServiceName(&quot;%sService&quot;)  // 设定 service 类名不带 I
        );
        // 包信息
        autoGenerator.setPackageInfo(new PackageConfig()
                .setParent(&quot;com.southwind.mybatis_plus&quot;)
                .setModuleName(&quot;generator&quot;)
                .setController(&quot;controller&quot;)
                .setEntity(&quot;entity&quot;)
                .setMapper(&quot;mapper&quot;)
                .setService(&quot;service&quot;)
                .setServiceImpl(&quot;service.impl&quot;)
        );
        // 策略配置
        autoGenerator.setStrategy(new StrategyConfig()
                .setEntityLombokModel(true)
                .setColumnNaming(NamingStrategy.underline_to_camel) //数据库下划线自动转 entity 驼峰
                .setNaming(NamingStrategy.underline_to_camel)
        );
        autoGenerator.execute();
    }
}

```
</code></pre>
<h2 id="redis"><a class="header" href="#redis">Redis</a></h2>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;version&gt;2.4.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>yml</li>
</ul>
<pre><code class="language-yml">sprint:
  redis:
    database: 0
    host: localhost
    port: 6379
</code></pre>
<ul>
<li>controller</li>
</ul>
<pre><code class="language-java">@RestController
public class RedisController {

    @Autowired
    private RedisTemplate redisTemplate;

    @PostMapping(&quot;/set&quot;)
    public void set(@RequestBody Student student) {
        redisTemplate.opsForValue().set(&quot;student&quot;, student);
        System.out.println(&quot;设置完成&quot;);
    }

    @GetMapping(&quot;/get/{key}&quot;)
    public Student get(@PathVariable(&quot;key&quot;) String key) {
        return (Student) redisTemplate.opsForValue().get(key);
    }

    @DeleteMapping(&quot;/delete/{key}&quot;)
    public boolean delete(@PathVariable(&quot;key&quot;) String key) {
        return !redisTemplate.delete(key);
    }

    @GetMapping(&quot;/string&quot;)
    public String string() {
        redisTemplate.opsForValue().set(&quot;string&quot;, &quot;hello world&quot;);
        return (String) redisTemplate.opsForValue().get(&quot;string&quot;);
    }

    @GetMapping(&quot;/list&quot;)
    public List&lt;String&gt; list() {
        ListOperations&lt;String, String&gt; listOperations = redisTemplate.opsForList();
        listOperations.leftPush(&quot;list&quot;, &quot;aaa&quot;);
        listOperations.leftPush(&quot;list&quot;, &quot;bbb&quot;);
        listOperations.leftPush(&quot;list&quot;, &quot;ccc&quot;);
        return listOperations.range(&quot;list&quot;, 0, 1);
    }

    @GetMapping(&quot;/set&quot;)
    public Set&lt;String&gt; set() {
        SetOperations&lt;String, String&gt; setOperations = redisTemplate.opsForSet();
        setOperations.add(&quot;set&quot;, &quot;集合 1&quot;);
        setOperations.add(&quot;set&quot;, &quot;集合 4&quot;);
        return setOperations.members(&quot;set&quot;);
    }

    @GetMapping(&quot;/zset&quot;)
    public Set&lt;String&gt; zset() {
        ZSetOperations&lt;String, String&gt; zSetOperations = redisTemplate.opsForZSet();
        //zSetOperations.add(&quot;zset&quot;, &quot;hello&quot;, 1);
        zSetOperations.add(&quot;zset&quot;, &quot;hello&quot;, 2);
        zSetOperations.add(&quot;zset&quot;, &quot;world&quot;, 1);
        zSetOperations.add(&quot;zset&quot;, &quot;hello&quot;, 3);
        return zSetOperations.range(&quot;zset&quot;, 0, 2);
    }

    @GetMapping(&quot;/hash&quot;)
    public String hash() {
        HashOperations hashOperations = redisTemplate.opsForHash();
        hashOperations.put(&quot;hash&quot;, &quot;id&quot;, &quot;1&quot;);
        hashOperations.put(&quot;hash&quot;, &quot;name&quot;, &quot;张三&quot;);
        hashOperations.put(&quot;hash&quot;, &quot;score&quot;, &quot;1.345&quot;);
        return (String) hashOperations.get(&quot;hash&quot;, &quot;name&quot;);
    }

}
</code></pre>
<h2 id="shiro"><a class="header" href="#shiro">Shiro</a></h2>
<h3 id="核心组件"><a class="header" href="#核心组件">核心组件</a></h3>
<ol>
<li>UsernamePasswordToken: 封装用户登录信息，根据信息创建令牌 token</li>
<li>SecurityManager：核心部分，负责安全认证和授权</li>
<li>Subject：抽象概念，包含了用户信息</li>
<li>Realm：开发者自定义模块，登录授权的逻辑具体实现</li>
<li>Authenticationinfo：用户角色信息，认证时使用</li>
<li>Authorization：角色权限信息，授权时使用</li>
<li>DefaultWebSecurityManager：开发者将 Realm 注入其中才能生效</li>
<li>ShiroFilterFactoryBean：过滤器对象，shiro 通过创建 filter 对象执行开发者定义的过滤规则 ::: tip
用户与权限没有直接关联 用户 - 角色 - 权限 三者之间为多对多关系 :::</li>
</ol>
<h3 id="依赖"><a class="header" href="#依赖">依赖</a></h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
    &lt;version&gt;1.7.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="过滤器的实现"><a class="header" href="#过滤器的实现">过滤器的实现</a></h3>
<pre><code class="language-java">public class ShiroUserRealm extends AuthorizingRealm {

    @Autowired
    ShiroUserService shiroUserService;
    // 授权
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        return null;
    }
    // 验证
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) token;
        ShiroUser shiroUser = shiroUserService.findByUsername(usernamePasswordToken.getUsername());
        if (shiroUser != null) {
            // 密码是否正确不用手动验证，丢进去就行
            // 不正确会抛出密码错误异常
            return new SimpleAuthenticationInfo(shiroUser, shiroUser.getPassword(), getName());
        }
        // 会自动抛出账户不存在的异常
        return null;
    }
}
</code></pre>
<h3 id="配置类"><a class="header" href="#配置类">配置类</a></h3>
<ol>
<li>Realm Manager Factory 三层注入</li>
<li>@Qualifier(&quot;defaultWebSecurityManager&quot;) 按照名字查询 Bean</li>
</ol>
<pre><code class="language-java">@Configuration
public class ShiroConfig {

    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(&quot;defaultWebSecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);
        return shiroFilterFactoryBean;
    }

    @Bean
    public DefaultWebSecurityManager defaultWebSecurityManager(@Qualifier(&quot;shiroUserRealm&quot;) ShiroUserRealm shiroUserRealm) {
        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();
        defaultWebSecurityManager.setRealm(shiroUserRealm);
        return defaultWebSecurityManager;
    }

    @Bean
    public ShiroUserRealm shiroUserRealm() {
        return new ShiroUserRealm();
    }

}
</code></pre>
<h3 id="授权认证规则"><a class="header" href="#授权认证规则">授权认证规则</a></h3>
<ol>
<li>认证过滤器
<ul>
<li>anon：无需认证</li>
<li>authc：必须认证</li>
<li>authcBasic：需要通过 HttpBasic 认证</li>
<li>user：不一定需要认证，只需要被记录就不需要再次认证</li>
</ul>
</li>
<li>授权过滤器
<ul>
<li>perms：必须拥有某个权限</li>
<li>role：必须拥有某个角色</li>
<li>port：请求端口必须是指定值</li>
<li>rest：请求必须基于 Restful，GET、POST、PUT、DELETE</li>
<li>ssl：必须是安全的 URL 请求，协议是 HTTPS</li>
</ul>
</li>
</ol>
<pre><code class="language-java">@Bean
public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(&quot;defaultWebSecurityManager&quot;) DefaultWebSecurityManager defaultWebSecurityManager) {
    ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
    shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);
    // 权限设置
    Map&lt;String, String&gt; map = new Hashtable&lt;&gt;();
    map.put(&quot;/index&quot;, &quot;anon&quot;);
    map.put(&quot;/userspace&quot;, &quot;authc&quot;);
    map.put(&quot;/manage&quot;, &quot;perms[manager]&quot;);
    map.put(&quot;/root&quot;, &quot;roles[vip]&quot;);
    map.put(&quot;/special&quot;, &quot;authc, roles[vip]&quot;);
    shiroFilterFactoryBean.setFilterChainDefinitionMap(map);
    shiroFilterFactoryBean.setLoginUrl(&quot;shiroUser/login&quot;);
    return shiroFilterFactoryBean;
}
</code></pre>
<h2 id="spring-cloud-alibaba"><a class="header" href="#spring-cloud-alibaba">Spring-Cloud-Alibaba</a></h2>
<h3 id="服务治理-nacos"><a class="header" href="#服务治理-nacos">服务治理 Nacos</a></h3>
<p><a href="https://nacos.io/zh-cn/docs/quick-start.html">官网教程</a> Nacos 网页使用
nacos 默认需要配置 nginx 才能通过网页访问，执行<code>sh startup.sh -m standalone</code>可以直接访问</p>
<ol>
<li>服务注册
<ul>
<li>在 SpringBoot 下新建<code>Provider</code>子模块，继承<code>SCAlbaba</code>父项目，</li>
</ul>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;!--&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;
    &lt;!--&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;--&gt;
    &lt;!--&lt;version&gt;2.4.5&lt;/version&gt;--&gt;
    &lt;!--&lt;relativePath/&gt; &amp;lt;!&amp;ndash; lookup parent from repository &amp;ndash;&amp;gt;--&gt;
    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;southwind_springcloudalibaba&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;/parent&gt;
</code></pre>
<ul>
<li>加上 web 依赖，加上 nacos-discovery 依赖</li>
</ul>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
    &lt;version&gt;2021.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>配置 yml</li>
</ul>
<pre><code class="language-yml">spring:
cloud:
    nacos:
    discovery:
        server-addr: localhost:8848
application:
    name: provider
server:
port: 8082
</code></pre>
</li>
</ol>
<p>::: tip 提示 Idea 通过编辑配置可以多开应用 ::: 2. 服务发现 -
在 SpringBoot 下新建<code>Consumer</code>子模块，继承<code>SCAlbaba</code>父项目， - 继承和依赖同上 - yml 只用配端口
<code>yml server: port: 8082</code> - controller ```java @RestController public class
ConsumerController {</p>
<pre><code>        @Autowired
        private DiscoveryClient discoveryClient;

        @GetMapping(&quot;/getInstance&quot;)
        public List&lt;ServiceInstance&gt; getInstance() {
            return this.discoveryClient.getInstances(&quot;provider&quot;);
        }

    }
```
</code></pre>
<h3 id="负载均衡"><a class="header" href="#负载均衡">负载均衡</a></h3>
<ol>
<li>服务调用 Privider 中提供了 getPort 方法，多个 Provider 实例由 Consumer 调用 Provider</li>
</ol>
<pre><code class="language-java">@RestController
public class ProviderController {

    @Value(&quot;${server.port}&quot;)   // el 表达式，读取 yml 文件中的内容
    private String port;

    @GetMapping(&quot;/getPort&quot;)
    public String getPort() {
        return port;
    }

}
</code></pre>
<p>Consumer</p>
<pre><code class="language-java">@RestController
@Slf4j // 日志打印
public class ConsumerController {

    @Autowired
    private DiscoveryClient discoveryClient;
    @Autowired
    private RestTemplate restTemplate;  // 需要手动装载

    @GetMapping(&quot;/port&quot;)
    public String getPort() {
        // 1. 获取随机一个 provider 实例
        List&lt;ServiceInstance&gt; providers = discoveryClient.getInstances(&quot;provider&quot;);
        int randomIndex = ThreadLocalRandom.current().nextInt(providers.size());
        ServiceInstance provider = providers.get(randomIndex);
        String uri = provider.getUri().toString();  // uri： ip + port
        String url = uri + &quot;/getPort&quot;;
        // 2. 接口调用
        log.info(&quot;调用的端口是&quot; + provider.getHost());
        String port = restTemplate.getForObject(url, String.class);
        return &quot;调用 Consumer，调用了端口为&quot; + port + &quot;的 Provider 的 getPort&quot;;
    }
}
</code></pre>
<p>::: warning restTemplte 无法自动注入，需要手动注入 :::</p>
<pre><code class="language-java">@Configuration
public class ConsumerConfiguration {

    // 放到 Main 下也可
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
</code></pre>
<ol start="2">
<li>
<p>Ribbon 负载均衡</p>
<ul>
<li>config 配置</li>
</ul>
<pre><code class="language-java">@Bean
@LoadBalanced
public RestTemplate restTemplate() {
    return new RestTemplate();
}
</code></pre>
<ul>
<li>controller</li>
</ul>
<pre><code class="language-java">// Ribbon 负载均衡
@GetMapping(&quot;/getPort2&quot;)
public String getPort2() {
    // 默认轮询算法
    String port = restTemplate.getForObject(&quot;http://provider/getPort&quot;, String.class);
    return &quot;调用 Consumer，调用了端口为&quot; + port + &quot;的 Provider 的 getPort&quot;;
}
</code></pre>
<ul>
<li>负载均衡算法（可自定义）</li>
</ul>
<pre><code class="language-java">@Bean
public IRule myRule(){
	return new RandomRule();
}
</code></pre>
<ol>
<li>RoundRobinRule：	轮询</li>
<li>RandomRule：	随机</li>
<li>AvaliabilityFilteringRule：	会先过滤由于多次访问故障而处于断路器跳闸的状态的服务和并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略</li>
<li>WeightedResponseTimeRule：	根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大</li>
<li>RetryRule：	先按照 RoundRobinRule 策略获取服务，如果获取服务失败会在指定时间内重试</li>
<li>BestAvailableRule：	会先过滤掉由于多次访问故障二处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</li>
<li>ZoneAvoidanceRule：	默认规则，复合判断 server 所在的区域的性能和 server 的可用性选择服务器</li>
</ol>
</li>
</ol>
<h3 id="待续-3"><a class="header" href="#待续-3">待续...</a></h3>
<h2 id="待续-4"><a class="header" href="#待续-4">待续...</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spring"><a class="header" href="#spring">Spring</a></h1>
<h2 id="ioc"><a class="header" href="#ioc">IOC</a></h2>
<h3 id="获取实例"><a class="header" href="#获取实例">获取实例</a></h3>
<pre><code class="language-java">ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
// 1. 通过 id 获取实例
Student student = (Student) applicationContext.getBean(&quot;student&quot;);
// 2. 通过运行时类获取实例 (缺点：xml 中一种数据类型只能有一个实例)
//Student student = (Student) applicationContext.getBean(Student.class);
System.out.println(student);
</code></pre>
<h3 id="bean-配置"><a class="header" href="#bean-配置">Bean 配置</a></h3>
<ol>
<li>无参构造</li>
</ol>
<pre><code class="language-java">&lt;bean id=&quot;student&quot; class=&quot;com.southwind.entity.Student&quot;
    scope=&quot;prototype&quot; parent=&quot;student&quot; autowire=&quot;byType&quot; depends-on=&quot;a2&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;12&quot;/&gt;
    &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>scope: 默认为 singleton，单例模式，prototype 为工厂模式</li>
<li>panent 参数：不同对象只要属性相同就能继承</li>
<li>autowire: byName 根据 id=(address) 寻找，根据 class=(Student) 寻找</li>
<li>depend-on: 规定 bean 创建顺序</li>
</ul>
<ol start="2">
<li>有参构造</li>
</ol>
<pre><code class="language-java">&lt;bean id=&quot;student3&quot; class=&quot;com.southwind.entity.Student&quot;&gt;
    &lt;constructor-arg name=&quot;id&quot; value=&quot;3&quot;/&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;李四&quot;/&gt;
    &lt;!--可以用 index 代替 name，但是也要按顺序写--&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;14&quot;/&gt;
    &lt;!--&lt;constructor-arg index=&quot;2&quot; value=&quot;14&quot;/&gt;--&gt;
    &lt;constructor-arg name=&quot;address&quot; ref=&quot;address&quot;/&gt;
    &lt;constructor-arg name=&quot;addresses&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;address&quot;/&gt;
            &lt;ref bean=&quot;address2&quot;/&gt;
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>::: tip 提示 spring 通过反射调用无参构造创建对象，bean 必须有无参构造 :::
ClassPathXmlApplicationContext 类实现了 ApplicationContext 接口，有 getBean 方法
下面是一个 ClassPathXmlApplicationContext 的简单实现</p>
<pre><code class="language-java">public class ClassPathXmlApplicationContext implements ApplicationContext {

    private Map&lt;String, Object&gt; ioc = new HashMap&lt;&gt;();

    public ClassPathXmlApplicationContext(String path) {
        try {
            // xml 文件解析
            SAXReader saxReader = new SAXReader();
            Document document = saxReader.read(&quot;./src/main/resources/&quot; + path);
            System.out.println(document);
            Element root = document.getRootElement();
            Iterator&lt;?&gt; iterator = root.elementIterator();
            // 遍历所有节点
            while (iterator.hasNext()) {
                Element element = (Element) iterator.next();
                String id = element.attributeValue(&quot;id&quot;);
                String className = element.attributeValue(&quot;class&quot;);
                // 通过反射创建对象
                Class&lt;?&gt; clazz = Class.forName(className);
                // 获取无参构造函数
                Constructor&lt;?&gt; constructor = clazz.getConstructor();
                Object object = constructor.newInstance();
                Iterator&lt;Element&gt; beanIterator = element.elementIterator();
                while (beanIterator.hasNext()) {
                    Element property = beanIterator.next();
                    String name = property.attributeValue(&quot;name&quot;);
                    String value = property.attributeValue(&quot;value&quot;);
                    String ref = property.attributeValue(&quot;ref&quot;);
                    // 获取 set 方法
                    // 1. 拼接方法名
                    String methodName = &quot;set&quot; + name.substring(0, 1).toUpperCase() + name.substring(1);
                    // 2. 获取形参类型
                    Field field = clazz.getDeclaredField(name);
                    // 3. 获取带参数的方法
                    Method method = clazz.getDeclaredMethod(methodName, field.getType());
                    // 4. 将实参类型 String 转换为所需的
                    String fieldName = field.getType().getName();
                    if (fieldName == &quot;long&quot;) {
                        method.invoke(object, Long.parseLong(value));
                    } else if (fieldName == &quot;int&quot;) {
                        method.invoke(object, Integer.parseInt(value));
                    } else {
                        method.invoke(object, value);
                    }
                    if (ref != null) {
                        method.invoke(object, ioc.get(ref));
                        // 这里可能要做个递归
                        // 或者是把 bean 全找到后再根据 ref 互相赋值
                        // 这里简单写
                    }
                }
                ioc.put(id, object);
                System.out.println(object);
            }
            System.out.println(&quot;XML 解析完毕&quot;);
        } catch (DocumentException | ClassNotFoundException | NoSuchMethodException | InstantiationException | InvocationTargetException | IllegalArgumentException | IllegalAccessException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }

    }

    @Override
    public Object getBean(String id) {
        return ioc.get(id);
    }
}
</code></pre>
<ol start="3">
<li>静态工厂</li>
</ol>
<ul>
<li>factory</li>
</ul>
<pre><code class="language-java">public class StaticCarFactory {
    private static Map&lt;Long, Car&gt; carMap;
    static {
        carMap = new HashMap&lt;&gt;();
        carMap.put(1L, new Car(1L, &quot;宝马&quot;));
        carMap.put(2L, new Car(2L, &quot;奔驰&quot;));
    }
    public static Car getCar(long id) {
        return carMap.get(id);
    }
}
</code></pre>
<ul>
<li>spring.xml</li>
</ul>
<pre><code class="language-xml">&lt;!--配置静态工厂--&gt;
&lt;bean id=&quot;car&quot; class=&quot;com.southwind.factory.StaticCarFactory&quot;               factory-method=&quot;getCar&quot;&gt;
    &lt;constructor-arg value=&quot;2&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="4">
<li>实例工厂</li>
</ol>
<ul>
<li>factory</li>
</ul>
<pre><code class="language-java">public class InstanceCarFactory {
    private Map&lt;Long, Car&gt; carMap;
    public InstanceCarFactory() {
        carMap = new HashMap&lt;&gt;();
        carMap.put(1L, new Car(1L, &quot;宝马&quot;));
        carMap.put(2L, new Car(2L, &quot;奔驰&quot;));
    }
    public Car getCar(long id) {
        return carMap.get(id);
    }
}
</code></pre>
<ul>
<li>xml</li>
</ul>
<pre><code class="language-java">&lt;!--配置实例工厂--&gt;
&lt;bean id=&quot;carFactory&quot; class=&quot;com.southwind.factory.InstanceCarFactory&quot;/&gt;
&lt;bean id=&quot;car2&quot; factory-bean=&quot;carFactory&quot; factory-method=&quot;getCar&quot;&gt;
    &lt;constructor-arg value=&quot;2&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h2 id="aop"><a class="header" href="#aop">AOP</a></h2>
<h3 id="手动反射实现"><a class="header" href="#手动反射实现">手动反射实现</a></h3>
<ul>
<li>handler</li>
</ul>
<pre><code class="language-java">public class CalInvocationHandler implements InvocationHandler {
    // 接受委托对象
    private Object object = null;

    // 返回代理对象
    public Object bind(Object object) {
        this.object = object;
        // 获取运行时类
        Class&lt;?&gt; clazz = object.getClass();
        // 获取类加载器
        ClassLoader classLoader = clazz.getClassLoader();
        // 获取类的所有接口
        Class&lt;?&gt;[] interfaces = clazz.getInterfaces();
        //创建能实现委托对象所有功能的代理对象
        return Proxy.newProxyInstance(classLoader, interfaces, this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(method.getName() + &quot;的参数是&quot; + Arrays.toString(args));
        Object result = method.invoke(this.object, args);
        System.out.println(method.getName() + &quot;的结果是&quot; + result);

        return result;
    }
}
</code></pre>
<ul>
<li>Test</li>
</ul>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        Cal cal = new CalImpl();
        CalInvocationHandler calInvocationHandler = new CalInvocationHandler();
        cal = (Cal) calInvocationHandler.bind(cal);
        cal.add(1, 2);
    }
}
</code></pre>
<h3 id="aspect-实现"><a class="header" href="#aspect-实现">@Aspect 实现</a></h3>
<ul>
<li>loggerAspect</li>
</ul>
<pre><code class="language-java">@Aspect  // 让普通对象成为切面对象
@Component  // 交给 ioc 管理 bean  同时委托对象也要被 ioc 管理
public class loggerAspect {

    // 方法名用*代替  参数用..代替
    //@Before(&quot;execution(public int com.southwind.utils.impl.CalImpl.add(int, int))&quot;)
    @Before(&quot;execution(int com.southwind.utils.impl.CalImpl.*(..))&quot;)
    public void before(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());
        System.out.println(methodName + &quot;的参数是&quot; + args);
    }

    @After(&quot;execution(int com.southwind.utils.impl.CalImpl.*(..))&quot;)
    public void after(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(methodName + &quot;执行完毕&quot;);
    }

    @AfterReturning(
            value = &quot;execution(int com.southwind.utils.impl.CalImpl.*(..))&quot;,
            returning = &quot;result&quot;)
    public void afterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(methodName + &quot;的结果是&quot; + result);
    }

    @AfterThrowing(
            value = &quot;execution(int com.southwind.utils.impl.CalImpl.*(..))&quot;,
            throwing = &quot;e&quot;)
    public void afterThrowing(JoinPoint joinPoint, Exception e) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(methodName + &quot;抛出异常&quot; + e);
    }
}
</code></pre>
<ul>
<li>spring.xml</li>
</ul>
<pre><code class="language-xml">&lt;!--自动扫描 base-package 下的对象，将添加了 @component 注解的对象加入 ioc 容器--&gt;
&lt;context:component-scan base-package=&quot;com.southwind&quot;/&gt;

&lt;!--自动扫描，为添加了 @aspect 注解的对象自动生成代理对象--&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<ul>
<li>Test2</li>
</ul>
<pre><code class="language-java">// 加载配置文件
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
// 自动生成的代理对象被自动加入 ioc,
// @component(&quot;id&quot;) 如果不加参数 bean 的 id 为委托对象首字母小写
Cal proxy = (Cal) applicationContext.getBean(&quot;calImpl&quot;);
proxy.add(1, 2);
</code></pre>
<h2 id="spring-mvc"><a class="header" href="#spring-mvc">spring-mvc</a></h2>
<h2 id="mybatis"><a class="header" href="#mybatis">Mybatis</a></h2>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.5.6&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.23&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>config.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
&lt;!--    配置 mybits 运行环境--&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
&lt;!--            JDBC 事务管理--&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
&lt;!--            POOLED 配置数据库连接池--&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/library?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;!--注册 xml 文件--&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;com/southwind/mapper/AccountMapper.xml&quot;&gt;&lt;/mapper&gt;
        &lt;mapper resource=&quot;com/southwind/mapper/StudentMapper.xml&quot;&gt;&lt;/mapper&gt;
        &lt;mapper resource=&quot;com/southwind/mapper/ClassesMapper.xml&quot;&gt;&lt;/mapper&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合框架"><a class="header" href="#集合框架">集合框架</a></h1>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<h4 id="arrayscopy"><a class="header" href="#arrayscopy">Arrays.copy()</a></h4>
<ol>
<li>创建一个新的集合用来储存数据
<ul>
<li>type(T) == type(U) ? 直接创建 : 通过反射机制创建</li>
</ul>
</li>
<li>调用 System.arraycopy() 拷贝到新集合上</li>
</ol>
<pre><code class="language-java">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {
    @SuppressWarnings(&quot;unchecked&quot;)
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    System.arraycopy(original, 0, copy, 0,
                        Math.min(original.length, newLength));
    return copy;
}
</code></pre>
<h3 id="collection"><a class="header" href="#collection">Collection</a></h3>
<ol>
<li>解释</li>
</ol>
<pre><code class="language-java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {
</code></pre>
<ul>
<li>继承自 Iterable，实现了 forEach &amp;&amp; iterator &amp;&amp; spliterator</li>
<li>removeIf 方法传入 Predicate(函数接口，传入比较的方法), 利用 Iterator 迭代</li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">public interface MyCollection&lt;E&gt; extends Iterable&lt;E&gt; {
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator&lt;E&gt; iterator();
    Object[] toArray();
    &lt;T&gt; T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection&lt;?&gt; c);
    boolean addAll(Collection&lt;? extends E&gt; c);
    boolean removeAll(Collection&lt;?&gt; c);
    default boolean removeIf(Predicate&lt;? super E&gt; filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator&lt;E&gt; each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }
    boolean retainAll(Collection&lt;?&gt; c);
    void clear();
    boolean equals(Object o);
    int hashCode();

    // 自从 1.8
    //default Spliterator&lt;E&gt; spliterator() {
    //    return Spliterators.spliterator(this, 0);
    //}
    //default Stream&lt;E&gt; stream() {
    //    return StreamSupport.stream(spliterator(), false);
    //}
    //default Stream&lt;E&gt; parallelStream() {
    //    return StreamSupport.stream(spliterator(), true);
    //}

}
</code></pre>
<h3 id="list-1"><a class="header" href="#list-1">List</a></h3>
<ol>
<li>解释</li>
</ol>
<ul>
<li>相比于 Collection，主要增加了</li>
<li>get</li>
<li>sort</li>
<li>index 相关</li>
<li>listIterator</li>
<li>SubList</li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">public interface MyList&lt;E&gt; extends Collection&lt;E&gt; {
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator&lt;E&gt; iterator();
    Object[] toArray();
    &lt;T&gt; T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection&lt;?&gt; c);
    boolean addAll(Collection&lt;? extends E&gt; c);
    boolean addAll(int index, Collection&lt;? extends E&gt; c);
    boolean removeAll(Collection&lt;?&gt; c);
    boolean retainAll(Collection&lt;?&gt; c);
    default void replaceAll(UnaryOperator&lt;E&gt; operator) {
        Objects.requireNonNull(operator);
        final ListIterator&lt;E&gt; li = this.listIterator();
        while (li.hasNext()) {
            li.set(operator.apply(li.next()));
        }
    }
    default void sort(Comparator&lt;? super E&gt; c) {
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator&lt;E&gt; i = this.listIterator();
        for (Object e : a) {
            i.next();
            i.set((E) e);
        }
    }
    void clear();
    boolean equals(Object o);
    int hashCode();
    E get(int index);
    E set(int index, E element);
    void add(int index, E element);
    E remove(int index);
    int indexOf(Object o);
    int lastIndexOf(Object o);
    ListIterator&lt;E&gt; listIterator();
    ListIterator&lt;E&gt; listIterator(int index);
    List&lt;E&gt; subList(int fromIndex, int toIndex);
</code></pre>
<h3 id="abstractcollection"><a class="header" href="#abstractcollection">AbstractCollection</a></h3>
<ol>
<li>解释</li>
</ol>
<ul>
<li>提供了两个抽象方法</li>
</ul>
<pre><code class="language-java">public abstract Iterator&lt;E&gt; iterator();
public abstract int size();
</code></pre>
<ul>
<li>实现了 toArray() 方法</li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">public abstract class MyAbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {
    protected MyAbstractCollection() {
    }
    public abstract Iterator&lt;E&gt; iterator();
    public abstract int size();
    public boolean isEmpty() {
        return size() == 0;
    }
    public boolean contains(Object o) {
        Iterator&lt;E&gt; it = iterator();
        if (o==null) {
            while (it.hasNext())
                if (it.next()==null)
                    return true;
        } else {
            while (it.hasNext())
                if (o.equals(it.next()))
                    return true;
        }
        return false;
    }
    public Object[] toArray() {
        // Estimate size of array; be prepared to see more or fewer elements
        Object[] r = new Object[size()];
        Iterator&lt;E&gt; it = iterator();
        for (int i = 0; i &lt; r.length; i++) {
            if (! it.hasNext()) // fewer elements than expected
                return Arrays.copyOf(r, i);
            r[i] = it.next();
        }
        return it.hasNext() ? finishToArray(r, it) : r;
    }
    public &lt;T&gt; T[] toArray(T[] a) {
        // Estimate size of array; be prepared to see more or fewer elements
        int size = size();
        T[] r = a.length &gt;= size ? a :
                (T[])java.lang.reflect.Array
                        .newInstance(a.getClass().getComponentType(), size);
        Iterator&lt;E&gt; it = iterator();

        for (int i = 0; i &lt; r.length; i++) {
            if (! it.hasNext()) { // fewer elements than expected
                if (a == r) {
                    r[i] = null; // null-terminate
                } else if (a.length &lt; i) {
                    return Arrays.copyOf(r, i);
                } else {
                    System.arraycopy(r, 0, a, 0, i);
                    if (a.length &gt; i) {
                        a[i] = null;
                    }
                }
                return a;
            }
            r[i] = (T)it.next();
        }
        // more elements than expected
        return it.hasNext() ? finishToArray(r, it) : r;
    }
    private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) {
        int len = r.length;
        int i = len;
        while (it.hasNext()) {
            if (i == len) {
                len = ArraysSupport.newLength(len,
                        1,             /* minimum growth */
                        (len &gt;&gt; 1) + 1 /* preferred growth */);
                r = Arrays.copyOf(r, len);
            }
            r[i++] = (T)it.next();
        }
        // trim if overallocated
        return (i == len) ? r : Arrays.copyOf(r, i);
    }
    public boolean add(E e) {
        throw new UnsupportedOperationException();
    }
    public boolean remove(Object o) {
        Iterator&lt;E&gt; it = iterator();
        if (o==null) {
            while (it.hasNext()) {
                if (it.next()==null) {
                    it.remove();
                    return true;
                }
            }
        } else {
            while (it.hasNext()) {
                if (o.equals(it.next())) {
                    it.remove();
                    return true;
                }
            }
        }
        return false;
    }
    public boolean containsAll(Collection&lt;?&gt; c) {
        for (Object e : c)
            if (!contains(e))
                return false;
        return true;
    }
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        boolean modified = false;
        for (E e : c)
            if (add(e))
                modified = true;
        return modified;
    }
    public boolean removeAll(Collection&lt;?&gt; c) {
        Objects.requireNonNull(c);
        boolean modified = false;
        Iterator&lt;?&gt; it = iterator();
        while (it.hasNext()) {
            if (c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }
    public boolean retainAll(Collection&lt;?&gt; c) {
        Objects.requireNonNull(c);
        boolean modified = false;
        Iterator&lt;E&gt; it = iterator();
        while (it.hasNext()) {
            if (!c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }
    public void clear() {
        Iterator&lt;E&gt; it = iterator();
        while (it.hasNext()) {
            it.next();
            it.remove();
        }
    }
    public String toString() {
        Iterator&lt;E&gt; it = iterator();
        if (! it.hasNext())
            return &quot;[]&quot;;
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (;;) {
            E e = it.next();
            sb.append(e == this ? &quot;(this Collection)&quot; : e);
            if (! it.hasNext())
                return sb.append(']').toString();
            sb.append(',').append(' ');
        }
    }

}
</code></pre>
<ol start="2">
<li>解释</li>
</ol>
<ul>
<li>toArray 该方法没有直接返回，目的是为了应对多线程</li>
</ul>
<pre><code class="language-java">public Object[] toArray() {
    // Estimate size of array; be prepared to see more or fewer elements
    Object[] r = new Object[size()];
    Iterator&lt;E&gt; it = iterator();
    for (int i = 0; i &lt; r.length; i++) {
        if (! it.hasNext()) // fewer elements than expected
            return Arrays.copyOf(r, i);
        r[i] = it.next();
    }
    return it.hasNext() ? finishToArray(r, it) : r;
}
</code></pre>
<ul>
<li>为什么不是遍历迭代器？如果有多个线程操作该集合，其中某个线程向集合中添加了元素，此时如果在迭代器的遍历中向数组中添加元素，则会抛出数组越界异常。</li>
<li>为什么返回一个新数组？如果多线程删除了元素，新数组长度更小，节约空间 如果多线程添加了元素，调用 finishToArray</li>
</ul>
<pre><code class="language-java">private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) {
    int len = r.length;
    int i = len;
    while (it.hasNext()) {
        if (i == len) {
            len = ArraysSupport.newLength(len,
                    1,             /* minimum growth */
                    (len &gt;&gt; 1) + 1 /* preferred growth */);
            r = Arrays.copyOf(r, len);
        }
        r[i++] = (T)it.next();
    }
    // trim if overallocated
    return (i == len) ? r : Arrays.copyOf(r, i);
}
</code></pre>
<ul>
<li>该方法每次迭代都会比较当前数组长度与迭代器长度，利用 Array.copyOf 进行扩容 最后返回前再次判断，确保数组容量与实际数据长度相同</li>
</ul>
<h3 id="abstractlist"><a class="header" href="#abstractlist">AbstractList</a></h3>
<ol>
<li>概述</li>
</ol>
<ul>
<li>extend
<ul>
<li>AbstractList 继承自 AbstractCollection 抽象类，实现了 List 接口，</li>
<li>它实现了 List 的一些位置相关操作 (比如 get,set,add,remove)，是第一个实现随机访问方法的集合类，但不支持添加和替换。</li>
<li>AbstractList 内部已经提供了 Iterator, ListIterator 迭代器的实现类，分别为 Itr, ListItr</li>
<li>实现了 SubList 类</li>
</ul>
</li>
<li>super
<ul>
<li>是 ArrayList 和 AbstractSequentiaList 的父类。</li>
<li>提供了一个抽象类 <code>public abstract E get(int index);</code></li>
</ul>
</li>
</ul>
<h4 id="modcount-与-fail-fast"><a class="header" href="#modcount-与-fail-fast">modCount 与 fail-fast</a></h4>
<ul>
<li>modCount 作用是记录集合结构被改变的次数 (添加，删除等等), 目的是为了防止迭代过程中，其他线程，或者自己对集合结构修改，并不只是更改元素内容</li>
<li>fail-fast 机制在迭代器中实现，
fail-fast 机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测 bug。</li>
</ul>
<h4 id="itr-类"><a class="header" href="#itr-类">Itr 类</a></h4>
<ol>
<li>特征变量</li>
</ol>
<ul>
<li>cursor: 是指集合遍历过程中的即将遍历的元素的索引</li>
<li>lastRet: 它主要用于记录刚刚遍历过的元素的索引</li>
<li>expectedModCount: 为集合修改次数 (默认为 0) <code>int expectedModCount = modCount;</code></li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">private class Itr implements Iterator&lt;E&gt; {
        /**
         * Index of element to be returned by subsequent call to next.
         */
        int cursor = 0;

        /**
         * Index of element returned by most recent call to next or
         * previous.  Reset to -1 if this element is deleted by a call
         * to remove.
         */
        int lastRet = -1;

        /**
         * The modCount value that the iterator believes that the backing
         * List should have.  If this expectation is violated, the iterator
         * has detected concurrent modification.
         */
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size();
        }

        public E next() {
            checkForComodification();
            try {
                int i = cursor;
                E next = get(i);
                lastRet = i;
                cursor = i + 1;
                return next;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException(e);
            }
        }

        public void remove() {
            if (lastRet &lt; 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                AbstractList.this.remove(lastRet);
                if (lastRet &lt; cursor)
                    cursor--;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
</code></pre>
<ol start="3">
<li>解释</li>
</ol>
<ul>
<li>iterator 进行 next() 和 remove() 前都需要进行 checkForComodification(), 检查迭代过程中集合结构是否放生改变 ?
抛出 ConcurrentModificationException() : 正常执行</li>
<li>迭代器自身的 next, remove 不会对 modCount 进行修改，集合调用 add 等方法时会修改</li>
</ul>
<h4 id="如何避免-fail-fast"><a class="header" href="#如何避免-fail-fast">如何避免 fail-fast</a></h4>
<ol>
<li>调用 Iterator 自身的 remove() 而不是集合的
Itr.remove() 并不会修改 modCount 的值，并且不会对后面的遍历造成影响，因为该方法 remove 不能指定元素，只能 remove 当前遍历过的那个元素，所以调用该方法并不会发生 fail-fast 现象。该方法有局限性。</li>
<li>使用 java 并发包 (java.util.concurrent) 中的类来代替 ArrayList 和 hashMap。示例</li>
</ol>
<ul>
<li>CopyOnWriterArrayList
CopyOnWriter 是写时复制的容器 (COW)，在读写时是线程安全的。该容器在对 add 和 remove 等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于
CopyOnWriterArrayList 在迭代过程并不会发生 fail-fast 现象。但
CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。</li>
<li>ConcurrentHashMap
ConcurrentHashMap 采用了锁机制，是线程安全的。在迭代方面，ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而不影响原有的数据
，iterator 完成后再将头指针替换为新的数据
，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。即迭代不会发生 fail-fast，但不保证获取的是最新的数据。</li>
</ul>
<h4 id="listitr-类"><a class="header" href="#listitr-类">ListItr 类</a></h4>
<ol>
<li>概述</li>
</ol>
<ul>
<li>ListItr 继承自 Itr 实现了 ListIterator 接口</li>
<li>添加了 previous(返回前一位), add(增加), set(修改) 方法</li>
<li>与 Itr 一样，每次修改前需要检查 modCount 是否一致，修改后再次同步 modCount</li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">private class ListItr extends Itr implements ListIterator&lt;E&gt; {
        ListItr(int index) {
            cursor = index;
        }

        public boolean hasPrevious() {
            return cursor != 0;
        }

        public E previous() {
            checkForComodification();
            try {
                int i = cursor - 1;
                E previous = get(i);
                lastRet = cursor = i;
                return previous;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException(e);
            }
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor-1;
        }

        public void set(E e) {
            if (lastRet &lt; 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                AbstractList.this.set(lastRet, e);
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        public void add(E e) {
            checkForComodification();

            try {
                int i = cursor;
                AbstractList.this.add(i, e);
                lastRet = -1;
                cursor = i + 1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
    }
</code></pre>
<h4 id=""><a class="header" href="#"></a></h4>
<h3 id="arraylist"><a class="header" href="#arraylist">ArrayList</a></h3>
<p>:::warning 注意 ArrayList 不是线程安全的，如果需要，
可以选择使用 Collections.synchronizedList 方法“包装”列表。最好在创建时执行此操作，以防止意外不同步地访问列表 - from Josh
Bloch, Neal Gafter :::</p>
<h4 id="概述"><a class="header" href="#概述">概述</a></h4>
<ol>
<li>创建</li>
</ol>
<pre><code class="language-java">public class ArrayList&lt;E&gt;
    extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
</code></pre>
<ol start="2">
<li>构造函数：</li>
</ol>
<ul>
<li>无参长度默认为 10</li>
<li>指定长度</li>
<li>从另一个 Collection 拷贝</li>
</ul>
<pre><code class="language-java">public ArrayList(Collection&lt;? extends E&gt; c) {
        Object[] a = c.toArray();
        if ((size = a.length) != 0) {
            if (c.getClass() == ArrayList.class) {
                elementData = a;
            } else {
                elementData = Arrays.copyOf(a, size, Object[].class);
            }
        } else {
            // replace with empty array.
            elementData = EMPTY_ELEMENTDATA;
        }
    }
</code></pre>
<h4 id="其他方法"><a class="header" href="#其他方法">其他方法</a></h4>
<ol>
<li>trimToSize(最小化)</li>
</ol>
<ul>
<li>用来最小化实例存储，将容器大小调整为当前元素所占用的容量大小。</li>
</ul>
<pre><code class="language-java">public void trimToSize() {
    modCount++;
    if (size &lt; elementData.length) {
        elementData = (size == 0)
            ? EMPTY_ELEMENTDATA
            : Arrays.copyOf(elementData, size);
    }
}
</code></pre>
<ol start="2">
<li>ensureCapacity(最大化)</li>
</ol>
<ul>
<li>利用 grow(minCapacity) 主动扩容，当需要扩大的容量很大时，能有效提高效率</li>
</ul>
<pre><code class="language-java">public void ensureCapacity(int minCapacity) {
    if (minCapacity &gt; elementData.length
        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
                &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) {
        modCount++;
        grow(minCapacity);
    }
}
</code></pre>
<ol start="3">
<li>addAll</li>
</ol>
<ul>
<li>modCount++</li>
<li>拷贝新集合</li>
<li>判断是否超出原集合剩余容量</li>
<li>System.copy()</li>
</ul>
<ol start="4">
<li>shiftTailOverGap</li>
</ol>
<ul>
<li>将某段元素进行平移</li>
</ul>
<ol start="5">
<li>batchRemove retainAll , removeAll 均通过调用此方法实现</li>
<li>第一次循环，记录原数组中第一次出现的位置</li>
<li>第二次循环</li>
</ol>
<pre><code class="language-java">for (Object e; r &lt; end; r++)
    if (c.contains(e = es[r]) == complement)
        es[w++] = e;
</code></pre>
<ul>
<li>r: 记录遍历到的 index</li>
<li>w: 记录原始数组被覆盖到的 index</li>
<li>这部分的意思是，w 的目的是记录新的内容覆盖掉原有的内容，覆盖的原则是，判断 elementData[r] 是否符合需要，若符合就把他粘到 w 处</li>
<li>最后 finally 执行 shiftTailOverGap，目的是把后面的乱七八糟的后缀</li>
</ul>
<h4 id="核心方法"><a class="header" href="#核心方法">核心方法</a></h4>
<ol>
<li>grow</li>
</ol>
<ul>
<li>不传参 <code>return grow(size + 1);</code></li>
<li>传参</li>
</ul>
<pre><code class="language-java">private Object[] grow(int minCapacity) {
    int oldCapacity = elementData.length;
    if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        int newCapacity = ArraysSupport.newLength(oldCapacity,
                minCapacity - oldCapacity, /* minimum growth */
                oldCapacity &gt;&gt; 1           /* preferred growth */);
        return elementData = Arrays.copyOf(elementData, newCapacity);
    } else {
        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
    }
}
</code></pre>
<ul>
<li>若扩容时没有元素直接阔到 max(10, minCapacity)</li>
<li>若有元素，由于右移运算符的存在，每次扩容并不一定是 minCapacity 的的大小，一般为原大小的 1.5 倍，
具体可以查看 System.newLength 和 System.hugeLength</li>
</ul>
<ol start="2">
<li>
<p>clone() 常规的浅拷贝</p>
</li>
<li>
<p>add(), set(), remove()</p>
<ol>
<li>new ArrayList()
<ul>
<li>调用构造函数创建新的空集合集合</li>
<li>通过 AbstractList 创建 modCount=0</li>
</ul>
</li>
<li>add():
<ul>
<li>modCount++</li>
<li>if elementData.length &gt;= 0 ? 扩容 50% :扩容默认 10 格</li>
<li>elementData[size] = e (size 是已经存入的数据个数)</li>
</ul>
</li>
<li>若集合满了则先调用 grow() 扩容，在赋值</li>
</ol>
</li>
<li>
<p>add(index), remove(index)</p>
</li>
</ol>
<ul>
<li>add(index) 同理，扩容采用 System.arraycopy 在原数组上扩容</li>
<li>若 index 不是最后一个，则需要先用 System.arraycopy 从 index 让后方的数据向后挪一位，空出新的位置用来插入</li>
</ul>
<pre><code class="language-java">System.arraycopy(elementData, index,
                         elementData, index + 1,
                         s - index);
</code></pre>
<ul>
<li>remove(index) 调用了 fastRemove(), 通过 System.arraycopy() 最小化容器，在将指定位置设置为 null</li>
</ul>
<pre><code class="language-java">private void fastRemove(Object[] es, int i) {
    modCount++;
    final int newSize;
    if ((newSize = size - 1) &gt; i)
        System.arraycopy(es, i + 1, es, i, newSize - i);
    es[size = newSize] = null;
}
</code></pre>
<h3 id="待续-5"><a class="header" href="#待续-5">待续...</a></h3>
<h2 id="set"><a class="header" href="#set">Set</a></h2>
<h3 id="set-1"><a class="header" href="#set-1">Set</a></h3>
<h4 id="概述-1"><a class="header" href="#概述-1">概述</a></h4>
<pre><code class="language-java">public interface Set&lt;E&gt; extends Collection&lt;E&gt; {
</code></pre>
<h3 id="abstractset"><a class="header" href="#abstractset">AbstractSet</a></h3>
<h4 id="概述-2"><a class="header" href="#概述-2">概述</a></h4>
<pre><code class="language-java">public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; {
</code></pre>
<ol>
<li>继承自 AbstractCollection，实现了 Set 接口</li>
<li>只重写了 equals(), hashcode(), removeAll() 方法，几乎没变</li>
</ol>
<h3 id="待续-6"><a class="header" href="#待续-6">待续...</a></h3>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<h3 id="接口-map"><a class="header" href="#接口-map">接口 Map</a></h3>
<h3 id="map-1"><a class="header" href="#map-1">Map</a></h3>
<h4 id="基础方法"><a class="header" href="#基础方法">基础方法</a></h4>
<pre><code class="language-java">public interface Map&lt;K, V&gt; {
    int size();
    boolean isEmpty();
    boolean containsKey(Object key);
    boolean containsValue(Object value);
    V get(Object key);
    V put(K key, V value);
    V remove(Object key);
    void putAll(Map&lt;? extends K, ? extends V&gt; m);
    void clear();

    Set&lt;K&gt; keySet();
    Collection&lt;V&gt; values();
    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();

    static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2) {  // 最大支持 10 对
        return new ImmutableCollections.MapN&lt;&gt;(k1, v1, k2, v2);
    }
    default boolean remove(Object key, Object value) { // 允许 key 为 null
        Object curValue = get(key);
        if (!Objects.equals(curValue, value) ||
            (curValue == null &amp;&amp; !containsKey(key))) {
            return false;
        }
        remove(key);
        return true;
    }
</code></pre>
<h4 id="内部-entry-接口"><a class="header" href="#内部-entry-接口">内部 Entry 接口</a></h4>
<pre><code class="language-java">interface Entry&lt;K, V&gt; {
    K getKey();
    V getValue();
    V setValue(V value);
    boolean equals(Object o);
    int hashCode();
    public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey() {
        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());
    }
    public static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue() {}
    public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? super K&gt; cmp) {
        Objects.requireNonNull(cmp);
        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());
    }
    public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? super V&gt; cmp) {}
}
</code></pre>
<h4 id="其他方法-1"><a class="header" href="#其他方法-1">其他方法</a></h4>
<ul>
<li>equal hashcode</li>
<li>3 个 replace 4 个 ifAbsent 1 个 merge</li>
</ul>
<pre><code class="language-java">    boolean equals(Object o);
    int hashCode();
    default V getOrDefault(Object key, V defaultValue) {  // 没有则返回
        V v;
        return (((v = get(key)) != null) || containsKey(key))
            ? v
            : defaultValue;
    }
    default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
        Objects.requireNonNull(action);
        for (Map.Entry&lt;K, V&gt; entry : entrySet()) {
            K k;
            V v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch (IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }
            action.accept(k, v);
        }
    }
    default boolean replace(K key, V oldValue, V newValue) {
        Object curValue = get(key);
        if (!Objects.equals(curValue, oldValue) ||
            (curValue == null &amp;&amp; !containsKey(key))) {
            return false;
        }
        put(key, newValue);
        return true;
    }
    default V replace(K key, V value) {}
    default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {  // function 批量处理
        Objects.requireNonNull(function);
        for (Map.Entry&lt;K, V&gt; entry : entrySet()) {
            K k;
            V v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch (IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }

            // ise thrown from function is not a cme.
            v = function.apply(k, v);

            try {
                entry.setValue(v);
            } catch (IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }
        }
    }
    default V putIfAbsent(K key, V value) {  // 不存在 key 则添加
        V v = get(key);
        if (v == null) {
            v = put(key, value);
        }
        return v;
    }

    // computeIfPresent 同理
    // compute 用 key 和 value 生产新的 value
    default V computeIfAbsent(K key,
            Function&lt;? super K, ? extends V&gt; mappingFunction) {  // 不存在就用方法新建
        Objects.requireNonNull(mappingFunction);
        V v;
        if ((v = get(key)) == null) {
            V newValue;
            if ((newValue = mappingFunction.apply(key)) != null) {
                put(key, newValue);
                return newValue;
            }
        }

        return v;
    }
    default V merge(K key, V value,
        BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        Objects.requireNonNull(value);
        V oldValue = get(key);
        V newValue = (oldValue == null) ? value :
                remappingFunction.apply(oldValue, value);
        if (newValue == null) {
            remove(key);
        } else {
            put(key, newValue);
        }
        return newValue;
    }
</code></pre>
<h3 id="abstractmap"><a class="header" href="#abstractmap">AbstractMap</a></h3>
<h4 id="概述-3"><a class="header" href="#概述-3">概述</a></h4>
<ol>
<li>实现 Map 接口，没有实现 Map.Entry() 接口</li>
<li>有一个抽象方法</li>
</ol>
<pre><code class="language-java">public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();
</code></pre>
<ol start="3">
<li>默认不支持修改</li>
</ol>
<h4 id="enttryset"><a class="header" href="#enttryset">enttrySet()</a></h4>
<pre><code class="language-java">public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();
</code></pre>
<ol>
<li>当我们要实现一个不可变的 Map 时，只需要继承这个类，然后实现 entrySet() 方法，这个方法返回一个保存所有 key-value 映射的
set。通常这个 Set 不支持 add(), remove() 方法，Set 对应的迭代器也不支持 remove() 方法。</li>
<li>如果想要实现一个可变的 Map，我们需要在上述操作外，重写 put() 方法，因为 默认不支持 put 操作：</li>
</ol>
<pre><code class="language-java">public V put(K key, V value) {
    throw new UnsupportedOperationException();
}
</code></pre>
<p>而且 entrySet() 返回的 Set 的迭代器，也得实现 remove() 方法，因为 AbstractMap 中的 删除相关操作都需要调用该迭代器的
remove() 方法。</p>
<h4 id="基础方法-1"><a class="header" href="#基础方法-1">基础方法</a></h4>
<ol>
<li>put() 默认需要重写，否则直接抛异常</li>
<li>其他无非都是 Iterator 遍历</li>
</ol>
<h4 id="三个视图"><a class="header" href="#三个视图">三个视图</a></h4>
<ol>
<li>获取所有键 <code>public Set&lt;K&gt; keySet() {</code></li>
<li>获取所有值 <code>public Collection&lt;V&gt; values() {</code></li>
<li>获取所有键值对 <code>public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</code></li>
</ol>
<h3 id="sortedmap"><a class="header" href="#sortedmap">SortedMap</a></h3>
<pre><code class="language-java">public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; {
</code></pre>
<p>内置方法：</p>
<pre><code class="language-java">Comparator&lt;? super K&gt; comparator();
SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);
SortedMap&lt;K,V&gt; headMap(K toKey);
SortedMap&lt;K,V&gt; tailMap(K fromKey);
K firstKey();
K lastKey();
Set&lt;K&gt; keySet();
Collection&lt;V&gt; values();
Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();
</code></pre>
<h3 id="navigablemap"><a class="header" href="#navigablemap">NavigableMap</a></h3>
<pre><code class="language-java">public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; {
</code></pre>
<p>内置方法：</p>
<pre><code class="language-java">Map.Entry&lt;K,V&gt; lowerEntry(K key);  // 比给定的 entry 小的最大的 entry
K lowerKey(K key);
Map.Entry&lt;K,V&gt; floorEntry(K key);
K floorKey(K key); // &lt;=
Map.Entry&lt;K,V&gt; ceilingEntry(K key);
K ceilingKey(K key);
Map.Entry&lt;K,V&gt; higherEntry(K key);
K higherKey(K key);
Map.Entry&lt;K,V&gt; firstEntry();
Map.Entry&lt;K,V&gt; lastEntry();
Map.Entry&lt;K,V&gt; pollFirstEntry();
Map.Entry&lt;K,V&gt; pollLastEntry();
NavigableMap&lt;K,V&gt; descendingMap();  // reverse order view
NavigableSet&lt;K&gt; navigableKeySet();
NavigableSet&lt;K&gt; descendingKeySet();
NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
                         K toKey,   boolean toInclusive);
NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive);  // less than toKey
NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive);
SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);
SortedMap&lt;K,V&gt; headMap(K toKey);
SortedMap&lt;K,V&gt; tailMap(K fromKey);
</code></pre>
<h3 id="treemap"><a class="header" href="#treemap">TreeMap</a></h3>
<pre><code class="language-java">public class TreeMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable
{
</code></pre>
<h4 id="成员变量"><a class="header" href="#成员变量">成员变量</a></h4>
<pre><code class="language-java">    // maintain the order Or keep keys'order natural
    private final Comparator&lt;? super K&gt; comparator;
    private transient Entry&lt;K,V&gt; root;
    private transient int size = 0;
    private transient int modCount = 0;
static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        K key;
        V value;
        Entry&lt;K,V&gt; left;
        Entry&lt;K,V&gt; right;
        Entry&lt;K,V&gt; parent;
        boolean color = BLACK;
</code></pre>
<h4 id="构造器"><a class="header" href="#构造器">构造器</a></h4>
<p>是否自带 Comparator 是否从其他 Map 复制</p>
<pre><code class="language-java">public TreeMap() {
    comparator = null;
}
public TreeMap(Comparator&lt;? super K&gt; comparator) {
    this.comparator = comparator;
}
public TreeMap(Map&lt;? extends K, ? extends V&gt; m) {
    comparator = null;
    putAll(m);
}
public TreeMap(SortedMap&lt;K, ? extends V&gt; m) {
    comparator = m.comparator();
    try {
        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);
    } catch (java.io.IOException cannotHappen) {
    } catch (ClassNotFoundException cannotHappen) {
    }
}
</code></pre>
<h4 id="put"><a class="header" href="#put">Put</a></h4>
<p>put 就是普通的二叉树插入 若用户指定判断条件，就按照指定的条件判断插入坐枝还是插入右枝 否则使用默认的比较方法
重点是插入后调用了 fixAfterInsertion(e);</p>
<pre><code class="language-java">public V put(K key, V value) {
    Entry&lt;K,V&gt; t = root;
    if (t == null) {
        compare(key, key); // type (and possibly null) check
        root = new Entry&lt;&gt;(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    int cmp;
    Entry&lt;K,V&gt; parent;
    // split comparator and comparable paths
    Comparator&lt;? super K&gt; cpr = comparator;
    if (cpr != null) {
        do {
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    else {
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings(&quot;unchecked&quot;)
            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
    if (cmp &lt; 0)
        parent.left = e;
    else
        parent.right = e;
    fixAfterInsertion(e);
    size++;
    modCount++;
    return null;
}
</code></pre>
<h4 id="fixafterinsertione"><a class="header" href="#fixafterinsertione">fixAfterInsertion(e);</a></h4>
<h4 id="-1"><a class="header" href="#-1"></a></h4>
<h3 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h3>
<pre><code class="language-java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable {
</code></pre>
<h4 id="成员变量-1"><a class="header" href="#成员变量-1">成员变量</a></h4>
<ol>
<li><code>private static final long serialVersionUID = 362498820763181265L;</code>：序列化 ID</li>
<li><code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code>：指定默认初始长度</li>
<li><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>：最大长度</li>
<li><code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>：负载因子</li>
<li><code>static final int TREEIFY_THRESHOLD = 8;</code>：由链表转为红黑树的临界值 1（链表长度&gt;8）</li>
<li><code>static final int UNTREEIFY_THRESHOLD = 6;</code>：由红黑树转为链表的临界值</li>
<li><code>static final int MIN_TREEIFY_CAPACITY = 64;</code>：：由链表转为红黑树的临界值 2（capicity&gt;64）</li>
</ol>
<ul>
<li>loadFactor 值为 0.75 加载因子的选择与 Poisson_distribution 有关
链表 8 号位有值的概率是 0.00000006（理想随机情况下），具体可以查看源码注释
更多的是为了防止用户自己实现了不好的哈希算法时导致链表过长，从而导致查询效率低，而此时转为红黑树更多的是一种保底策略，用来保证极端情况下查询的效率。</li>
<li>刚开始不使用红黑树的原因</li>
</ul>
<p>单个 TreeNode 需要占用的空间大约是普通 Node 的两倍，所以只有当包含足够多的 Nodes 时才会转成 TreeNodes，
而当桶中节点数小于 6 时又会变回普通的链表的形式，以便节省空间，</p>
<ul>
<li>链表转红黑树选择 8 红黑树平均查找长度为 log(n) 链表平均查找长度为 n/2</li>
</ul>
<h4 id="构造器-1"><a class="header" href="#构造器-1">构造器</a></h4>
<ol>
<li>HashMap 提供了 4 种构造器，可以自主选择初始长度和负载因子</li>
<li>若传入的初始长度不是二次幂，java 会自动将用户传入的 initialCapacity 转换为比它大的二进制数，目的是方便在求索引时使用位运算更快取模 :::
tip 注意 虽然创建了新的 table，但是没有将 capicity 进行赋值仍然是零，只将 loadFactor 和 threshold 进行赋值
这点需要在 resize() 中用到 :::</li>
</ol>
<pre><code class="language-java">public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);
    // 不能超过默认最大长度
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    // 负载因子不能小于零
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);
    this.loadFactor = loadFactor;
    // 这里虽然不是用`capicity * loadfactory`为扩容临界值赋值，但是还会在 put 方法里重新修正
    this.threshold = tableSizeFor(initialCapacity);
}
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    // 此时阈值和容量值大小都为 0
}

public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}
</code></pre>
<h4 id="初始长度修正"><a class="header" href="#初始长度修正">初始长度修正</a></h4>
<p>这里使用 5 次右移 + 或运算 一下是举例：</p>
<pre><code>0000 0000 0000 1010 0000 0011 1110 1010  n
0000 0000 0000 0101 0000 0001 1111 0101  n &gt;&gt;&gt; 1
---------------------------------------  |
0000 0000 0000 1111 0000 0011 1111 1111  n
0000 0000 0000 0011 1100 0000 1111 1111  n &gt;&gt;&gt; 2
---------------------------------------  |
0000 0000 0000 1111 1100 0011 1111 1111  n
0000 0000 0000 0000 1111 1100 0011 1111  n &gt;&gt;&gt; 4
---------------------------------------  |
0000 0000 0000 1111 1111 1111 1111 1111  n
0000 0000 0000 0000 0000 1111 1111 1111  n &gt;&gt;&gt; 8
剩下的就不用写了全部被转换成 1，最后在加上 1 就是：
&gt;Returns a power of two size for the given target capacity.
</code></pre>
<pre><code class="language-java">static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre>
<h4 id="链表转红黑树"><a class="header" href="#链表转红黑树">链表转红黑树</a></h4>
<p>若链表长度&gt;8，尝试转为红黑树</p>
<pre><code class="language-java">if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
    treeifyBin(tab, hash);
</code></pre>
<ul>
<li>若检测到 size&lt;64，扩容，不转为红黑树</li>
</ul>
<pre><code class="language-java">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
    int n, index; Node&lt;K,V&gt; e;
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
        resize();
</code></pre>
<p>resize 扩容后所有元素的索引值会重新分配，链表长度会发生变化，更加散列</p>
<ul>
<li>若检测到 size&gt;=64，转为红黑树
<ol>
<li>链表转为 LinkedHashMap（节点转为 TreeNode，加入向前的指针和左右字节点）</li>
</ol>
<pre><code class="language-java">else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
    TreeNode&lt;K,V&gt; hd = null, tl = null;
    do {
        TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
        if (tl == null)
            hd = p;
        else {
            p.prev = tl;
            tl.next = p;
        }
        tl = p;
    } while ((e = e.next) != null);
</code></pre>
<ol start="2">
<li>
<p>把根节点放入桶中，进行平衡</p>
</li>
<li>
<p>待续</p>
</li>
</ol>
</li>
</ul>
<h4 id="扩容_resize"><a class="header" href="#扩容_resize">扩容_resize</a></h4>
<ol>
<li>
<p>确定新容量的大小：</p>
<ul>
<li>若 oldCap &gt; 0(正常情况下扩容)
<pre><code class="language-java">//翻倍或者调为 MAXIMUM_CAPACITY(本身就超过最大值或者翻倍后会超过最大值)
if (oldCap &gt; 0) {
    if (oldCap &gt;= MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return oldTab;
    }
    else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
        newThr = oldThr &lt;&lt; 1; // double threshold
}
</code></pre>
</li>
<li>若 oldThr &gt; 0（初始化下需要扩容，手动选择初始容量）
<pre><code class="language-java">// 确定初始长度
else if (oldThr &gt; 0) // initial capacity was placed in threshold
    newCap = oldThr;
</code></pre>
这里需要说明，在构造器中有如下代码
<pre><code class="language-java">this.threshold = tableSizeFor(initialCapacity);
// tableSizeFor 返回的就是 Capicity，只不过赋值给了 threshold(也就是 oldThr)，在这里 newCap 才被确定
</code></pre>
</li>
<li>若 oldCap == oldThr == 0（初始化下需要扩容，没有手动选择初始容量）按照默认值进行初始化
<pre><code class="language-java">else {               // zero initial threshold signifies using defaults
    newCap = DEFAULT_INITIAL_CAPACITY;
    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>确定新的扩容边界</p>
<pre><code class="language-java">if (newThr == 0) {
    float ft = (float)newCap * loadFactor;
    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                (int)ft : Integer.MAX_VALUE);
}
threshold = newThr;
</code></pre>
</li>
<li>
<p>开辟新的空间，重新排列原来的元素</p>
<ul>
<li>开辟</li>
</ul>
<pre><code class="language-java">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
table = newTab;
</code></pre>
<p>若原数组不为空（不是刚初始化的），循环原 tab</p>
<ul>
<li>用 e 代替 oldTab</li>
</ul>
<pre><code class="language-java">if (oldTab != null) {
    for (int j = 0; j &lt; oldCap; ++j) {
        Node&lt;K,V&gt; e;
        if ((e = oldTab[j]) != null) {
</code></pre>
<ul>
<li>若原 tab 在 j 处不为空
<ol>
<li>清空原 table 在 j 处的占用
<pre><code class="language-java">oldTab[j] = null;
</code></pre>
</li>
<li>重新计算索引
<ul>
<li>若不是链表或红黑树，直接移动</li>
</ul>
<pre><code class="language-java">if (e.next == null)
    newTab[e.hash &amp; (newCap - 1)] = e;
</code></pre>
<ul>
<li>若是红黑树，待续</li>
</ul>
<pre><code class="language-java">else if (e instanceof TreeNode)
    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
</code></pre>
<ul>
<li>若是链表 这里 e.hash &amp; oldCap 直接与二次幂（不是 n-1）做&amp;运算
二次幂低位全为零，与 hash 做与运算后能够得到得到新索引的最高位为是 0 还是 1 (e.hash &amp; oldCap) == 0 =&gt;
确定新索引是原索引还是原索引 +n</li>
</ul>
<pre><code class="language-java">    else { // preserve order
        Node&lt;K,V&gt; loHead = null, loTail = null;
        Node&lt;K,V&gt; hiHead = null, hiTail = null;
        Node&lt;K,V&gt; next;
        do {
            next = e.next;
            // 判断新索引最高为
            if ((e.hash &amp; oldCap) == 0) {
                if (loTail == null)
                    loHead = e;
                else
                    //如果可能会拼接一个新链表
                    loTail.next = e;
                loTail = e;
            }
            else {
                if (hiTail == null)
                    hiHead = e;
                else
                    hiTail.next = e;
                hiTail = e;
            }
        } while ((e = next) != null);
        // 新链表的头节点装入到新桶中
        if (loTail != null) {
            loTail.next = null;
            newTab[j] = loHead;
        }
        if (hiTail != null) {
            hiTail.next = null;
            newTab[j + oldCap] = hiHead;
        }
    }
}
```java
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="扩容后的索引规律"><a class="header" href="#扩容后的索引规律">扩容后的索引规律</a></h4>
<p>假如原数组长度 n = 16</p>
<ol>
<li>hash &amp; (n-1)</li>
</ol>
<pre><code>- key1 与 15
1101 1001 0010 1100 1111 000|0 0101  key1.hashCode()
0000 0000 0000 0000 0000 000|0 1111  n - 1
----------------------------------  &amp;
0000 0000 0000 0000 0000 000|0 0101  5
- key1 与 31
1101 1001 0010 1100 1111 000|0 0101  key1.hashCode()
0000 0000 0000 0000 0000 000|1 1111  n * 2 - 1
----------------------------------  &amp;
0000 0000 0000 0000 0000 000|0 0101  5
- key2 与 15
1101 1001 0010 1100 1111 001|1 0101  key2.hashCode()
0000 0000 0000 0000 0000 000|0 1111  n - 1
----------------------------------  &amp;
0000 0000 0000 0000 0000 000|0 0101  5
- key2 与 31
1101 1001 0010 1100 1111 001|1 0101  key2.hashCode()
0000 0000 0000 0000 0000 000|1 1111  n * 2 - 1
----------------------------------  &amp;
0000 0000 0000 0000 0000 000|1 0101  5 + 16
</code></pre>
<p>由上图可见，新索引位置只能是原索引或者原索引 +n，到底是那种情况只用看新索引高位是 0 还是 1</p>
<ul>
<li>优点：不用真的重新计算新索引位置，只需要计算高位是 0 还是 1 即可确定新索引</li>
</ul>
<ol start="2">
<li>hash &amp; n</li>
</ol>
<ul>
<li>key2 与 16 1101 1001 0010 1100 1111 001|1 0101 key2.hashCode() 0000 0000 0000
0000 0000 000|0 1111 n ---------------------------------- &amp; 0000 0000 0000
0000 0000 000|0 0101 5</li>
<li>key2 与 32 1101 1001 0010 1100 1111 001|1 0101 key2.hashCode() 0000 0000 0000
0000 0000 000|1 0000 n ---------------------------------- &amp; 0000 0000 0000
0000 0000 000|1 0000 得到最高位为 1</li>
</ul>
<h4 id="hash-计算方法"><a class="header" href="#hash-计算方法">hash 计算方法</a></h4>
<p>先调用 key.hashCode()，在于自身高位异或</p>
<pre><code class="language-java">static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p>示例</p>
<pre><code>1101 0111 1010 1111 1000 0110 0001 1011  hash
0000 0000 0000 0000 1101 0111 1010 1111  hash &gt;&gt;&gt; 16
---------------------------------------  ^
1101 0111 1010 1111 0101 0001 1011 0100
</code></pre>
<p>原因：</p>
<ol>
<li>混合高低位信息</li>
<li>确保 hash 不会向 0 或 1 单独靠拢</li>
</ol>
<h4 id="put-1"><a class="header" href="#put-1">put</a></h4>
<ul>
<li>
<p>put 调用 putVal 实现</p>
<pre><code class="language-java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
</code></pre>
</li>
<li>
<p>方法参数</p>
<ol>
<li>boolean onlyIfAbsent：只有不存在才添加（即不修改原数据）</li>
<li>boolean evict：如果为 false 表示为创建状态</li>
</ol>
</li>
<li>
<p>具体实现</p>
</li>
</ul>
<ol>
<li>如果 table == null，resize 新建数组</li>
</ol>
<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
</code></pre>
<ol start="2">
<li>插入/或记录被修改 value 的节点 e
<ul>
<li>若索引位置为空，直接插入</li>
</ul>
<pre><code class="language-java">if ((p = tab[i = (n - 1) &amp; hash]) == null)
    tab[i] = newNode(hash, key, value, null);
else {
</code></pre>
<ul>
<li>若不为空，且 key 相同，e 就是当前节点</li>
</ul>
<pre><code class="language-java">Node&lt;K,V&gt; e; K k;
if (p.hash == hash &amp;&amp;
    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
    e = p;
</code></pre>
<ul>
<li>若不为空，但是为红黑树，按照红黑树插入</li>
</ul>
<pre><code class="language-java">else if (p instanceof TreeNode)
    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
</code></pre>
<ul>
<li>若不为空但是为链表 找到相同节点就记录 e 没找到就尾插新结点，并判断是否转为红黑树</li>
</ul>
<pre><code class="language-java">else {
    for (int binCount = 0; ; ++binCount) {
        if ((e = p.next) == null) {
            p.next = newNode(hash, key, value, null);
            if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                treeifyBin(tab, hash);
            break;
        }
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
            break;
        p = e;
    }
}
</code></pre>
</li>
<li>如果上一步没有插入新结点而是准备覆盖 value，就在这一步覆盖</li>
</ol>
<pre><code class="language-java">    if (e != null) { // existing mapping for key
        V oldValue = e.value;
        if (!onlyIfAbsent || oldValue == null)
            e.value = value;
        afterNodeAccess(e);
        return oldValue;
    }
}
</code></pre>
<ol start="4">
<li>fastfail 检验，扩容检验</li>
</ol>
<pre><code class="language-java">    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict); // 空函数，不知道有啥用
    return null;
}
</code></pre>
<h4 id="remove"><a class="header" href="#remove">remove</a></h4>
<ol>
<li>判断 table 是否为空，table 是否存有元素，要找的索引位置是否有值</li>
</ol>
<pre><code class="language-java">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (p = tab[index = (n - 1) &amp; hash]) != null) {
</code></pre>
<ol start="2">
<li>找到待删除节点 node 记录
<ul>
<li>index 处就是所找节点
<pre><code class="language-java">Node&lt;K,V&gt; node = null, e; K k; V v;
if (p.hash == hash &amp;&amp;
    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
    node = p;
</code></pre>
</li>
<li>是红黑树，按照红黑树的方式查找
<pre><code class="language-java">else if ((e = p.next) != null) {
    if (p instanceof TreeNode)
        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
</code></pre>
</li>
<li>是链表，按照链表方式查找
<pre><code class="language-java">    else {
        do {
            if (e.hash == hash &amp;&amp;
                ((k = e.key) == key ||
                    (key != null &amp;&amp; key.equals(k)))) {
                node = e;
                break;
            }
            p = e;
        } while ((e = e.next) != null);
    }
}
</code></pre>
</li>
</ul>
</li>
<li>删除节点，处理后事</li>
</ol>
<pre><code class="language-java">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                                (value != null &amp;&amp; value.equals(v)))) {
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
</code></pre>
<h4 id="待续-7"><a class="header" href="#待续-7">待续...</a></h4>
<h3 id="待续-8"><a class="header" href="#待续-8">待续...</a></h3>
<h2 id="标记接口"><a class="header" href="#标记接口">标记接口</a></h2>
<h3 id="序列化"><a class="header" href="#序列化">序列化</a></h3>
<h4 id="serializable-接口"><a class="header" href="#serializable-接口">Serializable 接口</a></h4>
<ul>
<li>序列化就是将对象转换为字节序列的过程，反序列化就是把持久化的字节文件数据恢复为对象的过程。</li>
<li>对于 JVM 来说，要进行持久化的类必须要有一个标记，只有持有这个标记 JVM 才允许类创建的对象可以通过其 IO 系统转换为字节数据，从而实现持久化，而这个标记就是 Serializable 接口。</li>
<li>而在反序列化的过程中则需要使用 serialVersionUID 来确定由那个类来加载这个对象，所以我们在实现 Serializable 接口的时候，一般还会要去尽量显示地定义 serialVersionUID</li>
</ul>
<pre><code class="language-java">public class MySerializable {
    public static void main(String[] args) {
        write();
        read();
    }

    public static void write() {
        Student student = new Student(1, &quot;zhangsan&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;src/resources/student.txt&quot;));
        objectOutputStream.writeObject(student);
    }

    public static void read() {
        ObjectInputStream objectInputStream = null;
        objectInputStream = new ObjectInputStream(new FileInputStream(&quot;src/resources/student.txt&quot;));
        Student student = (Student) objectInputStream.readObject();
    }
}
@Data
@AllArgsConstructor
class Student implements Serializable {
    private int id;
    private String name;
}
</code></pre>
<blockquote>
<p>如果我们在序列化中没有显示地声明 serialVersionUID，则序列化运行时将会根据该类的各个方面计算该类默认的 serialVersionUID 值。&gt;但是，Java 官方强烈建议所有要序列化的类都显示地声明 serialVersionUID 字段，因为如果高度依赖于 JVM 默认生成 serialVersionUID，可&gt;能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的 InvalidClassException 异常。因此，为了保证跨不？&gt;同 Java 编译器实现的 serialVersionUID 值的一致，实现 Serializable 接口的必须显示地声明 serialVersionUID 字段。<br/></p>
</blockquote>
<blockquote>
<p>此外 serialVersionUID 字段地声明要尽可能使用 private 关键字修饰，这是因为该字段的声明只适用于声明的类，该字段作为成员变量被子&gt;类继承是没有用处的！有个特殊的地方需要注意的是，数组类是不能显示地声明 serialVersionUID 的，因为它们始终具有默认计算的值，不过&gt;数组类反序列化过程中也是放弃了匹配 serialVersionUID 值的要求。</p>
</blockquote>
<h4 id="transient"><a class="header" href="#transient">transient</a></h4>
<ul>
<li>在实现 Serializable 接口后可以用该关键字修饰，让这个属性不序列化</li>
<li>但是用 static 修饰后，一定不会被序列化</li>
<li>若选择实现 Externalizable 接口，则属性是否进行序列化需要手动指定，与是否有 transient 关键字无关</li>
</ul>
<h3 id="randomaccess"><a class="header" href="#randomaccess">RandomAccess</a></h3>
<ol>
<li>概述 RandomAccess 是一个空的接口，它用来标识某个类是否支持
随机访问（随机访问，相对比“按顺序访问”）。一个支持随机访问的类明显可以使用更加高效的算法。</li>
</ol>
<pre><code class="language-java">public interface RandomAccess {
}
</code></pre>
<ul>
<li>List 中支持随机访问最佳的例子就是 ArrayList，它的数据结构使得 get(), set(), add() 等方法的时间复杂度都是 O(1);</li>
<li>反例就是 LinkedList，链表结构使得它不支持随机访问，只能按序访问，因此在一些操作上性能略逊一筹。</li>
</ul>
<ol start="2">
<li>例子</li>
</ol>
<ul>
<li>通常在操作一个 List 对象时，通常会判断是否支持 随机访问，也就是* 是否为 RandomAccess 的实例*，从而使用不同的算法。比如遍历，实现了
RandomAccess 的集合使用 get():</li>
</ul>
<pre><code class="language-java">for (int i=0, n=list.size(); i &amp;lt; n; i++)
          list.get(i);
</code></pre>
<p>比用迭代器更快：</p>
<pre><code class="language-java">for (Iterator i=list.iterator(); i.hasNext(); )
    i.next();
</code></pre>
<blockquote>
<p>实现了 RandomAccess 接口的类有：ArrayList, AttributeList, CopyOnWriteArrayList,
Vector, Stack 等。</p>
</blockquote>
<h3 id="cloneable"><a class="header" href="#cloneable">Cloneable</a></h3>
<h4 id="浅拷贝"><a class="header" href="#浅拷贝">浅拷贝</a></h4>
<ol>
<li>概述 实现了 Cloneable 接口的对象能进行克隆，Object 实现了先拷贝</li>
</ol>
<pre><code class="language-java">public interface Cloneable {
}
</code></pre>
<p>clon 方法再 Object 类中定义</p>
<pre><code class="language-java">protected native Object clone() throws CloneNotSupportedException;
</code></pre>
<ol start="2">
<li>引例</li>
</ol>
<ul>
<li>这里先定义一个学生</li>
</ul>
<pre><code class="language-java">@Data
@AllArgsConstructor
class Student implements Cloneable{
    String name;
    Address address;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>
<ul>
<li>student2 由 student 浅拷贝得到</li>
</ul>
<pre><code class="language-java">Student student = new Student(&quot;a&quot;, address1);
Student student2 = (Student) student.clone();
</code></pre>
<ul>
<li>student == student2 =&gt; False</li>
<li>student.address == student2.address =&gt; True 两人的地址不同，但是“地址”所指向的地址相同</li>
</ul>
<h4 id="深拷贝"><a class="header" href="#深拷贝">深拷贝</a></h4>
<ol>
<li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法；</li>
</ol>
<ul>
<li>
<p>在上面的例子中想要实现 address 也不相同可以在重写 clone() 加上
<code>stu.addr = (Address)addr.clone();   //深度复制</code></p>
</li>
<li>
<p>缺点：
如果引用类型里面还包含很多引用类型，或者内层引用类型的类里面又包含引用类型，使用 clone 方法就会很麻烦。这时我们可以用序列化的方式来实现对象的深克隆。</p>
</li>
</ul>
<ol start="2">
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li>
</ol>
<ul>
<li>
<p>手动写新的 clone 方法</p>
</li>
<li>
<p>缺点：需要对象及对象所有的对象属性都实现序列化</p>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-java">public class DeepClone {
    public static void main(String[] args) {
        Inner inner = new Inner();
        Outer outer = new Outer(inner);
        Outer outer1 = outer.myClone();
        System.out.println(outer.inner == outer1.inner); // False
    }
}

@AllArgsConstructor
class Outer implements Serializable {
    private static final long serialVersionUID = 369285298572941L;  //最好是显式声明 ID
    public Inner inner;
    public Outer myClone() {
        Outer outer = null;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(this);
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        outer = (Outer) ois.readObject();
        return outer;
    }
}

class Inner implements Serializable {
    private static final long serialVersionUID = 872390113109L; //最好是显式声明 ID
}
</code></pre>
<p>::: tip 注意
注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用 Object 类的 clone 方法克隆对象。让问题在编译的时候暴露出来总是优于把问题留到运行时。
:::</p>
<h3 id="待续-9"><a class="header" href="#待续-9">待续...</a></h3>
<h2 id="函数式接口"><a class="header" href="#函数式接口">函数式接口</a></h2>
<h3 id="概述-4"><a class="header" href="#概述-4">概述</a></h3>
<p><code>@FunctionalInterface</code></p>
<ol>
<li>特征</li>
</ol>
<ul>
<li>该注解只能标记在&quot;有且仅有一个抽象方法&quot;的接口上。</li>
<li>JDK8 接口中的静态方法和默认方法，都不算是抽象方法。</li>
<li>接口默认继承 java.lang.Object，所以如果接口显示声明覆盖了 Object 中方法，那么也不算抽象方法。</li>
<li>该注解不是必须的，如果一个接口符合&quot;函数式接口&quot;定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了 @FunctionInterface，那么编译器会报错。</li>
</ul>
<ol start="2">
<li>示例</li>
</ol>
<pre><code class="language-java">// 正确的函数式接口
@FunctionalInterface
public interface TestInterface {

    // 抽象方法
    public void sub();

    // java.lang.Object 中的方法不是抽象方法
    public boolean equals(Object var1);

    // default 不是抽象方法
    public default void defaultMethod(){}

    // static 不是抽象方法
    public static void staticMethod(){}
}
</code></pre>
<h3 id="consumer"><a class="header" href="#consumer">Consumer</a></h3>
<h4 id="consumer-1"><a class="header" href="#consumer-1">Consumer</a></h4>
<ol>
<li>定义</li>
</ol>
<ul>
<li>它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定</li>
<li>泛型指定什么类型，就可以使用 accept 方法消费什么类型的数据</li>
<li>至于具体怎么消费 (使用)，需要自定义</li>
</ul>
<pre><code class="language-java">@FunctionalInterface
public interface Consumer&lt;T&gt; {

    void accept(T t);

    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&gt; { accept(t); after.accept(t); };
    }
}
</code></pre>
<h4 id="bicomsumer"><a class="header" href="#bicomsumer">BiComsumer</a></h4>
<p>与 Consumer 类似</p>
<pre><code class="language-java">@FunctionalInterface
public interface BiConsumer&lt;T, U&gt; {
    void accept(T t, U u);
default BiConsumer&lt;T, U&gt; andThen(BiConsumer&lt;? super T, ? super U&gt; after) {
    Objects.requireNonNull(after);
    return (l, r) -&gt; {
        accept(l, r);
        after.accept(l, r);
    };
}
</code></pre>
<ol start="2">
<li>示例 Iterable 接口，用法和 Thread 类似</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;1&quot;);
    list.add(&quot;1&quot;);
    Consumer consumer = new Consumer() {
        @Override
        public void accept(Object o) {
            System.out.println(o);
        }
    };
    list.forEach(consumer);
}
</code></pre>
<h3 id="predicate"><a class="header" href="#predicate">Predicate</a></h3>
<ol>
<li>特性</li>
</ol>
<ul>
<li>JDK8 提供的函数式接口</li>
<li>提供一个抽象方法 test，接受一个参数，根据这个参数进行一些判断，返回判断结果 true / false</li>
<li>提供几个默认的 default 方法，and, or, negate 用于进行组合判断</li>
<li>在流中被广泛使用</li>
</ul>
<ol start="2">
<li>定义</li>
</ol>
<pre><code class="language-java">@FunctionalInterface
public interface MyPredict&lt;T&gt; {
    // jdk 1.8

    boolean test(T t);

    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) {
        Objects.requireNonNull(other);
        return (t) -&gt; test(t) &amp;&amp; other.test(t);
    }
    default Predicate&lt;T&gt; negate() {
        return (t) -&gt; !test(t);
    }
    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) {
        Objects.requireNonNull(other);
        return (t) -&gt; test(t) || other.test(t);
    }
    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) {
        return (null == targetRef)
                ? Objects::isNull
                : object -&gt; targetRef.equals(object);
    }
    // jdk 11
    static &lt;T&gt; Predicate&lt;T&gt; not(Predicate&lt;? super T&gt; target) {
        Objects.requireNonNull(target);
        return (Predicate&lt;T&gt;)target.negate();
    }
}
</code></pre>
<ol start="3">
<li>示例</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
    Predicate predicate = &quot;Yes&quot;::equals;   // lambda 表达式
    Predicate predicate2 = o -&gt; !&quot;No&quot;.equals(o);
    System.out.println(predicate.test(&quot;Yes&quot;));
    System.out.println(predicate.and(predicate2).test(&quot;Yes&quot;));;
}
</code></pre>
<h3 id="function"><a class="header" href="#function">Function</a></h3>
<h4 id="function-1"><a class="header" href="#function-1">Function</a></h4>
<ol>
<li>特性 Function 接口的主要作用是将一个给定的对象进行加工，然后返回加工后的对象，这个加工可以是任何操作。</li>
<li>定义</li>
</ol>
<pre><code class="language-java">public interface MyFunction&lt;T, R&gt; {
    R apply(T t);

    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {
        Objects.requireNonNull(before);
        return (V v) -&gt; apply(before.apply(v));
    }

    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&gt; after.apply(apply(t));
    }

    static &lt;T&gt; Function&lt;T, T&gt; identity() {
        return t -&gt; t;
    }

}
</code></pre>
<ol start="3">
<li>示例</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
    Function&lt;String, Integer&gt; f1 = (t) -&gt; Integer.valueOf(t) * 10;
    System.out.println(f1.apply(&quot;3&quot;));
    // 返回自己
    System.out.println(Function.identity().apply(&quot;3&quot;));
    // apply 后执行
    System.out.println(f1.andThen((r) -&gt; String.valueOf(r) + &quot;.....&quot;).apply(&quot;4&quot;));
    // apply 前执行
    System.out.println(f1.compose((String r) -&gt; r.substring(1)).apply(&quot;a5&quot;));
}
</code></pre>
<h4 id="bifunction"><a class="header" href="#bifunction">BiFunction</a></h4>
<pre><code class="language-java">@FunctionalInterface
public interface BiFunction&lt;T, U, R&gt; {
    R apply(T t, U u);
    default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
        Objects.requireNonNull(after);
        return (T t, U u) -&gt; after.apply(apply(t, u));
    }
</code></pre>
<h3 id="unaryoperator"><a class="header" href="#unaryoperator">UnaryOperator</a></h3>
<ol>
<li>定义</li>
</ol>
<pre><code class="language-java">@FunctionalInterface
public interface MyUnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; {
    static &lt;T&gt; UnaryOperator&lt;T&gt; identity() {
        return t -&gt; t;
    }
}
`
</code></pre>
<ol start="2">
<li>示例</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
    UnaryOperator&lt;Integer&gt; unaryOperator = x -&gt; x + 1;
    System.out.println(unaryOperator.apply(10)); // 11
    UnaryOperator&lt;String&gt; unaryOperator1 = x -&gt; x + 1;
    System.out.println(unaryOperator1.apply(&quot;aa&quot;)); // aa1
}
</code></pre>
<h3 id="compare"><a class="header" href="#compare">Compare</a></h3>
<h4 id="comparable"><a class="header" href="#comparable">Comparable</a></h4>
<ul>
<li>Comparable 是排序接口。</li>
<li>若一个类实现了 Comparable 接口，就意味着“该类支持排序”。</li>
</ul>
<pre><code class="language-java">public interface Comparable&lt;T&gt; {
        public int compareTo(T o);
}
</code></pre>
<h4 id="comparator"><a class="header" href="#comparator">Comparator</a></h4>
<h5 id="源码"><a class="header" href="#源码">源码</a></h5>
<pre><code class="language-java">@FunctionalInterface
public interface MyComparator&lt;T&gt; {

    // jdk 1.2
    int compare(T o1, T o2);
    boolean equals(Object obj);

    // jdk 1.8
    //default Comparator&lt;T&gt; reversed() {
    //    return Collections.reverseOrder(this);
    //}

    default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) {
        Objects.requireNonNull(other);
        return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; {
            int res = compare(c1, c2);
            return (res != 0) ? res : other.compare(c1, c2);
        };
    }
    default &lt;U&gt; Comparator&lt;T&gt; thenComparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor,
            Comparator&lt;? super U&gt; keyComparator)
    {
        return thenComparing(comparing(keyExtractor, keyComparator));
    }
    default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor)
    {
        return thenComparing(comparing(keyExtractor));
    }

    default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) {
        return thenComparing(comparingInt(keyExtractor));
    }
    default Comparator&lt;T&gt; thenComparingLong(ToLongFunction&lt;? super T&gt; keyExtractor) {
        return thenComparing(comparingLong(keyExtractor));
    }
    default Comparator&lt;T&gt; thenComparingDouble(ToDoubleFunction&lt;? super T&gt; keyExtractor) {
        return thenComparing(comparingDouble(keyExtractor));
    }

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder() {
        return Collections.reverseOrder();
    }
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalOrder() {
        return (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;
    }
    public static &lt;T&gt; Comparator&lt;T&gt; nullsFirst(Comparator&lt;? super T&gt; comparator) {
        return new Comparators.NullComparator&lt;&gt;(true, comparator);
    }
    public static &lt;T&gt; Comparator&lt;T&gt; nullsLast(Comparator&lt;? super T&gt; comparator) {
        return new Comparators.NullComparator&lt;&gt;(false, comparator);
    }
    public static &lt;T, U&gt; Comparator&lt;T&gt; comparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor,
            Comparator&lt;? super U&gt; keyComparator)
    {
        Objects.requireNonNull(keyExtractor);
        Objects.requireNonNull(keyComparator);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1),
                        keyExtractor.apply(c2));
    }
    public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor)
    {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
    }
    public static &lt;T&gt; Comparator&lt;T&gt; comparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));
    }
    public static &lt;T&gt; Comparator&lt;T&gt; comparingLong(ToLongFunction&lt;? super T&gt; keyExtractor) {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; Long.compare(keyExtractor.applyAsLong(c1), keyExtractor.applyAsLong(c2));
    }
    public static&lt;T&gt; Comparator&lt;T&gt; comparingDouble(ToDoubleFunction&lt;? super T&gt; keyExtractor) {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; Double.compare(keyExtractor.applyAsDouble(c1), keyExtractor.applyAsDouble(c2));
    }
}
</code></pre>
<h5 id="方法解释"><a class="header" href="#方法解释">方法解释</a></h5>
<ol>
<li>thenComparing</li>
</ol>
<ul>
<li>&amp;是 java8 新语法</li>
</ul>
<pre><code class="language-java">// (Comparator&lt;T&gt; &amp; Serializable) == (Comparator&lt;T&gt;) (Serializable)
default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) {
    Objects.requireNonNull(other);
    return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; {
        int res = compare(c1, c2);
        return (res != 0) ? res : other.compare(c1, c2);
    };
}
</code></pre>
<ul>
<li>示例</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) {
    Comparator comparator = new Comparator() {
        @Override
        public int compare(Object o1, Object o2) {
            return (o1 != o2) ? 1 : 0;
        }
    };
    System.out.println(comparator.compare(&quot;111&quot;, &quot;111&quot;));
    System.out.println(comparator.thenComparing((o1, o2) -&gt; (o1 == o2) ? 1 : 0).compare(&quot;111&quot;, &quot;111&quot;));
}
</code></pre>
<ol start="2">
<li>comparing</li>
</ol>
<ul>
<li>利用 Function 先处理再比较</li>
</ul>
<pre><code class="language-java">public static &lt;T, U&gt; Comparator&lt;T&gt; comparing(   Function&lt;? super T, ? extends U&gt; keyExtractor,
                                                Comparator&lt;? super U&gt; keyComparator) {
        Objects.requireNonNull(keyExtractor);
        Objects.requireNonNull(keyComparator);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1),
                        keyExtractor.apply(c2));
    }
</code></pre>
<ol start="3">
<li>reverseOrder</li>
</ol>
<ul>
<li>利用 Collections 实现</li>
</ul>
<pre><code class="language-java">public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder() {
    return Collections.reverseOrder();
}
</code></pre>
<h3 id="待续-10"><a class="header" href="#待续-10">待续...</a></h3>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<h3 id="object"><a class="header" href="#object">Object</a></h3>
<ol>
<li>概述</li>
</ol>
<ul>
<li>@HotSpotIntrinsicCandidate</li>
<li>自 JDK 9 引入</li>
<li>作用：
被 @HotSpotIntrinsicCandidate 标注的方法，在 HotSpot 中都有一套高效的实现，该高效实现基于 CPU 指令，运行时，HotSpot 维护的高效实现会替代 JDK 的源码实现，从而获得更高的效率。</li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">public class MyObject {
    //@HotSpotIntrinsicCandidate
    public Object() {}
    //@HotSpotIntrinsicCandidate
    public final native Class&lt;?&gt; getClass();
    @HotSpotIntrinsicCandidate
    public native int hashCode();
    public boolean equals(Object obj) {
        return (this == obj);
    }
    @HotSpotIntrinsicCandidate
    protected native Object clone() throws CloneNotSupportedException;
    public String toString() {
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    }
    @HotSpotIntrinsicCandidate
    public final native void notify();
    @HotSpotIntrinsicCandidate
    public final native void notifyAll();
    public final void wait() throws InterruptedException {
        wait(0L);
    }
    public final native void wait(long timeoutMillis) throws InterruptedException;
    public final void wait(long timeoutMillis, int nanos) throws InterruptedException {
        if (timeoutMillis &lt; 0) {
            throw new IllegalArgumentException(&quot;timeoutMillis value is negative&quot;);
        }
        if (nanos &lt; 0 || nanos &gt; 999999) {
            throw new IllegalArgumentException(
                    &quot;nanosecond timeout value out of range&quot;);
        }
        if (nanos &gt; 0 &amp;&amp; timeoutMillis &lt; Long.MAX_VALUE) {
            timeoutMillis++;
        }
        wait(timeoutMillis);
    }
    @Deprecated(since=&quot;9&quot;)
    protected void finalize() throws Throwable { }
}
</code></pre>
<h2 id="待续-11"><a class="header" href="#待续-11">待续...</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-2"><a class="header" href="#java-2">java</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frontend"><a class="header" href="#frontend">frontend</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现一个-mini-bundle"><a class="header" href="#实现一个-mini-bundle">实现一个 mini-bundle</a></h1>
<pre><code class="language-js">const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const babylon = require(&quot;babylon&quot;);
const traverse = require(&quot;babel-traverse&quot;).default;
const babel = require(&quot;babel-core&quot;);

let ID = 0;

// 根据文件名，拿到该文件的信息，包括 id，code(转换后的), requirements
function createAsset(filename) {
  // 通过 fs 引入入口文件
  const content = fs.readFileSync(filename, &quot;utf8&quot;);

  // 解析出语法树
  const ast = babylon.parse(content, {
    sourceType: &quot;module&quot;,
  });

  // 拿到所有的 import 依赖
  const dependencies = [];

  traverse(ast, {
    ImportDeclaration: (({ node }) =&gt; {
      dependencies.push(node.source.value);
    }),
  });

  const id = ID++;

  const code = babel.transformFromAst(ast, null, {
    // presets 告诉 babel 转换的方法
    // env 指 babel-preset-env 插件，确保转换的代码能够在所有浏览器上运行
    presets: [&quot;env&quot;],
  });

  return {
    id,
    filename,
    dependencies,
    code,
  };
}

// 创建一个 Array，里面是所有的依赖，每一个 Node 用 mapping 保存依赖之间的关系
function createGraph(entry) {
  // 通过入口文件开始，拿到所有文件
  const mainAsset = createAsset(entry);

  // 保存所有的依赖
  const queue = [mainAsset];

  for (const asset of queue) {
    const dirname = path.dirname(asset.filename);

    asset.mapping = {};

    asset.dependencies.forEach((relativePath) =&gt; {
      const absolutePath = path.join(dirname, relativePath);

      const child = createAsset(absolutePath);

      // 每个 Node 用一个 map 存储他依赖的对象
      asset.mapping[relativePath] = child.id;

      queue.push(child);
    });
  }

  return queue;
}

function bundle(graph) {
  // 构造参数（超大的）
  // 参数整体是一个 Object，下面拼接了 Object 里的所有键值对，如下：
  // id: [code, mapping]
  // code 最外层还套上了一个 function
  let modules = ``;

  graph.forEach((mod) =&gt; {
    modules += `${mod.id}: [
            function(require, module, exports) {
                ${mod.code.code}
            },
            ${JSON.stringify(mod.mapping)}
        ],`;
  });

  const result = `
        // 最外面是一层自调用函数，传入了上面构造的参数
        (function(modules) {
            // 通过文件的 id，
            function require(id) {
                // 通过文件获得文件的函数和依赖 map
                const [fn, mapping] = modules[id];
                // 通过依赖的 id，在 mapping 中找到对应的文件名，接着直接调用 require
                function localRequire(relativePath) {
                    return require(mapping[relativePath]);
                }
                // 保存 export
                const module = { exports: {} };
                // 调用函数
                fn(localRequire, module, module.exports);
                return module.exports;
            }
            // 从入口文件开始
            require(0)
        })({${modules}});
    `;

  return result;
}

const graph = createGraph(&quot;./example/entry.js&quot;);
console.log(graph);
const result = bundle(graph);
console.log(result);

fs.writeFileSync(&quot;./app.js&quot;, result.toString());
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="js-进阶"><a class="header" href="#js-进阶">JS 进阶</a></h1>
<h2 id="1-objectdefineproperty"><a class="header" href="#1-objectdefineproperty">1. Object.defineProperty</a></h2>
<pre><code class="language-js">Object.defineProperty(obj, prop, description)

obj
  要定义属性的对象。
prop
  要定义或修改的属性的名称或 Symbol 。
descriptor
  要定义或修改的属性描述符。
</code></pre>
<p>该函数能够精确的定义一个对象上某个属性的描述符 属性描述符分为数据描述符和存取描述符，判断是什么描述符需要看这个描述符中拥有的键值 如果一个描述符不具有
value、writable、get 和 set 中的任意一个键，那么它将被认为是一个数据描述符。如果一个描述符同时拥有 value 或 writable 和
get 或 set 键，则会产生一个异常。</p>
<p>下面是描述符可选的键值</p>
<ol>
<li><strong>通用键值</strong></li>
</ol>
<ul>
<li>configurable 当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。
默认为 false。</li>
<li>enumerable 当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。默认为 false。</li>
</ul>
<ol start="2">
<li><strong>数据描述符</strong>还具有以下可选键值：</li>
</ol>
<ul>
<li>value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</li>
<li>writable 当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符 (en-US) 改变。
默认为 false。</li>
</ul>
<ol start="3">
<li><strong>存取描述符</strong>还具有以下可选键值：</li>
</ol>
<ul>
<li>get 属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入
this 对象（由于继承关系，这里的 this 并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。默认为 undefined。</li>
<li>set 属性的 setter 函数，如果没有 setter，则为
undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined。</li>
</ul>
<h2 id="2-new-proxytarget-handler"><a class="header" href="#2-new-proxytarget-handler">2. new Proxy(target, handler)</a></h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN-Proxy</a></p>
<h3 id="21-基本概念"><a class="header" href="#21-基本概念">2.1 基本概念</a></h3>
<p>创建代理对象实现对对象操作时的拦截和自定义</p>
<ul>
<li>handler (en-US) 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</li>
<li>traps handler 对象拥有的 traps（捕获器）</li>
<li>target 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li>
</ul>
<h3 id="22-标准的-traps"><a class="header" href="#22-标准的-traps">2.2 标准的 traps</a></h3>
<p>下面列出了一些常用的捕获器</p>
<ul>
<li>handler.getPrototypeOf() Object.getPrototypeOf 方法的捕捉器。</li>
<li>handler.setPrototypeOf() Object.setPrototypeOf 方法的捕捉器。</li>
<li>handler.isExtensible() Object.isExtensible 方法的捕捉器。</li>
<li>handler.preventExtensions() Object.preventExtensions 方法的捕捉器。</li>
<li>handler.getOwnPropertyDescriptor() Object.getOwnPropertyDescriptor 方法的捕捉器。</li>
<li>handler.defineProperty() Object.defineProperty 方法的捕捉器。</li>
<li>handler.has() in 操作符的捕捉器。</li>
<li>handler.get() 属性读取操作的捕捉器。</li>
<li>handler.set() 属性设置操作的捕捉器。</li>
<li>handler.deleteProperty() delete 操作符的捕捉器。</li>
<li>handler.ownKeys() Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols
方法的捕捉器。</li>
<li>handler.apply() 函数调用操作的捕捉器。</li>
<li>handler.construct() new 操作符的捕捉器。</li>
</ul>
<h3 id="23-get-set"><a class="header" href="#23-get-set">2.3 get set</a></h3>
<p>下面是一个使用 get 捕获器进行变量打印的例子</p>
<pre><code class="language-js">let target = {
  id: 1,
  name: &quot;小明&quot;,
};

const handler = {
  get: function (target, property, reveiver) {
    console.log(&quot;target: &quot;, target);
    console.log(&quot;property: &quot;, property);
    console.log(&quot;reveiver: &quot;, reveiver);
    return target[property];
  },
};

let proxyTarget = new Proxy(target, handler);

console.log(proxyTarget.id);

Object.defineProperty(proxyTarget, &quot;id&quot;, {
  get: undefined,
});

console.log(&quot;id&quot;, proxyTarget.id);
console.log(&quot;name:&quot;, proxyTarget.name);

console.log(&quot;target&quot;, target);
console.log(&quot;proxyTarget&quot;, proxyTarget);
</code></pre>
<h3 id="24-代理转发"><a class="header" href="#24-代理转发">2.4 代理转发</a></h3>
<p>下面对 proxy 的修改被正确转发到 target 上</p>
<pre><code class="language-js">let target = {};
let p = new Proxy(target, {});

p.a = 37; // 操作转发到目标

console.log(target.a); // 37. 操作已经被正确地转发
</code></pre>
<p>set trap 可以进行值修正及附加属性 比如</p>
<pre><code class="language-js">let products = new Proxy({
  browsers: [&quot;Internet Explorer&quot;, &quot;Netscape&quot;],
}, {
  get: function (obj, prop) {
    // 附加一个属性
    if (prop === &quot;latestBrowser&quot;) {
      return obj.browsers[obj.browsers.length - 1];
    }

    // 默认行为是返回属性值
    return obj[prop];
  },
  set: function (obj, prop, value) {
    // 附加属性
    if (prop === &quot;latestBrowser&quot;) {
      obj.browsers.push(value);
      return;
    }

    // 如果不是数组，则进行转换
    if (typeof value === &quot;string&quot;) {
      value = [value];
    }

    // 默认行为是保存属性值
    obj[prop] = value;

    // 表示成功
    return true;
  },
});

console.log(products.browsers); // ['Internet Explorer', 'Netscape']
products.browsers = &quot;Firefox&quot;; // 如果不小心传入了一个字符串
console.log(products.browsers); // ['Firefox'] &lt;- 也没问题，得到的依旧是一个数组

products.latestBrowser = &quot;Chrome&quot;;
console.log(products.browsers); // ['Firefox', 'Chrome']
console.log(products.latestBrowser); // 'Chrome'
</code></pre>
<h3 id="25-对方法调用的代理"><a class="header" href="#25-对方法调用的代理">2.5 对方法调用的代理</a></h3>
<pre><code class="language-js">function sum(a, b) {
  return a + b;
}

const handler2 = {
  apply: function (target, thisArg, argumentsList) {
    console.log(`argumentsList ${argumentsList}`);
    // expected output: &quot;Calculate sum: 1,2&quot;
    console.log(&quot;thisArg&quot;, thisArg);
    return target(argumentsList[0], argumentsList[1]) * 10;
  },
};

const proxy1 = new Proxy(sum, handler2);

console.log(sum(1, 2));
// expected output: 3
console.log(proxy1(1, 2));
// expected output: 30
</code></pre>
<h3 id="26-对构造函数的代理"><a class="header" href="#26-对构造函数的代理">2.6 对构造函数的代理</a></h3>
<p>使用构造函数声明类</p>
<pre><code class="language-js">var Person = function (name) {
  this.name = name;
};

let person = new Person(&quot;aa&quot;);
console.log(person);
</code></pre>
<p>使用 extend 方法代理 Boy 类的构造方法</p>
<pre><code class="language-js">function extend(sup, base) {
  var descriptor = Object.getOwnPropertyDescriptor(
    base.prototype,
    &quot;constructor&quot;,
  );
  base.prototype = Object.create(sup.prototype);
  var handler = {
    construct: function (target, args) {
      var obj = Object.create(base.prototype);
      this.apply(target, obj, args);
      return obj;
    },
    apply: function (target, that, args) {
      sup.apply(that, args);
      base.apply(that, args);
    },
  };
  var proxy = new Proxy(base, handler);
  descriptor.value = proxy;
  Object.defineProperty(base.prototype, &quot;constructor&quot;, descriptor);
  return proxy;
}

var Person = function (name) {
  this.name = name;
};

var Boy = extend(Person, function (name, age) {
  this.age = age;
});

Boy.prototype.sex = &quot;M&quot;;

var Peter = new Boy(&quot;Peter&quot;, 13);
console.log(Peter.sex); // &quot;M&quot;
console.log(Peter.name); // &quot;Peter&quot;
console.log(Peter.age); // 13
</code></pre>
<h3 id="27-实例交换两个单选框的选择状态"><a class="header" href="#27-实例交换两个单选框的选择状态">2.7 实例：交换两个单选框的选择状态</a></h3>
<pre><code class="language-js">let view = new Proxy({
  selected: null,
}, {
  set: function (obj, prop, newval) {
    let oldval = obj[prop];

    if (prop === &quot;selected&quot;) {
      if (oldval) {
        oldval.setAttribute(&quot;aria-selected&quot;, &quot;false&quot;);
      }
      if (newval) {
        newval.setAttribute(&quot;aria-selected&quot;, &quot;true&quot;);
      }
    }

    // 默认行为是存储被传入 setter 函数的属性值
    obj[prop] = newval;

    // 表示操作成功
    return true;
  },
});

let i1 = view.selected = document.getElementById(&quot;item-1&quot;);
console.log(i1.getAttribute(&quot;aria-selected&quot;)); // 'true'

let i2 = view.selected = document.getElementById(&quot;item-2&quot;);
console.log(i1.getAttribute(&quot;aria-selected&quot;)); // 'false'
console.log(i2.getAttribute(&quot;aria-selected&quot;)); // 'true'
</code></pre>
<h3 id="28-实例对数组方法的拓展"><a class="header" href="#28-实例对数组方法的拓展">2.8 实例：对数组方法的拓展</a></h3>
<ol>
<li>products.number 为 array.length 起别名 array.number</li>
<li>products.name | products.type 通过 array 中 object 的某个键获取元素</li>
</ol>
<pre><code class="language-js">let products = new Proxy([
  { name: &quot;Firefox&quot;, type: &quot;browser&quot; },
  { name: &quot;SeaMonkey&quot;, type: &quot;browser&quot; },
  { name: &quot;Thunderbird&quot;, type: &quot;mailer&quot; },
], {
  get: function (obj, prop) {
    // 默认行为是返回属性值，prop ?通常是一个整数
    if (prop in obj) {
      return obj[prop];
    }

    // 获取 products 的 number; 它是 products.length 的别名
    if (prop === &quot;number&quot;) {
      return obj.length;
    }

    let result, types = {};

    for (let product of obj) {
      if (product.name === prop) {
        result = product;
      }
      if (types[product.type]) {
        types[product.type].push(product);
      } else {
        types[product.type] = [product];
      }
    }

    // 通过 name 获取 product
    if (result) {
      return result;
    }

    // 通过 type 获取 products
    if (prop in types) {
      return types[prop];
    }

    // 获取 product type
    if (prop === &quot;types&quot;) {
      return Object.keys(types);
    }

    return undefined;
  },
});

console.log(products[0]); // { name: 'Firefox', type: 'browser' }
console.log(products[&quot;Firefox&quot;]); // { name: 'Firefox', type: 'browser' }
console.log(products[&quot;Chrome&quot;]); // undefined
console.log(products.browser); // [{ name: 'Firefox', type: 'browser' }, { name: 'SeaMonkey', type: 'browser' }]
console.log(products.types); // ['browser', 'mailer']
console.log(products.number); // 3
</code></pre>
<h2 id="其他-1"><a class="header" href="#其他-1">其他</a></h2>
<h3 id="map-vs-weakmap"><a class="header" href="#map-vs-weakmap">Map vs WeakMap</a></h3>
<pre><code>WeakMap 只能用 Object 做键，而且是一个弱引用，

能够触发垃圾回收机制
不能被 enumerate
Map 使用任意类型作为键

在 gc 时不能自动删除关联内存
可以被迭代
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue-mastery"><a class="header" href="#vue-mastery">Vue Mastery</a></h1>
<p>Deep Dive With Even You</p>
<h2 id="1-v-dom"><a class="header" href="#1-v-dom">1. V-DOM</a></h2>
<p>实现 dom 重点在于</p>
<ol>
<li>获取新增节点的各种属性，使用 createElement 拼接出一个新的节点，并将其挂载到 dom 树中</li>
<li>能够用比较算法比较新的 dom 和旧的 dom 的不同，并高效的更新节点</li>
</ol>
<h3 id="11-h"><a class="header" href="#11-h">1.1 h</a></h3>
<p>该函数只是定义了一个标签的属性并返回</p>
<pre><code class="language-js">function h(tag, props, children) {
  return {
    tag,
    props,
    children,
  };
}
</code></pre>
<h3 id="12-mount"><a class="header" href="#12-mount">1.2 mount</a></h3>
<p>生成 + 挂载节点的封装 使用 node.el 作为指针保存了节点的信息</p>
<pre><code class="language-js">function mount(vnode, container) {
  // 创建新节点
  // 这里用 node.el 保存了旧的 dom 树
  const el = vnode.el = document.createElement(vnode.tag);
  // 添加 props 属性
  if (vnode.props) {
    for (const key in vnode.props) {
      const value = vnode.props[key];
      el.setAttribute(key, value);
    }
  }
  // 挂载子节点
  // string 类型就直接修改 textContent
  // Array 类型就以此对 child 调用 mount 挂载到新节点上
  if (vnode.children) {
    if (typeof vnode.children === &quot;string&quot;) {
      el.textContent = vnode.children;
    } else if (vnode.children instanceof Array) {
      console.log(vnode.children);
      vnode.children.forEach((child) =&gt; {
        mount(child, el);
      });
    } else {
      el.textContent = `[ERROR]: ${vnode.children}`;
    }
  }
  container.appendChild(el);
}
</code></pre>
<h3 id="13-patch"><a class="header" href="#13-patch">1.3 patch</a></h3>
<p>比较新节点和旧节点的差异，最小化修改节点内容 重点在于新旧节点的 children 都是 Array 类型时，如何最高效的实现两组 Array 的同步
比如多的添加，少的删除，变的修改，换为位置的怎么把位置换回来</p>
<pre><code class="language-js">function patch(n1, n2) {
  // 1. 比较是不是同一个标签
  if (n1.tag === n2.tag) {
    const el = n2.el = n1.el;
    // check props 检查 props 属性，变了的就修改，没有的就添加
    const oldProps = n1.props || {};
    const newProps = n2.props || {};
    for (const key in newProps) {
      const oldValue = oldProps[key];
      const newValue = newProps[key];
      if (oldValue !== newValue) {
        el.setAttribute(key, newValue);
      }
    }
    // 把旧节点多余的 props 删除
    for (const key in oldProps) {
      if (!(key in newProps)) {
        el.removeAttribute(key);
      }
    }

    // children 检查子节点
    const oldChildren = n1.children;
    const newChildren = n2.children;
    // 如果新节点是 string 类型且和旧节点不一样，就覆盖掉旧节点
    if (typeof newChildren === &quot;string&quot;) {
      if (typeof oldChildren === &quot;string&quot;) {
        if ((oldChildren !== newChildren)) {
          el.textContent = newChildren;
        }
      } else {
        el.textContent = newChildren;
      }
      // 如果新节点是 Array 类型
    } else if (newChildren instanceof Array) {
      // 旧的是 string 类型，依次添加 newChild
      if (typeof oldChildren === &quot;string&quot;) {
        el.innerHTML = &quot;&quot;;
        newChildren.forEach((child) =&gt; {
          mount(child, el);
        });
        // 旧的也是个 Array
      } else if (oldChildren instanceof Array) {
        const commonLength = Math.min(oldChildren.length, newChildren.length);
        // 一次比较每一对 child，修改旧 child 的内容
        for (let i = 0; i &lt; commonLength; i++) {
          patch(oldChildren[i], newChildren[i]);
        }
        // 如果 newChildren 数量更多，就把多出的新节点添加到新节点上
        if (newChildren.length &gt; oldChildren.length) {
          newChildren.slice(oldChildren.length).forEach((child) =&gt; {
            mount(child, el);
          });
          // 否则，删除多余的新节点
        } else if (newChildren.length &lt; oldChildren.length) {
          oldChildren.slice(newChildren.length).forEach((child) =&gt; {
            el.removeChild(child.el);
          });
        }
      }
    } else {
    }
  } else {
    // replace
  }
}
</code></pre>
<h3 id="14-完整代码"><a class="header" href="#14-完整代码">1.4 完整代码</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        .red {
            color: red;
        }
        .green {
            color: green;
        }
        .m-4 {
            margin: 10px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;title&lt;/div&gt;
    &lt;script&gt;
        // @ts-check
        function h(tag, props, children) {
            return {
                tag,
                props,
                children
            }
        }

        function mount(vnode, container) {
            // 这里用 node.el 保存了旧的 dom 树
            const el = vnode.el = document.createElement(vnode.tag)
            // props
            if (vnode.props) {
                for (const key in vnode.props) {
                    const value = vnode.props[key]
                    el.setAttribute(key, value)
                }
            }
            if (vnode.children) {
                if (typeof vnode.children === 'string') {
                    el.textContent = vnode.children
                } else if (vnode.children instanceof Array) {
                    console.log(vnode.children)
                    vnode.children.forEach(child =&gt; {
                        mount(child, el)
                    })
                } else {
                    el.textContent = `[ERROR]: ${vnode.children}`
                }
            }
            container.appendChild(el)
        }

        const vdom = h('div', { class: 'red' }, [
            h('span', {class: 'm-4'}, 'hello')
        ])

        function patch(n1, n2) {
            if (n1.tag === n2.tag) {
                const el = n2.el = n1.el
                // check props
                const oldProps = n1.props || {};
                const newProps = n2.props || {};
                for (const key in newProps) {
                    const oldValue = oldProps[key]
                    const newValue = newProps[key]
                    if (oldValue !== newValue) {
                        el.setAttribute(key, newValue)
                    }
                }
                for (const key in oldProps) {
                    if (!(key in newProps)) {
                        el.removeAttribute(key)
                    }
                }

                // childrem
                const oldChildren = n1.children
                const newChildren = n2.children
                if (typeof newChildren === &quot;string&quot;) {
                    if (typeof oldChildren === 'string') {
                        if ((oldChildren !== newChildren)) {
                            el.textContent = newChildren
                        }
                    } else {
                        el.textContent = newChildren
                    }
                } else if (newChildren instanceof Array) {
                    if (typeof oldChildren === 'string') {
                        el.innerHTML = ''
                        newChildren .forEach(child =&gt; {
                            mount(child, el)
                        })
                    } else if (oldChildren instanceof Array) {
                        const commonLength = Math.min(oldChildren.length, newChildren.length)
                        for (let i = 0; i &lt; commonLength; i++) {
                            patch(oldChildren[i], newChildren[i])
                        }
                        if (newChildren.length &gt; oldChildren.length) {
                            newChildren.slice(oldChildren.length).forEach(child =&gt; {
                                mount(child, el)
                            })
                        } else if (newChildren.length &lt; oldChildren.length) {
                            oldChildren.slice(newChildren.length).forEach(child =&gt; {
                                el.removeChild(child.el)
                            })
                        }
                    }
                } else {

                }
            } else {
                // replace


            }
        }

        mount(vdom, document.querySelector(&quot;#app&quot;))

        const vdom2 = h('div', { class: 'green' }, [
            h('span', {class: 'm-4'}, 'msg')
        ])

        patch(vdom, vdom2)

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="2-ref"><a class="header" href="#2-ref">2. Ref</a></h2>
<p>实现 ref，和 watchEffect 的监听</p>
<h3 id="21-基本过程"><a class="header" href="#21-基本过程">2.1 基本过程</a></h3>
<p>为 Dep 类实现了 set，get，可以像 ref 一样通过 dep.value 获取和修改变量 而且能在 get，set 前后做一些其他工作，比如这里用到的
set 后调用 notify 激活 watchEffect get 时 (首次调用 watchEffect 时)，把用到的变量添加到各自的 subscriber 里</p>
<ol>
<li>被监听变量加载 subscriber
首次调用 watchffect 时，先初始化 activeEffect 为传入 watchEffect 的函数，被 get 过的变量会执行 depend，向 subscriber 中加入 activeEffect(即为 warchEffect 函数内传递的箭头函数)
接着在变量被 set 后就能调用 notify，唤醒 subscriber 中的箭头函数</li>
<li>误区 如果，像下面的例子中，假如 ok.value 的值开始为 true，那么 ok 和 msg 都能正确加载 subscriber
加入 ok.value 开始为 false，msg 就不能正确加载 subscriber，在之后修改中也不会正确激活 notify，即使在之后 get 也不行，因为 depend 只有在 effect 不为空才能添加 subscriber，effect 的初始化是在 watchEffect() 中进行的，watchffect 结束后 acticeEffect 就被 null 了</li>
</ol>
<h3 id="22-watcheffect-的初始化"><a class="header" href="#22-watcheffect-的初始化">2.2 watchEffect 的初始化</a></h3>
<p>watchEffect 函数完成的工作是初始化 activeEffect
在 watchEffect() 首次被调用时，执行每个监听变量的 depend()，加入 subscriber，之后在变量被修改时就能使用 notify 激活 activeEffect</p>
<pre><code class="language-js">function watchEffect(effect) {
  activeEffect = effect;
  effect();
  activeEffect = null;
}
watchEffect(() =&gt; {
  // console.log(dep.value)

  if (ok.value) {
    console.log(ok.value, msg.value);
  } else {
    console.log(&quot;Error&quot;);
  }
});
</code></pre>
<h3 id="23-dep-类的实现"><a class="header" href="#23-dep-类的实现">2.3 Dep 类的实现</a></h3>
<pre><code class="language-js">class Dep {
  constructor(value) {
    this.subscriber = new Set();
    this._value = value;
  }

  get value() {
    this.depend();
    return this._value;
  }

  set value(value) {
    this._value = value;
    this.notify();
  }

  depend() {
    if (activeEffect) {
      this.subscriber.add(activeEffect);
    }
  }

  notify() {
    this.subscriber.forEach((effect) =&gt; {
      effect();
    });
  }
}
</code></pre>
<h3 id="24-完整代码"><a class="header" href="#24-完整代码">2.4 完整代码</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script&gt;

        let activeEffect
        class Dep {

            constructor(value) {
                this.subscriber = new Set()
                this._value = value
            }

            get value() {
                this.depend()
                return this._value
            }

            set value(value) {
                this._value = value
                this.notify()
            }

            depend() {
                if (activeEffect) {
                    this.subscriber.add(activeEffect)
                }
            }

            notify() {
                this.subscriber.forEach(effect =&gt; {
                    effect()
                })
            }
        }

        function watchEffect(effect) {
            activeEffect = effect
            effect()
            activeEffect = null
        }

        const dep = new Dep({aa: 1});
        const ok = new Dep(true);
        const msg = new Dep('hello');

        watchEffect(() =&gt; {
            // console.log(dep.value)

            if (ok.value) {
                console.log(ok.value, msg.value);
            } else {
                console.log('Error');
            }
        })


        dep.o = {aa: 2}
        msg.value = &quot;Ss&quot;
        ok.value = false
        msg.value = &quot;Ssr&quot;


        &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="25-方便调试的版本"><a class="header" href="#25-方便调试的版本">2.5 方便调试的版本</a></h3>
<pre><code class="language-js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;


    &lt;script&gt;

        let activeEffect
        class Dep {

            constructor(value) {
                this.subscriber = new Set()
                this._value = value
            }

            get value() {
                console.log('in get value');
                this.depend()
                return this._value
            }

            set value(value) {
                console.log('in set value');
                this._value = value
                this.notify()
            }

            depend() {
                console.log('activateEffect: ', activeEffect);
                if (activeEffect) {
                    this.subscriber.add(activeEffect)
                }
            }

            notify() {
                console.log('subscriber: ', this.subscriber);
                this.subscriber.forEach(effect =&gt; {
                    effect()
                })
            }
        }

        function watchEffect(effect) {
            activeEffect = effect
            effect()
            activeEffect = null
        }

        const dep = new Dep({aa: 1});
        const ok = new Dep(false);
        const msg = new Dep('hello');

        console.log('ok', ok, 'msg', msg);
        console.log('----------- 0 -----------');
        watchEffect(() =&gt; {
            // console.log(dep.value)

            if (ok.value) {
                console.log(ok.value, msg.value);
            } else {
                console.log('Error');
            }
        })
        console.log('ok', ok, 'msg', msg);
        console.log('----------- 1 -----------');
        // dep 不在 watchffect 中
        console.log(dep.value)
        dep.value = {aa: 2}
        console.log(dep.value)
        console.log('----------- 2 -----------');
        // 这里虽然修改了 msg 的值，但是由于 msg 之前没有被 get 过，他的 subscriber 为空，notify 不会激活 watchEffect 运行
        console.log(msg.value);
        msg.value = &quot;Ss&quot;
        console.log('ok', ok, 'msg', msg);
        console.log('----------- 3 -----------');
        ok.value = true
        console.log('----------- 4 -----------');
        msg.value = &quot;Ssr&quot;
        console.log('ok', ok, 'msg', msg);


        &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="3-reactive"><a class="header" href="#3-reactive">3. Reactive</a></h2>
<p>大体思路和 dep 相似，这里提供两套实现</p>
<ol>
<li>基于 Object.defineProperty (vue2)</li>
</ol>
<pre><code class="language-js">function reactive(raw) {
  // 仿照 dep 类，为每个键值设定 setter 和 getter 方法
  // raw 中的每个对象都是一个 Dep 实例
  Object.keys(raw).forEach((key) =&gt; {
    let dep = new Dep(key);
    let value = raw[key];
    Object.defineProperty(raw, key, {
      fuck() {
        console.log(&quot;cnm&quot;);
      },
      get() {
        dep.depend();
        return value;
      },
      set(newValue) {
        value = newValue;
        dep.notify();
      },
    });
  });
  return raw;
}
</code></pre>
<ol start="2">
<li>基于 Proxy 的实现 (vue3)</li>
</ol>
<pre><code class="language-js">const targetMap = new WeakMap();

function getDep(target, key) {
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    depsMap = new Map();
    targetMap.set(target, depsMap);
  }
  let dep = depsMap.get(key);
  if (!dep) {
    dep = new Dep();
    depsMap.set(key, dep);
  }
  return dep;
}

// 使用 Proxy 实现的另一个好处是，我们能够检测到添加新元素，比如下面的 state.msg
const reactiveHandler = {
  get(target, key, receiver) {
    const dep = getDep(target, key);
    dep.depend();
    return Reflect.get(target, key, receiver);
  },
  set(target, key, value, receiver) {
    const dep = getDep(target, key);
    const result = Reflect.set(target, key, value, receiver);
    // 先修改值在 notify
    dep.notify();
    return result;
  },
  // 还可以实现更多的 traps
  has() {
  },
  onKeys() {
  },
};

function reactive(raw) {
  return new Proxy(raw, reactiveHandler);
}
const state = reactive({
  count: 0,
  fuck: &quot;Fuck!&quot;,
});
</code></pre>
<ol start="3">
<li>完整代码</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

    &lt;script&gt;
        let activeEffect
        class Dep {

            subscriber = new Set()

            depend() {
                if (activeEffect) {
                    this.subscriber.add(activeEffect)
                }
            }

            notify() {
                this.subscriber.forEach(effect =&gt; {
                    effect()
                })
            }
        }

        function watchEffect(effect) {
            activeEffect = effect
            effect()
            activeEffect = null
        }
        // function reactive(raw) {
        //     // 仿照 dep 类，为每个键值设定 setter 和 getter 方法
        //     // raw 中的每个对象都是一个 Dep 实例
        //     Object.keys(raw).forEach(key =&gt; {
        //         let dep = new Dep(key)
        //         let value = raw[key]
        //         Object.defineProperty(raw, key, {
        //             fuck() {
        //                 console.log('cnm');
        //             },
        //             get() {
        //                 dep.depend()
        //                 return value
        //             },
        //             set(newValue) {
        //                 value = newValue
        //                 dep.notify()
        //             }
        //         })
        //     })
        //     return raw
        // }

        // targetMap depMap
        // obj1    key1 dep
        //         key2 dep
        // obj2    key1 dep
        //         key2 dep
        const targetMap = new WeakMap();

        function getDep(target, key) {
            let depsMap = targetMap.get(target);
            if (!depsMap) {
                depsMap = new Map();
                targetMap.set(target, depsMap);
            }
            let dep = depsMap.get(key);
            if (!dep) {
                dep = new Dep();
                depsMap.set(key, dep);
            }
            return dep
        }

        // 使用 Proxy 实现的另一个好处是，我们能够检测到添加新元素，比如下面的 state.msg
        const reactiveHandler = {
            get(target, key, receiver) {
                const dep = getDep(target, key);
                dep.depend()
                return Reflect.get(target, key, receiver)
            },
            set(target, key, value, receiver) {
                const dep = getDep(target, key);
                const result = Reflect.set(target, key, value, receiver);
                // 先修改值在 notify
                dep.notify()
                return result
            },
            // 还可以实现更多的 traps
            has() {

            },
            onKeys() {

            }
        }

        function reactive(raw) {
            return new Proxy(raw, reactiveHandler)
        }
        const state = reactive({
            count: 0,
            fuck: 'Fuck!'
        })
        console.log('state:', state);

        watchEffect(() =&gt; {
            console.log(state.count, state.msg)
        })

        state.count++

        state.msg = 'i am not exist before '

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="4-mini-vue"><a class="header" href="#4-mini-vue">4. Mini-Vue</a></h2>
<p>有了上面的东西基本就够了</p>
<p>下面是一个计数应用</p>
<pre><code class="language-js">const App = {
  data: reactive({
    count: 0,
  }),
  render() {
    return h(&quot;div&quot;, {
      onclick: () =&gt; {
        this.data.count++;
      },
    }, this.data.count);
  },
};

function mountApp(component, container) {
  let isMounted = false;
  let prevVdom;
  watchEffect(() =&gt; {
    if (!isMounted) {
      prevVdom = component.render();
      mount(prevVdom, container);
      isMounted = true;
    } else {
      const newVdom = component.render();
      patch(prevVdom, newVdom);
      prevVdom = newVdom;
    }
  });
}

mountApp(App, document.querySelector(&quot;#app&quot;));
</code></pre>
<h2 id="5-composition-api"><a class="header" href="#5-composition-api">5. Composition API</a></h2>
<p>一个小小的封装应用</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;script src=&quot;https://unpkg.com/vue@next&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

  &lt;script&gt;
    const { createApp, ref, watchEffect } = Vue

    function usePost(getId) {
      return useFetch(() =&gt; `https://jsonplaceholder.typicode.com/todos/${getId()}`)
    }

    function useFetch(getUrl) {
      const data = ref(null)
      const error = ref(null)
      const isPending = ref(true)

      watchEffect(() =&gt; {
        isPending.value = true
        data.value = null
        error.value = null
        fetch(getUrl())
          .then(res =&gt; res.json())
          .then(_data =&gt; {
            setTimeout(() =&gt; {
              data.value = _data
              isPending.value = false
            }, 1000)
          })
          .catch(e =&gt; {
            error.value = e
            isPending.value = false
          })
      })
      return { data, error, isPending }
    }

    const Post = {
      template: `
        Posts
        &lt;div v-if='isPending'&gt;Loading...&lt;/div&gt;
        &lt;div v-else-if=&quot;data&quot;&gt;{{ data }}&lt;/div&gt;
        &lt;div v-else-if=&quot;error&quot;&gt;Something is wrong: {{ error.message }}&lt;/div&gt;
      `,
      props: {
        id: 0
      },
      setup(props) {
        console.log('props', props);
        const { data, error, isPending } = usePost(() =&gt; props.id)
        return {
          data,
          error,
          isPending
        }
      }
    }

    const App = {
      components: { Post },
      data() {
        return {
          id: 1
        }
      },
      template: `
        &lt;button @click=&quot;id++&quot;&gt;Change ID&lt;/button&gt;
        &lt;Post :id=&quot;2&quot;/&gt;
      `
    }

    createApp(App).mount(&quot;#app&quot;)

  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue"><a class="header" href="#vue">Vue</a></h1>
<h2 id="vue2x"><a class="header" href="#vue2x">Vue2.x</a></h2>
<h3 id="vue-基础"><a class="header" href="#vue-基础">Vue 基础</a></h3>
<h4 id="src-引入"><a class="header" href="#src-引入">src 引入</a></h4>
<pre><code class="language-javascript">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;;
</code></pre>
<h4 id="questionhtml-例子"><a class="header" href="#questionhtml-例子">question.html 例子</a></h4>
<pre><code class="language-javascript">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;script src=&quot;vue.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
		&lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;&gt;&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id=&quot;watch-example&quot;&gt;
		  &lt;p&gt;输入框：
			&lt;input v-model=&quot;question&quot; placeholder=&quot;sss&quot;&gt;
		  &lt;/p&gt;
		  &lt;p&gt; 答案： {{ answer }}&lt;/p&gt;
           &lt;!--// {{}}语法不能作用在 HTML attribute 上，的但是可以用 [attributeName]
             可以嵌入 JavaScript 表达式--&gt;
		&lt;/div&gt;
		&lt;script&gt;
			var vm = new Vue({
				el: &quot;#watch-example&quot;,  // 1. 绑定的根节点
				data: {   // 2. 一个组件的 data 选项必须是一个函数  data: function () {return {count: 0}}
					question: '',
					answer: &quot;你还没有输入任何问题&quot;,
				},
				watch: {  // 如果 `question` 发生改变，这个函数就会运行
					question: function(newQuestion, oldQuestion) {
						console.log(1);
						this.answer = &quot;等待您输入完成&quot;;   // 只有当实例被创建时就已经存在于 data 中的 property 才是响应式的
						setTimeout(function(){}, 1000);
						this.getAnswer();
					}
				},
				methods: {
					getAnswer: function() {
						console.log(&quot;正在查询结果&quot;)
						if (this.question.indexOf(&quot;?&quot;) === -1) {
							this.answer = '问题要以？结尾';
						}
						this.answer = &quot;Thinking...&quot;
						var this_ = this;  // axios 为新的 this
						axios.get(&quot;https://yesno.wtf/api&quot;).then(function (response) {
							this_.answer = &quot;找到结果&quot;
						}).catch(function(error) {
							this_.answer = &quot;没找到结果&quot;;
						})
					},
				}
			})
		&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="计算属性"><a class="header" href="#计算属性">计算属性</a></h4>
<pre><code class="language-javascript">computed: {
   fullName:  // 默认为 set，可增加 get
     (set: )function () {
     return this.firstName + ' ' + this.lastName
   }
 }
</code></pre>
<h4 id="v-bind-for-class"><a class="header" href="#v-bind-for-class">v-bind for class</a></h4>
<ul>
<li>对象语法
<pre><code class="language-javascript">// 1.
v-bind:class=&quot;{ active: isActive, 'text-danger': hasError }&quot;
data: {
isActive: true,
hasError: false
}
// 2.
&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;
data: {
classObject: {
    active: true,
    'text-danger': false
}
}
computed: {
classObject: function () {
    return {
    active: this.isActive &amp;&amp; !this.error,
    'text-danger': this.error &amp;&amp; this.error.type === 'fatal'
    }
}
}
</code></pre>
</li>
<li>数组语法</li>
</ul>
<pre><code class="language-javascript">// 1.
&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
// 2.
&lt;div v-bind:class=&quot;[isActive ? activeClass : '', errorClass]&quot;&gt;&lt;/div&gt;
// 3.
&lt;div v-bind:class=&quot;[{ active: isActive }, errorClass]&quot;&gt;&lt;/div&gt;
</code></pre>
<pre><code class="language-javascript"></code></pre>
<h2 id="vuepress"><a class="header" href="#vuepress">VuePress</a></h2>
<h3 id="注意"><a class="header" href="#注意">注意</a></h3>
<ol>
<li>部分字符需转义，例如<code>&lt;&gt;</code></li>
</ol>
<h3 id="home-配置"><a class="header" href="#home-配置">Home 配置</a></h3>
<pre><code class="language-yaml">---
home: true
heroImage: logo.png
heroText: Trdthg 的个人主页
# tagline: Hero 副标题
# actionText: 快速上手 →
# actionLink: /zh/guide/
features:
- title: 简洁至上
  details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。
- title: Vue 驱动
  details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。
- title: 高性能
  details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。
footer: MIT Licensed | Copyright © 2020-present Evan You
---
</code></pre>
<h3 id="自定义主题"><a class="header" href="#自定义主题">自定义主题</a></h3>
<ol>
<li>
<p>新建 .vuepress -&gt; styles -&gt; palette.styl</p>
</li>
<li>
<p>示例</p>
</li>
</ol>
<pre><code class="language-styl">// $accentColor =blue//默认主题颜色
// $textColor = #006400//默认字体颜色
$textColor = #000//默认字体颜色
$borderColor = #eaecef//默认边框颜色
$codeBgColor = #282c34//默认背景颜色

//示例修改相关样式 f12 找到需要修改的地方找到对应 class 类拿过来直接用就行了

.sidebar-group.is-sub-group &gt; .sidebar-heading:not(.clickable){
  opacity :1
}

.theme-container {
  background-image: url(https://www.10wallpaper.com/wallpaper/1920x1200/1909/2019_Red_Blue_Abstract_Design_Desktop_1920x1200.jpg);
  background-repeat:no-repeat;
  background-attachment:fixed;
}
.page {
  padding-top: 5rem;
  padding-left: 15rem;
}
.sidebar {
  width: 15rem;
  opacity:0.5;
}
.theme-default-content {
  top: 200px;
  background-color: #FFFAFA;
}
.content__default {
    // background-color: #000;
    top: 200px;
    border-radius: 10px;
}
</code></pre>
<h3 id="nav--sidebar"><a class="header" href="#nav--sidebar">nav &amp;&amp; sidebar</a></h3>
<pre><code class="language-js">sidebar: {
  '/java/': ['java', 'sourceread', 'spring', 'springboot', 'stuffs'],
  '/js/': ['js', 'vue'],
  '/python/': ['python'],
  '/rust/': ['rust', 'lists'],
  '/other/': ['other', 'script', 'datastructure'],
  '/': [''] //不能放在数组第一个，否则会导致右侧栏无法使用
}, // 侧边栏配置
nav:[ // 导航栏配置
  {text: 'Java',  link: '/java/java'},
  {text: '前端', link: '/js/js' },
  {text: 'Python', link: '/python/python'},
  {text: 'Rust', link: '/rust/rust' },
  {text: '其他', link: '/other/other'},
  {text: 'Github', link: 'https://github.com/trdthg'}
],
</code></pre>
<h3 id="更新时间"><a class="header" href="#更新时间">更新时间</a></h3>
<pre><code class="language-js">plugins: ['@vuepress/last-updated'],
themeConfig: {
  lastUpdated: 'Last Updated', // string | boolean
}
</code></pre>
<h3 id="待续-12"><a class="header" href="#待续-12">待续...</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="未整理"><a class="header" href="#未整理">未整理</a></h1>
<h2 id="未整理-1"><a class="header" href="#未整理-1">未整理</a></h2>
<ul>
<li>图片
<ul>
<li>雪碧图</li>
<li>svg(svgo)</li>
<li>dataURL
<ul>
<li>种类</li>
<li>img：base64，以及为什么用 base64(减少请求)</li>
<li>svg 为什么不使用 64，他是文本格式，img 是二进制</li>
</ul>
</li>
<li>图标字体 (icon-font)</li>
</ul>
</li>
<li>prefetch 加载优先级低的资源，比如其他路由资源，link 的别的页面等等</li>
<li>preload 加在当前路由的必要资源</li>
<li>图片懒加载 data-src -&gt; src (当视口到达后赋值，加载实现懒加载图片)</li>
<li>防抖，节流</li>
<li>路由懒加载</li>
<li>HTTP2, HTTP3/QUIC，HTTP 长连接</li>
<li>Vue 虚拟 DOM 优化
<ul>
<li>静态节点</li>
</ul>
</li>
<li>禁止选中 | 禁止复制：
<ul>
<li>css: user-select：none</li>
<li>
<h2 id="js"><a class="header" href="#js">js:</a></h2>
<ol>
<li>document.body.selectstart = (e) =&gt; {e.preventDefault()}</li>
</ol>
<ul>
<li>
<ol start="2">
<li>document.body.oncopy = (e) =&gt; {e.preventDefault()}</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>取消请求 需要一个 controller 和 siginal，把 siginal 传递给请求对象，使用 controller 改变 signal 的状态，fetch:
AbortController, axios: CancelToken
<a href="https://z.itpub.net/article/detail/38D9DDF9A9CB14B29239BFEFDA2AD193">面试官：如何中断已发出去的请求？</a></li>
</ul>
<h1 id="网站"><a class="header" href="#网站">网站</a></h1>
<ul>
<li><a href="http://yulilong.cn/">前端知识</a></li>
<li><a href="https://q.shanyue.tech/engineering/">山月前端面试题</a></li>
<li><a href="https://www.ttalk.im/index.html">Tech Talk</a></li>
<li><a href="https://github.com/qq449245884/xiaozhi">资源</a></li>
<li><a href="https://www.kancloud.cn/cyyspring/webpack/1986854">前端工程化学习笔记</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-相关"><a class="header" href="#http-相关">HTTP 相关</a></h1>
<h2 id="压缩"><a class="header" href="#压缩">压缩</a></h2>
<h3 id="后端-gzip"><a class="header" href="#后端-gzip">后端 gzip</a></h3>
<pre><code>网址 trdthg.github.io 检测结果
是否压缩是
压缩类型 gzip
原始文件大小 23146 字节
压缩后文件大小 3454 字节
压缩率（估计值）85.08%
</code></pre>
<h4 id="配置压缩"><a class="header" href="#配置压缩">配置压缩</a></h4>
<ol start="2">
<li>在 nginx 配置压缩效果
<a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">官方 doc</a>
<a href="https://www.cnblogs.com/Renyi-Fan/p/11047490.html">博客</a></li>
</ol>
<pre><code>gzip on;  #是否开启 gzip 模块 on 表示开启 off 表示关闭
gzip_buffers 4 16k;  #设置压缩所需要的缓冲区大小
gzip_comp_level 6;  #压缩级别 1-9，数字越大压缩的越好，也越占用 CPU 时间
gzip_min_length 100k;  #设置允许压缩的最小字节
gzip_http_version 1.1;  #设置压缩 http 协议的版本，默认是 1.1
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;  #设置压缩的文件类型
gzip_vary on;  #是否在 http header 中添加`Vary: Accept-Encoding`，辅助选择不同压缩算法产生的副本
</code></pre>
<p>注意一些不常用的资源，比如字体，有需要也应该加入 gzip_type</p>
<pre><code>字体类型扩展名	Content-type
.eot	application/vnd.ms-fontobject
.ttf	font/ttf
.otf	font/opentype
.woff	font/x-woff
.svg	image/svg+xml
</code></pre>
<p><strong>怎么选择合适的压缩比</strong></p>
<pre><code>gzip_comp_level 0: 0，94840, 63 [ms], 29%
gzip_comp_level 1: 2.43，39005, 248 [ms], 100%
gzip_comp_level 2: 2.51，37743, 273 [ms], 100%
gzip_comp_level 3; 2.57，36849, 327 [ms], 100%
gzip_comp_level 4; 2.73，34807, 370 [ms], 100%
gzip_comp_level 5; 2.80，33898, 491 [ms], 100%
gzip_comp_level 6; 2.82，33686, 604 [ms], 100%
gzip_comp_level 7; 2.82，33626, 659 [ms], 100%
gzip_comp_level 8; 2.82，33626, 698 [ms], 100%
gzip_comp_level 9; 2.82，33626, 698 [ms], 100%
- 随着压缩级别的升高，压缩比有所提高，但到了级别 6 后，很难再提高；
- 随着压缩级别的升高，处理时间明显变慢；
- gzip 很消耗 cpu 的性能，高并发情况下 cpu 达到 100%
</code></pre>
<p>注意事项</p>
<ul>
<li>不是压缩级别越高越好，其实 gzip_comp_level 1 的压缩能力已经够用了，后面级别越高，压缩的比例其实增长不大，反而很吃处理性能。</li>
<li>压缩一定要和静态资源缓存相结合，缓存压缩后的版本，否则每次都压缩高负载下服务器肯定吃不住。</li>
<li>图片/mp3 这样的二进制文件，不必压缩，因为压缩率比较小，比如 100 只能压缩到 80 字节，而且压缩也是耗费 CPU 资源的。</li>
<li>比较小的文件不必压缩，意义不存在。</li>
</ul>
<h4 id="配置压缩缓存"><a class="header" href="#配置压缩缓存">配置压缩缓存</a></h4>
<p>这里的缓存控制主要是针对图片，css,js 等变化周期较短的静态文件; 第一次访问 以图片为例，当我们第一次访问这张图片时，服务器返回的是
200，同时在响应头返回了两个键，</p>
<ul>
<li>Etag:即该文件的'指纹'(唯一标识)</li>
<li>Last-Modified:'文件的修改时间'; 此时浏览器，以及其他的缓存服务器就会把这张图片给缓存起来;</li>
</ul>
<p>第二次访问 再次请求这张图片时，请求头增加了两个键值，</p>
<ul>
<li>If-Modified-Since:上次发生改变的时间;</li>
<li>If-None-Match:上次文件本身的 Etag 值，服务器根据这两个键值判断其 Etag 和
Last-Modified，如果都没发生改变就不返回这张图片，只返回一个 304 的状态码，服务器接收到这个 304
的状态码就会自己去从缓存里面找这个被缓存的图片;</li>
</ul>
<p>可以减少服务器的带宽压力以及提升了网站访问速度;</p>
<pre><code class="language-conf">location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ {
  access_log   off;
  expires      30d;
}

location ~* ^.+\.(css|js|txt|xml|swf|wav)$ {
  access_log   off;
  expires      24h;
}

location ~* ^.+\.(html|htm)$ {
  expires      1h;
}
</code></pre>
<h3 id="terser-压缩"><a class="header" href="#terser-压缩">terser 压缩</a></h3>
<ul>
<li>去除多余字符：空格，换行及注释
<ul>
<li>多行代码压缩到一行时要注意行尾分号</li>
</ul>
</li>
<li>压缩变量名：变量名，函数名及属性名
<ul>
<li>缩短变量的命名也需要 AST 支持，不至于在作用域中造成命名冲突。</li>
</ul>
</li>
<li>解析程序逻辑：合并声明以及布尔值简化
<pre><code class="language-js">// 压缩前
const a = 3;
const b = 4;

// 压缩后
const a = 3, b = 4;

// 压缩前
!b &amp;&amp; !c &amp;&amp; !d &amp;&amp; !e;

// 压缩后
!(b || c || d || e);
</code></pre>
<ul>
<li>解析程序逻辑：编译预计算</li>
</ul>
<pre><code class="language-js">// 压缩前
const ONE_YEAR = 365 * 24 * 60 * 60;
// 压缩后
const ONE_YAAR = 31536000;

// 压缩前
function hello() {
  console.log(&quot;hello, world&quot;);
}
hello();
// 压缩后
console.log(&quot;hello, world&quot;);
</code></pre>
</li>
</ul>
<h4 id="库"><a class="header" href="#库">库</a></h4>
<p>uglify、terser 与 swc</p>
<h3 id="tree-shaking"><a class="header" href="#tree-shaking">tree shaking</a></h3>
<ul>
<li>依赖于 webpack 静态分析，结合 AST 删除不必要的节点</li>
<li>对引入的 json 文件做静态分析
<ul>
<li>需要使用 wabpack 插件<code>webpack-json-access-optimizer</code></li>
<li>把 json 转换为 array，并删除不必要的内容
<pre><code class="language-js">// strings.json
[&quot;Hello world!&quot;, &quot;Hello world again!&quot;];

// index.js
const strings = require(&quot;./strings.json&quot;);
console.log(strings[0], strings[1]);
</code></pre>
</li>
</ul>
</li>
<li>对 css，下面用到了 style-loader，会把 css 加到 style 标签里
<pre><code class="language-js">{
    test: /\.css$/,
    use: ['style-loader', 'css-loader'],
}
// You just have to add the sideEffects: true property to it.

{
    test: /\.css$/,
    use: ['style-loader', 'css-loader'],
    sideEffects: true
}
</code></pre>
</li>
<li>sideeffect 能直接跳过整个模块/文件
<img src="https://blog.logrocket.com/tree-shaking-json-files-webpack/" alt="Webpack - Tree Shaking" />
<img src="https://blog.logrocket.com/tree-shaking-json-files-webpack/" alt="JSON-CSS" /></li>
</ul>
<h2 id="http-缓存"><a class="header" href="#http-缓存">http 缓存</a></h2>
<h3 id="介绍"><a class="header" href="#介绍">介绍</a></h3>
<p>更少的请求，更少的流量，更少的峰值带宽，从而节省一大笔服务器或者 CDN 的费用。</p>
<ul>
<li>减少请求次数</li>
<li>减少峰值带宽 控制 HTTP 缓存只需要使用 Cache-control 控制</li>
</ul>
<blockquote>
<p>Expires：是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串。比如网页的 Expires 值是：expires:Mar,
06 Apr 2020 10:47:02 GMT。问题：到期时间是由服务端生成的，如果客户端时间跟服务器时间不一致，这就会导致缓存命中的误差。
<strong>两者同时存在的话，Cache-Control 优先级高于 Expires</strong></p>
</blockquote>
<h3 id="cache-control"><a class="header" href="#cache-control">Cache-Control</a></h3>
<pre><code>1) max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；
2) s-maxage：和 max-age 是一样的，不过它只针对代理服务器缓存而言；**s-maxage 的优先级高于 max-age**

3) public：可以被所有的用户缓存，包括用户浏览器和 CDN 等中间代理服务器。
4) private：只能被用户浏览器缓存，而不能被代理服务器缓存；

5) no-cache：no-cache 是会被缓存的，但是依然强制客户端直接向服务器发送请求，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。当服务器接收到请求，会判断资源是否变更，变更则返回新内容，否则返回 304。
6) no-store：禁止一切缓存（响应真的不被缓存）。

7) max-stale：能容忍的最大过期时间。max-stale 指令标示了客户端愿意接收一个已经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确认的时间与当前时间的差值）。
8) min-fresh：能够容忍的最小新鲜度。min-fresh 标示了客户端不愿意接受新鲜度不多于当前的 age 加上 min-fresh 设定的时间之和的响应。
</code></pre>
<h3 id="什么是指纹"><a class="header" href="#什么是指纹">什么是指纹</a></h3>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202122340765.png" alt="" />
如图所示，指纹就是文件的 hash 值</p>
<ul>
<li>main.js 带有 hash 值，属于带指纹的永久资源 (强缓存)</li>
<li>index.js 不带 hash 值，虽然设置了 no-chche，但是依然是协商缓存</li>
</ul>
<p>区别下面两种缓存就是依靠指纹 (是不是永久缓存)，而 cache-control 值是决定对缓存的处理策略 (存不存，用不用)</p>
<h3 id="文件指纹生成策略"><a class="header" href="#文件指纹生成策略">文件指纹生成策略</a></h3>
<h4 id="生成策略"><a class="header" href="#生成策略">生成策略</a></h4>
<ul>
<li>hash：当有文件修改，整个项目构建的 hash 值就会更新。 <code>filename: '[name]-[hash].bundle.css'</code></li>
<li>chunkhash：和 webpack 打包的 chunk 相关，不同的 entry 会生成不同的 hash，一般用于 js 的打包。
<code>filename: '[name]-[chunkhash].bundle.css'</code></li>
<li>contenthash：根据文件内容来定义 hash，文件内容不变，contenthash 不变。例如 css 的打包，由于 修改 js 或 html
文件，但是没有修改引入的 css 样式时，文件不需要生成新的哈希值，所以可适用于 css 的打包。
<code>filename: '[name]-[contenthash:8].bundle.css'</code></li>
</ul>
<blockquote>
<p>可以在哈希末尾配置哈希值的长度
<a href="https://webpack.js.org/configuration/output/#template-strings">filename 配置格式</a></p>
</blockquote>
<h4 id="js-chunkhash"><a class="header" href="#js-chunkhash">js-chunkhash</a></h4>
<pre><code class="language-js">JS 文件指纹设置：
chunkhash;
module.export = {
  entry: {
    index: &quot;./src/index.js&quot;,
    search: &quot;./src/search.js&quot;,
  },
  output: {
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;[name][chunkhash:8].js&quot;,
  },
};
</code></pre>
<h3 id="css-contenthash"><a class="header" href="#css-contenthash">css-contenthash</a></h3>
<p>CSS 文件指纹：contenthash --（min-css-extract-plugin 可以生产 css 文件）
1.直接使用'style-loader'方式通过 style 标签将 CSS 插入到 head 中并没有生成单独的 CSS 文件，因此也不存在
使用指纹时候可以更新文件，所以这里通过'min-css-extract-plugin'插件将 CSS 提取成单独的 CSS 文件，并添加文件指纹。2.安装依赖
mini-css-extract-plugin -- 'npm i mini-css-extract-plugin -D'</p>
<pre><code class="language-js">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);
module.export = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          MiniCssExtractPlugin.loader,
          &quot;css-loader&quot;,
        ],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: &quot;[name][contenthash:8].css&quot;,
    }),
  ],
};
</code></pre>
<h4 id="img-hash"><a class="header" href="#img-hash">img-hash</a></h4>
<p>图片文件指纹设置：hash 1.其中，hash 对应的是文件内容的哈希值，默认为 md5 生成，不同于前面所说的 hash 值。</p>
<pre><code class="language-js">module.export = {
  module: {
    rules: [
      {
        test: /\.(png|svg|jpg|jpeg|gif)$/,
        use: [{
          loader: &quot;file-loader&quot;,
          options: {
            name: &quot;img/[name][hash:8].[ext]&quot;,
          },
        }],
      },
    ],
  },
};
</code></pre>
<h4 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h4>
<blockquote>
<p>使用了 md5 指纹之后发现每次打包还是会发生变化？答：这是由于 webpack 的处理机制导致的，webpack
每次打包会把每个模块的配置信息，如文件名、文件顺序、文件 md5 等信息作为配置打入 js
中，以便于其进行模块管理，而这部内容，每次打包都有可能发生变化，导致整个 js 文件名每次都会发生变化。webpack 提供了一个 manifest
的机制来剥出这个配置文件。我们需要使用 CommonsChunkPlugin 来将其剥离，同时使用
chunk-manifest-webpack-plugin 读取其 内容导出另外一个文件，防止其内容变化导致整个 js 文件指纹发生变化</p>
</blockquote>
<h4 id="bundle-splitting尽量减少资源变更"><a class="header" href="#bundle-splitting尽量减少资源变更">Bundle Splitting：尽量减少资源变更</a></h4>
<p>把大 js 文件，分成小的文件，尽量减少缓存失效的范围
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202130126302.png" alt="" />
此时我们可以对资源进行分层次缓存的打包方案，这是一个建议方案：</p>
<ul>
<li>webpack-runtime: 应用中的 webpack 的版本比较稳定，分离出来，保证长久的永久缓存</li>
<li>react/react-dom: react 的版本更新频次也较低</li>
<li>vendor: 常用的第三方模块打包在一起，如 lodash，- classnames
基本上每个页面都会引用到，但是它们的更新频率会更高一些。另外对低频次使用的第三方模块不要打进来</li>
<li>pageA: A 路由页面，当 A 页面的组件发生变更后，它的缓存将会失效</li>
<li>pageB: B 路由页面</li>
<li>echarts: 不常用且过大的第三方模块单独打包</li>
<li>mathjax: 不常用且过大的第三方模块单独打包</li>
<li>jspdf: 不常用且过大的第三方模块单独打包</li>
</ul>
<p>随着 <strong>http2</strong>
的发展，特别是多路复用，初始页面的静态资源不受资源数量的影响。因此为了更好的缓存效果以及按需加载，也有很多方案建议把<strong>所有的第三方模块进行单模块打包</strong>。</p>
<h3 id="永久缓存--强制缓存-带指纹"><a class="header" href="#永久缓存--强制缓存-带指纹">永久缓存 / 强制缓存 (带指纹)</a></h3>
<pre><code>Cache-Control: public,max-age=31536000,immutable
</code></pre>
<p>max-age 表示缓存时间为 1 年，直接从缓存数据库 (浏览器的本地缓存) 拿到数据，下图中的 (disk cache) 就是
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202122312621.png" alt="" />
而为了解决更新的问题，就需要在文件名 (或者路径) 中添加 hash，版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效
(其实并未立即失效，只是不再使用了而已)。在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。</p>
<p><strong>默认的强制缓存时间</strong></p>
<p>首先要明确两个响应头代表的含义：</p>
<ul>
<li>Date: 指源服务器响应报文生成的时间，差不多与发请求的时间等价</li>
<li>Last-Modified: 指静态资源上次修改的时间，取决于 mtime</li>
</ul>
<p>LM factor 算法认为当请求服务器时，如果没有设置 Cache-Control，如果距离上次的 Last-Modified
越远，则生成的强制缓存时间越长。</p>
<pre><code class="language-js">// 用公式表示如下，其中 factor 介于 0 与 1 之间：
MaxAge = (Date - LastModified) * factor;
</code></pre>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202130123289.png" alt="" /></p>
<h3 id="协商缓存--对比缓存-不带指纹"><a class="header" href="#协商缓存--对比缓存-不带指纹">协商缓存 / 对比缓存 (不带指纹)</a></h3>
<p>第一次请求会缓存<code>数据，Etag，Last-Modified</code>，之后请求都要发出请求携带<code>If-Modified-Since, If-None-Match</code>判断缓存的时效性，如果是
304，就表示缓存可用，浏览器就直接用缓存数据
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202122321204.png" alt="" /></p>
<h3 id="etag-和-last-modified-的区别"><a class="header" href="#etag-和-last-modified-的区别">Etag 和 Last-Modified 的区别</a></h3>
<p>Etag 优先级更高，服务前先比较 Etag，同时存在时会以 ETag 为准。</p>
<h4 id="last-modified--if-modified-since"><a class="header" href="#last-modified--if-modified-since">Last-Modified / If-Modified-Since</a></h4>
<ol>
<li>精确到秒：<code>Last-Modify: Thu,31 Dec 2037 23:59:59 GMT</code></li>
<li>使用<code>stat ./xxx.txt</code>获取文件 (夹) 信息</li>
</ol>
<p>服务器响应请求时，会告诉浏览器一个告诉浏览器资源的最后修改时间：Last-Modified，浏览器之后再请求的时候，会带上一个头：If-Modified-Since，这个值就是服务器上一次给的
Last-Modified 的时间，服务器会比对资源当前最后的修改时间，如果大于
If-Modified-Since，则说明资源修改过了，浏览器不能再使用缓存，否则浏览器可以继续使用缓存，并返回 304 状态码。</p>
<h4 id="etag--if-none-match"><a class="header" href="#etag--if-none-match">Etag / If-None-Match</a></h4>
<ol>
<li>Etag/If-None-Match 是“实体标签”（Entity Tag）的缩写</li>
<li>优先级高于 Last-Modified / If-Modified-Since）</li>
<li>优势</li>
</ol>
<ul>
<li>解决内容并不改变，仅仅改改变修改时间的问题</li>
<li>解决只就精确到秒的问题：某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since
能检查到的粒度是 s 级的，这种修改无法判断 (或者说 UNIX 记录 MTIME 只能精确到秒)；</li>
<li>某些服务器不能精确的得到文件的最后修改时间。</li>
</ul>
<p>服务器响应请求时，通过 Etag 头部告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定），浏览器再次请求时，就会带上一个头
If-None-Match，这个值就是服务器上一次给的 Etag 的值，服务器比对一下资源当前的 Etag 是否跟 If-None-Match
一致，不一致则说明资源修改过了，浏览器不能再使用缓存，否则浏览器可以继续使用缓存，并返回 304 状态码。</p>
<p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#etag">nginx 配置 etag</a>
由文件内容的 hash 或者 mtime/size 生成</p>
<h3 id="最佳缓存策略"><a class="header" href="#最佳缓存策略">最佳缓存策略</a></h3>
<h4 id="缓存位置"><a class="header" href="#缓存位置">缓存位置</a></h4>
<p>请求一个资源时，会按照优先级（Service Worker - Memory Cache - Disk Cache - Push
Cache）依次查找缓存，如果命中则使用缓存，否则发起请求。</p>
<ol>
<li>service walker</li>
</ol>
<p>浏览器背后的独立线程，Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全</p>
<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker
命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service
Worker 中获取的内容。</p>
<ol start="2">
<li>200 from memory cache</li>
</ol>
<p>主要包含的是当前中页面中已经抓取到的资源，会随着进程的释放而释放，一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
一般来说，系统不会给内存分配较大的容量，因此内存缓存一般用于存储较小文件。同时内存缓存在有时效性要求的场景下也很有用（比如浏览器的隐私模式）。当前系统内存使用率高的话，文件优先存储进硬盘</p>
<blockquote>
<p>还保存着 preload/prefetch 相关的资源，preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css
文件，一边网络请求下一个资源。200 from prefetch cache 在 preload 或 prefetch 的资源加载时，两者也是均存储在
http cache，当资源加载完成后，如果资源是可以被缓存的，那么其被存储在 http cache
中等待后续使用；如果资源不可被缓存，那么其在被使用前均存储在 memory cache。</p>
</blockquote>
<ol start="3">
<li>
<p>200 from disk cache
表示不访问服务器，直接从硬盘中读取缓存。与内存相比，硬盘的读取速度相对较慢，但硬盘缓存持续的时间更长，关闭进程之后，缓存的资源仍然存在。由于硬盘的容量较大，因此一般用于存储大文件。
对于大文件来说，大概率是不存储在内存中的，反之优先</p>
</li>
<li>
<p>Push cache</p>
</li>
</ol>
<p>Push Cache（推送缓存）是 HTTP/2
中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome
浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p>
<ul>
<li>可以推送 no-cache 和 no-store 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用同一个 HTTP/2 的连接，可以使用同一个 Push Cache，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接。</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
<p>其他</p>
<ol>
<li>CDN Cache</li>
</ol>
<p>以腾讯 CDN 为例：X-Cache-Lookup:Hit From MemCache 表示命中 CDN 节点的内存；X-Cache-Lookup:Hit
From Disktank 表示命中 CDN 节点的磁盘；X-Cache-Lookup:Hit From Upstream 表示没有命中 CDN。</p>
<ol start="2">
<li>其他的不展开了，具体参考下面的 所有缓存机制的解读</li>
</ol>
<p>IndexDB(浏览器本地存储)，Service Worker，LocalStorage，SessionStorage</p>
<h4 id="用户行为如何触发缓存策略"><a class="header" href="#用户行为如何触发缓存策略">用户行为如何触发缓存策略</a></h4>
<ol>
<li>
<p>打开网页，地址栏输入地址：查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</p>
</li>
<li>
<p>普通刷新 (F5)：跳过强缓存，但是会检查协商缓存 (因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用
(如果匹配的话)。其次才是 disk cache)。</p>
</li>
</ol>
<ul>
<li>当你点“刷新”按钮的时候，浏览器会在请求头里加一个“Cache-Control: maxage=0”。因为 max-age
是“生存时间”，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服务器发请求。服务器看到
max-age=0，也就会用一个最新生成的报文回应浏览器。</li>
</ul>
<ol start="3">
<li>强制刷新 (Ctrl + F5)：浏览器不使用缓存 (跳过强缓存和协商缓存)，直接从服务器加载，因此发送的请求头部均带有 Cache-control:
no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。</li>
</ol>
<ul>
<li>“Cache-Control: no-cache”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。</li>
</ul>
<h4 id="最佳缓存策略-1"><a class="header" href="#最佳缓存策略-1">最佳缓存策略</a></h4>
<p>定义最优缓存策略</p>
<ul>
<li>
<p>更新频繁的应该提取为单文件：有些资源的更新比其他资源频繁。如果资源的特定部分（例如 JS 函数或一组 CSS
样式）会经常更新，应考虑将其代码作为单独的文件提供。这样，每次获取更新时，剩余内容（例如不会频繁更新的库代码）可以从缓存中获取，确保下载的内容量最少；</p>
</li>
<li>
<p>确保服务器配置或移除 ETag：因为 Etag 跟服务器配置有关，每台服务器的 Etag 都是不同的；其他</p>
</li>
<li>
<p>确定中继缓存可以缓存哪些资源：对所有用户的响应完全相同的资源很适合由 CDN 或其他中继缓存进行缓存；</p>
</li>
<li>
<p>使用一致的网址：如果您在不同的网址上提供相同的内容，将会多次获取和存储该内容。注意：URL 区分大小写！</p>
</li>
<li>
<p>确定每个资源的最优缓存周期：不同的资源可能有不同的更新要求。审查并确定每个资源适合的 max-age；</p>
</li>
<li>
<p>确定网站的最佳缓存层级：对 HTML 文档组合使用包含内容特征码的资源网址以及短时间或 no-cache 的生命周期，可以控制客户端获取更新的速度；</p>
</li>
<li>
<p>善用 HTML5 的缓存机制：合理设计启用 LocalStorage、SessionStorage、IndexDB、SW 等存储，会给页面性能带来明显提升；</p>
</li>
<li>
<p>用好本地缓存</p>
</li>
</ul>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202130038910.png" alt="" /></p>
<h3 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h3>
<ul>
<li><a href="https://www.jiqizhixin.com/articles/2020-07-24-12">所有缓存机制的解读</a></li>
<li><a href="https://developer.huawei.com/consumer/cn/forum/topic/0202357360658600848">前端学习之浏览器缓存机制</a></li>
<li><a href="https://cloud.tencent.com/developer/news/588770">资料</a></li>
<li><a href="https://shanyue.tech/frontend-engineering/http-cache.html">山月</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching">MDN-caching</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/111190645">缓存策略：强缓存&amp;协商缓存</a></li>
<li><a href="https://www.kancloud.cn/cyyspring/webpack/1836682">文件指纹</a></li>
</ul>
<h2 id="cookie-和-session-的区别"><a class="header" href="#cookie-和-session-的区别">cookie 和 session 的区别</a></h2>
<p>1.使用方式</p>
<p>cookie 机制：如果不在浏览器中设置过期事件，cookie 被保存在内存中，生命周期随浏览器的关闭而结束，这种 cookie 简称为会话
cookie。如果在浏览器中设置了 cookie 的过期事件，cookie 会被保存在硬盘中，关闭浏览器后，cookie
数据仍然存在，直到过期事件结束才消失。cookie 是服务端发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时都带上它</p>
<p>session 机制：当服务器收到请求需要创建 session 对象时，首先会检查客户端请求中是否包含 sessionid。如果有
sessionid，服务器将根据该 id 返回对应 session 对象。如果客户端请求中没有 sessionid，服务器会创建新的 session 对象，并把
sessionid 在本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端，在交互中浏览器按照规则将 sessionid
发送给服务器。如果用户禁用 cookie，则要使用 URL 重写，可以通过 response.encodeURL(url) 进行实现；API 对
encodeURL 的结束为，当浏览器支持 cookie 时，url 不做任何处理；当浏览器不支持 cookie 的时候，将会重写 URL 将
sessionid 拼接到访问地址后。</p>
<p>2.保持状态</p>
<p>cookie 保存在浏览器端，session 保存在服务器端</p>
<p>3.存储的大小</p>
<p>单个 cookie 保存的数据不能超过 4kb；session 大小没有限制。</p>
<p>4.存储内容</p>
<p>cookie 只能保存字符串类型，以文本的方式。session 通过类似与 Hashtable 的数据结构来保存，能支持任何类型的对象（session
中可含有多个对象）</p>
<p>5.安全性</p>
<p>session 的安全性大于 cookie。原因如下：</p>
<p>① sessionid 存储在 cookie 中，若要攻破 session 首先要攻破 cookie； ② sessionid 是要有人登录，或者启动
session_start 才会有，所以攻破 cookie 也不一定能得到 sessionid； ③ 第二次启动 session_start 后，前一次的
sessionid 就是失效了，session 过期后，sessionid 也随之失效。 ④ sessionid 是加密的。</p>
<p>综上所述，攻击者必须在短时间内攻破加密的 sessionid，这很难。</p>
<p>6.应用场景</p>
<p>cookie：（1）判断用户是否登录过网站，以便下次登录时能够实现自动登录（或者记住密码）。（2）保存上次登录的事件等信息。（3）保存上次查看的页面
（4）浏览计数</p>
<p>session：</p>
<p>（1）网上商城中的购物车（2）保存用户登录信息（3）将某些数据放入 session 中，供同一用户的不同页面使用（4）防止用户非法登录</p>
<h3 id="localstorage-和-sessionstorage-的区别"><a class="header" href="#localstorage-和-sessionstorage-的区别">localStorage 和 sessionStorage 的区别</a></h3>
<p>1.生命周期</p>
<p>localStorage 的生命周期是永久的，关闭页面或浏览器之后 localStorage 中的数据也不会消失。localStorage
除非主动删除数据，否则数据永远不会消失。</p>
<p>sessionStorage 的生命周期是仅在当前会话下有效。sessionStorage 引入了一个“浏览器窗口”的概念，sessionStorage
是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是 sessionStorage
在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage 也是不一样的。</p>
<p>2.存储大小</p>
<p>localStorage 和 sessionStorage 的存储数据大小一般都是：5MB</p>
<p>3.存储位置</p>
<p>localStorage 和 sessionStorage 都保存在客户端，不与服务器进行交互通信</p>
<p>4.存储内容类型</p>
<p>localStorage 和 sessionStorage 只能存储字符串类型，对于复杂的对象可以使用 ECMAScript 提供的 JSON 对象的
stringify 和 parse 来处理</p>
<p>5.应用场景</p>
<p>localStorage：常用于长期登录（+ 判断用户是否已登录），适合长期保存在本地的数据</p>
<p>sessionStorage：敏感账号一次性登录</p>
<h3 id="cookie-中的-httponly-的属性和作用"><a class="header" href="#cookie-中的-httponly-的属性和作用">Cookie 中的 httponly 的属性和作用</a></h3>
<p>1.什么是 HttpOnly?</p>
<p>如果 cookie 中设置了 HttpOnly 属性，那么，这样能有效的防止 XSS 攻击，窃取 cookie 内容，这样就增加了 cookie
的安全性，即便是这样，也不要将重要信息存入 cookie。XSS 全称 Cross SiteScript，跨站脚本攻击，是 Web 程序中常见的漏洞，XSS
属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有 XSS 漏洞的网站中输入 (传入) 恶意的 HTML
代码，当其它用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。如，盗取用户 Cookie、破坏页面结构、重定向到其它网站等。</p>
<p>2.HttpOnly 的设置样例</p>
<p>response.setHeader(&quot;Set-Cookie&quot;,
&quot;cookiename=httponlyTest;Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly&quot;);
例如： //设置 cookie</p>
<p>response.addHeader(&quot;Set-Cookie&quot;, &quot;uid=112; Path=/; HttpOnly&quot;)</p>
<p>//设置多个 cookie</p>
<p>response.addHeader(&quot;Set-Cookie&quot;, &quot;uid=112; Path=/; HttpOnly&quot;);</p>
<p>response.addHeader(&quot;Set-Cookie&quot;, &quot;timeout=30; Path=/test; HttpOnly&quot;);</p>
<p>//设置 https 的 cookie</p>
<p>response.addHeader(&quot;Set-Cookie&quot;, &quot;uid=112; Path=/; Secure; HttpOnly&quot;);</p>
<p>具体参数的含义再次不做阐述，设置完毕后通过 js 脚本是读不到该 cookie 的，但使用如下方式可以读取。</p>
<p>Cookie cookies[]=request.getCookies();</p>
<h3 id="参考资料-1"><a class="header" href="#参考资料-1">参考/资料</a></h3>
<ul>
<li><a href="https://github.com/xuexueq/blog/issues/5">浏览器存储方案（Cookie、LocalStorage、SessionStorage）</a></li>
</ul>
<h2 id="packagejson"><a class="header" href="#packagejson">package.json</a></h2>
<h3 id="dependencies-与-devdependencies-有何区别"><a class="header" href="#dependencies-与-devdependencies-有何区别">dependencies 与 devDependencies 有何区别</a></h3>
<ul>
<li>对于业务代码，打包时依靠的是 bundle 的依赖分析，与 dev 无关</li>
<li>对于库而言，当库被引入时，dev 中的依赖不会被下载</li>
</ul>
<h3 id="cjsesumd"><a class="header" href="#cjsesumd">cjs、es、umd</a></h3>
<ol>
<li>cjs 是动态加载模块，可以直接 require 一个变量</li>
</ol>
<pre><code class="language-js">require(`./${a}`);
</code></pre>
<ol start="2">
<li>esm 是语言上的规范，因此在 Node 及 浏览器中均会支持</li>
</ol>
<ul>
<li>esm 是静态导入，可以在编译期进行 Tree shaking，减少 js 体积</li>
<li>如果要动态导入，可以
<pre><code class="language-js">const ms = await import(&quot;https://cdn.skypack.dev/ms@latest&quot;);
ms.default(1000);
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter"><a class="header" href="#flutter">flutter</a></h1>
<h2 id="无线调试"><a class="header" href="#无线调试">无线调试</a></h2>
<blockquote>
<p>老连根线是真的不爽，usb 接口不稳定老是端开连接🔗，这下就好了</p>
</blockquote>
<ol>
<li>查看连接设备</li>
</ol>
<pre><code>»»»» adb devices
List of devices attached
LGV358fbccb96	device
</code></pre>
<ol start="2">
<li>设置监听端口</li>
</ol>
<pre><code>»»»» adb tcpip 1583
restarting in TCP mode port: 1583
</code></pre>
<ol start="3">
<li>局域网内连接到手机</li>
</ol>
<blockquote>
<p>手机 ip 一般在 wifi 设置里可以查到</p>
</blockquote>
<pre><code>»»»» adb connect 192.168.31.176:1583
connected to 192.168.31.176:1583
</code></pre>
<h2 id="路由系统"><a class="header" href="#路由系统">路由系统</a></h2>
<h3 id="两个关联的页面"><a class="header" href="#两个关联的页面">两个关联的页面</a></h3>
<pre><code>HOME(FirstRoute) -&gt; SecondRoute HOME(FirstRoute) &lt;- SecondRoute
</code></pre>
<pre><code class="language-dart">class FirstRoute extends StatelessWidget {
  const FirstRoute({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
        appBar: AppBar(title: const Text(&quot;First Route&quot;)),
        body: Center(
          child: ElevatedButton(
            child: const Text(&quot;Open route&quot;),
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (context) =&gt; const SecondRoute()),
              );
            },
          ),
        ));
  }
}

class SecondRoute extends StatelessWidget {
  const SecondRoute({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text(&quot;Second Route&quot;)),
      body: Center(
          child: ElevatedButton(
        child: const Text(&quot;Go Back!&quot;),
        onPressed: () {
          Navigator.pop(context);
        },
      )),
    );
  }
}
</code></pre>
<h3 id="定义路由"><a class="header" href="#定义路由">定义路由</a></h3>
<ol>
<li>常规的方法</li>
</ol>
<pre><code class="language-dart">// 定义路由
initialRoute: '/random-words',
routes: {
    '/': (context) =&gt; const FirstRoute(),
    '/second': (context) =&gt; const SecondRoute(),
    '/random-words': (context) =&gt; const RandomWords(),
},

Navigator.pushNamed(context, '/second');
</code></pre>
<p>::: warn 注意：home 与 initialRoute 冲突 ::: 2. 使用常量定义在组件内部定义路由</p>
<pre><code class="language-dart">class RandomWords extends StatefulWidget {
  const RandomWords({Key? key}) : super(key: key);

    // 这里！
  static const routeName = '/random-words';

  @override
  _RandomWordsState createState() =&gt; _RandomWordsState();
}

// 使用 1
initialRoute: HomePage.routeName,
routes: {
    FirstRoute.routeName: (context) =&gt; const FirstRoute(),
},

// 使用 2
final result = await Navigator.pushNamed(context, SecondRoute.routeName);
</code></pre>
<h3 id="返回数据到老页面"><a class="header" href="#返回数据到老页面">返回数据到老页面</a></h3>
<ul>
<li>pop 方法有第二个参数，可以返回一些东西</li>
<li>push 方法有返回值，可以接收 pop 的值，不过是 Future 类型，需要用 async 和 await 处理</li>
</ul>
<pre><code class="language-dart">// First Route
ElevatedButton(
    child: const Text(&quot;Open new route and choose one&quot;),
    onPressed: () {
        _navigateAndDisplaySelection(context);
    },
),

void _navigateAndDisplaySelection(BuildContext context) async {
    // Navigator.push returns a Future that completes after calling
    // Navigator.pop on the Selection Screen.
    final result = await Navigator.pushNamed(context, '/second');
    ScaffoldMessenger.of(context)
      ..removeCurrentSnackBar()
      ..showSnackBar(SnackBar(content: Text('you choose `$result`')));
}

// Second Route
ElevatedButton(
    child: const Text(&quot;Open route&quot;),
    onPressed: () {
        Navigator.pop(context, &quot;this arg is optional&quot;);
    },
),
</code></pre>
<h3 id="传递数据到新页面"><a class="header" href="#传递数据到新页面">传递数据到新页面</a></h3>
<ol>
<li>通过构造函数指定参数</li>
</ol>
<p>只能在定义路由时：<code>const XXXScreen(args)</code>传递参数 这种方法只适用于直接 navigate 到新页面时使用</p>
<pre><code class="language-dart">class TodoDetailScreen extends StatelessWidget {
  const TodoDetailScreen({Key? key, required this.todo}) : super(key: key);

  final Todo todo;
</code></pre>
<ol start="2">
<li>在 build 函数内指定参数</li>
</ol>
<p>通过<code>ModalRoute.of</code>函数拿到参数</p>
<pre><code class="language-dart">class ExtractArguementScreen extends StatelessWidget {
  const ExtractArguementScreen({Key? key}) : super(key: key);

  static const routeName = '/navigator-3-extractArguments';

  @override
  Widget build(BuildContext context) {
    /// `ModalRoute.of`能返回当前路由以及携带的参数
    final args = ModalRoute.of(context)!.settings.arguments as ScreenArguments;

    return Scaffold(
      appBar: AppBar(
        title: Text(args.title),
      ),
      body: Center(child: Text(args.message)),
    );
  }
}
</code></pre>
<ol start="3">
<li>还是在构造函数里指定，不过定义为<code>生成路由</code></li>
</ol>
<pre><code class="language-dart">// 声明组件
class PassArguementScreen extends StatelessWidget {
  const PassArguementScreen({Key? key, required this.args}) : super(key: key);

  static const routeName = &quot;/navigator-3-passArguements&quot;;

  // 这里和 1 一样
  final ScreenArguments args;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(args.title),
      ),
      body: Center(child: Text(args.message)),
    );
  }
}

// 定义路由，可 route 并列

onGenerateRoute: (settings) {
    if (settings.name == PassArguementScreen.routeName) {
        final args = settings.arguments as ScreenArguments;
        return MaterialPageRoute(builder: (context) {
        return PassArguementScreen(
            args: ScreenArguments(args.title, args.message));
        });
    }
    assert(false, 'Need to implement ${settings.name}');
    return null;
},
</code></pre>
<h3 id="页面之间的动效"><a class="header" href="#页面之间的动效">页面之间的动效</a></h3>
<ol>
<li>Hreo 组件</li>
</ol>
<p>只需要在两个页面都是用 Hero 组件包起来就行了</p>
<ul>
<li><code>tag</code>：作为 <code>Hero</code> 组件的标识，在这两个页面中必须相同。</li>
<li><code>child</code>：在两个屏幕直接跨越的那个 widget。</li>
</ul>
<pre><code class="language-dart">child: Hero(
    tag: src,
    child: Image.network(src),
)),
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用-css"><a class="header" href="#常用-css">常用 css</a></h1>
<ul>
<li>使用伪类扩大可点击区域</li>
</ul>
<pre><code class="language-css">#btn::before {
  content: &quot;&quot;;
  position: absolute;
  top: -20px;
  right: -20px;
  bottom: -20px;
  left: -20px;
}
</code></pre>
<ul>
<li>sroll-behavior: smooth | 实现平滑滚动</li>
<li>user-select: all | 选择所有文本</li>
<li>Text Overflow | ...代替多的文本</li>
<li>object-fit: cover | 保持长宽比</li>
</ul>
<pre><code class="language-css">img {
  width: 128px;
  height: 128px;
  object-fit: cover;
}
</code></pre>
<ul>
<li>onerror | 无图片 404</li>
</ul>
<pre><code class="language-css">img.error {
    display: inline-block;
    transform: scale(1);
    content: '';
    color: transparent;
}
img.error::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: #f5f5f5 url('https://cdn-images-1.medium.com/max/1600/1*we8wfyztsdo12e2Cww6oVA.jpeg') no-repeat center / 100% 100%;
}
// 一些优化
img.error::after {
    content: attr(alt);
    position: absolute;
    left: 0;
    bottom: 0;
    width: 100%;
    line-height: 2;
    background-color: rgba(0, 0, 0, .5);
    color: white;
    font-size: 12px;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
</code></pre>
<p>Image 无图片</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟-dom"><a class="header" href="#虚拟-dom">虚拟 DOM</a></h1>
<h2 id="基本介绍"><a class="header" href="#基本介绍">基本介绍</a></h2>
<blockquote>
<p>React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render()
方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。
该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。</p>
</blockquote>
<h2 id="diff-算法"><a class="header" href="#diff-算法">Diff 算法</a></h2>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202111251286.png" alt="" /></p>
<h3 id="根节点是不同元素"><a class="header" href="#根节点是不同元素">根节点是不同元素</a></h3>
<p>React 会拆卸原有的树并且建立起新的树 (触发一个完整的重建流程)。在根节点以下的组件也会被卸载，它们的状态会被销毁。比如，当比对以下更变时：</p>
<pre><code class="language-jsx">&lt;div&gt;
    &lt;Counter /&gt;
&lt;/div&gt;

&lt;span&gt;
    &lt;Counter /&gt;
&lt;/span&gt;
</code></pre>
<p>React 会销毁 Counter 组件并且重新装载一个新的组件。</p>
<blockquote>
<p>销毁的过程：当卸载一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 componentWillUnmount() 方法。当建立一棵新的树时，对应的
DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 UNSAFE_componentWillMount() 方法，紧接着
componentDidMount() 方法。所有与之前的树相关联的 state 也会被销毁。</p>
</blockquote>
<h3 id="对比同一类型元素"><a class="header" href="#对比同一类型元素">对比同一类型元素</a></h3>
<p>保留原来的 DOM 节点，只需要比较属性</p>
<pre><code class="language-jsx">&lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&gt;

&lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&gt;
// 通过对比这两个元素，React 知道只需要修改 DOM 元素上的 className 属性。
</code></pre>
<p>在对子节点进行递归</p>
<h3 id="对子节点进行递归"><a class="header" href="#对子节点进行递归">对子节点进行递归</a></h3>
<p>默认情况下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。</p>
<ul>
<li>在子元素列表末尾新增元素时，更新开销比较小。比如：
<pre><code class="language-jsx">&lt;ul&gt;
    &lt;li&gt;first&lt;/li&gt;
    &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
    &lt;li&gt;first&lt;/li&gt;
    &lt;li&gt;second&lt;/li&gt;
    &lt;li&gt;third&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
React 会先匹配两个 <code>&lt;li&gt;first&lt;/li&gt;</code> 对应的树，然后匹配第二个元素 <code>&lt;li&gt;second&lt;/li&gt;</code> 对应的树，最后插入第三个元素的
<code>&lt;li&gt;third&lt;/li&gt;</code> 树。</li>
<li>将新增元素插入到表头，那么更新开销会比较大
<pre><code class="language-jsx">&lt;ul&gt;
    &lt;li&gt;Duke&lt;/li&gt;
    &lt;li&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
    &lt;li&gt;Connecticut&lt;/li&gt;
    &lt;li&gt;Duke&lt;/li&gt;
    &lt;li&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
React 并不会意识到应该保留 <code>&lt;li&gt;Duke&lt;/li&gt;</code> 和
<code>&lt;li&gt;Villanova&lt;/li&gt;</code>，而是会重建每一个子元素。这种情况会带来性能问题。</li>
</ul>
<h3 id="key"><a class="header" href="#key">Key</a></h3>
<ol>
<li>使用 Key 进行优化 为了解决上述问题，React 引入了 key 属性。当子元素拥有 key 时，React 使用 key
来匹配原有树上的子元素以及最新树上的子元素。以下示例在新增 key 之后，使得树的转换效率得以提高：</li>
</ol>
<pre><code class="language-jsx">// 现在 React 知道只有带着 '2014' key 的元素是新元素，带着 '2015' 以及 '2016' key 的元素仅仅移动了。
&lt;ul&gt;
  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt;
  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>另一个例子</p>
<pre><code class="language-jsx">// 记的带上 ID
&lt;div&gt;
  {events.map((event) =&gt; &lt;Event event={event} key={event.id} /&gt;)}
&lt;/div&gt;;
</code></pre>
<ol start="2">
<li>如何使用 Key</li>
</ol>
<pre><code class="language-jsx">&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;;
</code></pre>
<ul>
<li>key 不需要全局唯一，但在列表中需要保持唯一</li>
<li>新增一个 ID 字段到你的模型中</li>
<li>利用一部分内容作为哈希值来生成一个 key</li>
<li>元素在数组中的下标作为 key :::warn 利用下标的注意事项</li>
<li>Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM
节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失。</li>
<li>这个策略在元素不进行重新排序时比较合适，如果有顺序修改，diff 就会变慢。</li>
<li>如果 key 是一个下标，修改顺序时会修改当前的 key，会导致非受控组件的 state（比如输入框）可能相互篡改，会出现无法预期的变动。 :::</li>
</ul>
<h2 id="组件更新时机"><a class="header" href="#组件更新时机">组件更新时机</a></h2>
<h3 id="一个例子"><a class="header" href="#一个例子">一个例子</a></h3>
<p>App 为父组件，Tile 为子组件</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const [message, setMessage] = React.useState(&quot;&quot;);
  return (
    &lt;&gt;
      &lt;Tile message={message} /&gt;
      &lt;Tile /&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>所以，渲染函数一共被调用 3 次，真实 dom 只被更新 1 次 当 message 更新后，两个子组件会被重新渲染，即使第二个 Tail 没有 prop
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202111209533.png" alt="" />
其中红色点代表渲染节点。在 React 中，这代表调用渲染函数。在真实 DOM 中，这代表重新绘制 UI。</p>
<ul>
<li>重绘 UI 的性能瓶颈已经被 React 进行了优化。</li>
<li>但是所有左侧的红色点代表这些组件的渲染函数都被执行了。react 需要在组件上使用 diff 算法检查组件的差异</li>
</ul>
<h3 id="一些函数"><a class="header" href="#一些函数">一些函数</a></h3>
<ol>
<li>shouldComponentUpdate 这个函数是 React 的生命周期函数之一，它允许我们通过告诉 React 何时更新类组件来优化渲染性能。</li>
</ol>
<pre><code class="language-jsx">// 它的参数是组件要进行渲染时，下一个 props 和下一个 state：
shouldComponentUpdate(nextProps, nextState) {
  // return true or false
}
</code></pre>
<p>这个函数非常简单：返回 true 会让 React 调用渲染函数，返回 false 就会阻止 React 调用渲染函数。</p>
<h3 id="什么时候不更新"><a class="header" href="#什么时候不更新">什么时候不更新</a></h3>
<ul>
<li>props 并没有使用 setState 进行更新。
<pre><code class="language-jsx">// 比如
this.props.user.name = &quot;Felix&quot;;
</code></pre>
</li>
<li>prop 的引用并没有发生变化。</li>
</ul>
<h3 id="如何强制重新渲染"><a class="header" href="#如何强制重新渲染">如何强制重新渲染</a></h3>
<p>使用 React Hooks 进行强制渲染</p>
<pre><code class="language-jsx">const [state, updateState] = React.useState();
const forceUpdate = React.useCallback(() =&gt; updateState({}), []);
</code></pre>
<h2 id="改变结构进行优化"><a class="header" href="#改变结构进行优化">改变结构进行优化</a></h2>
<p>把 setState 放到子组件内部</p>
<pre><code class="language-jsx">const InputSelfHandling = () =&gt; {
  const [text, setText] = React.useState(&quot;&quot;);
  return (
    &lt;input
      value={text}
      placeholder=&quot;Write something&quot;
      onChange={(e) =&gt; setText(e.target.value)}
    /&gt;
  );
};
</code></pre>
<h2 id="使用-memo-优化"><a class="header" href="#使用-memo-优化">使用 Memo 优化</a></h2>
<h3 id="使用-reactmemo"><a class="header" href="#使用-reactmemo">使用 React.memo()</a></h3>
<p>使用方法非常简单</p>
<pre><code class="language-jsx">const Tile = React.memo(() =&gt; {
  let eventUpdates = React.useRef(0);
  return (
    &lt;div className=&quot;black-tile&quot;&gt;
      &lt;Updates updates={eventUpdates.current++} /&gt;
    &lt;/div&gt;
  );
});
</code></pre>
<h3 id="坑"><a class="header" href="#坑">坑</a></h3>
<p>下面的例子中 React.memo 无效</p>
<pre><code class="language-jsx">const App = () =&gt; {
  const updates = React.useRef(0);
  const [text, setText] = React.useState(&quot;&quot;);
  //   const data = React.useState(&quot;&quot;);                            // !!! 这个没事
  const data = { test: &quot;data&quot; }; // !!! 这个不行
  React.useEffect(() =&gt; {
    updates.current++;
  });

  return (
    &lt;div className=&quot;app&quot;&gt;
      &lt;div className=&quot;blue-wrapper&quot;&gt;
        &lt;input
          value={text}
          placeholder=&quot;Write something&quot;
          onChange={(e) =&gt; setText(e.target.value)}
        /&gt;
        &lt;Updates updates={updates.current} /&gt;
        &lt;br /&gt;
        &lt;Tile /&gt;
        &lt;TileMemo data={data} /&gt; // !!! 这里会重新渲染
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;app&quot;));
</code></pre>
<p>原因：data 这个变量在 render 函数执行后就被重新声明了，所以他们的引用不同，但是值是相同的</p>
<h3 id="解决方法"><a class="header" href="#解决方法">解决方法</a></h3>
<ol>
<li>使用 React.memo 的第二个参数</li>
</ol>
<pre><code class="language-jsx">const TileMemo = React.memo(() =&gt; {
  let updates = React.useRef(0);
  return (
    &lt;div className=&quot;black-tile&quot;&gt;
      &lt;Updates updates={updates.current++} /&gt;
    &lt;/div&gt;
  );
}, (prevProps, nextProps) =&gt; {
  if (prevProps.data.test === nextProps.data.test) {
    return true; // props are equal
  }
  return false; // props are not equal -&gt; update the component
});
</code></pre>
<ol start="2">
<li>使用 React.useMemo 把这种变量用 React.useMemo 包裹起来，这个变量在 re-render 时就不会重新 new</li>
</ol>
<pre><code class="language-jsx">const data = React.useMemo(() =&gt; ({
  test: &quot;data&quot;,
}), []);
</code></pre>
<p>array 里的变量发生改变后会重新计算 data 变量</p>
<h3 id="关于函数"><a class="header" href="#关于函数">关于函数</a></h3>
<p>在 js 里，function 就像对象一样，在 re-render 后引用也会改变，所以这时需要用<code>useCallback</code></p>
<pre><code class="language-js">const App = () =&gt; {
  const updates = React.useRef(0);
  const [text, setText] = React.useState(&quot;&quot;);

  // const onClick = () =&gt; {
  //   console.log('click');
  // };
  const onClick = React.useCallback(() =&gt; {
    console.log(&quot;click&quot;);
  }, []);

  return (
    &lt;div className=&quot;app&quot;&gt;
      &lt;div className=&quot;blue-wrapper&quot;&gt;
        &lt;input
          value={text}
          placeholder=&quot;Write something&quot;
          onChange={(e) =&gt; setText(e.target.value)}
        /&gt;
        &lt;Updates updates={updates.current++} /&gt;
        &lt;Tile /&gt;
        &lt;TileMemo onClick={onClick} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<h3 id="什么时候不使用"><a class="header" href="#什么时候不使用">什么时候不使用</a></h3>
<ul>
<li>组件太大，消耗内存</li>
<li>props 变更非常频繁</li>
</ul>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a href="https://felixgerschau.com/react-rerender-components/">When does React re-render components?</a></li>
<li><a href="https://www.ttalk.im/2021/12/when-does-react-re-render-components.html">React 何时才会进行组件重渲染</a></li>
<li><a href="https://felixgerschau.com/react-performance-react-memo/?utm_source=ttalk.im&amp;utm_medium=website&amp;utm_campaign=Tech%2520Talk">How to use React.memo() to improve performance</a></li>
<li><a href="https://zh-hans.reactjs.org/docs/reconciliation.html">React-高级 - 协调</a>
给工程师带来额外的心智负担😅</li>
<li><a href="https://attardi.org/why-we-memo-all-the-things/">Why We Memo All the Things</a></li>
<li><a href="https://www.ttalk.im/2021/12/why-we-memo-all-the-things.html">为什么我们在所有的东西上使用 Memo</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frontend-1"><a class="header" href="#frontend-1">frontend</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blog"><a class="header" href="#blog">Blog</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="日志"><a class="header" href="#日志">日志</a></h1>
<p>::: tip 提示 this is a tip :::</p>
<h2 id="6-月"><a class="header" href="#6-月">6 月</a></h2>
<h3 id="6-月-13-日"><a class="header" href="#6-月-13-日">6 月 13 日</a></h3>
<p>计划还行吧，虽然期末没好好复习 看 java 源码是真的劝退，HashMap 的红黑树实现先放一边吧，这边准备先从 TreeMap 入手 :-）
Spring-Cloud-Alibaba 的版本问题真烦人，加了 @LoadBalanced，服务都在 nacos 注册了也还是找不到</p>
<h3 id="6-月-9-日"><a class="header" href="#6-月-9-日">6 月 9 日</a></h3>
<p>去了腾讯 serverless 大会，学习了一波新知识，停更了几天 指定了学习计划</p>
<ol>
<li>Rust（个人兴趣）</li>
<li>Java（混口饭吃：基础 + 框架）目前缓步推进中 希望文档补齐也能加入每日任务中</li>
</ol>
<h3 id="6-月-2-日"><a class="header" href="#6-月-2-日">6 月 2 日</a></h3>
<p>这两天自己通过购买 VPS 搭建了自己的 v2ray，搭建过程中服务端安装配置很简单，配置完成后可以用<code>v2ray url</code>获取 vmess 配置连接，手机端连接很顺利，windows，linux 配置很有问题，linux 下 edge 浏览器没法翻墙，直到突然发现火狐能正常使用才知道 edge（chrome）走的是系统代理，需要手动配置系统代理后才能正常使用。</p>
<h2 id="5-月"><a class="header" href="#5-月">5 月</a></h2>
<h3 id="5-月-31-日"><a class="header" href="#5-月-31-日">5 月 31 日</a></h3>
<p>修复了关联查询的 bug 修复了权限验证的 bug，权限验证也要在 map 中添加 authc 进行登录验证 把 token 改为了 access_token +
refresh_token 实现了 token 的自动更新 将 username 改为从 token 解析得到</p>
<h3 id="5-月-30-日"><a class="header" href="#5-月-30-日">5 月 30 日</a></h3>
<p>今天写了 Shiro 模块（southwind_shiro），以及 shiro + redis +
token 整合版，现在关于权限还没有测试，下一步是把权限信息也加入到 redis 缓存里，整一套可以复用的登录模板</p>
<h3 id="5-月-27-日"><a class="header" href="#5-月-27-日">5 月 27 日</a></h3>
<p>10 天前开得 hashmap 终于继续了，今天只把增删看了，关于红黑树方面的具体实现明天再说</p>
<h3 id="5-月-26-日"><a class="header" href="#5-月-26-日">5 月 26 日</a></h3>
<p>花了几天天装了个 manjaro 系统双系统，用了两天感觉还不错，今天早上发现耗电量不尽人意，只能说一般般吧，比 windows 看着好像差点，在用用看先;</p>
<h3 id="5-月-22-日"><a class="header" href="#5-月-22-日">5 月 22 日</a></h3>
<p>卡了几天的红黑树终于写完了... 回去看 HashMap 吧 (≧﹏≦)</p>
<h3 id="5-月-20-日"><a class="header" href="#5-月-20-日">5 月 20 日</a></h3>
<ol>
<li>昨天的 avl 树，因为需要在添加节点后重置 height，必须使用递归</li>
<li>今天的红黑树非常带劲，判断旋转条件太 xx 了，红黑树没有 height 了，while 循环会好些的多，我却用递归，今天只写了 add，剩下的明天再说，
先写作业了</li>
</ol>
<h3 id="5-月-18-日"><a class="header" href="#5-月-18-日">5 月 18 日</a></h3>
<p>昨天开了 HashMap 源码学习 决定先去学习树 (二叉搜索树 -&gt; AVL 树 -&gt; 红黑树)</p>
<h3 id="5-月-15-日"><a class="header" href="#5-月-15-日">5 月 15 日</a></h3>
<p>对博客加了自定义内容</p>
<ul>
<li>添加背景</li>
<li>美化布局</li>
<li>分离 java 部分</li>
</ul>
<h3 id="5-月-14-日"><a class="header" href="#5-月-14-日">5 月 14 日</a></h3>
<p>开了 rust 的坑，开坑真爽</p>
<h3 id="5-月-13-日"><a class="header" href="#5-月-13-日">5 月 13 日</a></h3>
<p>开了集合框架源码阅读的坑</p>
<h3 id="5-月-12-日"><a class="header" href="#5-月-12-日">5 月 12 日</a></h3>
<p>c++ 菜鸟教程看完了反正，java 简直是 C++--, 舍弃了大量的模块，升华了面向对象的思想 8266 micropython 成功运行</p>
<h3 id="5-月-11-日"><a class="header" href="#5-月-11-日">5 月 11 日</a></h3>
<p>开了 8266 模块的坑 并发编程 ++</p>
<h3 id="5-月-10-日"><a class="header" href="#5-月-10-日">5 月 10 日</a></h3>
<p>开了 C++ 的新坑，看到了重裁 java 把书看完了，感觉讲的贼浅，只讲了某些类怎么用而已，不过网络编程那部分的感念倒是更清晰了 UDP + TCP
并发编程 ++</p>
<h2 id="3-月"><a class="header" href="#3-月">3 月</a></h2>
<h3 id="3-月-6-日"><a class="header" href="#3-月-6-日">3 月 6 日</a></h3>
<h5 id="1-pickle-模块"><a class="header" href="#1-pickle-模块">1. pickle 模块</a></h5>
<pre><code class="language-python">#pickle 提供了一个简单的持久化功能。可以将对象以文件的形式存放在磁盘上。
'''pickle 模块只能在 python 中使用，python 中几乎所有的数据类型（列表，字典，集合，类等）都可以用 pickle 来序列化，
pickle 序列化后的数据，可读性差，人一般无法识别。'''

1. pickle.dump(obj, file[, protocol])
  序列化对象，并将结果数据流写入到文件对象中。参数 protocol 是序列化模式，默认值为 0，表示以文本的形式序列化。		protocol 的值还可以是 1 或 2，表示以二进制的形式序列化。
1. pickle.load(file)
  反序列化对象。将文件中的数据解析为一个 Python 对象。
　　
#其中要注意的是，在 load(file) 的时候，要让 python 能够找到类的定义，否则会报错：
</code></pre>
<h5 id="2-networksfrom_dict_of_lists"><a class="header" href="#2-networksfrom_dict_of_lists">2. networks.from_dict_of_lists</a></h5>
<pre><code class="language-python"># 读取字典对象，并制成 graph
dol= {0:[1]} # single edge (0,1)
G=nx.from_dict_of_lists(dol)
</code></pre>
<h2 id="1-月"><a class="header" href="#1-月">1 月</a></h2>
<h3 id="1-月-14-日"><a class="header" href="#1-月-14-日">1 月 14 日</a></h3>
<h4 id="1-java-处理-json"><a class="header" href="#1-java-处理-json">1. Java 处理 JSON</a></h4>
<pre><code class="language-java">@RequestMapping(value=&quot;/aaa&quot;,  method = RequestMethod.POST)
    @ResponseBody
    public JSONObject aaa(@RequestBody JSONObject user) {
        // 一。读取 json 数据
        {
            &quot;num&quot;: 1234567,
            &quot;pwd&quot;: 689753,
            &quot;arr&quot;: [
                {&quot;name&quot;:&quot;张三&quot;, &quot;age&quot;:12},
                {&quot;name&quot;:&quot;李四&quot;, &quot;age&quot;:13},
                {&quot;name&quot;:&quot;王五&quot;, &quot;age&quot;:14}
            ]
        }
        // 1.普通数据
        Integer num = user.get(&quot;num&quot;)
        // 2.列表嵌套 json
        ArrayList&lt;Map&gt; mmm = (ArrayList) user.get(&quot;arr&quot;);
        for (Map mm : mmm) {
            System.out.println(mm.get(&quot;name&quot;));
        }

        // 二。创建 JSONObject 实例并返回
        //1. 普通数据
        JSONObject user_ = new JSONObject();
        user_.put(&quot;num&quot;, user.get(&quot;num&quot;));
        //2. 列表
        JSONObject info = new JSONObject();
        info.put(&quot;num&quot;, user.get(&quot;num&quot;));    //创建{}
        JSONArray arr = new JSONArray();
        arr.add(user__);                     // 创建列表 arr[],并把 info 添加到 arr 中 =&gt; [{},{}]
        user_.put(&quot;套娃&quot;, arr);              // { key:val, key: [{}, {}]}
        return user_;
    }
</code></pre>
<h4 id="2-arraylist"><a class="header" href="#2-arraylist">2. ArrayList</a></h4>
<ol>
<li>添加：add()</li>
<li>取值：get( int index )</li>
<li>修改：set( int index, Object obj)</li>
<li>删除：remove(int index)</li>
<li>计算大小：list.size() 方法</li>
</ol>
<table><thead><tr><th><a href="https://www.runoob.com/java/java-arraylist-addall.html">addAll()</a></th><th>添加集合中的所有元素到 arraylist 中</th></tr></thead><tbody>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-clear.html">clear()</a></td><td>删除 arraylist 中的所有元素</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-clone.html">clone()</a></td><td>复制一份 arraylist</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-contains.html">contains()</a></td><td>判断元素是否在 arraylist</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-indexof.html">indexOf()</a></td><td>返回 arraylist 中元素的索引值</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-removeall.html">removeAll()</a></td><td>删除存在于指定集合中的 arraylist 里的所有元素</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-remove.html">remove()</a></td><td>删除 arraylist 里的单个元素</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-isempty.html">isEmpty()</a></td><td>判断 arraylist 是否为空</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-sublist.html">subList()</a></td><td>截取部分 arraylist 的元素</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-sort.html">sort()</a></td><td>对 arraylist 元素进行排序</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-toarray.html">toArray()</a></td><td>将 arraylist 转换为数组</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-surecapacity.html">ensureCapacity</a>()</td><td>设置指定容量大小的 arraylist</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-lastindexof.html">lastIndexOf()</a></td><td>返回指定元素在 arraylist 中最后一次出现的位置</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-retainall.html">retainAll()</a></td><td>保留 arraylist 中在指定集合中也存在的那些元素</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-containsall.html">containsAll()</a></td><td>查看 arraylist 是否包含指定集合中的所有元素</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-trimtosize.html">trimToSize()</a></td><td>将 arraylist 中的容量调整为数组中的元素个数</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-removerange.html">removeRange()</a></td><td>删除 arraylist 中指定索引之间存在的元素</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-replaceall.html">replaceAll()</a></td><td>将给定的操作内容替换掉数组中每一个元素</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-arraylist-removeif.html">removeIf()</a></td><td>删除所有满足特定条件的 arraylist 元素</td></tr>
</tbody></table>
<h4 id="3-hashmap"><a class="header" href="#3-hashmap">3. HashMap</a></h4>
<p>创建 Map: HashMap&lt;String, String&gt; map = <strong>new</strong> HashMap&lt;String, String&gt;();</p>
<ol>
<li>
<p>添加 : map.put(&quot;key&quot; : &quot;value&quot; )</p>
</li>
<li>
<p>获取 : map.get(int index)</p>
</li>
<li>
<p>删除 : map.remove(int index)</p>
</li>
<li>
<p>迭代方法</p>
<pre><code class="language-java">// 方法 1    map.keySet() 返回键集合   使用 map.get(key) 获取 value
for (Integer i : Sites.keySet()) {
    System.out.println(&quot;key: &quot; + i + &quot; value: &quot; + Sites.get(i));
}
// 方法 2    map.values() 返回值集合
for(String value: Sites.values()) {
    System.out.print(value + &quot;, &quot;);
}
</code></pre>
</li>
</ol>
<table><thead><tr><th><a href="https://www.runoob.com/java/java-hashmap-clear.html">clear()</a></th><th>删除 hashMap 中的所有键/值对</th></tr></thead><tbody>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-clone.html">clone()</a></td><td>复制一份 hashMap</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-isempty.html">isEmpty()</a></td><td>判断 hashMap 是否为空</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-size.html">size()</a></td><td>计算 hashMap 中键/值对的数量</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-put.html">put()</a></td><td>将键/值对添加到 hashMap 中</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-putall.html">putAll()</a></td><td>将所有键/值对添加到 hashMap 中</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-putifabsent.html">putIfAbsent()</a></td><td>如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-remove.html">remove()</a></td><td>删除 hashMap 中指定键 key 的映射关系</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-containskey.html">containsKey()</a></td><td>检查 hashMap 中是否存在指定的 key 对应的映射关系。</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-containsvalue.html">containsValue()</a></td><td>检查 hashMap 中是否存在指定的 value 对应的映射关系。</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-replace.html">replace()</a></td><td>替换 hashMap 中是指定的 key 对应的 value。</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-replaceall.html">replaceAll()</a></td><td>将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-get.html">get()</a></td><td>获取指定 key 对应对 value</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-getordefault.html">getOrDefault()</a></td><td>获取指定 key 对应对 value，如果找不到 key，则返回设置的默认值</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-foreach.html">forEach()</a></td><td>对 hashMap 中的每个映射执行指定的操作。</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-entryset.html">entrySet()</a></td><td>返回 hashMap 中所有映射项的集合集合视图。</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-keyset.html">keySet</a>()</td><td>返回 hashMap 中所有 key 组成的集合视图。</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-values.html">values()</a></td><td>返回 hashMap 中存在的所有 value 值。</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-merge.html">merge()</a></td><td>添加键值对到 hashMap 中</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-compute.html">compute()</a></td><td>对 hashMap 中指定 key 的值进行重新计算</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-computeifabsent.html">computeIfAbsent()</a></td><td>对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中</td></tr>
<tr><td><a href="https://www.runoob.com/java/java-hashmap-computeifpresent.html">computeIfPresent()</a></td><td>对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。</td></tr>
</tbody></table>
<h3 id="1-月-15-日"><a class="header" href="#1-月-15-日">1 月 15 日</a></h3>
<h4 id="1-神经八股复习"><a class="header" href="#1-神经八股复习">1. 神经八股复习</a></h4>
<pre><code class="language-python"># 1. 引入数据集
fashion_mnist = tf.keras.datasets.fashion_mnist
# (x_train, y_train), (x_test, y_test) = mnist.load_data()
(x_train, y_train), (x_test, y_test) = fashion_mnist.load_data()
x_train, x_test = x_train/255.0, x_test/255.0
# 2. 搭建神经网络
model = tf.keras.Sequential([
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation='relu'),
    # tf.keras.layers.Dense(32, activation='sigmoid',kernel_regularizer=tf.keras.regularizers.l2()),
    tf.keras.layers.Dense(10, activation='softmax'),
])
# 3. 选择 优化器 | 损失函数 | 以及 metrics
model.compile(  optimizer='adam',
                loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),
                metrics=['sparse_categorical_accuracy'])
# PS: metrics 可选：y_ = y_train  y = x_train * w + b
        1. 'accuracy'  y_和 y 都是数值
        2. 'categorical_accuracy' y_和 y 都是独热码
        3. 'sparsecategorical_accuracy' y_是数值 y 是独热码
# 4. 执行训练过程
model.fit(
    x_train, y_train,
    batch_size=48, epochs=5,
    validation_data=(x_test,y_test),  #(1) 任选一个 选择测试集
    validation_split=                 #(2) 任选一个 不选择测试集，从训练集中划分一块作为测试集
    validation_freq=1   # 多少 epoch 测试一次
)
# 5. 打印网络结构和参数统计
model.summary()
</code></pre>
<h4 id="2-numpy-方法"><a class="header" href="#2-numpy-方法">2. numpy 方法</a></h4>
<pre><code class="language-python">1.   reshape(数据，形状)  =&gt;   x_train = np.reshape(x_train,  (len(x_train), 1, 5))
2.   np.random.shuffle()   # 列表打乱重排，将 x_train 和 y_train 用相同的随机数重排
</code></pre>
<h4 id="3-rnn-期望的输入形状"><a class="header" href="#3-rnn-期望的输入形状">3. RNN 期望的输入形状</a></h4>
<pre><code class="language-python"># 以字母预测为例    a-&gt;b b-&gt;c c-&gt;d d-&gt;e e-&gt;a
x_train = np.reshape(x_train, (len(x_train), 1, 5))
'''
三个参数分别是 (送入样本数 循环核时间展开步数 每个时间步输入特征数)
这里每次输入一个字母 返回一个预测字母 (输入一次就给出预测结果)  所以循环核时间展开步数为 1
输入特征是独热码 [1,0,0,0,0] 有五个值，所以每个时间步输入特征数为 5
'''
</code></pre>
<h3 id="1-月-16-日"><a class="header" href="#1-月-16-日">1 月 16 日</a></h3>
<h4 id="1-embedding-编码"><a class="header" href="#1-embedding-编码">1. Embedding 编码</a></h4>
<pre><code class="language-python"># 在 sequential 中搭建神经网络时先进行 embedding 编码
# 1. 将 x_train 变成 embedding 期待的形状
x_train = np.reshape(x_train, (len(x_train), 1)  # (样本数，时间展开步数)
# 2. 搭建神经网络
model = tf.keras.Sequential([
    Embedding(5,2),   # (需要表示的结果数量，编码维度 (几个数字能表示一个结果))
    SimpleRNN(3),
    Dense(5, activation='softmax')
])
</code></pre>
<h4 id="2-spring-mvc"><a class="header" href="#2-spring-mvc">2. spring MVC</a></h4>
<pre><code class="language-java">    /// 1. 普通传参
	@RequestMapping(value=&quot;/index3&quot;, method = RequestMethod.POST, params={&quot;name&quot;, &quot;id=10&quot;})
    // ！！！注意！！！id 的类型已经被自动完成类型转换
    //0 public String index3(String name, int id) {    正常
    //(1) 如果不想用 name 和 id 作为参数  需要进行参数绑定
    //(2)（1）public String index3(String str, int age) {    报错
    //(2)（2）public String index3(String str, Integer age) {   不报错 但值均为 Null
    public String index3(@RequestParam(&quot;name&quot;) String str,@RequestParam(&quot;id&quot;) int age) {
        System.out.println(&quot;执行了带有参数的 POST 请求&quot;);
        // return &quot;您传递的 name 是&quot; + name + &quot; id 是&quot; + id;
        return &quot;您传递的 name 是&quot; + str + &quot; id 是&quot; + age;
    }
    /// 2. rest 风格的传参  必须进行参数映射
    @RequestMapping(value=&quot;/rest/{name}/{id}&quot;, method = RequestMethod.POST)
    public String rest(@PathVariable(&quot;name&quot;) String name,@PathVariable(&quot;id&quot;) int id) {
        return &quot;您传递的 name 是&quot; + name + &quot; id 是&quot; + id;
    }

    /// 3. 取出 cookie 信息
    @RequestMapping(&quot;/cookie&quot;)
    public String cookie (@CookieValue(value = &quot;JSESSIONID&quot;) String sessionId) {
        return &quot;SESSIONID: &quot; + sessionId ;
    }
</code></pre>
<h4 id="3-springboot水"><a class="header" href="#3-springboot水">3. SpringBoot(水)</a></h4>
<pre><code class="language-yml">server:
  port: 8081  # 默认端口
</code></pre>
<h4 id="4-pandas-读取列"><a class="header" href="#4-pandas-读取列">4. pandas 读取列</a></h4>
<pre><code class="language-python">data = pd.read_csv('./pandas/test.csv')
# 1. loc 单行
# 2. iloc[1:2,3:4] 按索引 行和列
# 3. iloc[[1,2,3], [2,3]] 第 1,2,3 行的第 2,3 列
data_name_and_score = data.iloc[1:2, 1:3].values  # iloc 方法 [行，列] 都是前闭后开  结果以二维数组表示
# 4. 写入 csv/excel
df.to_csv('a.csv')
df.to_excel('a.xlsx', sheet_name='sheet1')
</code></pre>
<h4 id="5-numpy"><a class="header" href="#5-numpy">5. numpy</a></h4>
<pre><code class="language-python"># 1. np.asarray() 可以将数据转为 numpy 格式
# 2. data.flatten() 可以将数据拉为一维
# 3. reshaape(data, (1,-1))   (数据，形状) 不必多说
</code></pre>
<h3 id="1-月-17-日"><a class="header" href="#1-月-17-日">1 月 17 日</a></h3>
<h4 id="1-sequential-参数"><a class="header" href="#1-sequential-参数">1. Sequential 参数</a></h4>
<pre><code class="language-python"># 1. RNN
SimpleRNN(80, return_sequences=True),  # 两层都是 RNN 时，前一层要加上 return_sequences=True
# 2. Dropout
Dropout(0.2),  # 随即扔掉一些神经元，防止过拟合，可以先设为 0，逐渐调大，找到最优值
</code></pre>
<h4 id="2-cp_callbacks-参数"><a class="header" href="#2-cp_callbacks-参数">2. cp_callbacks 参数</a></h4>
<pre><code class="language-python">cp_callback = tf.keras.callbacks.ModelCheckPoint(
    filepath = checkpoint_save_path,
    save_weights_only = True,
    save_best_only = True,
    monitor = 'var_loss', # 指定需要监测的值
)
</code></pre>
<h4 id="3-modelfit-参数"><a class="header" href="#3-modelfit-参数">3. model.fit 参数</a></h4>
<pre><code class="language-python"># 都用来描述验证集，与测试集不同
validation_data=(x_test, y_test),
validation_freq=1,
'''
其实验证集是从训练集中抽取出来用于调参的，
而测试集是和训练集无交集的，用于测试所选参数用于该模型的效果的，这个还是不要弄错了。。。
在 Keras 中，验证集的划分只要在 fit 函数里设置 validation_split 的值就好了，这个对应了取训练集中百分之几的数据出来当做验证集。
'''
</code></pre>
<ol>
<li>
<p>训练集（train set）—— 用于模型拟合的数据样本。在训练过程中对训练误差进行梯度下降</p>
<blockquote>
<p>作用：训练的权重参数。</p>
</blockquote>
</li>
<li>
<p>验证集（validation set）—— 是模型训练过程中单独留出的样本集，</p>
<blockquote>
<p>作用：调整模型的超参数
验证集可以用在训练的过程中，一般在训练时，几个 epoch 结束后跑一次验证集看看效果。(验证得太频繁会影响训练速度) 这样做的第一个好处是，可以及时发现模型或者参数的问题，比如模型在验证集上发散啦、出现很奇怪的结果啦 (如无穷大)、mAP 不增长或者增长很慢啦等等情况，这时可以及时终止训练，重新调参或者调整模型，而不需要等到训练结束。另外一个好处是验证模型的泛化能力，如果在验证集上的效果比训练集上差很多，就该考虑模型是否过拟合了。同时，还可以通过验证集对比不同的模型。在一般的神经网络中，
我们用验证数据集去寻找最优的网络深度（number of hidden
layers)，或者决定反向传播算法的停止点或者在神经网络中选择隐藏层神经元的数量；
由于验证集是用来”训练”超参数的，尽管验证集的误差通常会比训练集误差小，一般来说验证集比较小会低估泛化误差。所有超参数优化完成之后，泛化误差可能会通过测试集来估计。
在普通的机器学习中常用的交叉验证（Cross Validation) 就是把训练数据集本身再细分成不同的验证数据集去训练模型。</p>
</blockquote>
</li>
<li>
<p>测试集 —— 用来评估模最终模型的泛化能力。但不能作为调参、选择特征等算法相关的选择的依据。</p>
<blockquote>
<p>作用：只是验证</p>
</blockquote>
</li>
</ol>
<h4 id="4-归一化操作"><a class="header" href="#4-归一化操作">4. 归一化操作</a></h4>
<pre><code class="language-python">from sklearn.preprocessing import MinMaxScaler
motai = pd.read_csv('./tensorflow/SH600519.csv')
train_set = motai.iloc[:2426-300,2:3].values
test_set = motai.iloc[2426-300:,2:3].values
# !! 归一化 !!
sc = MinMaxScaler(feature_range=(0,1))  # 定义归一化，选定范围到 (0-1) 间
train_set_scaled = sc.fit_transform(train_set)
# fit 求得训练集固有属性 (如平均值，最大值，方差等), transform 对训练集进行归一化
test_set = sc.transform(test_set)
# 利用训练集的属性对测试集进行归一化
</code></pre>
<h4 id="5-tensorboard-使用"><a class="header" href="#5-tensorboard-使用">5. TensorBoard 使用</a></h4>
<pre><code class="language-python"># 1. 设置路径和文件名
log_dir=&quot;logs/fit/&quot; + datetime.datetime.now().strftime(&quot;%Y%m%d-%H%M%S&quot;)
# 2. 添加 tf.keras.callback.TensorBoard 回调可确保创建和存储日志
tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=1)
# 3. callbacks 中加入
callbacks = [cp_callback,tensorboard_callback]
# 4. 控制台运行  (需要将 tensorboard 加入环境变量  例如:C:\Users\YMZ\anaconda3\envs\tf2\Scripts  )
tensorboard --logdir logs/fit
</code></pre>
<h3 id="1-月-18-日"><a class="header" href="#1-月-18-日">1 月 18 日</a></h3>
<h4 id="1-傻子预测股市"><a class="header" href="#1-傻子预测股市">1. 傻子预测股市</a></h4>
<ol>
<li>输入 : 60 天的开盘价</li>
<li>输出 : 61 天的开盘价</li>
<li>把预测的 61 天当作输入值 , 重复上述实验</li>
<li>结果 : 曲线趋于平坦，没用</li>
</ol>
<pre><code class="language-python">i = 500
data60_ori = maotai.iloc[:1213,2:3].values
def pre(i, data60_ori):
    i -= 1
    if i &gt; 0:
        data60 = data60_ori
        data60 = sc.transform(data60)
        readyfortest = []
        readyfortest.append(data60[len(data60)-60:len(data60),0])
        readyfortest = np.array(readyfortest)
        readyfortest = np.reshape(readyfortest, (readyfortest.shape[0], 60, 1))
        preprice = model.predict(readyfortest)
        preprice = sc.inverse_transform(preprice)
        data60_ori = np.vstack((data60_ori, preprice))
        pre(i, data60_ori)
    else:
        print('------over------')
        print(data60_ori.shape)
        plt.plot(all_set, c='r', label='Real Price')
        plt.plot(data60_ori, c='b', label='Predict Price')
        plt.plot(test1, c='y', label='Predict Price')
        plt.legend()
        plt.show()
</code></pre>
<h4 id="2-pandas-删除列"><a class="header" href="#2-pandas-删除列">2. pandas 删除列</a></h4>
<pre><code class="language-python"># 在数据预处理中，需要删除 dataframe 的一列的话，可以使用下面的方法。
train = train.drop(['A'], axis=1)
# 其中 axis=1 代表的是要删除一列，而不是一行。
</code></pre>
<h4 id="3-pandas-解析时间"><a class="header" href="#3-pandas-解析时间">3. pandas 解析时间</a></h4>
<pre><code class="language-python">trips = pd.read_csv('./data/trips.csv',encoding='gbk')
# 1. 转换格式
trips['进站时间'] = pd.to_datetime(trips['进站时间'],format=&quot;%Y/%m/%d %H:%M&quot;)
# 2. 解析
year = trips['某一列'].dt.year  # 获取一列
year = trips['某一列'][int index].year # 只获取一个
</code></pre>
<h4 id="4-pandas-筛选数据"><a class="header" href="#4-pandas-筛选数据">4. pandas 筛选数据</a></h4>
<pre><code class="language-python"># 1. ==
print( trips.loc[ trips['进站时间'].dt.month.isin([4,5]) ])
# 2. is in []
print( trips.loc[ trips['进站时间'].dt.month.isin([2,3,4]) ])
# 3.  &amp; | !
注意只有一个 &amp; 或 |
# 4. 筛选结果计数 (两种都行)
print( trips.loc[ trips['进站时间'].dt.month.isin([2,3,5,6,7]) ].count())
print( trips.loc[ trips['进站时间'].dt.month.isin([2,3,5,6,7]) ]['进站时间'].count())
</code></pre>
<h3 id="1-月-19-日"><a class="header" href="#1-月-19-日">1 月 19 日</a></h3>
<h4 id="1-pandas-行列操作"><a class="header" href="#1-pandas-行列操作">1. pandas 行列操作</a></h4>
<pre><code class="language-python"># 1. 判断是星期几
trips['dayofweek'] = trips['进站时间'].dt.dayofweek
# 2. 新增行/列
trips['new_col'] = '0'
trips.loc['new_row'] = '0'
# 3. 遍历行
for index, row in trips.iterrows():
# 4. 替换某格数据
trips.iloc[index,10] = row_[1]
</code></pre>
<h4 id="2-pandas-日期-完整"><a class="header" href="#2-pandas-日期-完整">2. pandas 日期 (完整)</a></h4>
<pre><code class="language-python">pandas 日期时间数据的分割提取操作
import pandas as pd
import numpy as np
import time
s=time.time()
data_2019=pd.read_excel('d:\\data\\abc.xlsx')
data=data_2019[['卡号','交易时间']]
data['日期'] =data_2019['交易时间'].dt.date
data['时间'] =data_2019['交易时间'].dt.time
data['年'] = data_2019['交易时间'].dt.year
data['季节'] = data_2019['交易时间'].dt.quarter
data['月'] = data_2019['交易时间'].dt.month
data['周']=data_2019['交易时间'].dt.week
data['日'] = data_2019['交易时间'].dt.day
data['小时'] =data_2019['交易时间'].dt.hour
data['分钟'] =data_2019['交易时间'].dt.minute
data['秒'] = data_2019['交易时间'].dt.second
data['一年第几天'] =data_2019['交易时间'].dt.dayofyear
data['一年第几周'] = data_2019['交易时间'].dt.weekofyear
data['一周第几天'] = data_2019['交易时间'].dt.dayofweek
data['一个月含有多少天'] = data_2019['交易时间'].dt.days_in_month
data['星期名称'] =data_2019['交易时间'].dt.weekday_name
print(data)
data.to_excel('d:\\data\\abcsss.xlsx')
</code></pre>
<h4 id="3-series-对象"><a class="header" href="#3-series-对象">3. Series 对象</a></h4>
<pre><code class="language-python"># Series 常用属性和方法
获取数据的值，使用 values 方法
获取索引的值，使用 index 方法
获取每对索引的值，使用 items 方法
</code></pre>
<h3 id="1-月-20-日"><a class="header" href="#1-月-20-日">1 月 20 日</a></h3>
<h4 id="1-获取某月天数"><a class="header" href="#1-获取某月天数">1. 获取某月天数</a></h4>
<pre><code class="language-python">import calendar
res = calendar.monthrange(2020,5)
print(res[1])
</code></pre>
<h4 id="2-纵向显示-x-轴坐标"><a class="header" href="#2-纵向显示-x-轴坐标">2. 纵向显示 x 轴坐标</a></h4>
<pre><code class="language-python">df = pd.DataFrame(pd.read_csv('./sta_flow_by_day.csv'))

plt.xticks(rotation=270)
plt.bar([f'{month}.{day}' for month, day in zip(np.array(df['month']), np.array(df['day']))], np.array(df['flow']))
plt.show()
</code></pre>
<h4 id="3-pandas-筛选注意"><a class="header" href="#3-pandas-筛选注意">3. pandas 筛选注意</a></h4>
<pre><code class="language-python"># 不同条件一定要加括号
df = df.loc[(df['sta'] == 'Sta1') &amp; (df['month']==2)]
</code></pre>
<h3 id="1-月-21-日"><a class="header" href="#1-月-21-日">1 月 21 日</a></h3>
<h4 id="1-分割线-水"><a class="header" href="#1-分割线-水">1. 分割线 (水)</a></h4>
<pre><code class="language-python">print('#-&amp;-$-@-%-'*13)
</code></pre>
<h4 id="2-防止无-key"><a class="header" href="#2-防止无-key">2. 防止无 key</a></h4>
<blockquote>
<h6 id="try-except-真好用"><a class="header" href="#try-except-真好用">try except 真好用</a></h6>
</blockquote>
<pre><code class="language-python">for key in stas.keys():
    month = stas[key]
    for sta in month.keys():
        try:
            big_dict[sta][key] = month[sta]
        except:
            try:
                big_dict_gun[sta][key] = month[sta]
            except:
                big_dict_gun[sta] = {}
</code></pre>
<h4 id="3-onehot-应用"><a class="header" href="#3-onehot-应用">3. onehot 应用</a></h4>
<pre><code class="language-python"># 2. 把 route 列转为 onehot 编码
enc_route = sklearn.preprocessing.OneHotEncoder(sparse=False) # Key here is sparse=False!
route_onehot = enc_route.fit_transform(np.array(list(df['route'])).reshape(len(df['route']),1))
print(df['route'].shape)
print(route_onehot)

# fit_transform = fit + transform
# 之后可以用 enc_route.transform() 编码测试集
</code></pre>
<h3 id="1-月-22-日"><a class="header" href="#1-月-22-日">1 月 22 日</a></h3>
<h4 id="1-反归一化-117"><a class="header" href="#1-反归一化-117">1. 反归一化 (1.17)</a></h4>
<pre><code class="language-python">preprice = model.predict(readyfortest)
preprice = sc.inverse_transform(preprice)
</code></pre>
<h4 id="2-pandas-排序"><a class="header" href="#2-pandas-排序">2. pandas 排序</a></h4>
<pre><code class="language-python">#默认为升序
df_3 = df.sort_values(by=['day','flow'])
</code></pre>
<h3 id="123-日-127-日"><a class="header" href="#123-日-127-日">1.23 日~ 1.27 日</a></h3>
<h4 id="1神经网络经验总结"><a class="header" href="#1神经网络经验总结">1.神经网络经验总结</a></h4>
<pre><code class="language-python"># 1. 模型隐藏层层数设置
1. 在神经网络中，当且仅当数据非线性分离时才需要隐藏层！
2. 对于一般简单的数据集，一两层隐藏层通常就足够了。但对于涉及时间序列或计算机视觉的复杂数据集，则需要额外增加层数。单层神经网络只能用于表示线性分离函数，也就是非常简单的问题，比如分类问题中的两个类可以用一条直线整齐地分开。
3. 一般规律
没有隐藏层：仅能够表示线性可分函数或决策
隐藏层数=1：可以拟合任何“包含从一个有限空间到另一个有限空间的连续映射”的函数
隐藏层数=2：搭配适当的激活函数可以表示任意精度的任意决策边界，并且可以拟合任何精度的任何平滑映射
隐藏层数&gt;2：多出来的隐藏层可以学习复杂的描述（某种自动特征工程）
# 2. 模型隐藏层神经元个数设置
1、隐藏单元的数量不应该超过输入层中单元的两倍
2、隐藏单元的大小应该介于输入单元和输出单元之间
3、神经元的数量应捕获输入数据集方差的 70~90%
# 3. 注意输入训练集的形状
# 4. 注意输入层特征的输入顺序
与输出层关联性强的放前面
有些关联性弱的特征加入会严重扰乱准确性 比如 day
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文档页"><a class="header" href="#文档页">文档页</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="magic"><a class="header" href="#magic">magic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="risc-v"><a class="header" href="#risc-v">RISC-V</a></h1>
<h2 id="risc-v-特点"><a class="header" href="#risc-v-特点">RISC-V 特点</a></h2>
<ol>
<li>增量 ISA(指令集架构)</li>
</ol>
<ul>
<li>核心是名为 RV32I 的核心 ISA，它是固定的永远不会改变</li>
<li>可以增加拓展，例如 RV32IMDF 将乘法 (RV32M),单精度浮点 (RV32D) 和双精度浮点 (RV32D) 的拓展添加到了基础指令集中。</li>
<li>RISC-V 编译器可以根据拓展生成当前硬件环境下的最佳代码</li>
</ul>
<h2 id="isa"><a class="header" href="#isa">ISA</a></h2>
<h3 id="isa-设计"><a class="header" href="#isa-设计">ISA 设计</a></h3>
<ul>
<li>成本</li>
<li>简洁性
<ul>
<li>ISA 的简洁性，从而缩小实现 ISA 的处理器的尺寸</li>
</ul>
</li>
<li>性能</li>
<li>架构和具体实现的分离</li>
<li>提升空间</li>
<li>程序大小</li>
<li>易于编程/编译/链接</li>
</ul>
<h3 id="rv32i-指令格式"><a class="header" href="#rv32i-指令格式">RV32I 指令格式</a></h3>
<p>六种基本指令格式分别是：</p>
<ul>
<li>用于 <code>寄存器-寄存器</code> 操作的 R 类型指令</li>
<li>用于短立即数和访存 load 操作的 I 型指令</li>
<li>用于访存 store 操作的 S 型指令</li>
<li>用于条件跳转操作的 B 类型指令</li>
<li>用于长立即数的 U 型指令</li>
<li>用于无条件跳转的 J 型指令</li>
</ul>
<p>优势：</p>
<ul>
<li>指令只有六种格式，并且所有的指令都是 32 位长，这简化了指令解码</li>
<li>第二，RISC-V 指令提供三个寄存器操作数，而不是像 x86-32 一样，让源操作数和目的操作数共享一个字段。(节约了 1 条 move（搬运）指令)</li>
</ul>
<h3 id="寄存器"><a class="header" href="#寄存器">寄存器</a></h3>
<ul>
<li>RV32I 有 31 寄存器加上一个值恒为 0 的 x0 寄存器。</li>
<li>ARM-32 只有 16 个寄存器</li>
<li>x86-32 甚至只有 8 个寄存器。</li>
</ul>
<ol>
<li>
<p>为常量 0 单独分配一个寄存器是 RISC-V ISA 能如此简单的一个很
大的因素。而 ARM-32 和 x86-32 指令集中没有零寄存器。</p>
</li>
<li>
<p>程序计数器（PC）是 ARM-32 的 16 个寄存器之一，这意味着任何改变寄存器的指令
都有可能导致分支跳转。PC 作为一个寄存器使硬件分支预测变得复杂，因为在典型的 ISA
中，仅 10%-20% 的指令为分支指令，而在 ARM-32 中，任何指令都有可能是分支指令。而
分支预测的准确性对于良好的流水线性能至关重要。另外将 PC 作为一个寄存器也意味着
可用的通用寄存器少了一个。</p>
</li>
</ol>
<table><thead><tr><th>寄存器</th><th>功能</th></tr></thead><tbody>
<tr><td>x0 / szero</td><td>硬连线到 0 (Hardwired zero)</td></tr>
<tr><td>x1 / ra</td><td>返回地址 (Return address)</td></tr>
<tr><td>x2 / sp</td><td>栈指针 (Stack pointer)</td></tr>
<tr><td>x3 / gp</td><td>全局指针 (Global pointer)</td></tr>
<tr><td>x4 / tp</td><td>线程指针 (Thread pointer)</td></tr>
<tr><td>x5 / t0</td><td>临时 (Temporary)</td></tr>
<tr><td>x6 / t1</td><td>临时</td></tr>
<tr><td>x7 / t2</td><td>临时</td></tr>
<tr><td>x8 / s0 / fp</td><td>保存寄存器 (saved register) / frame pointer</td></tr>
<tr><td>x9 / s1</td><td>保存寄存器</td></tr>
<tr><td>x10 / a0</td><td>函数参数 (Function argument), 返回地址</td></tr>
<tr><td>x11 / a1</td><td>函数参数，返回地址</td></tr>
<tr><td>x12 / a2</td><td>函数参数</td></tr>
<tr><td>x13 / a3</td><td>函数参数</td></tr>
<tr><td>x14 / a4</td><td>函数参数</td></tr>
<tr><td>x15 / a5</td><td>函数参数</td></tr>
<tr><td>x16 / a6</td><td>函数参数</td></tr>
<tr><td>x17 / a7</td><td>函数参数</td></tr>
<tr><td>x18 / s2</td><td>保存寄存器</td></tr>
<tr><td>x19 / s3</td><td>保存寄存器</td></tr>
<tr><td>x20 / s4</td><td>保存寄存器</td></tr>
<tr><td>x21 / s5</td><td>保存寄存器</td></tr>
<tr><td>x22 / s6</td><td>保存寄存器</td></tr>
<tr><td>x23 / s7</td><td>保存寄存器</td></tr>
<tr><td>x24 / s8</td><td>保存寄存器</td></tr>
<tr><td>x25 / s9</td><td>保存寄存器</td></tr>
<tr><td>x26 / s10</td><td>保存寄存器</td></tr>
<tr><td>x27 / s11</td><td>保存寄存器</td></tr>
<tr><td>x28 / t3</td><td>临时</td></tr>
<tr><td>x29 / t4</td><td>临时</td></tr>
<tr><td>x30 / t5</td><td>临时</td></tr>
<tr><td>x31 / t6</td><td>临时</td></tr>
<tr><td></td><td></td></tr>
<tr><td>PS</td><td>程序计数器</td></tr>
</tbody></table>
<p>保存寄存器和临时寄存器为什么不是连续编号的？</p>
<p>为了支持 RV32E——一个只有 16 个寄存器的嵌入式版本的 RISC-V（参见第 11 章），只使用寄存器 x0 到 x15——一部分保存寄存器和一部分临时寄存器都在这个范围内。其它的保存寄存器和临时寄存器在剩余 16 个寄存器内。RV32E 较小，但由于和 RV32I 不匹配，目前还没有编译器支持。</p>
<h2 id="计算机中的指令表示"><a class="header" href="#计算机中的指令表示">计算机中的指令表示</a></h2>
<h3 id="指令"><a class="header" href="#指令">指令</a></h3>
<p><img src="docs/magic/./riscv/instructions_size.jpg" alt="size" />
<img src="docs/magic/./riscv/instructions_usage.jpg" alt="usage" />
<img src="docs/magic/./riscv/instructions_format.jpg" alt="format" />
<img src="docs/magic/./riscv/instructions_binary2asm.jpg" alt="binary2asm" /></p>
<h3 id="计算指令"><a class="header" href="#计算指令">计算指令</a></h3>
<ul>
<li>简单计算：add, sub</li>
<li>逻辑指令：and, or, xor</li>
<li>移位指令：sll, srl, sra</li>
<li>小于时置位：slt, altu (unsigned), 立即数版 (slti，sltiu)</li>
</ul>
<h3 id="决策指令"><a class="header" href="#决策指令">决策指令</a></h3>
<h4 id="判断-if-then-else"><a class="header" href="#判断-if-then-else">判断 (if-then-else)</a></h4>
<pre><code class="language-c">// f,   g,   h,   i,   j
// x19, x20, x21, x22, x23

if (i == g)
    f = g + h;
else
    f = g - h;
</code></pre>
<p>除了 Else 标签之外，还需要有一个 Exit 的标签，用于 If 执行完跳过 Else。</p>
<pre><code class="language-assembly">    bne x22, x23, Else  // if
    add x19, x20, x21
    beq x0, x0, Exit    // 无条件分支的一种实现方法
Else: sub x19, x20. x21 // else
Exit:
</code></pre>
<h4 id="循环-for--while"><a class="header" href="#循环-for--while">循环 (for / while)</a></h4>
<pre><code class="language-c">// i: x22, k: x24, save: x25
while (save[i] == k)
    i += 1;
</code></pre>
<ul>
<li>将 <code>save[i]</code> 加载到临时寄存器里。
<ul>
<li>加载 <code>save[i]</code> 前还需要得到它的地址，将 i 加到 save 的基址上。</li>
<li>由于字节寻址问题，i 还需要乘 8。这个可以通过左移实现</li>
<li>添加 Loop 标签</li>
</ul>
</li>
</ul>
<pre><code class="language-asm">      slid x10, x22, 3  ; i * 8, 并存到 x10 里
      add x10, x10, x25 ; 在加上 save 基址
      ld x9, 0(x10)     ; 将 x10 存储到临时寄存器
Loop: bne x9, x24, Exit ; 比较
      addi x22, x22, 1  ; i = i + １
      beq x0, x0, Loop  ; 继续循环
Exit：
</code></pre>
<h4 id="case--switch"><a class="header" href="#case--switch">case / switch</a></h4>
<p>实现方法：</p>
<ol>
<li>转换为一系列 if-then-else</li>
<li>更高效的方法：使用分支地址表或分支表。</li>
</ol>
<h3 id="过程指令-函数"><a class="header" href="#过程指令-函数">过程指令 (函数)</a></h3>
<h4 id="过程调用时的寄存器的分配"><a class="header" href="#过程调用时的寄存器的分配">过程调用时的寄存器的分配</a></h4>
<ul>
<li><code>x0</code> 硬连线为 0</li>
<li><code>x10 - x17</code>: 参数寄存器，用于传递参数或者返回值</li>
<li><code>x1</code>: 一个返回地址寄存器</li>
</ul>
<h4 id="跳转指令"><a class="header" href="#跳转指令">跳转指令</a></h4>
<ul>
<li><code>jal</code>: 跳转 - 链接指令</li>
</ul>
<pre><code class="language-asm">jal x1, ProcedureAddress
</code></pre>
<p>跳转到 ProcedureAddress 并把下一条指令的返回值保存到目标寄存器 <strong><code>rd</code></strong>.</p>
<blockquote>
<p>在存储程序中，总需要一个寄存器存储当前指令的地址，这个寄存器被称为 &quot;程序计数器&quot;, 缩写为 &quot;PC&quot;.所以 <code>jal</code> 指令实际上是将 <code>PC + 4</code> 写入到 x1 中</p>
</blockquote>
<ul>
<li><code>jalr</code> 间接跳转，可以用于处理 case 语句。</li>
</ul>
<pre><code class="language-asm">jalr x0, 0(x1)
</code></pre>
<p>由于 x0 硬连线到 0，所以其效果是丢弃返回地址</p>
<p>当用户 <code>jal x1 X</code> <code>jalr x0, 0(x1)</code></p>
<h4 id="使用更多寄存器"><a class="header" href="#使用更多寄存器">使用更多寄存器</a></h4>
<p>假设一个过程需要比 8 个更多的寄存器，需要将寄存器换出到存储器。</p>
<p>换出寄存器的理想结构是栈，栈中需要一个指针，指向下一个过程应该放置寄存器的位置（或者旧寄存器值的存放位置）。在 RISC-V 中，栈指针是 <code>x2</code> 也称 <code>sp</code>。</p>
<pre><code class="language-c">// g: x10, h: x11, i: x12, j: x13
// f: x20
// 临时寄存器：x5, x6
long long int leaf_example(long long int g, long long int h, long long int i, long long int k) {
    long long int f;
    f = (g + h) - (i + j);
    return f;
}
</code></pre>
<p>汇编：</p>
<pre><code class="language-asm">leaf_example:
    ; 压栈 (sd 从寄存器取双字到存储器)
    addi sp, sp, -24
    sd x5, 16(sp)        ; tmp1
    sd x6, 8(sp)         ; tmp2
    sd x20, 0(sp)        ; f

    ; 计算
    add x5, x10, x11     ; x5 = g + h
    add x6, x12, x13     ; x6 = i + j
    sub x20, x5, x6      ; f = x5 - x6

    ; 把返回值复制到一个参数寄存器
    addi x10, x20, 0     ; f -&gt; x10

    ; 弹栈 (ld 从存储器取双字到寄存器)
    ld x20, 0(sp)
    ld x6, 8(sp)
    ld x5, 16(sp)
    addi sp, sp, 24

    ; 返回
    jalr x0, 0(x1)
</code></pre>
<p>上面使用了 x5 和 x6 作为临时寄存器，并假设它的旧值必须被保存和恢复。为了避免保存和恢复一个其值从没被用过的寄存器 (通常称为临时寄存器), RISC-V 把寄存器分为类两组：</p>
<ul>
<li>x5 ~ x7, x28 ~ x31: 临时寄存器，在过程调用时，不会被调用者保存。</li>
<li>x8 ~ x9, x18 ~ x27: 保存寄存器 (saved register), 在过程调用中，必须被保存。</li>
</ul>
<p>这一约定，减少了寄存器换出，x5, x6 不用保存，减少了两次存储和载入，x20 必须保存和恢复。</p>
<h4 id="嵌套过程"><a class="header" href="#嵌套过程">嵌套过程</a></h4>
<p>不调用其他过程的过程称为 leaf 进程</p>
<p>如何解决嵌套？</p>
<p>将其他所有必须保存的寄存器压栈。调用者将所有参数寄存器 (x10 ~ x17) 或临时寄存器 (x5~x7 和 x28 ~ x31) 压栈，被调用者将返回地址寄存器 x1 和被调用者使用的保存寄存器 (x8~x9 和 x18 ~ x27) 压栈。</p>
<pre><code class="language-c">long long int fact(long long int n) {
    if (n &lt; 1)
        return 1;
    else
        return n * fact(n - 1);
}
</code></pre>
<p>汇编：</p>
<pre><code class="language-asm">fact:
    ; 压栈
    addi sp, sp, -16   ; 参数 n 和返回地址 x1
    sd x1, 8(sp)       ; 把返回地址 x1 存到 8[sp] 中
    sd x10, 0(sp)      ; 把 x10 [[参数 n]] 存到 0[sp] 中

    ; 判断
    addi x5, x10, -1   ; x5 = n - 1
    bge x5, x0, L1     ; if (n - 1 &gt;= 0) goto L1;

    ; true
    addi x10, x0, 1    ; x10 = 1

    addi sp, sp, 16    ; 弹栈
    jalr x0, 0(x1)     ; 跳回去 x1
L1:
    ; false
    addi x10, x10, -1  ; [[x10 = n - 1]]
    jal x1, fact       ; fact // 这里发生递归

    addi x6, x10, 0    ; 把计算结果存到 x6

    ld x10, 0(sp)
    ld x1, 8(sp)
    addi sp, sp, 16    ; 弹栈

    mul x10, x10, x6   ; return n * fact(n - 1)
    jalr x0, 0(x1)
</code></pre>
<p>通过把返回地址 (PC + 4) 存到栈上实现了返回。</p>
<h4 id="尾递归"><a class="header" href="#尾递归">尾递归</a></h4>
<pre><code class="language-c">long long int sum(long long int n, long long int acc) {
    if (n &gt; 0)
        return sum(n - 1, acc + n);
    else
        return acc;
}
</code></pre>
<p>这种求和的递归可以用迭代高效实现</p>
<pre><code class="language-asm">    ; 假设 x10 = n, x11 = acc, 结果放入 x12
sum:
    ble x10, x0, sum_exit
    add x11, x11, x10
    addi x10, x10, -1
    jal x0, sum
sum_exit:
    addi x12, x11, 0
    jalr x0, 0(x1)
</code></pre>
<h3 id="字符处理指令"><a class="header" href="#字符处理指令">字符处理指令</a></h3>
<p>RISC-V 中一系列指令可以从双字中提取一个字节</p>
<ul>
<li><code>lbu</code> (加载无符号字节): 从内存中加载一个字节，放到寄存器的最右边八位</li>
<li><code>sb</code> (存储字节): 从存储器最右边八位取一个字节并写入内存</li>
</ul>
<pre><code class="language-asm">lbu x12 0(x10) // read from x10
sb x12 0(x11)  // write to x11
</code></pre>
<p>字符串的设计：</p>
<ol>
<li>字符串第一位保留，表示字符串长度</li>
<li>附加长度的变量（如结构体）</li>
<li>字符串的结尾用一个字符标记结尾</li>
</ol>
<p><code>strcpy</code> 的汇编实现</p>
<pre><code class="language-c">void strcpy(char x[], char y[]) {
    size_t i;
    i = 0;
    while ((x[i] = y[i]) != '\0') { // copy &amp; test byte
        i += 1;
    }
}
</code></pre>
<p>假设 x: x10, y: x11, i: x19</p>
<pre><code class="language-asm">strcpy:
    addi sp, sp, -8   ; 压栈
    sd x19, 0(sp)     ; 保存 i
    add x19, 0, 0;    ; i = 0 + 0
L1:
    add x5, x19, x11  ; 计算 数组基址 + 偏移量 (i)
    lbu x6, 0(x5)     ; 加载对应字节，注意：这里不用 *8，因为是字节数组

    bep x6, x0, L2
    addi x19, x19, 1  ; if (== '\0')
    jal x0, L1
L2:
    ld x19, 0(sp)     ; else
    addi sp, sp, 8    ; 弹栈
    jalr x0, 0(x1)    ; 返回
</code></pre>
<h3 id="大立即数"><a class="header" href="#大立即数">大立即数</a></h3>
<p>假如常量超过了 12 位怎么办？</p>
<p>RISC-V 提供了 lui (load upper immediate) 指令 (取高位立即数)，能够将 20 位常量加载到寄存器的第 31 到 12 位。</p>
<p>将以下 64 位常量加载到寄存器 x19：</p>
<pre><code class="language-asm">; 00000000 00000000 00000000 00000000 00000000 00111101 00000101 00000000


; 加载前 20 位
lui x19, 976                   ; 976: 00000000 00111101

; 此时 x19
; 00000000 00000000 00000000 00000000 00000000 00111101 00000000 00000000

; 加载后 12 位
addi x19, x19, 1280                             ; 1280: 00000101 00000000
</code></pre>
<h3 id="swap-和-排序"><a class="header" href="#swap-和-排序">swap 和 排序</a></h3>
<h4 id="swap"><a class="header" href="#swap">swap</a></h4>
<pre><code class="language-c">void swap(long long int v[], size_t k) {
    long long int temp;
    temp = v[k];
    v[k] = v[k + 1];
    v[k + 1] = temp;
}
</code></pre>
<p>手动把 C 翻译为 ASM 时，我们遵循一下步骤：</p>
<ol>
<li>为程序中的变量分配寄存器</li>
<li>为过程生成汇编代码</li>
<li>保存过程调用间的寄存器</li>
</ol>
<p>下面是详细过程：</p>
<p>寄存器的分配。RISC-V 参数传递默认使用 x10 和 x17 寄存器，由于 swap 只有两个参数，所以可以在 x10 和 x17 保存。</p>
<p>还剩一个变量 temp，我们用 x5 保存它。</p>
<p>剩下的 C 过程代码：</p>
<pre><code class="language-c">temp     = v[k];
v[k]     = v[k + 1];
v[k + 1] = tmep;
</code></pre>
<p>对应的 ASM:</p>
<pre><code class="language-asm">; 使用数组基址 + 8 * i 计算地址
alli x6, x11, 3     ; reg x6 = k * 8
add  x6, x10, x6    ; reg x6 = x6 + (k * 8)

; 加载数组数据到寄存器
ld x5, 0(x6)        ; reg x5 (temp) = v[k]
ld x7, 8(x6)        ; reg x7        = v[k + 1]

; 把寄存器数据存入数组
sd x7, 0(x6)        ; v[k]     = reg x7
sd x5, 8(x6)        ; v[k + 1] = reg x5 (temp)
</code></pre>
<p>RISC-V 是字节寻址，双字之间相差了 8 个字节。</p>
<h4 id="sort"><a class="header" href="#sort">sort</a></h4>
<pre><code class="language-c">void sort(long long int v[], size_t int n) {
    size_t i, j;
    for (int i = 0; i &lt; n; i += 1) {
        for (j = i - 1; j &gt;= 0 &amp;&amp; v[j] &gt; v[j + 1]; j -= 1) {
            swap(v, j);
        }
    }
}
</code></pre>
<ol>
<li>
<p>寄存器的分配：</p>
<p>v 和 n 两个参数保存在 x10 和 x11 中，我们将 i 和 j 两个临时寄存器分配在 x19 和 x20 (都是保存寄存器).</p>
</li>
<li>
<p>翻译过程体代码：</p>
<p>过程体由两层 for 循环和一个 swap 调用组成，我们从外到内展开代码。</p>
</li>
</ol>
<h5 id="第一层-for-循环"><a class="header" href="#第一层-for-循环">第一层 for 循环</a></h5>
<p><code>for (int i = 0; i &lt; n; i += 1) {</code>:</p>
<p>for 循环分三步，对 i 做初始化，判断 <code>i &lt; n</code> 和 <code>i += 1</code>, 分别对应下面的汇编指令：</p>
<pre><code class="language-asm">; 初始化
li x19, 0         ; li 是汇编器提供的伪指令, 目的是简化汇编的编写

; i += 1
addi x19, x19, 1

; 判断 i &lt; n
for1tst:
    beg x19, x11, exit1 ; 如果 i &gt;= 0, 则退出
    j for1tst
exit1:
</code></pre>
<p>经过排序后：</p>
<pre><code class="language-asm">li x19, 0
for1tst:
    bge x19, x11, exit1 ; 如果 i &gt;= 0, 则退出
    ...
    ; i 循环的 body
    ...
    addi x19, x19, 1  ; i += 1
    j for1tst         ; 继续循环
exit1:
</code></pre>
<h5 id="第二层循环"><a class="header" href="#第二层循环">第二层循环</a></h5>
<p><code>for (j = i - 1; j &gt;= 0 &amp;&amp; v[j] &gt; v[j + 1]; j -= 1) {</code></p>
<pre><code class="language-asm">; 初始化
addi x20, x19, -1

; j -= 1
addi x20, x20, -1

; 判断条件,任意一个为假都要推出循环
for2tst:
    ; 判断 j &gt;= 0
    ble x20, 0, exit2

    ; 判断 v[j]&gt; v[j + 1]
    ; 先计算地址
    slii x5, x20, 8    ; reg x5 = j * 8
    add x5, x10, x5    ; reg x5 = v = j * 8
    ld x6, 0(x5)       ; 加载 v[j]
    ld x7, 8(x5)       ; 加载 v[j + 1]
    bge x6, x7, exit2  ; 比较
    ...
    (第二个循环的内容)
    ...
    addi x20, x20, -1  ; j -= 1
    j for2tst          ; 重复循环
exit2:
</code></pre>
<h5 id="调用-swap"><a class="header" href="#调用-swap">调用 swap</a></h5>
<p>调用 swap 很容易： <code>j x1 swap</code></p>
<p>swap 需要 x10 (v) 和 x11 (k) 中的值，其中一种方法是：将 swap 的参数提前复制到其他寄存器中，使得 x10 和 x11 在调用 swap 时可用。</p>
<pre><code class="language-asm">mv x21, x10 ; 把 x10 复制到 x21
mv x22, x11 ; 把 x11 复制到 x20
</code></pre>
<p>然后将这两个参数传递给 swap:</p>
<pre><code class="language-asm">mv x10, x21 ; 把 x10 从 x21 恢复回去
mv x11, x20 ; ?
</code></pre>
<p>保留 sort 中的寄存器</p>
<pre><code class="language-asm">sort:
    addi sp, sp, -40
    sd x1, 32(sp)       ; 返回地址
    sd x22, 24(sp)      ; 把 x22 保存到栈
    sd x21, 16(sp)      ; 同上
    sd x20, 8(sp)       ; 同上
    sd x19, 0(sp)       ; 同上
</code></pre>
<h5 id="完整过程"><a class="header" href="#完整过程">完整过程</a></h5>
<pre><code class="language-c">void sort(long long int v[], size_t int n) {
    size_t i, j;
    for (int i = 0; i &lt; n; i += 1) {
        for (j = i - 1; j &gt;= 0 &amp;&amp; v[j] &gt; v[j + 1]; j -= 1) {
            swap(v, j);
        }
    }
}
</code></pre>
<ul>
<li>v 和 n 两个参数保存在 x10 和 x11 中，</li>
<li>i 和 j 两个临时寄存器分配在 x19 和 x20 (都是保存寄存器).</li>
</ul>
<pre><code class="language-asm">
sort:
    addi sp, sp, -40
    sd x1, 32(sp)       ; 返回地址
    sd x22, 24(sp)      ; 把 x22 保存到栈
    sd x21, 16(sp)      ; 同上
    sd x20, 8(sp)       ; 同上
    sd x19, 0(sp)       ; 同上

    ; 为 swap 保存参数
    mv x21, x10 ; 把 x10 (v) 复制到 x21
    mv x22, x11 ; 把 x11 (k) 复制到 x22

    ; 初始化 i = 0
    li x19, 0
for1tst:
    bge x19, x22, exit1 ; 如果 i &gt;= 0, 则退出
    ; 初始化 j = i - 1
    addi x20, x19, -1   ; j = i - 1
for2tst:
    ; 判断 j &gt;= 0
    ble x20, 0, exit2

    ; 判断 v[j]&gt; v[j + 1]
    ; 先计算地址
    slii x5, x20, 8    ; reg x5 = j * 8
    add x5, x10, x5    ; reg x5 = v = j * 8
    ld x6, 0(x5)       ; 加载 v[j]
    ld x7, 8(x5)       ; 加载 v[j + 1]
    bge x6, x7, exit2  ; 如果 v[j] &gt; v[j + 1], 则退出

    ; 恢复寄存器, 并调用 swap
    mv x10, x21
    mv x11, x20
    jal x1, swap

    addi x20, x20, -1  ; j -= 1
    j for2tst          ; 重复循环
exit2:
    addi x19, x19, 1  ; i += 1
    j for1tst         ; 继续循环
exit1:
    ld x19, 0(sp)
    ld x20, 8(sp)
    ld x21, 16(sp)
    ld x22, 24(sp)
    ld x1, 32(sp)
    addi sp, sp, 40
    jalr x0, 0(x1)
</code></pre>
<pre><code class="language-asm">swap:
    ; 使用数组基址 + 8 * i 计算地址
    alli x6, x11, 3     ; reg x6 = k * 8
    add  x6, x10, x6    ; reg x6 = x6 + (k * 8)

    ; 加载数组数据到寄存器
    ld x5, 0(x6)        ; reg x5 (temp) = v[k]
    ld x7, 8(x6)        ; reg x7        = v[k + 1]

    ; 把寄存器数据存入数组
    sd x7, 0(x6)        ; v[k]     = reg x7
    sd x5, 8(x6)        ; v[k + 1] = reg x5 (temp)
</code></pre>
<h3 id="数组和指针"><a class="header" href="#数组和指针">数组和指针</a></h3>
<pre><code class="language-c">clear1(long long int array[], size_t int size) {
    size_t i;
    for (i = 0; i &lt; size; i += 1) {
        array[i] = 0;
    }
}
clear2(long long int *array, size_t int size) {
    long long int *p
    for (p = &amp;array[0]; p &lt; &amp;array[size]; p = p + 1) {
        *p = 0;
    }
}
</code></pre>
<p>假设 array: x10, size: x11, i: x5</p>
<pre><code class="language-asm">    li x5, 0            ; i = 0
loop1:
    slii x6, x5, 3      ; i * 8
    add x7, x10, x6
    sd 0, 0(x7)         ; array[i] = 0
    addi x5, x5, 1
    ble x5, x11, loop1  ; if i &lt; size; goto loop1
</code></pre>
<p>指针实现</p>
<pre><code class="language-asm">    mv x5, x10          ; p(x5) = x10
loop2:
    sd x0, 0(x5)        ; 加载 *p
    addi x5, x5, 8      ; p = p + 8
    slli x6, x11, 3     ; x6 = size + 8
    add x7, x10, x6     ; x7 = &amp;array[size]
    bltu x5, x7, loop2
</code></pre>
<p>这段代码可以优化，将计算 <code>&amp;array[size]</code> 移动到外部：</p>
<pre><code class="language-asm">    mv x5, x10          ; p(x5) = x10
    slli x6, x11, 3     ; x6 = size + 8
    add x7, x10, x6     ; x7 = &amp;array[size]
loop2:
    sd x0, 0(x5)        ; 加载 *p
    addi x5, x5, 8      ; p = p + 8
    bltu x5, x7, loop2
</code></pre>
<p>减少了两条指令，这种优化对应分别于两种编译器优化：</p>
<ul>
<li>&quot;强度削弱&quot;: 使用移位代替乘法</li>
<li>循环变量消除：消除循环内的数组地址计算</li>
</ul>
<h2 id="并发"><a class="header" href="#并发">并发</a></h2>
<p>这里介绍上锁 (lock) 和解锁 (unlock) 的同步实现</p>
<p>在多处理器中实现同步所需的关键是一组硬件原语，它们能够提供以原子方式读取和修改内存单元的能力。也就是说在内存单元的读取和写人之间不能插人其他任何操作。</p>
<blockquote>
<p>如果没有这样的能力，构建基本同步原语的成本将会很高并会随着处理器数量的增加而急剧增加。</p>
</blockquote>
<p>有许多基本硬件原语的实现方案，所有这些都提供了原子读和原子写的能力以及一些判断读写是否是原子操作的力法。</p>
<blockquote>
<p>通常，体系结构设计人员不希望用户使用基本的硬件原语而是期望系统程序员使用原语来构建同步库，这个过程通常复杂且棘手。</p>
</blockquote>
<p>我们从 <strong>原子交换</strong> (atomic exchange 或 atomic swap) 原语开始展示如何使用它来构建 基本同步原语。它是构建同步机制的一种典型操作，它将寄存器中的值与存储器中的值进行交换。</p>
<p>为了了解如何使用它来构建基木同步原语，假设要构建一个简单的锁变量，其中用 0 表示锁可用，用 1 用于表示锁已被占用。</p>
<p>处理器尝试通过将寄存器中的 1 与该锁变量对应的内存地址的值进行交换来设置加锁。如果某个其他处理器已声明访间该锁变量则交换指令的返回值为 1 表明该锁已被其他处理器占用，否则为 0 表示加锁成功。在后一种情况下，锁变量的值变为 1 以防止其他处理器也加锁成功</p>
<p>现在考虑两个处理器尝试同时进行交换操作：这种竞争会被阻止。因为其中一个处理器将首先执行交换并返回。而第二个处理器在进行交换时将返回 1。使用交换原语实现同步的关键是操作的原子性：交换是不可分割的．硬件将对两个同时发生的交换进行排序，尝试以这种方式设置同步变量的两个处理器都不可能认为它们同时设置了变量。</p>
<p>实现单个的原子存储操作为处理器的设计带来了一些挑战，因为它要求在单条不可中断的指令中完成存储器的读和写操作</p>
<p>另一种方法是使用指令对其中第二条指令返回一个值，该值表示该指令对是否被原子执行。如果任何处理器执行的所有其他操作都发生在该对指令之前或之后，则该指令对实际上是原子的。因此，当指令对实际上是原子操作时没有其他处理器可以在指令对之间改变值。</p>
<p>在 RISC-V 中，这对指令指的是一个称为 <strong>保留加载 (load-reserved) 双字 (1 rd)</strong> 的特殊加载指令，和一个称为 <strong>条件存储 (store-conditional) 双字 (sc.d)</strong> 的特殊存储指令。这些指令按序使用：</p>
<ul>
<li>如果保留加载指令指定的内存位置的内容在条件存储指令执行到同一地址之前发生了变化，则条件存储指令失败且不会将值写人内存。</li>
<li>条件存储指令定义为将（可能是不同的）寄存器的值存储在内存中，如果成功则将另一个寄存器的值更改为 0 ,如果失败则更改为非零值。</li>
</ul>
<p>因此，sc.d 指定了三个寄存器：</p>
<ul>
<li>一个用于保存地址</li>
<li>一个用于指示原子操作的失败或成功</li>
<li>还有一个用于如果成功则将值存储在内存中。</li>
</ul>
<p>由于保留加载指令返回初始位，并且条件存储指令仅在成功时返回 0，因此以下序列在寄存器 x20 中指定的内存位置上实现原子交换</p>
<pre><code class="language-asm">again:
    lr.d x10, (x20)         ; 保留加载 load-reserved
    sc.d x11, x23, (x20)    ; 条件存储 store-conditional
    bne  x11, x0, again     ; 失败则重试
    addi x23, x10, 0        ; 保存加载到的值到 x23
</code></pre>
<p>详细阐述：虽然同步是为多处理器而提出的，但原子交换对于单个处理器操作系统中处理多个进程也很有用。为了确保单个处理器中的执行不受任何干扰，如果处理器在<strong>两个指令对之间进行上下文切换</strong>，则条件存储也会失败</p>
<p>详细阐述：保留加载/条件存储机制的一个优点是可以用于构建其他同步原语，例如原子的比较和交换 (atomic compare and swap) 或原子的取后加 (atomic fetch-and-increment), 这在一些并行编程模型中使用。这些同步原语的实现需要在 <code>lr.d</code> 和 <code>sc.d</code> 之间插入更多指令，但不会太多</p>
<p>由于条件存储会在另一个 store 尝试加载保留地址或异常之后失败，因此必须注意选择在两个指令之间插入哪些指令。特别是，只有保留加载/条件存储块中的整点算术、前向分支和后向分支被允许执行且不会出现问题；否则，可能会产生死锁情况 - 由于重复的页错误，处理器永远无法完成 <code>sc.d</code>。此外，保留加载和条件存储之间的指令数应该很少，以将由于不相关事件或竞争处理器导致条件存储频繁失败的可能性降至最低。</p>
<p>详细阐述：虽然上面的代码实现了原子交换，但下面的代码可以更有效地获取寄存器 x20 对应存储中的锁变量，其中值 0 表示锁变量是空闲的，值 1 表示锁变量被占用：</p>
<pre><code class="language-asm">    addi x12, x0, 1         ; x12 设为 1
again:
    lr.d x10, (x20)         ; 读取锁状态
    bne x10, x0, again      ; 如果是 0
    sc.d x11, x12, (x20)    ; 把 1 存到 x20, 把 x20 返回到 x11
    bne x11, 0, again       ; 如果 x11 为 1, 说明已经被上锁, again
    sd x0, 0(x20)           ; 使用普通的存储指令就能释放锁
</code></pre>
<h2 id="向量-or-simd"><a class="header" href="#向量-or-simd">向量 or SIMD？</a></h2>
<p>数组是一个常见的例子。虽然它是科学应用的基础，但它也被多媒体程序使
用。前者使用单精度和双精度浮点数据，后者通常使用 8 位和 16 位整数数据。</p>
<h3 id="simd"><a class="header" href="#simd">SIMD</a></h3>
<p>最著名的数据级并行架构是单指令多数据 (SIMD，Single Instruction Multiple Data)。
SIMD</p>
<ul>
<li>它将 64 位寄存器的数据分成许多个 8 位、16 位或 32 位的部分，
然后并行地计算它们。</li>
<li>操作码提供了数据宽度和操作类型。</li>
<li>数据传输只用单个（宽）SIMD 寄存器的 load 和 store 进行。</li>
</ul>
<h3 id="向量"><a class="header" href="#向量">向量</a></h3>
<ul>
<li>计算机从内存中中收集数据并将它们放入长的，顺序的向量寄存器中。在这些向
量寄存器上，流水线执行单元可以高效地执行运算。</li>
<li>向量架构将结果从向量寄存器中取出，并将其并分散地存回主存。</li>
<li>向量寄存器的大小由实现决定，而不是像 SIMD 中那样嵌入操作码中。</li>
</ul>
<h3 id="对比"><a class="header" href="#对比">对比</a></h3>
<p><strong>将向量的长度和每个时钟周期可以进行的最大操作数分离，是向量体系结构的关键所在</strong>：</p>
<ul>
<li>向量微架构可以灵活地设计数据并行硬件而不会影响到程序员，程序员可以不用重写代码就享受到长向量带来的好处。</li>
<li>向量架构比 SIMD 架构拥有更少的指令数量。</li>
<li>与 SIMD 不同，向量架构有着完善的编译器技术。</li>
</ul>
<blockquote>
<p>向量架构不如 SIMD 架构受欢迎的一个原因是：大家担心增加大型向量寄存器会延长中断时保存和恢复程序（上下文切换）的时间。动态寄存器类型对此很有帮助。程序员必须告诉处理器正在使用哪些向量寄存器，这意味着处理器需要在上下文切换中仅保存和恢复那些寄存器。RV32V 约定在不使用向量指令的时候禁用所有向量寄存器，这意味着处理器既可以具有向量寄存器的性能优势，又仅会在向量指令执行过程中发生中断时才会带来额外的上下文切换开销。早期的向量架构在发生中断时，不得不忍受保存和恢复全部向量寄存器的最大的上下文切换开销。</p>
</blockquote>
<h2 id="高级专题"><a class="header" href="#高级专题">高级专题</a></h2>
<h3 id="cjava-与-jit"><a class="header" href="#cjava-与-jit">C，Java 与 Jit</a></h3>
<p>为了保持可移植性并提高执行速度，Java 发展的下一阶段目标 是设计在程序运行时翻译的编译器。</p>
<p>这样的 <strong>即时编译器（JIT)</strong> 通常会对正在运行的程序进行剖视，以找到 &quot;热点&quot; 方法所在的位置，然后将它们翻译成（运行虚拟机的）宿主机对应的指令。编译过的部分将在下次运行程序时保存，以便每次运行时速度更快。这种解释和编译的平衡随着时间的推移而发展，因此经常运行的 Java 程序几乎没有解释的开销。</p>
<p>随着计算机的速度变得越来越快，编译器也变得更为强大，并且随着研究人员发明出更 好的动态编译 Java 的方法，Java 与 C 或 C+＋之间的性能差距正在缩小。</p>
<h3 id="其他-ips"><a class="header" href="#其他-ips">其他 IPS</a></h3>
<h3 id="总结-4"><a class="header" href="#总结-4">总结</a></h3>
<ol>
<li><strong>简单源于规整</strong>。规整性使 RISC-V 指令系统具有很多特点：所有指令都保持单一长度、算术指令中总是使用寄存器作为操作数、所有指令格式中寄存器字段都保持在相同位置。</li>
<li><strong>更少则更决</strong>。对速度的要求导致 RISC-V 有 32 个寄存器而不是更多。</li>
<li><strong>优秀的设计需要适当的折中</strong>。一个 RISC-V 的例子是，在指令中提供更大的地址和常 数．与保持所有的指令具有相同的长度之间的折中。</li>
</ol>
<p>每种类型的 RISC-v 指令都与编程语言中出现的结构相关：</p>
<ul>
<li>算术指令对应于赋值语句中的操作</li>
<li>传输指令最有可能发生在处理数组或结构体等数据结构时。</li>
<li>条件分支用于 if 语句和循环中。</li>
<li>无条件分支用于过程调用和返回，以及 case/switch 语句</li>
</ul>
<p>这些指令出现频率不相等，少数常用指令在大多数指令中占主导地位。下图展示了 SPEC CPU 2006 的每类指令的出现频率。指令的不同出现频率在数据路径、控制和流水线中起着重要作用</p>
<table><thead><tr><th>指令类别</th><th>RISC-V 实例</th><th>对应的高级语言</th><th>整数频率</th><th>浮点频率</th></tr></thead><tbody>
<tr><td>算术</td><td>add, sub, addi</td><td>赋值语句中的操作</td><td>6%</td><td>48%</td></tr>
<tr><td>数据传输</td><td>ld, sd, lw, sw, lh, sh, lb, sb, lui</td><td>对存储器中数据结构的引用</td><td>35%</td><td>36%</td></tr>
<tr><td>逻辑</td><td>and, or, xor, sll, srl, sra</td><td>赋值语句中的操作</td><td>12%</td><td>14%</td></tr>
<tr><td>分支</td><td>beq, bne, blt, bge, bltu, bgeu</td><td>if 语句；循环</td><td>34%</td><td>8%</td></tr>
<tr><td>跳转</td><td>jal, jalr</td><td>过程调用&amp;返回；switch 语句</td><td>2%</td><td>0%</td></tr>
</tbody></table>
<h2 id="翻译并启动程序"><a class="header" href="#翻译并启动程序">翻译并启动程序</a></h2>
<h3 id="编译器"><a class="header" href="#编译器">编译器</a></h3>
<p>函数调用过程</p>
<p>函数调用过程通常分为 6 个阶段：</p>
<ol>
<li>将参数存储到函数能够访问到的位置；</li>
<li>跳转到函数开始位置 (使用 RV32I 的 jal 指令)；</li>
<li>获取函数需要的局部存储资源，按需保存寄存器；</li>
<li>执行函数中的指令；</li>
<li>将返回值存储到调用者能够访问到的位置，恢复寄存器，释放局部存储资源；</li>
<li>返回调用函数的位置 (使用 ret 指令);</li>
</ol>
<h3 id="汇编器"><a class="header" href="#汇编器">汇编器</a></h3>
<p>ret 实际上是一个伪指令，汇编器会用 jalr x0, x1, 0 来替换它。大多数的 RISC-V 伪指令依赖于 x0。因此，把一个寄存器硬编码为 0 便于将许多常用指令——如跳转 (jump）、返回 (return)、等于 0 时转移 (branch on equal to zero)——作为伪指令，进而简化 RISC-V 指令集。</p>
<p><img src="docs/magic/./riscv/instructions_fakes.png" alt="fakes" />
<img src="docs/magic/./riscv/instructions_fakes2.png" alt="fakes2" /></p>
<p>hello.c</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main() {
    printf(&quot;hello, %s\n&quot;, &quot;world&quot;);
    return 0;
}
</code></pre>
<p>hello.s</p>
<pre><code class="language-asm">    ; Directive: enter text section         指示符: 进入代码段
    .text
    ; Directive: align code to 2^2 bytes    指示符: 按 2^2 字节对齐代码
    .align 2
    ; Directive: declare global symbol main 指示符: 声明全局符号 main
    .globl main
; label for start of main                   main 的开始标记
main:
    ; allocate stack frame                  分配栈帧
    addi sp, sp, -16
    ; save return address                   存储返回地址
    sw ra, 12(sp)
    ; compute address of string1            计算 string1 的地址
    lui a0, %hi(string1)
    ;   string1
    addi a0, a0, %lo(string1)
    ; compute address of string2            计算 string2 的地址
    lui a1, %hi(string2)
    ;   string2
    addi a1, a1, %lo(string2)
    ; call function printf                  调用 printf 函数
    call printf

    ; restore return address                恢复返回地址
    lw ra, 12(sp)
    ; deallocate stack frame                释放栈帧
    addi sp, sp, 16
    ; load return value 0                   读取返回值
    li a0, 0
    ; return                                返回
    ret

    ; Directive: enter read-only data section   指示符: 进入只读数据段
    .section .rodata
    ; Directive: align data section to 4 bytes  指示符: 按 4 字节对齐数据
    .balign 4
; label for first string                        第一个字符串标记
string1:
    ; Directive: null-terminated string         指示符: 空字符结尾的字符串
    .string &quot;Hello, %s\n&quot;
; label for second string                       第二个字符串标记
string2:
    ; Directive: null-terminated string         指示符: 空字符结尾的字符串
    .string &quot;world&quot;
</code></pre>
<p>hello.o</p>
<pre><code class="language-asm">00000000 &lt;main&gt; :
 0: ff010113 addi   sp, sp, -16
 4: 00112623 sw     ra, 12(sp)
 8: 00000537 lui    a0, 0x0
 c: 00050513 mv     a0, a0
10: 000005b7 lui    a1, 0x0
14: 00058593 mv     a1, a1
18: 00000097 auipc  ra, 0x0
1c: 000080e7 jalr   ra
20: 00c12083 lw     ra, 12(sp)
24: 01010113 addi   sp, sp, 16
28: 00000513 li     a0, 0
2c: 00008067 ret
</code></pre>
<p>位置 8 到 1c 的这几条指令的地址为 0, 将被链接器填充。</p>
<h2 id="特权架构"><a class="header" href="#特权架构">特权架构</a></h2>
<h3 id="简介"><a class="header" href="#简介">简介</a></h3>
<p>为什么需要特权机架构？</p>
<ol>
<li>
<p>管理，保护共享资源</p>
<ul>
<li>共享资源：例如内存，IO 设备（音响，声卡输出），处理器核心</li>
</ul>
</li>
<li>
<p>对上层用户屏蔽下层实现细节</p>
</li>
</ol>
<p>如何管理，保护：</p>
<ul>
<li>内存：使用虚拟内存地址</li>
<li>IO 设备：也使用虚拟内存地址</li>
<li>访问权限：</li>
</ul>
<p>特权等级：</p>
<ul>
<li>M：机器（Machine）</li>
<li>U：用户（程序执行）（User）</li>
<li>S：监管（Supervisor）</li>
<li>U：虚拟</li>
</ul>
<p>不同的芯片有不同的使用场景，有不同的价格，实现了不同的特权机别</p>
<p>两种权限模式</p>
<ul>
<li>运行最可信的代码的机器模式（machine mode）M-mode</li>
<li>以及为 Linux，FreeBSD 和 Windows 等操作系统提供支持的监管者模式（supervisor mode）。</li>
</ul>
<blockquote>
<p>处理器通常大部分时间都运行在权限最低的模式下，处理中断和异常时会将控制权移交到更高权限的模式。</p>
</blockquote>
<h3 id="特权级的组合"><a class="header" href="#特权级的组合">特权级的组合</a></h3>
<h4 id="m-mode"><a class="header" href="#m-mode">M-mode</a></h4>
<p>机器模式（缩写为 M 模式，M-mode）是 RISC-V 中 hart（hardware thread，硬件线
程）可以执行的最高权限模式。</p>
<ul>
<li>
<p>在 M 模式下运行的 hart 对内存，I/O 和一些对于启动和配置系统来说必要的底层功能有着完全的使用权。</p>
</li>
<li>
<p>是所有标准 RISC-V 处理器都必须实现的权限模式。实际上简单的 RISC-V 微控制器仅支持 M 模式。</p>
</li>
<li>
<p>可以在没有外部输入的情况下自己运行，没有什么外部网络接入（即程序在烧写之后也不会更新，上面的代码绝对安全），这时就不需要区分特权台和用户态，代码运行在最高权限下，应用层代码对 CPU 有完全的控制权，成本最低。</p>
</li>
<li>
<p>M 态也可以运行例如 FreeRTOS 之类的操作系统实现分时多任务调度，但是因为没有实现内存保护，操作系统可能会被应用程序搞垮</p>
</li>
</ul>
<h4 id="m--u"><a class="header" href="#m--u">M + U</a></h4>
<ul>
<li>增加了内存保护，操作系统可以运行在受保护的内存段里。运行在 U 态的应用程序无法修改运行在 M 态的操作系统。</li>
<li>可以接入网络，甚至能自己升级</li>
<li>应用程序出错不会影响操作系统，操作系统可以对出错做一些处理（善后工作）</li>
</ul>
<h4 id="m--s--u"><a class="header" href="#m--s--u">M + S + U</a></h4>
<ul>
<li>引入了页表，从而可以实现虚拟内存等高级功能，实现了安全上的保障。</li>
</ul>
<h4 id="对比--其他"><a class="header" href="#对比--其他">对比 &amp; 其他</a></h4>
<p>特权级为什么不在操作系统层实现？</p>
<ul>
<li>也可以，不过太常用，下放到了硬件</li>
<li>软件无法模拟（对内存的访问）</li>
</ul>
<p>更高级别的特权级更强大</p>
<ul>
<li>可以执行更多指令</li>
<li>可以操作更多 CSR（Control/State Register）</li>
</ul>
<blockquote>
<p>不同的 CSR 在不同的特权级可能会有不同的副本，例如 mtvec 和 stvec，一个是 M 态，一个是 S 态</p>
</blockquote>
<h4 id="各特权态的指令"><a class="header" href="#各特权态的指令">各特权态的指令</a></h4>
<ol>
<li>
<p>各特权级都有的指令</p>
<ul>
<li>
<p>ECALL</p>
<ul>
<li>实现特权级别的切换，通常是在 U 态（用户态）调用来陷入 S 态，在 S 态调用陷入 M 态。
<blockquote>
<p>不过为了实现这种陷入关系，还需要额外的配置，见下文</p>
</blockquote>
</li>
<li>ECALL 是单向的，需要用 SRET 返回</li>
</ul>
</li>
<li>
<p>EBREAK</p>
<ul>
<li>产生断点异常，对于程序调试有帮助</li>
</ul>
</li>
<li>
<p>FENCE.L</p>
<ul>
<li>产生一个内存读写屏障</li>
</ul>
</li>
<li>
<p>SRET</p>
<ul>
<li>从 S 态返回 U 态（只有在支持在 S 态的 CPU 上才可以）</li>
</ul>
<blockquote>
<p>还有一个 URET 指令</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>S 态引入的指令</p>
<ul>
<li>SFENCE.VMA
<ul>
<li>刷页表</li>
</ul>
</li>
</ul>
</li>
<li>
<p>M 态引入的指令</p>
<ul>
<li>WFI
<ul>
<li>让当前处理器进入休眠状态</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="各特权态的-csr"><a class="header" href="#各特权态的-csr">各特权态的 CSR</a></h4>
<ul>
<li>CSR 寄存器有一套独立的地址空间，访问 CSR 需要使用专有指令</li>
<li>每一个处理器核心都有自己的一套独立的 4K CSR，均分给了 4 各特权态，对于每一个特权态，最多有 1024 个 CSR 寄存器可以使用。</li>
<li>访问没有权限的，不存在的，写只读的 CSR 都会 Trap。</li>
</ul>
<p>RISC-V 只分配了 4K 的地址空间给 CSR，这 4K 空间的第 <code>[9:8]</code> 两个 bit 表示了 CSR 输入那个特权级</p>
<h3 id="内存地址翻译虚拟内存"><a class="header" href="#内存地址翻译虚拟内存">内存地址翻译：虚拟内存</a></h3>
<ul>
<li>在 RISC-V 下，页表最小为 4K</li>
<li>有多种地址映射方式（如 Sv32, Sv39, Sv48, 它们的虚拟地址的位宽不同，最大寻址范围也不同）</li>
<li>巨页！</li>
</ul>
<h4 id="页表项结构"><a class="header" href="#页表项结构">页表项结构</a></h4>
<p>一个 RV32 Sv32 页表项</p>
<pre><code class="language-txt">|32    20|19    10|9   8|7|6|5|4|3|2|1|0|
| PPN[1] | PPN[0] | RSW |D|A|G|U|X|W|R|V|
</code></pre>
<p>一个 RV32 Sv39 页表项</p>
<pre><code class="language-txt">|63      54|53    28|27    19|18    10|9   8|7|6|5|4|3|2|1|0|
| Reserved | PPN[2] | PPN[1] | PPN[0] | RSW |D|A|G|U|X|W|R|V|
</code></pre>
<ul>
<li>
<p>V: 其他位是否有效（V=1 有效），如果 V = 0，则便利到该页表的会直接产生错误</p>
</li>
<li>
<p>R | W | X：可读可写可执行。如果都是 0，则这个页表项是指向下一级页表的指针，否则它是页表树的一个页节点</p>
</li>
<li>
<p>U：是否为用户界面。如果 U = 0，则 U 模式不能访问，但 S 可以，如果 U = 1，则 U 模式可以访问，但 S 不可以。对于云服务，用户数据安全也很重要，用户的私有数据也不是操作系统可以随便访问的。</p>
</li>
<li>
<p>G：这个映射是否对所有虚拟内存都有效，硬件根据它提高地址转换性能</p>
</li>
<li>
<p>A：是否被访问过（从上次清除开始）</p>
</li>
<li>
<p>D：是否被写入过（从上次清除开始）</p>
</li>
</ul>
<blockquote>
<p>A 和 D 可以用来判断缺页，mmap 文件映射到地址，判断是否要加载，是否要刷新</p>
</blockquote>
<ul>
<li>RSW：留给操作系统使用，会被硬件忽略</li>
<li>PPN:包含物理页号，是物理地址的一部分。
<ul>
<li>若这个页表是一个页节点，则 PPN 是转换后物理地址的一部分</li>
<li>否则，是下一个页表的地址</li>
</ul>
</li>
</ul>
<h4 id="内存屏障"><a class="header" href="#内存屏障">内存屏障</a></h4>
<p>S 态唯一引入的指令：SFENCE.VMA</p>
<p>只会刷新当前处理器的快表（页表缓存），如果是多核环境，还需要核间通信同步刷新其他核心的页表缓存</p>
<h4 id="内存保护"><a class="header" href="#内存保护">内存保护</a></h4>
<p>有两种机制</p>
<ul>
<li>如果处理器支持，并且开启了内存地址转换（也就利用了页表），就可以通过页表里的权限位控制每个内存页的访问</li>
<li>如果不支持 S 态，可以通过 PMP（物理内存保护单元）。粒度大，保护区域小</li>
<li>虚拟内存优先于 PMP</li>
</ul>
<h3 id="中断与异常"><a class="header" href="#中断与异常">中断与异常</a></h3>
<p>机器模式最重要的特性是拦截和处理异常（不寻常的运行时事件）的能力。</p>
<p>RISC-V 将异常分为两类：</p>
<ul>
<li>
<p>（同步）异常</p>
<ul>
<li>同步事件</li>
<li>发生原因明确，由具体的某一条指令导致。这类异常在指令执行期间产生，如访问了无效的存储器地址或执行了具有无效操作码的指令时。</li>
</ul>
</li>
<li>
<p>中断。</p>
<ul>
<li>异步事件。它是与指令流异步的外部事件，比如鼠标的单击。</li>
<li>有三种标准的中断源：软件、时钟和外部来源。软件中断通过向内存映射寄存器中存数来触发</li>
</ul>
</li>
<li>
<p>中断和异常的处理流程几乎是一样的</p>
</li>
</ul>
<h3 id="和事件处理有关的-csr"><a class="header" href="#和事件处理有关的-csr">和事件处理有关的 CSR</a></h3>
<p>（说事件是因为它们异常和中断都能处理）</p>
<ul>
<li>
<p>stvec, mtved(Trap-Vector Base-Address Register)</p>
<ul>
<li>
<p>设置事件处理函数的地址，事件发生后会跳转到这里并执行对应的处理函数</p>
</li>
<li>
<p>跳转策略有两种</p>
<ul>
<li>无论发生什么时间，都跳到同一个固定的位置执行处理函数</li>
</ul>
<blockquote>
<p>然后再分发，虽然性能低，但是代码灵活</p>
</blockquote>
<ul>
<li>通过向量表，根据事件编号跳到不同的地址。</li>
</ul>
<blockquote>
<p>通常第二种的跳转效率比较高，但是逻辑死板</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>medeleg，mideleg（Trap Delegation Register)</p>
<ul>
<li>决定发生事件时跳到那个特权级</li>
</ul>
</li>
<li>
<p>scause，mcause（Cause Register）</p>
<ul>
<li>存储时间发生原因的 ID，最高位是 1 表示中断，最高位 0 表示异常。</li>
</ul>
</li>
<li>
<p>stval，mtval（Trap Value Register）</p>
<ul>
<li>存储和事件相关的外部信息，例如非法地址，非法操作数，</li>
</ul>
</li>
<li>
<p>sepc，sstatus（Exception Program Register）</p>
<ul>
<li>记录从高特权级别返回低特权级时，要返回到的地址</li>
</ul>
</li>
<li>
<p>mstatus，sstatus（Status Register）</p>
<ul>
<li>记录一些常用的标志位</li>
</ul>
</li>
</ul>
<h3 id="trap-的代理机制"><a class="header" href="#trap-的代理机制">Trap 的代理机制</a></h3>
<p>通常事件发生就会直接跳转到 M 态，但是没必要。</p>
<p>一般是 <code>U -&gt; S -&gt; M</code></p>
<p>直接调用 ECALL 会无条件跳转到 M 态，通过设置 medeleg 和 mideleg 能够实现在 U 态执行 ECALL 跳转到 S 态，在 S 态执行 ECALL 会跳转到 M 态。</p>
<h3 id="异常"><a class="header" href="#异常">异常</a></h3>
<p>RISC-V 中实现精确例外：保证异常之前的所有指令都完整地执行了，而后续的指令都没有开始执行（或等同于没有执行）。</p>
<p>在 M 模式运行期间可能发生的同步例外有五种：</p>
<ul>
<li>访问错误异常：当物理内存的地址不支持访问类型时发生（例如尝试写入 ROM）。</li>
<li>断点异常：在执行 <code>ebreak</code> 指令，或者地址或数据与调试触发器匹配时发生。</li>
<li>环境调用异常：在执行 <code>ecall</code> 指令时发生。</li>
<li>非法指令异常：在译码阶段发现无效操作码时发生。</li>
<li>非对齐地址异常：在有效地址不能被访问大小整除时发生，例如地址为 0x12 的 <code>amoadd.w</code>.</li>
</ul>
<p>不同的异常对应不同的操作码</p>
<h3 id="机器模式下的异常处理"><a class="header" href="#机器模式下的异常处理">机器模式下的异常处理</a></h3>
<p>八个控制状态寄存器（CSR）是机器模式下异常处理的必要部分：</p>
<ul>
<li>mtvec（Machine Trap Vector）它保存发生异常时处理器需要跳转到的地址。</li>
<li>mepc（Machine Exception PC）它指向发生异常的指令。</li>
<li>mcause（Machine Exception Cause）它指示发生异常的种类。</li>
<li>mie（Machine Interrupt Enable）它指出处理器目前能处理和必须忽略的中断。</li>
<li>mip（Machine Interrupt Pending）它列出目前正准备处理的中断。</li>
<li>mtval（Machine Trap Value）它保存了陷入（trap）的附加信息：地址例外中出错
的地址、发生非法指令例外的指令本身，对于其他异常，它的值为 0。</li>
<li>mscratch（Machine Scratch）它暂时存放一个字大小的数据。</li>
<li>mstatus（Machine Status）它保存全局中断使能，以及许多其他的状态</li>
</ul>
<h2 id="页表"><a class="header" href="#页表">页表</a></h2>
<ul>
<li>动态的申请内存</li>
<li>虚拟内存空洞</li>
<li>虚拟内存地址（VA），物理地址（PA）</li>
</ul>
<pre><code class="language-txt">| VA | PA | Size |
|    |    |      |
</code></pre>
<p>页表没有存在 PCB 中，位于一块单独的内存中。PCK 是一个相对紧凑的结构，里面存储了进程的状态，里面存储了页表的指针。当 CPU 切换进程时，还需要同时切换页表。</p>
<p>如何优化 VA 到 PA 的转换：</p>
<ul>
<li>让硬件自动完成查表和转换</li>
<li>优化列表的存储数据结构，加快查找。</li>
</ul>
<p>两种方案选择哪个呢？当然是两者都要 \doge。</p>
<h3 id="硬件查表"><a class="header" href="#硬件查表">硬件查表</a></h3>
<p>引入了一个 MMU 的硬件电路来实现。为了让 MMU 也能查的更快，也需要给 MMU 提供一种更加优化的数据结构。</p>
<p>TLB 是 MLU 的一个子电路，包含了页表缓存，TLB 可以实现的很复杂，例如用硬件电路实现的 哈希表，LRU 算法等。</p>
<p>当切换进程时，TLB 也需要被清空吗？</p>
<p>TLB 如果足够复杂的话，它里面可以设置进程的标志位，不同的区块存储不同进程的页表缓存</p>
<h3 id="优化存储数据结构"><a class="header" href="#优化存储数据结构">优化存储数据结构</a></h3>
<p>内存地址转换的最小单位是什么，或者说 Size 一列最小是多少。
假如以 1 字节为单位进行映射，那么映射以字节就需要存储 VA, PA, Size 一共 <code>3 * 4 = 12</code> 字节，属于是本末倒置了。</p>
<p>从而出现了页的概念。通常每个页的大小为 4KB，超过 4KB 的被称为巨页。最小的映射单元就是页。</p>
<p>我们把上面 VA 到 PA 的映射叫做页表，页表里的每一行映射关系被称为页表项。</p>
<h4 id="暴力存储"><a class="header" href="#暴力存储">暴力存储</a></h4>
<p>按照 VA 从小到大排序，检索时二分查找，复杂度 O(logN)</p>
<h4 id="页表存储"><a class="header" href="#页表存储">页表存储</a></h4>
<p>限制 Size 只能是 4KB，一次性把整个虚拟空间建立好映射关系</p>
<ul>
<li>Size 列可以去除</li>
<li>排序自然是排好的</li>
<li>复杂度为 O(1)，直接除 4096</li>
<li>映射表的 VA 列也不需要了，他可以用数组下标表示</li>
</ul>
<p>以 32 位机器为例，4GB 的 VA，一共包含了 1M 个 4KB 页。等于要申请一个长度为 <code>1M = 1024 * 1024</code> 的大数组，每个数组元素是 PA，占 32bit，所以整个页表占 <code>1M * 4B = 4MB</code></p>
<p>缺点</p>
<ul>
<li>上面的是 Sv32，对于 Sv39，每个进程就要分配 512MB 内存，10 个进程就是 5GB</li>
<li>页表利用率低？</li>
</ul>
<h4 id="多级页表"><a class="header" href="#多级页表">多级页表</a></h4>
<p>不是多有的进程都会使用完整的内存空间，虚拟地址空间里有很多的空洞，我们只需要把进程用到的 VA 做映射。所以我们现在的的目的是优化如何存储一个非常稀疏的数组。</p>
<p>地址是一个数，<strong>越高位表示的范围就越大</strong>，这是一种编码的思路。</p>
<p>具体到页表上，我们也可以把 32 各比特位划分为 <code>10 + 10 + 12</code> 三段，实现多级页表。前十位指向一级页表，中间 10 位指向二级页表，最后 10 位指向物理地址。</p>
<p>异同：</p>
<ul>
<li>需要查两次表，但是从时间复杂度上来看，这是一个常数级别的操作，仍然是 O(1)</li>
<li>由于构造的是树形结构，刚开始只需要存储树根，某些二级页表的 VA 从来没有被使用过，所以这一部分对应的的二级页表就不用存储。需要时随便找到一块 4KB 的空间就行，具有高效的插入和删除。</li>
</ul>
<h4 id="risc-v-中的实现"><a class="header" href="#risc-v-中的实现">RISC-V 中的实现</a></h4>
<p>Sv32，Sv39，Sv48 各种页表都有不同的划分</p>
<p>RISC-V 32 实际上有 34 位 12 + 10 + 12。芯片引用到 16 GB 的内存，但是进程依然只能访问 4GB 的空间。</p>
<p>一级、二级页表本身的地位都为 0，这些位被拿来做其他事了，提供了更丰富的功能，不只是地址映射，具体见 <a href="docs/magic/riscv.html#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84">页表项结构</a>。</p>
<h4 id="如何在多进程间切换页表"><a class="header" href="#如何在多进程间切换页表">如何在多进程间切换页表？</a></h4>
<p>每个进程都有自己的页表，每个页表都是一棵树，都有一个树根，这个树根也是一个大小为 4KB 的内存区域，只要我们能够知道这个区域（树根）的首地址，就相当于知道了整个页表</p>
<p>所以在 RISC-V 里，S 态引入了一个叫做 satp 的寄存器，apt 是 <code>Address.Translation and Protection</code>，即地址翻译和保护。这个地方存储的就是当前进程的根页表的页号，切换时就修改它的值。</p>
<h4 id="copy-on-write-的实现"><a class="header" href="#copy-on-write-的实现">Copy On Write 的实现</a></h4>
<p>当进行 fork 时，操作系统会把父进程的页表项都设置为只读，并把父进程的页表项复制一份给子进程（这里指的应该是一级页表）。所以子进程和父进程其实共享相同的物理内存（两个进程各自的 VA 映射到同一个 PA）。</p>
<p>只要父进程和子进程都只进行读操作，那么就无事发生。假如进行写操作，因为现在父子进程都是只读的，会触发一个异常，从 U 态陷入 S 态。此时有操作系统接管执行权，根据异常的原因发现是要修改共享的内存，于是操作系统就：</p>
<ul>
<li>为子进程重新分配一个页面</li>
<li>然后把子进程的页表项指向新的页面</li>
<li>并把这块内存在父子进程中都改为可读可写</li>
<li>最后返回用户态。</li>
</ul>
<blockquote>
<p>回顾中断和异常，这里的就是异常，trap 处理结束后会重新跳到导致异常的指令（即重试），程序就像什么都没发生一样。</p>
</blockquote>
<p>通过这种方式我们就实现了 COW，以 4KB 为单位，用多少内存就复制多少内存。</p>
<h4 id="mmap-的实现"><a class="header" href="#mmap-的实现">Mmap 的实现</a></h4>
<p>也是通过设置页表权限，然后引发异常，操作系统做一番操作。</p>
<p>当用户要把硬盘上的某个文件映射到内存的某个地址空间里时，就可以先在页表项里把这一段 VA 对应的内存映射到一块物理内存上，然后把硬盘文件里的数据加载到对应的物理内存对应的区域里。</p>
<p>如果映射的文件很小，那就可以把文件一次性读到内存。</p>
<p>如果文件很大，我们可以先在 VA 里把文件的内存空间都分配好页表，但是不指向具体的物理内存，同时设置读写权限。</p>
<ul>
<li>当程序读内存时，同样会触发陷入，然后操作系统会根据读写的地址将磁盘文件对应的区块加载到内存里，然后再修改页表。</li>
<li>当写内存时，对应的页表项的 D 标志位被设为 1，操作系统会有一个后台线程定期检查哪些页表是脏的，并把脏页刷回到内存。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haskell-语言"><a class="header" href="#haskell-语言">Haskell 语言</a></h1>
<p>⭐️<a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!</a></p>
<h2 id="0-特性"><a class="header" href="#0-特性">0. 特性</a></h2>
<ol>
<li>
<blockquote>
<p>We usually use ' to either denote a strict  version of a function (one that isn't lazy) or a slightly modified  version of a function or a variable. Because ' is a valid character in functions, we can make a function like this.</p>
</blockquote>
<p><code>‘</code> 在 haskell 中是声明的合法字符，一般中加 <code>’</code> 的函数代表一个函数的修改版本或者严格版本</p>
</li>
</ol>
<h2 id="1-开始"><a class="header" href="#1-开始">1. 开始</a></h2>
<p><strong>Starting Out</strong></p>
<h3 id="11-基本函数"><a class="header" href="#11-基本函数">1.1 基本函数</a></h3>
<ul>
<li>最小值：<code>min 1 3</code></li>
<li>最大值：<code>max 1 3</code></li>
<li>加一：<code>succ 1</code></li>
</ul>
<h3 id="12-列表"><a class="header" href="#12-列表">1.2 列表</a></h3>
<ul>
<li>
<p>合并： <code>[1,2,3,4] ++ [9,10,11,12] </code></p>
</li>
<li>
<p>根据索引取值： <code>&quot;Steve Buscemi&quot; !! 6</code></p>
</li>
<li>
<p>开头插入： <code>'A':&quot; SMALL CAT&quot; </code></p>
<blockquote>
<p>[1,2,3] is actually just syntactic sugar for 1:2:3:[].</p>
</blockquote>
</li>
<li>
<p>取表头：<code>head [1, 2, 3, 4, 5]</code></p>
</li>
<li>
<p>取表尾：<code>tail [1, 2, 3, 4, 5] </code></p>
</li>
<li>
<p>取最后一个元素：<code>last [1, 2, 3, 4, 5]</code></p>
</li>
<li>
<p>取除了最后一个元素： <code>init [1, 2, 3, 4, 5]</code></p>
</li>
<li>
<p>长度： <code>length [5,4,3,2,1] </code></p>
</li>
<li>
<p>是否为空： <code>null [1,2,3] </code></p>
</li>
<li>
<p>反转列表： <code>reverse [5,4,3,2,1] </code></p>
</li>
<li>
<p>取前 n 个： <code>take 3 [5,4,3,2,1] </code></p>
</li>
<li>
<p>从第 n 个开始向后取： <code>drop 3 [8,4,2,1,5,6] </code></p>
</li>
<li>
<p>最大元素： <code>maximum [1,9,2,3,4] </code></p>
</li>
<li>
<p>最小元素： <code>minimum [8,4,2,1,5,6]</code></p>
</li>
<li>
<p>加： <code>sum [5,2,1,6,3,2,5,7] </code></p>
</li>
<li>
<p>乘： <code>product [6,2,1,2] </code></p>
</li>
<li>
<p>是否在列表中： <code>4 </code>elem <code>[3,4,5,6]</code></p>
</li>
</ul>
<h3 id="13-生成式"><a class="header" href="#13-生成式">1.3 生成式</a></h3>
<ul>
<li>循环追加（append）： <code>cycle [1,2,3]</code></li>
<li>循环生成（extend）： <code>repeat 5</code></li>
<li>生成式： <code>boomBangs xs = [ if x &lt; 10 then &quot;BOOM!&quot; else &quot;BANG!&quot; | x &lt;- xs, odd x]</code></li>
</ul>
<h3 id="14-元组"><a class="header" href="#14-元组">1.4 元组</a></h3>
<p>类型随意，</p>
<ul>
<li>fst： <code>fst (&quot;Wow&quot;, False) </code></li>
<li>snd： <code>snd (&quot;Wow&quot;, False)</code></li>
</ul>
<h3 id="15-重要"><a class="header" href="#15-重要">1.5 重要</a></h3>
<ul>
<li>zip
<pre><code class="language-haskell">zip [5,3,2,6,2,7,2,5,4,6,6] [&quot;im&quot;,&quot;a&quot;,&quot;turtle&quot;]
    [(5,&quot;im&quot;),(3,&quot;a&quot;),(2,&quot;turtle&quot;)]
zip [1..] [&quot;apple&quot;, &quot;orange&quot;, &quot;cherry&quot;, &quot;mango&quot;]
    [(1,&quot;apple&quot;),(2,&quot;orange&quot;),(3,&quot;cherry&quot;),(4,&quot;mango&quot;)]
</code></pre>
</li>
</ul>
<h2 id="2-类型系统"><a class="header" href="#2-类型系统">2. 类型系统</a></h2>
<p><strong>Types and Typeclasses</strong></p>
<h3 id="21-查看类型"><a class="header" href="#21-查看类型">2.1 查看类型</a></h3>
<p>ghci 查看</p>
<pre><code class="language-haskell">：t (1, &quot;qqq&quot;)
</code></pre>
<h3 id="22-typeclasses-101"><a class="header" href="#22-typeclasses-101">2.2 Typeclasses 101</a></h3>
<p>所有的 <code>== + - * / </code> 都是 function</p>
<pre><code class="language-haskell">ghci&gt; :t (==)
(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool
</code></pre>
<blockquote>
<p>Everything before the =&gt; symbol is called a <em>class constraint</em>. We can read the previous type declaration like this: the equality  function takes any two values that are of the same type and returns a Bool. The type of those two values must be a member of the Eq class (this was the class constraint).</p>
</blockquote>
<ul>
<li><code>=&gt;</code> 之前的被叫做类型约束</li>
</ul>
<p><strong>Type variables</strong></p>
<pre><code class="language-haskell">ghci&gt; :t head
head :: [a] -&gt; a
</code></pre>
<p>a 就是类型变量，但是由于 a 不是某一个特定的类型，所以我们称 head 多态函数</p>
<blockquote>
<p>Functions that have type variables are called <strong>polymorphic functions</strong>.</p>
</blockquote>
<p><strong>Typeclasses</strong> 就是类型约束</p>
<p>下面举出了一系列常用的 Typeclasses</p>
<h4 id="221-eq"><a class="header" href="#221-eq">2.2.1 Eq</a></h4>
<blockquote>
<p>The Eq typeclass provides an interface for  testing for equality. Any type where it makes sense to test for equality between two values of that type should be a member of the Eq class. All standard Haskell types except for IO (the type for dealing with input and output) and functions are a part of the Eq typeclass.</p>
</blockquote>
<p>Eq 提供了一个比较的接口，任何能够比较该类型的两个值之间相等性的都应该是 Eq 类的成员</p>
<h4 id="222-ord"><a class="header" href="#222-ord">2.2.2 Ord</a></h4>
<blockquote>
<p>All the types we covered so far except for functions are part of Ord. Ord covers all the standard comparing functions such as &gt;, &lt;, &gt;= and &lt;=. The compare function takes two Ord members of the same type and returns an ordering. Ordering is a type that can be GT, LT or EQ, meaning <em>greater than</em>, <em>lesser than</em> and <em>equal</em>, respectively.</p>
</blockquote>
<p>Ord 包含了所有标准的比较函数，例如 &gt; &lt; &gt;= &lt;=, 比较函数接受两个类型相同的 Ord 成员，并返回一个排序，排序是 GT，LT，EQ，分别表示大于，小于，等于</p>
<pre><code class="language-haskell">ghci&gt; &quot;Abrakadabra&quot; &lt; &quot;Zebra&quot;
True
ghci&gt; &quot;Abrakadabra&quot; `compare` &quot;Zebra&quot;
LT
ghci&gt; 5 &gt;= 2
True
ghci&gt; 5 `compare` 3
GT
</code></pre>
<h4 id="223-show"><a class="header" href="#223-show">2.2.3 Show</a></h4>
<blockquote>
<p>Members of Show can be presented as strings. All types covered so far except for functions are a part of Show. The most used function that deals with the Show typeclass is show. It takes a value whose type is a member of Show and presents it to us as a string.</p>
</blockquote>
<p>Show 的成员可以被打印为字符串，到目前为止，除了函数之外的所有类型都是 Show 的一部分。</p>
<p>show 函数接受一个类型为 Show 成员的值，并将其作为字符串呈现</p>
<pre><code class="language-haskell">ghci&gt; :t read
read :: (Read a) =&gt; String -&gt; a
</code></pre>
<h4 id="224-read"><a class="header" href="#224-read">2.2.4 Read</a></h4>
<blockquote>
<p>Read is sort of the opposite typeclass of Show. The read function takes a string and returns a type which is a member of Read.</p>
</blockquote>
<p>read 函数接受一个 String，并返回一个 Read 的成员的类型</p>
<p><strong>问题</strong></p>
<pre><code class="language-haskell">ghci&gt; read &quot;4&quot;
    &lt;interactive&gt;:1:0:
        Ambiguous type variable `a' in the constraint:
        	`Read a' arising from a use of `read' at &lt;interactive&gt;:1:0-7
        Probable fix: add a type signature that fixes these type variable(s)
</code></pre>
<p><strong>指定 return 类型</strong></p>
<pre><code class="language-haskell">ghci&gt; read &quot;5&quot; :: Int
5
ghci&gt; read &quot;5&quot; :: Float
5.0
ghci&gt; (read &quot;5&quot; :: Float) * 4
20.0
ghci&gt; read &quot;[1,2,3,4]&quot; :: [Int]
[1,2,3,4]
ghci&gt; read &quot;(3, 'a')&quot; :: (Int, Char)
(3, 'a')
</code></pre>
<h4 id="225-enum"><a class="header" href="#225-enum">2.2.5 Enum</a></h4>
<blockquote>
<p>Enum members are sequentially ordered types — they can be enumerated. The main advantage of the Enum typeclass is that we can use its types in list ranges. They also have  defined successors and predecesors, which you can get with the succ and pred functions. Types in this class: (), Bool, Char, Ordering, Int, Integer, Float and Double.</p>
</blockquote>
<p>枚举类型是按照顺序排序的类型，他们可以被枚举，我们可以在列表中使用它的所有类型。</p>
<p>他们还被定义了前驱和后继，因此可以对它的类型使用 <code>succ</code> 和 <code>pred</code> 函数</p>
<pre><code class="language-haskell">ghci&gt; ['a'..'e']
&quot;abcde&quot;
ghci&gt; [LT .. GT]
[LT,EQ,GT]
ghci&gt; [3 .. 5]
[3,4,5]
ghci&gt; succ 'B'
'C'
</code></pre>
<h4 id="226-bounded"><a class="header" href="#226-bounded">2.2.6 Bounded</a></h4>
<blockquote>
<p>Bounded members have an upper and a lower bound.</p>
</blockquote>
<p>Bounded 类型有上界和下界</p>
<pre><code class="language-haskell">ghci&gt; minBound :: Int
-2147483648
ghci&gt; maxBound :: Char
'\1114111'
ghci&gt; maxBound :: Bool
True
ghci&gt; minBound :: Bool
False
</code></pre>
<blockquote>
<p>minBound and maxBound are interesting because they have a type of (Bounded a) =&gt; a. In a sense they are polymorphic constants.</p>
</blockquote>
<p>他们是多态性常量，见下文</p>
<p>如果元组的元素也在元组中，那么这个元组也是 Bounded 的成员。</p>
<pre><code class="language-haskell">ghci&gt; maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
</code></pre>
<h4 id="227-num"><a class="header" href="#227-num">2.2.7 Num</a></h4>
<p>Num 也是一个多态性常量，他能表现的向任何 Num 类的成员（包括 Int, Integer, Float, Double）</p>
<pre><code class="language-haskell">ghci&gt; :t 20
20 :: (Num t) =&gt; t

ghci&gt; 20 :: Int
20
ghci&gt; 20 :: Integer
20
ghci&gt; 20 :: Float
20.0
ghci&gt; 20 :: Double
20.0
</code></pre>
<p><code>(5 :: Int) * (6 :: Integer)</code> will error， while <code>5 * (6 :: Integer)</code>  will work just fine</p>
<h4 id="229-integral--floating"><a class="header" href="#229-integral--floating">2.2.9 Integral &amp; Floating</a></h4>
<ul>
<li><code>Integral </code>contains <code> Int</code> and <code>Integer</code></li>
<li><code>Floating</code> contains <code>Float</code> and <code>Double</code>.</li>
</ul>
<p><code>fromIntegral</code>可以帮我们实现类型转换</p>
<pre><code class="language-haskell">-- It has a type declaration of
fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b
-- so, you can use it as
fromIntegral (length [1,2,3,4]) + 3.2
</code></pre>
<h2 id="3-函数语法"><a class="header" href="#3-函数语法">3. 函数语法</a></h2>
<p><strong>Syntax in Functions</strong></p>
<h3 id="31-match-表达式"><a class="header" href="#31-match-表达式">3.1 Match 表达式</a></h3>
<p><strong>Pattern marching</strong></p>
<ol>
<li>
<p>在 ghci 中声明类型需要使用多行块中</p>
<pre><code class="language-haskell">:{
lucky :: Int -&gt; String
lucky a = show(a)
:}

:type lucky
lucky :: Int -&gt; String
</code></pre>
</li>
<li>
<p>匹配列表长度</p>
<pre><code class="language-haskell">tell :: (Show a) =&gt; [a] -&gt; String
tell [] = &quot;The list is empty&quot;
tell (x:[]) = &quot;The list has one element: &quot; ++ show x
tell (x:y:[]) = &quot;The list has two elements: &quot; ++ show x ++ &quot; and &quot; ++ show y
tell (x:y:_) = &quot;This list is long. The first two elements are: &quot; ++ show x ++ &quot; and &quot; ++ show y
</code></pre>
</li>
<li>
<p>一个 length 函数的实现</p>
<pre><code class="language-haskell">length' :: (Num b) =&gt; [a] -&gt; b
length' [] = 0
length' (_:xs) = 1 + length' xs
</code></pre>
</li>
</ol>
<h3 id="32-guard"><a class="header" href="#32-guard">3.2 Guard</a></h3>
<ol>
<li>
<p>标准</p>
<pre><code class="language-haskell">bmiTell :: (RealFloat a) =&gt; a -&gt; String
bmiTell bmi
   | bmi &lt;= 18.5 = &quot;You're underweight, you emo, you!&quot;
   | bmi &lt;= 25.0 = &quot;You're supposedly normal. Pffft, I bet you're ugly!&quot;
   | bmi &lt;= 30.0 = &quot;You're fat! Lose some weight, fatty!&quot;
   | otherwise   = &quot;You're a whale, congratulations!&quot;

myCompare :: (Ord a) =&gt; a -&gt; a -&gt; Ordering
a `myCompare` b
    | a &gt; b     = GT
    | a == b    = EQ
    | otherwise = LT
</code></pre>
</li>
<li>
<p>inline 版（可读性差）</p>
<pre><code class="language-haskell">max' :: (Ord a) =&gt; a -&gt; a -&gt; a
max' a b | a &gt; b = a | otherwise = b
</code></pre>
</li>
</ol>
<h3 id="33-where"><a class="header" href="#33-where">3.3 where</a></h3>
<ol>
<li>
<p>作用在 guard 上</p>
<pre><code class="language-haskell">    bmiTell :: (RealFloat a) =&gt; a -&gt; a -&gt; String
    bmiTell weight height
        | bmi &lt;= skinny = &quot;You're underweight, you emo, you!&quot;
        | bmi &lt;= normal = &quot;You're supposedly normal. Pffft, I bet you're ugly!&quot;
        | bmi &lt;= fat    = &quot;You're fat! Lose some weight, fatty!&quot;
        | otherwise     = &quot;You're a whale, congratulations!&quot;
        where bmi = weight / height ^ 2
              skinny = 18.5
              normal = 25.0
              fat = 30.0
</code></pre>
<blockquote>
<p><em>where</em> bindings aren't shared across function bodies of different  patterns. If you want several patterns of one function to access some  shared name, you have to define it globally.</p>
</blockquote>
<p>where 的绑定不能在函数体里共享，除非以全局方式定义</p>
</li>
<li>
<p>作用在 pattern match 上</p>
<pre><code class="language-haskell">    initials :: String -&gt; String -&gt; String
    initials firstname lastname = [f] ++ &quot;. &quot; ++ [l] ++ &quot;.&quot;
        where (f:_) = firstname
              (l:_) = lastname
</code></pre>
</li>
<li>
<p>使用 where 定义 function</p>
<pre><code class="language-haskell">    calcBmis :: (RealFloat a) =&gt; [(a, a)] -&gt; [a]
    calcBmis xs = [bmi w h | (w, h) &lt;- xs]
        where bmi weight height = weight / height ^ 2
</code></pre>
</li>
</ol>
<h3 id="34-let-it-be"><a class="header" href="#34-let-it-be">3.4 Let it be</a></h3>
<p>** <code>let &lt;bindings&gt; in &lt;expression&gt; </code>**</p>
<pre><code class="language-haskell">    cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a
    cylinder r h =
        let sideArea = 2 * pi * r * h
            topArea = pi * r ^2
        in  sideArea + 2 * topArea
</code></pre>
<blockquote>
<p>The difference is that <em>let</em> bindings are expressions themselves. <em>where</em> bindings are just syntactic constructs.</p>
</blockquote>
<p>Let 把绑定放在前面，where 把绑定放在后面，但是 Let 是一个表达式，Where 只是个语法结构</p>
<h3 id="35-case-expression"><a class="header" href="#35-case-expression">3.5 Case Expression</a></h3>
<ul>
<li>
<p>示例 1</p>
<pre><code class="language-haskell">describeList :: [a] -&gt; String
describeList xs = &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot;
                                               [x] -&gt; &quot;a singleton list.&quot;
                                               xs -&gt; &quot;a longer list.&quot;
</code></pre>
</li>
<li>
<p>示例 2</p>
<pre><code class="language-haskell">describeList :: [a] -&gt; String
describeList xs = &quot;The list is &quot; ++ what xs
    where what [] = &quot;empty.&quot;
          what [x] = &quot;a singleton list.&quot;
          what xs = &quot;a longer list.&quot;
</code></pre>
</li>
</ul>
<h2 id="4-递归"><a class="header" href="#4-递归">4. 递归</a></h2>
<p><strong>Recursion</strong></p>
<pre><code>### 4.1 maxium
</code></pre>
<pre><code class="language-haskell">-- 第一种
maximum' :: (Ord a) =&gt; [a] -&gt; a
maximum' [] = error &quot;maximum of empty list&quot;
maximum' [x] = x
maximum' (x:xs)
    | x &gt; maxTail = x
    | otherwise = maxTail
    where maxTail = maximum' xs
-- 第二种
maximum' :: (Ord a) =&gt; [a] -&gt; a
maximum' [] = error &quot;maximum of empty list&quot;
maximum' [x] = x
maximum' (x:xs) = max x (maximum' xs)
</code></pre>
<h3 id="42-replicate"><a class="header" href="#42-replicate">4.2 replicate</a></h3>
<pre><code class="language-haskell">replicate' :: (Num i, Ord i) =&gt; i -&gt; a -&gt; [a]
replicate' n x
    | n &lt;= 0    = []
    | otherwise = x:replicate' (n-1) x
</code></pre>
<h3 id="43-take"><a class="header" href="#43-take">4.3 take</a></h3>
<pre><code class="language-haskell">take' :: (Num i, Ord i) =&gt; i -&gt; [a] -&gt; [a]
take' n _
    | n &lt;= 0   = []
take' _ []     = []
take' n (x:xs) = x : take' (n-1) xs
</code></pre>
<h3 id="44-zip"><a class="header" href="#44-zip">4.4 zip</a></h3>
<pre><code class="language-haskell">elem' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
elem' a [] = False
elem' a (x:xs)
    | a == x    = True
    | otherwise = a `elem'` xs
</code></pre>
<h3 id="45-quick-sort"><a class="header" href="#45-quick-sort">4.5 quick sort</a></h3>
<pre><code class="language-haskell">quicksort :: (Ord a) =&gt; [a] -&gt; [a]
quicksort [] = []
quicksort (x:xs) =
    let smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]
        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]
    in  smallerSorted ++ [x] ++ biggerSorted
quicksort (x:xs) = quicksort [a | a &lt;- xs, a &lt;= x] ++ [x] ++ quicksort [a | a &lt;- xs, a &gt; x]
</code></pre>
<h2 id="5-高阶函数"><a class="header" href="#5-高阶函数">5. 高阶函数</a></h2>
<p><em>Higher order functions</em></p>
<p>能够以函数作为参数，或者返回一个函数的函数都是高阶函数，告诫函数就是 Haskell 的体验</p>
<h3 id="51-curried-functions"><a class="header" href="#51-curried-functions">5.1 Curried functions</a></h3>
<pre><code class="language-haskell">ghci&gt; max 4 5
5
-- max 本身可以这样写
ghci&gt; (max 4) 5
5
</code></pre>
<p>让我们看看 max 的类型</p>
<pre><code class="language-haskell">max :: (Ord a) =&gt; a -&gt; a -&gt; a.
-- 也能写作
max :: (Ord a) =&gt; a -&gt; (a -&gt; a).
</code></pre>
<p>所以 max 这个函数能够返回一个函数</p>
<p>同时</p>
<h3 id="52-一些高阶函数"><a class="header" href="#52-一些高阶函数">5.2 一些高阶函数</a></h3>
<pre><code class="language-haskell">applyTwice :: (a -&gt; a) -&gt; a -&gt; a
applyTwice f x = f (f x)

ghci&gt; applyTwice (+3) 10
16
</code></pre>
<pre><code class="language-haskell">zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys

zipWith' (++) [&quot;aaa&quot;, &quot;bbb&quot;] [&quot;ccc&quot;, &quot;ddd&quot;]
[&quot;aaaccc&quot;,&quot;bbbddd&quot;]
</code></pre>
<p><strong>flip</strong></p>
<pre><code class="language-haskell">flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
flip' f y x = f x y
</code></pre>
<h3 id="53-map"><a class="header" href="#53-map">5.3 Map</a></h3>
<blockquote>
<p><code>map (+3) [1,5,3,1,6] </code>is the same as writing <code>[x+3 | x &lt;- [1,5,3,1,6]].</code></p>
</blockquote>
<pre><code class="language-haskell">    map :: (a -&gt; b) -&gt; [a] -&gt; [b]
    map _ [] = []
    map f (x:xs) = f x : map f xs
</code></pre>
<h3 id="54-filter"><a class="header" href="#54-filter">5.4 Filter</a></h3>
<pre><code class="language-haskell">    filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
    filter _ [] = []
    filter p (x:xs)
        | p x       = x : filter p xs
        | otherwise = filter p xs
</code></pre>
<h3 id="55-takewhile"><a class="header" href="#55-takewhile">5.5 takeWhile</a></h3>
<p>take 直到限制条件到</p>
<pre><code class="language-haskell">sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..])))

sum (takeWhile (&lt;10000) [n^2 | n &lt;- [1..], odd (n^2)])
</code></pre>
<h3 id="56-chain"><a class="header" href="#56-chain">5.6 Chain</a></h3>
<p>生成 Collatz sequences</p>
<pre><code class="language-haskell">chain :: (Integral a) =&gt; a -&gt; [a]
chain 1 = [1]
chain n
    | even n =  n:chain (n `div` 2)
    | odd n  =  n:chain (n*3 + 1)

-- 小练习
numLongChains :: Int
numLongChains = length (filter isLong (map chain [1..100]))
    where isLong xs = length xs &gt; 15
</code></pre>
<h3 id="57-map--0"><a class="header" href="#57-map--0">5.7 map (*) [0..]</a></h3>
<blockquote>
<p>If we map <code>*</code> over the list <code> [0..]</code>, we get back a list of functions that only take one parameter, so <code>(Num a) =&gt; [a -&gt; a]</code>. <code>map (*) [0..]</code> produces a list like the one we'd get by writing <code>[(0*),(1*),(2*),(3*),(4*),(5*)...</code></p>
</blockquote>
<p>实例代码</p>
<pre><code class="language-haskell">ghci&gt; let listOfFuns = map (*) [0..]
ghci&gt; (listOfFuns !! 4) 5
20
</code></pre>
<h3 id="58-lambdas"><a class="header" href="#58-lambdas">5.8 Lambdas</a></h3>
<p>语法：一般以小括号阔起来，以 <code>\</code> 开头</p>
<pre><code class="language-haskell">numLongChains :: Int
numLongChains = length (filter (\xs -&gt; length xs &gt; 15) (map chain [1..100]))
</code></pre>
<p>一个比较好的用发</p>
<pre><code class="language-haskell">flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
flip' f = \x y -&gt; f y x
</code></pre>
<h3 id="59-fold"><a class="header" href="#59-fold">5.9 Fold</a></h3>
<p>我们用 <em>fold</em> 再次实现 <code>sum</code> 函数</p>
<pre><code class="language-haskell">sum' :: (Num a) =&gt; [a] -&gt; a
sum' xs = foldl (\acc x -&gt; acc + x) 0 xs
ghci&gt; sum' [3,5,2,1]
11
</code></pre>
<ol>
<li><strong>foldl</strong> 接受 2 个参数，分别是函数和一个初始值 (或者说累加器), acc 开始为 0，之后依次加 3, 5, 2, 1</li>
</ol>
<p>函数的第一个参数是累加器，第二个是当前的值</p>
<pre><code class="language-haskell">-- 再次实现 elem
elem' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
elem' x xs = foldl (\acc el -&gt; if el == x then True else acc) False xs
</code></pre>
<ol start="2">
<li>
<p><strong>foldr</strong> 与 foldl 相似，不过是从右侧开始遍历元素，其中，foldr 的第一个参数是当前元素，第二个元素是 acc 累加器</p>
</li>
<li>
<p><strong>两种 map 的实现</strong></p>
<pre><code class="language-haskell">-- foldr
map' :: (a -&gt; b) -&gt; [a] -&gt; [b]
map' f xs = foldr (\x acc -&gt; f x : acc) [] xs
-- foldl
map' f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs
</code></pre>
<p>在上面的案例中，<code>foldr</code> 实现的更好，因为 <code>:</code> 的开销比 <code>++</code> 小的多</p>
</li>
<li>
<p>要注意的是 foldr 可以作用在无线列表上，foldl 不能</p>
</li>
<li>
<p><strong>foldl1</strong> 和 <strong>foldr1</strong> 使用第一个或者最后一个作为初值，不需要那个参数了</p>
<pre><code class="language-haskell">-- 这里是一堆例子
maximum' :: (Ord a) =&gt; [a] -&gt; a
maximum' = foldr1 (\x acc -&gt; if x &gt; acc then x else acc)

reverse' :: [a] -&gt; [a]
reverse' = foldl (\acc x -&gt; x : acc) []

product' :: (Num a) =&gt; [a] -&gt; a
product' = foldr1 (*)

filter' :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
filter' p = foldr (\x acc -&gt; if p x then x : acc else acc) []

head' :: [a] -&gt; a
head' = foldr1 (\x _ -&gt; x)

last' :: [a] -&gt; a
last' = foldl1 (\_ x -&gt; x)
</code></pre>
</li>
<li>
<p><strong>scanl</strong> 和 <strong>scanr</strong> 和 fold 类似，不过会把中间的状态保留，并返回一个列表</p>
<pre><code class="language-haskell">ghci&gt; scanl (+) 0 [3,5,2,1]
[0,3,8,10,11]
ghci&gt; scanr (+) 0 [3,5,2,1]
[11,8,3,1,0]
ghci&gt; scanl1 (\acc x -&gt; if x &gt; acc then x else acc) [3,4,5,3,7,9,2,1]
[3,4,5,5,7,9,9,9]
ghci&gt; scanl (flip (:)) [] [3,2,1]
[[],[3],[2,3],[1,2,3]]
</code></pre>
</li>
</ol>
<h3 id="510--运算符"><a class="header" href="#510--运算符">5.10 $ 运算符</a></h3>
<blockquote>
<p>Whereas normal function application (putting a space between two things) has a really high precedence, the $ function has the lowest precedence. Function application with a space is left-associative (so f a b c is the same as ((f a) b) c)), function application with $ is right-associative.</p>
</blockquote>
<p>空格具有较高的优先级，但是 <code>$</code> 具有最低的优先级</p>
<p>使用空格分割的是左关联的，而使用 <code>$</code> 分割的是右关联的</p>
<p>有什么用？</p>
<ol>
<li>
<p>少些括号</p>
<p><code>sum (map sqrt [1..130])</code> 可以用 <code>sum $ map sqrt [1..130]</code> 代替，<code>sqrt 3 + 4 + 9</code>是 13+ 根号 3，但是 <code>sqrt $ 3 + 4 + 9</code> 就正常</p>
<p>[]:</p>
<blockquote>
<p>How about sum (filter (&gt; 10) (map (*2) [2..10]))? Well, because $ is right-associative, f (g (z x)) is equal to f $ g $ z x. And so, we can rewrite sum (filter (&gt; 10) (map (*2) [2..10])) as sum $ filter (&gt; 10) $ map (*2) [2..10].</p>
</blockquote>
</li>
<li>
<p>增加特性</p>
</li>
</ol>
<p>加了 <code>$</code> 意味着可以被当作函数来对待，所以下面的写法是可行的</p>
<pre><code class="language-haskell">ghci&gt; map ($ 3) [(4+), (10*), (^2), sqrt]
[7.0,30.0,9.0,1.7320508075688772]
</code></pre>
<h3 id="511-函数组合"><a class="header" href="#511-函数组合">5.11 函数组合</a></h3>
<p><code>.</code> 是一个运算符，他的定义如下</p>
<pre><code class="language-haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
f . g = \x -&gt; f (g x)
</code></pre>
<p>有了这个后，一些嵌套的函数就能简写，例如</p>
<pre><code class="language-haskell">-- before
ghci&gt; map (\x -&gt; negate (abs x)) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
-- now
ghci&gt; map (negate . abs) [5,-3,-6,7,-3,2,-19,24]
[-5,-3,-6,-7,-3,-2,-19,-24]
</code></pre>
<h2 id="6-模块"><a class="header" href="#6-模块">6. 模块</a></h2>
<p><strong>Modules</strong></p>
<h3 id="61-导入模块"><a class="header" href="#61-导入模块">6.1 导入模块</a></h3>
<ol>
<li>导入</li>
</ol>
<pre><code class="language-haskell">-- 1. 导入一个模块
ghci&gt; import Data.List
-- 2. 导入多个模块
ghci&gt; :m + Data.List Data.Map Data.Set
-- 3. 导入某些函数
ghci&gt; import Data.List (nub, sort)
-- 4. 不导入某些指定的函数
ghci&gt; import Data.List hiding (nub)
</code></pre>
<ol start="2">
<li>As</li>
</ol>
<pre><code class="language-haskell">-- 避免重名， 但是使用时必须指定 Data.Map.filter
import qualified Data.Map
-- 换名， 可以用 M.filter
import qualified Data.Map as M
</code></pre>
<h3 id="62-datalist"><a class="header" href="#62-datalist">6.2 Data.List</a></h3>
<ol>
<li>
<p>intersperse</p>
<p>向 List 中填充元素*, 类似与 python 中的 join</p>
<pre><code class="language-haskell">ghci&gt; intersperse '.' &quot;MONKEY&quot;
&quot;M.O.N.K.E.Y&quot;
ghci&gt; intersperse 0 [1,2,3,4,5,6]
[1,0,2,0,3,0,4,0,5,0,6]
</code></pre>
</li>
<li>
<p>intercalate</p>
<p>join 后进行 concat，填充后合并返回，</p>
<pre><code class="language-haskell">ghci&gt; intersperse '.' &quot;MONKEY&quot;
&quot;M.O.N.K.E.Y&quot;
ghci&gt; intersperse 0 [1,2,3,4,5,6]
[1,0,2,0,3,0,4,0,5,0,6]
</code></pre>
</li>
<li>
<p>transpose</p>
<p>矩阵转置</p>
<pre><code class="language-haskell">ghci&gt; transpose [[1,2,3],[4,5,6],[7,8,9]]
[[1,4,7],[2,5,8],[3,6,9]]
ghci&gt; transpose [&quot;hey&quot;,&quot;there&quot;,&quot;guys&quot;]
[&quot;htg&quot;,&quot;ehu&quot;,&quot;yey&quot;,&quot;rs&quot;,&quot;e&quot;]
</code></pre>
</li>
<li>
<p>foldl' foldl1'</p>
<p>能够立即运算，防止堆栈溢出</p>
<blockquote>
<p>foldl' and foldl1' are stricter versions of their respective lazy incarnations. When using lazy folds on really big lists, you might often get a stack overflow  error. The culprit for that is that due to the lazy nature of the folds, the accumulator value isn't actually updated as the folding happens.  What actually happens is that the accumulator kind of makes a promise  that it will compute its value when asked to actually produce the result (also called a thunk). That happens for every intermediate accumulator  and all those thunks overflow your stack. The strict folds aren't lazy  buggers and actually compute the intermediate values as they go along  instead of filling up your stack with thunks. So if you ever get stack  overflow errors when doing lazy folds, try switching to their strict  versions.</p>
</blockquote>
</li>
<li>
<p>concat</p>
<p>和并所有元素并返回</p>
<pre><code class="language-haskell">ghci&gt; concat [&quot;foo&quot;,&quot;bar&quot;,&quot;car&quot;]
&quot;foobarcar&quot;
ghci&gt; concat [[3,4,5],[2,3,4],[2,1,1]]
[3,4,5,2,3,4,2,1,1]
</code></pre>
<p><strong>concatMap == concat map</strong></p>
</li>
<li>
<p>and &amp; or</p>
<p>需要配合 map 使用</p>
<blockquote>
<p>and takes a list of boolean values and returns True only if all the values in the list are True.</p>
</blockquote>
<p>全为真返回 True</p>
<pre><code class="language-haskell">ghci&gt; and $ map (&gt;4) [5,6,7,8]
True
ghci&gt; and $ map (==4) [4,4,4,3,4]
False
</code></pre>
<blockquote>
<p>or is like and, only it returns True if any of the boolean values in a list is True.</p>
</blockquote>
<p>有真就返回 True</p>
<pre><code class="language-haskell">ghci&gt; or $ map (==4) [2,3,4,5,6,1]
True
ghci&gt; or $ map (&gt;4) [1,2,3]
False
</code></pre>
</li>
<li>
<p>all &amp; any</p>
<p>and 和 or 的替代品</p>
<pre><code class="language-haskell">ghci&gt; any (==4) [2,3,5,6,1,4]
True
ghci&gt; all (&gt;4) [6,9,10]
True
ghci&gt; all (`elem` ['A'..'Z']) &quot;HEYGUYSwhatsup&quot;
False
ghci&gt; any (`elem` ['A'..'Z']) &quot;HEYGUYSwhatsup&quot;
True
</code></pre>
</li>
<li>
<p>iterate</p>
<p>根据每次的结果生成下一次的值</p>
<pre><code class="language-haskell">Prelude&gt; take 10 (iterate (+10) 0)
[0,10,20,30,40,50,60,70,80,90]
Prelude&gt; take 5 $ iterate (++ &quot;haha&quot;) &quot;haha&quot;
[&quot;haha&quot;,&quot;hahahaha&quot;,&quot;hahahahahaha&quot;,&quot;hahahahahahahaha&quot;,&quot;hahahahahahahahahaha&quot;]
</code></pre>
</li>
<li>
<p>splitAt</p>
<p>分割生成列表</p>
<pre><code class="language-haskell">ghci&gt; splitAt 3 &quot;heyman&quot;
(&quot;hey&quot;,&quot;man&quot;)
ghci&gt; splitAt 100 &quot;heyman&quot;
(&quot;heyman&quot;,&quot;&quot;)
ghci&gt; splitAt (-3) &quot;heyman&quot;
(&quot;&quot;,&quot;heyman&quot;)
ghci&gt; let (a,b) = splitAt 3 &quot;foobar&quot; in b ++ a
&quot;barfoo&quot;
</code></pre>
</li>
<li>
<p>takeWhile &amp; dropWhile</p>
<p>根据条件 take 或 drop</p>
<pre><code class="language-haskell">ghci&gt; takeWhile (&gt;3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]
[6,5,4]
ghci&gt; takeWhile (/=' ') &quot;This is a sentence&quot;
&quot;This&quot;

ghci&gt; dropWhile (/=' ') &quot;This is a sentence&quot;
&quot; is a sentence&quot;
ghci&gt; dropWhile (&lt;3) [1,2,2,2,3,4,5,4,3,2,1]
[3,4,5,4,3,2,1]
</code></pre>
</li>
<li>
<p>break &amp; span</p>
<p>就是把 takeWhile 的后半部分也返回了</p>
<pre><code class="language-haskell">ghci&gt; break (==4) [1,2,3,4,5,6,7]
([1,2,3],[4,5,6,7])
ghci&gt; span (/=4) [1,2,3,4,5,6,7]
([1,2,3],[4,5,6,7])
</code></pre>
</li>
<li>
<p>sort</p>
<p>排序呗</p>
<pre><code class="language-haskell">ghci&gt; sort [8,5,3,2,1,6,4,2]
[1,2,2,3,4,5,6,8]
ghci&gt; sort &quot;This will be sorted soon&quot;
&quot;    Tbdeehiillnooorssstw&quot;
</code></pre>
</li>
<li>
<p>group</p>
<p>分组但不排序</p>
<pre><code class="language-haskell">ghci&gt; group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]
</code></pre>
</li>
<li>
<p>inits &amp; tails</p>
<p>生成一个前缀和</p>
<pre><code class="language-haskell">ghci&gt; inits &quot;w00t&quot;
[&quot;&quot;,&quot;w&quot;,&quot;w0&quot;,&quot;w00&quot;,&quot;w00t&quot;]
ghci&gt; tails &quot;w00t&quot;
[&quot;w00t&quot;,&quot;00t&quot;,&quot;0t&quot;,&quot;t&quot;,&quot;&quot;]
ghci&gt; let w = &quot;w00t&quot; in zip (inits w) (tails w)
[(&quot;&quot;,&quot;w00t&quot;),(&quot;w&quot;,&quot;00t&quot;),(&quot;w0&quot;,&quot;0t&quot;),(&quot;w00&quot;,&quot;t&quot;),(&quot;w00t&quot;,&quot;&quot;)]
</code></pre>
</li>
<li>
<p>isInfixOf &amp; isPrefixOf &amp; isSuffixOf</p>
<p>是否是 sublist，是否在开头，是否在结尾</p>
<pre><code class="language-haskell">ghci&gt; &quot;cat&quot; `isInfixOf` &quot;im a cat burglar&quot;
True
ghci&gt; &quot;Cat&quot; `isInfixOf` &quot;im a cat burglar&quot;
False
ghci&gt; &quot;cats&quot; `isInfixOf` &quot;im a cat burglar&quot;
False

ghci&gt; &quot;hey&quot; `isPrefixOf` &quot;hey there!&quot;
True
ghci&gt; &quot;hey&quot; `isPrefixOf` &quot;oh hey there!&quot;
False
ghci&gt; &quot;there!&quot; `isSuffixOf` &quot;oh hey there!&quot;
True
ghci&gt; &quot;there!&quot; `isSuffixOf` &quot;oh hey there&quot;
False
</code></pre>
</li>
<li>
<p>elem &amp; notElem &amp; partition</p>
</li>
</ol>
<pre><code>判断是否是，分为两组

```haskell
ghci&gt; partition (`elem` ['A'..'Z']) &quot;BOBsidneyMORGANeddy&quot;
(&quot;BOBMORGAN&quot;,&quot;sidneyeddy&quot;)
</code></pre>
<pre><code>
17. find &amp; findIndex &amp; findIndices

</code></pre>
<p>find 返回第一个符合的元素</p>
<pre><code class="language-haskell">ghci&gt; find (&gt;4) [1,2,3,4,5,6]
Just 5
ghci&gt; find (&gt;9) [1,2,3,4,5,6]
Nothing
ghci&gt; :t find
find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a

ghci&gt; findIndex (==4) [5,3,2,1,6,4]
Just 5
ghci&gt; findIndex (==7) [5,3,2,1,6,4]
Nothing
ghci&gt; findIndices (`elem` ['A'..'Z']) &quot;Where Are The Caps?&quot;
[0,6,10,14]
</code></pre>
<pre><code>
18. elemIndex  &amp; elemIndIces

    返回元素的 index

    ```haskell
    ghci&gt; :t elemIndex
    elemIndex :: (Eq a) =&gt; a -&gt; [a] -&gt; Maybe Int
    ghci&gt; 4 `elemIndex` [1,2,3,4,5,6]
    Just 3
    ghci&gt; 10 `elemIndex` [1,2,3,4,5,6]
    Nothing

    ghci&gt; ' ' `elemIndices` &quot;Where are the spaces?&quot;
    [5,9,13]
    ```
19. more zip

    一直提供到 7

    ```haskell
    ghci&gt; zipWith3 (\x y z -&gt; x + y + z) [1,2,3] [4,5,2,2] [2,2,3]
    [7,9,8]
    ghci&gt; zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]
    [(2,2,5,2),(3,2,5,2),(3,2,3,2)]
    ```
20. line &amp; word

    line 切出没一行，word 切出每个单词

    ```haskell
    ghci&gt; lines &quot;first line\nsecond line\nthird line&quot;
    [&quot;first line&quot;,&quot;second line&quot;,&quot;third line&quot;]
    ghci&gt; unlines [&quot;first line&quot;, &quot;second line&quot;, &quot;third line&quot;]
    &quot;first line\nsecond line\nthird line\n&quot;
    ghci&gt; words &quot;hey these are the words in this sentence&quot;
    [&quot;hey&quot;,&quot;these&quot;,&quot;are&quot;,&quot;the&quot;,&quot;words&quot;,&quot;in&quot;,&quot;this&quot;,&quot;sentence&quot;]
    ghci&gt; words &quot;hey these           are    the words in this\nsentence&quot;
    [&quot;hey&quot;,&quot;these&quot;,&quot;are&quot;,&quot;the&quot;,&quot;words&quot;,&quot;in&quot;,&quot;this&quot;,&quot;sentence&quot;]
    ghci&gt; unwords [&quot;hey&quot;,&quot;there&quot;,&quot;mate&quot;]
    &quot;hey there mate&quot;
    ```
21. nub

    元素去重

    ```haskell
    ghci&gt; nub [1,2,3,4,3,2,1,2,3,4,3,2,1]
    [1,2,3,4]
    ghci&gt; nub &quot;Lots of words and stuff&quot;
    &quot;Lots fwrdanu&quot;
    ```
22. delete

    删掉地一个匹配的元素

    ```haskell
    -- delete takes an element and a list and deletes the first occurence of that element in the list.

    ghci&gt; delete 'h' &quot;hey there ghang!&quot;
    &quot;ey there ghang!&quot;
    ghci&gt; delete 'h' . delete 'h' $ &quot;hey there ghang!&quot;
    &quot;ey tere ghang!&quot;
    ghci&gt; delete 'h' . delete 'h' . delete 'h' $ &quot;hey there ghang!&quot;
    &quot;ey tere gang!&quot;
    ```
23. \\\\

</code></pre>
<p>删掉更多</p>
<pre><code class="language-haskell">-- \\ is the list difference function. It acts like a set difference, basically. For every element in the right-hand list, it removes a matching element in the left one.

ghci&gt; [1..10] \\ [2,5,9]
[1,3,4,6,7,8,10]
ghci&gt; &quot;Im a big baby&quot; \\ &quot;big&quot;
&quot;Im a  baby&quot;
</code></pre>
<pre><code>
24. union

    求并集

    ```haskell
    ghci&gt; &quot;hey man&quot; `union` &quot;man what's up&quot;
    &quot;hey manwt'sup&quot;
    ghci&gt; [1..7] `union` [5..10]
    [1,2,3,4,5,6,7,8,9,10]
    ```
25. intersect

    求交集

    ```haskell
    ghci&gt; [1..7] `intersect` [5..10]
    [5,6,7]
    ```
26. insert

    插入呗

    ```haskell
    ghci&gt; insert 4 [3,5,1,2,8,2]
    [3,4,5,1,2,8,2]
    ghci&gt; insert 4 [1,3,4,4,1]
    [1,3,4,4,4,1]
    ```
27. deleteBy, unionBy, intersectBy and groupBy

    以一个数开始， 以此比较他后面的数，知道不匹配， 组成数组

    接着以第一个不匹配的数开始，重复比较

    ```haskell
    ghci&gt; let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3]
    ghci&gt; groupBy (\x y -&gt; (x &gt; 0) == (y &gt; 0)) values
    -- 也可以写成 \x y -&gt; (x &gt; 0) &amp;&amp; (y &gt; 0) || (x &lt;= 0) &amp;&amp; (y &lt;= 0)
    [[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
    ghci&gt; groupBy (\x y -&gt; (x&gt;0) == (y&lt;0)) values
    -- 第一个数和后面的符号都不同
    [[-4.3],[-2.4],[-1.2,0.4,2.3,5.9,10.5,29.1,5.3],[-2.4],[-14.5,2.9,2.3]]
    ```
28. on

    还有更好的方法写上面的 lambada 表达式

    on 需要从 Data.Function 导入

    on 接受两个参数，第二个会对参数做的运算， 第一个是函数会比较两个运算后结果

    ```haskell
    on :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
    f `on` g = \x y -&gt; f (g x) (g y)
    ```

### 6.3 Data.Char

Data.Char 提供了一系列处理字符的函数，配合 map 和 filter 使用也可以用来处理字符串

**1. 判断类**

1. isControl checks whether a character is a control character.
2. isSpace checks whether a character is a white-space characters. That includes spaces, tab characters, newlines, etc.
3. isLower checks whether a character is lower-cased.
4. isUpper checks whether a character is upper-cased.
5. isAlpha checks whether a character is a letter.
6. isAlphaNum checks whether a character is a letter or a number.
7. isPrint checks whether a character is printable. Control characters, for instance, are not printable.
8. isDigit checks whether a character is a digit.
9. isOctDigit checks whether a character is an octal digit.
10. isHexDigit checks whether a character is a hex digit.
11. isLetter checks whether a character is a letter.
12. isMark checks for Unicode mark characters. Those are characters that combine with preceding letters to form latters with accents. Use this if you are French.
13. isNumber checks whether a character is numeric.
14. isPunctuation checks whether a character is punctuation.
15. isSymbol checks whether a character is a fancy mathematical or currency symbol.
16. isSeparator checks for Unicode spaces and separators.
17. isAscii checks whether a character falls into the first 128 characters of the Unicode character set.
18. isLatin1 checks whether a character falls into the first 256 characters of Unicode.
19. isAsciiUpper checks whether a character is ASCII and upper-case.
20. isAsciiLower checks whether a character is ASCII and lower-case.

**2. 转换类**

1. toUpper converts a character to upper-case. Spaces, numbers, and the like remain unchanged.
2. toLower converts a character to lower-case.
3. toTitle converts a character to title-case. For most characters, title-case is the same as upper-case.
4. digitToInt converts a character to an Int. To succeed, the character must be in the ranges '0'..'9', 'a'..'f' or 'A'..'F'.
5. intToDigit is the inverse function of digitToInt. It takes an Int in the range of 0..15 and converts it to a lower-case character.
6. ord and chr convert characters to their corresponding numbers and vice versa:

   ```haskell
   ghci&gt; ord 'a'
   97
   ghci&gt; chr 97
   'a'
   ghci&gt; map ord &quot;abcdefgh&quot;
   [97,98,99,100,101,102,103,104]
</code></pre>
<ol start="7">
<li>
<p>encode</p>
<pre><code class="language-haskell">-- 一种编码方式
encode :: Int -&gt; String -&gt; String
encode shift msg =
	let ords = map ord msg
		shifted = map (+ shift) ords
	in  map chr shifted
-- 另一种实现
map (chr . (+ shift) . ord) msg.
-- 实例代码
ghci&gt; encode 3 &quot;Heeeeey&quot;
&quot;Khhhhh|&quot;
ghci&gt; encode 4 &quot;Heeeeey&quot;
&quot;Liiiii}&quot;
ghci&gt; encode 1 &quot;abcd&quot;
&quot;bcde&quot;
ghci&gt; encode 5 &quot;Marry Christmas! Ho ho ho!&quot;
&quot;Rfww~%Hmwnxyrfx&amp;%Mt%mt%mt&amp;&quot;
</code></pre>
</li>
</ol>
<h3 id="64-datamap"><a class="header" href="#64-datamap">6.4 Data.Map</a></h3>
<p>下面给出了几种写 map 的方法</p>
<pre><code class="language-haskell">-- 第一种 filter 实现
findKey :: (Eq k) =&gt; k -&gt; [(k, v)] -&gt; v
findKey key xs = (snd . head . filter (\ (k, v) -&gt; key == k)) xs

-- 第二种 Maybe 非空校验
findKey :: (Eq k) =&gt; k -&gt; [(k, v)] -&gt; Maybe v
findKey _ [] = Nothing
findKey key ((k, v):xs) = if k == key
                                                        then Just v
                                                        else findKey key xs

-- 第三种 使用 foldr 而非递归，因为比递归的可读性更好
-- Note: It's usually better to use folds for this standard list recursion pattern instead of explicitly writing the recursion because they're easier to read and identify. Everyone knows it's a fold when they see the foldr call, but it takes some more thinking to read explicit recursion.
findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v
findKey key xs = foldr (\(k,v) acc -&gt; if key == k then Just v else acc) Nothing xs

main :: IO ()
main = do
        let phoneBook =
                [(&quot;aaa&quot;,&quot;111&quot;)
                ,(&quot;bbb&quot;,&quot;222&quot;)
                ,(&quot;ccc&quot;,&quot;333&quot;)
                ]
        print $ findKey &quot;bbb&quot; phoneBook
</code></pre>
<p>下面是一堆函数</p>
<ol>
<li>
<p>fromList</p>
<p>创建一个 Map</p>
<pre><code class="language-haskell">ghci&gt; Map.fromList [(&quot;betty&quot;,&quot;555-2938&quot;),(&quot;bonnie&quot;,&quot;452-2928&quot;),(&quot;lucille&quot;,&quot;205-2928&quot;)]
fromList [(&quot;betty&quot;,&quot;555-2938&quot;),(&quot;bonnie&quot;,&quot;452-2928&quot;),(&quot;lucille&quot;,&quot;205-2928&quot;)]
ghci&gt; Map.fromList [(1,2),(3,4),(3,2),(5,5)]
fromList [(1,2),(3,2),(5,5)]
</code></pre>
<p>自己实现</p>
<pre><code class="language-haskell">-- We can implement our own fromList by using the empty map, insert and a fold. Watch:

fromList' :: (Ord k) =&gt; [(k,v)] -&gt; Map.Map k v
fromList' = foldr (\(k,v) acc -&gt; Map.insert k v acc) Map.empty
</code></pre>
</li>
<li>
<p>empty</p>
<p>返回一个空 Map</p>
<pre><code class="language-haskell">ghci&gt; Map.empty 
fromList []  
</code></pre>
</li>
<li>
<p>insert</p>
<p>插入一对 k，v</p>
<pre><code class="language-haskell">ghci&gt; Map.empty
fromList []
ghci&gt; Map.insert 3 100 Map.empty
fromList [(3,100)]
ghci&gt; Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty))
fromList [(3,100),(4,200),(5,600)]
ghci&gt; Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty
fromList [(3,100),(4,200),(5,600)]
</code></pre>
</li>
<li>
<p>null</p>
<p>检查是否为空</p>
<pre><code class="language-haskell">ghci&gt; Map.null Map.empty
True
ghci&gt; Map.null $ Map.fromList [(2,3),(5,5)]
False
</code></pre>
</li>
<li>
<p>size</p>
<p>返回 map 的大小</p>
<pre><code class="language-haskell">ghci&gt; Map.size Map.empty
0
ghci&gt; Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]
5
</code></pre>
</li>
<li>
<p>singleton</p>
<p>重建只有一对 kv 的 Map</p>
<pre><code class="language-haskell">ghci&gt; Map.singleton 3 9
fromList [(3,9)]
ghci&gt; Map.insert 5 9 $ Map.singleton 3 9
fromList [(3,9),(5,9)]
</code></pre>
</li>
<li>
<p>lookup</p>
<p>就是 get</p>
<pre><code class="language-haskell">Prelude Map&gt; Map.lookup 4 a
Just 200
</code></pre>
</li>
<li>
<p>member</p>
<p>就是 in</p>
<pre><code class="language-haskell">ghci&gt; Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)]
True
ghci&gt; Map.member 3 $ Map.fromList [(2,5),(4,5)]
False
</code></pre>
</li>
<li>
<p>map and filter</p>
<p>只作用于 v</p>
<pre><code class="language-haskell">ghci&gt; Map.map (*100) $ Map.fromList [(1,1),(2,4),(3,9)]
fromList [(1,100),(2,400),(3,900)]
ghci&gt; Map.filter isUpper $ Map.fromList [(1,'a'),(2,'A'),(3,'b'),(4,'B')]
fromList [(2,'A'),(4,'B')]
</code></pre>
</li>
<li>
<p>toList</p>
<p>如其名</p>
<pre><code class="language-haskell">ghci&gt; Map.toList . Map.insert 9 2 $ Map.singleton 4 3
[(4,3),(9,2)]
</code></pre>
</li>
<li>
<p>keys and elems</p>
<p>返回 keys 和 values</p>
</li>
<li>
<p>fromListWith</p>
<p>类似与 fromList， 不过有一个函数决定重复的 key 应该怎么办</p>
<pre><code class="language-haskell">-- 有重复的键
phoneBook =
    [(&quot;betty&quot;,&quot;555-2938&quot;)
    ,(&quot;betty&quot;,&quot;342-2492&quot;)
    ,(&quot;bonnie&quot;,&quot;452-2928&quot;)
    ,(&quot;patsy&quot;,&quot;493-2928&quot;)
    ,(&quot;patsy&quot;,&quot;943-2929&quot;)
    ,(&quot;patsy&quot;,&quot;827-9162&quot;)
    ,(&quot;lucille&quot;,&quot;205-2928&quot;)
    ,(&quot;wendy&quot;,&quot;939-8282&quot;)
    ,(&quot;penny&quot;,&quot;853-2492&quot;)
    ,(&quot;penny&quot;,&quot;555-2111&quot;)
]
-- 重复的键的值会被加一起
phoneBookToMap :: (Ord k) =&gt; [(k, String)] -&gt; Map.Map k String
phoneBookToMap xs = Map.fromListWith (\number1 number2 -&gt; number1 ++ &quot;, &quot; ++ number2) xs

-- 查看
ghci&gt; Map.lookup &quot;patsy&quot; $ phoneBookToMap phoneBook
&quot;827-9162, 943-2929, 493-2928&quot;
ghci&gt; Map.lookup &quot;wendy&quot; $ phoneBookToMap phoneBook
&quot;939-8282&quot;
ghci&gt; Map.lookup &quot;betty&quot; $ phoneBookToMap phoneBook
&quot;342-2492, 555-2938&quot;
</code></pre>
<p>下面是另外两个例子</p>
<pre><code class="language-haskell">ghci&gt; Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,100),(3,29),(4,22)]
ghci&gt; Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]
fromList [(2,108),(3,62),(4,37)]
</code></pre>
</li>
<li>
<p>insertWith</p>
<p>差不多， 条件插入</p>
<pre><code class="language-haskell">ghci&gt; Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)]
fromList [(3,104),(5,103),(6,339)]
</code></pre>
</li>
</ol>
<h3 id="65-dataset"><a class="header" href="#65-dataset">6.5 Data.Set</a></h3>
<ol>
<li>
<p>fromList</p>
<p>去重</p>
<pre><code class="language-haskell">text1 = &quot;I just had an anime dream. Anime... Reality... Are they so different?&quot;
text2 = &quot;The old man left his garbage can out and now his trash is all over my lawn!&quot;
ghci&gt; let set1 = Set.fromList text1
ghci&gt; let set2 = Set.fromList text2
ghci&gt; set1
fromList &quot; .?AIRadefhijlmnorstuy&quot;
ghci&gt; set2
fromList &quot; !Tabcdefghilmnorstuvwy&quot;
</code></pre>
</li>
<li>
<p>intersection</p>
<p>求交集</p>
<pre><code class="language-haskell">ghci&gt; Set.intersection set1 set2
fromList &quot; adefhilmnorstuy&quot;
</code></pre>
</li>
<li>
<p>difference</p>
<p>求第一个集合有第二个没有</p>
<pre><code class="language-haskell">ghci&gt; Set.difference set1 set2
fromList &quot;.?AIRj&quot;
ghci&gt; Set.difference set2 set1
fromList &quot;!Tbcgvw&quot;
</code></pre>
</li>
<li>
<p>union</p>
<pre><code class="language-haskell">ghci&gt; Set.union set1 set2
fromList &quot; !.?AIRTabcdefghijlmnorstuvwy&quot;
</code></pre>
</li>
<li>
<p>其他</p>
<p>null, size, member, empty, singleton, insert and delete 就和你想的一样</p>
</li>
</ol>
<h2 id="7-自定义类型"><a class="header" href="#7-自定义类型">7. 自定义类型</a></h2>
<p>使用 data 关键字定义</p>
<p>等号左边的是 <strong>type name</strong>，等好右边的是 <strong>value constructors</strong></p>
<pre><code class="language-haskell">data Bool = False | True
</code></pre>
<p>Int 类型可能有下面的定义</p>
<pre><code class="language-haskell">-- 真实不是这样的，只是为了说明问题
data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647
</code></pre>
<h3 id="71-基本类型定义"><a class="header" href="#71-基本类型定义">7.1 基本类型定义</a></h3>
<p>下面让我们进行一个形状的定义</p>
<p>一个圆的定义可能需要三个参数，前两个是圆的坐标，第三个参数是半径，所以我们可以想 <code>(43.1, 55.0, 10.4)</code>这样定义一个圆，但是这三个参数也能表示一个 3D vector 或者是别的什么东西，所以我们最好定义一个叫做 Shape 的新类型</p>
<pre><code class="language-haskell">data Shape = Circle Float Float Float | Rectangle Float Float Float Float

ghci&gt; :t Circle
Circle :: Float -&gt; Float -&gt; Float -&gt; Shape
ghci&gt; :t Rectangle
Rectangle :: Float -&gt; Float -&gt; Float -&gt; Float -&gt; Shape
</code></pre>
<p><strong>new 一个实例</strong></p>
<pre><code class="language-haskell">ghci&gt; Circle 10 20 5
Circle 10.0 20.0 5.0
ghci&gt; Rectangle 50 230 60 90
Rectangle 50.0 230.0 60.0 90.0
</code></pre>
<p>type name 和 value constructor 首字母需要大写</p>
<p>下面定义了一个完整的 Shape 模块</p>
<pre><code class="language-haskell">-- Shape(..) 会将所有的构造器暴露给外部
-- 等同于 Shape (Rectangle, Circle)
module Shapes
( Point(..)
, Shape(..)
, surface
, nudge
, baseCircle
, baseRect
) where

-- deriving (Show) 自动实现 Show
data Point = Point Float Float deriving (Show)
data Shape = Circle Point Float | Rectangle Point Point deriving (Show)
surface :: Shape -&gt; Float
surface (Circle _ r) = pi * r ^ 2
surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)

nudge :: Shape -&gt; Float -&gt; Float -&gt; Shape
nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r
nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))

baseCircle :: Float -&gt; Shape
baseCircle r = Circle (Point 0 0) r

baseRect :: Float -&gt; Float -&gt; Shape
baseRect width height = Rectangle (Point 0 0) (Point width height)
</code></pre>
<p>我们也可以不暴露 Shape，让用户只能通过 baseCircle，baseRect 构造，让我们的接口更加抽象</p>
<h3 id="72-record-syntax-定义类型"><a class="header" href="#72-record-syntax-定义类型">7.2 record syntax 定义类型</a></h3>
<p>第一种方式</p>
<pre><code class="language-haskell">data Person = Person String String Int Float String String deriving (Show)
firstName :: Person -&gt; String
firstName (Person firstname _ _ _ _ _) = firstname

lastName :: Person -&gt; String
lastName (Person _ lastname _ _ _ _) = lastname

age :: Person -&gt; Int
age (Person _ _ age _ _ _) = age

height :: Person -&gt; Float
height (Person _ _ _ height _ _) = height

phoneNumber :: Person -&gt; String
phoneNumber (Person _ _ _ _ number _) = number

flavor :: Person -&gt; String
flavor (Person _ _ _ _ _ flavor) = flavor
</code></pre>
<p>使用 record syntax 定义 Person</p>
<pre><code class="language-haskell">data Person = Person { firstName :: String
                     , lastName :: String
                     , age :: Int
                     , height :: Float
                     , phoneNumber :: String
                     , flavor :: String
                     } deriving (Show)
</code></pre>
<p>haskell 会自动生成上面的函数</p>
<pre><code class="language-haskell">ghci&gt; :t flavor
flavor :: Person -&gt; String
ghci&gt; :t firstName
firstName :: Person -&gt; String
</code></pre>
<p><strong>new 一个实例</strong></p>
<pre><code class="language-haskell">ghci&gt; Car {company=&quot;Ford&quot;, model=&quot;Mustang&quot;, year=1967}
Car {company = &quot;Ford&quot;, model = &quot;Mustang&quot;, year = 1967}
</code></pre>
<h3 id="73-类型参数"><a class="header" href="#73-类型参数">7.3 类型参数</a></h3>
<h4 id="731-maybe"><a class="header" href="#731-maybe">7.3.1 Maybe</a></h4>
<pre><code class="language-haskell">data Maybe a = Nothing | Just a
</code></pre>
<p><strong>类型构造器</strong></p>
<p>a 是一个类型参数，因为这个类型 a，所以我们称 Maybe 是一个 type constructor（类型构造器）（注意：和之前的 value constructor 不一样），所以 Maybe 不是一个类型</p>
<p>我们能够传入 Char 或者 Int，就能的到一个 Maybe Char 或者 Maybe Int 类型</p>
<h4 id="732-car"><a class="header" href="#732-car">7.3.2 Car</a></h4>
<p>下面举了一个 Car 的例子，他就可能是 (Car String String Int) 类型</p>
<pre><code class="language-haskell">    data Car a b c = Car { company :: a
                         , model :: b
                         , year :: c
                         } deriving (Show)
</code></pre>
<p>但是用这种形式声明并没有太多好处，大部分情况下我们只需要一种状态 <code>Car String String Int</code> 就够了</p>
<p>所以我们会用下面的方式</p>
<pre><code class="language-haskell">data Car = Car { company :: String
               , model :: String
               , year :: Int
               } deriving (Show)
tellCar :: Car -&gt; String
tellCar (Car {company = c, model = m, year = y}) = &quot;This &quot; ++ c ++ &quot; &quot; ++ m ++ &quot; was made in &quot; ++ show y
</code></pre>
<p>我们之前也见过一个使用类型参数的例子，就是 Map，k，v 分别是 key 和 value 的类型</p>
<pre><code class="language-haskell">data (Ord k) =&gt; Map k v = ...
</code></pre>
<h4 id="733-vector"><a class="header" href="#733-vector">7.3.3 Vector</a></h4>
<pre><code class="language-haskell">data Vector2 a = Vector2 [a] [a] [a] deriving (Show)
vplus :: (Char t) =&gt; Vector2 t -&gt; Vector2 t -&gt; Vector2 t
(Vector2 a1 a2 a3) `vplus` (Vector2 b1 b2 b3) = Vector2 a1++b1 a2++b2 a3++b3
</code></pre>
<h3 id="74-派生实例"><a class="header" href="#74-派生实例">7.4 派生实例</a></h3>
<p><strong>Derived instances</strong></p>
<h4 id="741-derive"><a class="header" href="#741-derive">7.4.1 derive</a></h4>
<p>Typeclasses 更像是接口，我们使用 <code>derive</code> 关键字可以自动派生出行为</p>
<pre><code class="language-haskell">    data Person = Person { firstName :: String
                         , lastName :: String
                         , age :: Int
                         } deriving (Eq, Show, Read)
</code></pre>
<p>该类型派生自 Eq，所以实现了 <code>==</code> 和 <code>/=</code>, 还能够应用在任何在类型签名上具有 <code>Eq a</code> 的函数</p>
<pre><code class="language-haskell">ghci&gt; let mikeD = Person {firstName = &quot;Michael&quot;, lastName = &quot;Diamond&quot;, age = 43}
ghci&gt; let adRock = Person {firstName = &quot;Adam&quot;, lastName = &quot;Horovitz&quot;, age = 41}
ghci&gt; let mca = Person {firstName = &quot;Adam&quot;, lastName = &quot;Yauch&quot;, age = 44}
ghci&gt; mca == adRock
False
ghci&gt; mikeD == Person {firstName = &quot;Michael&quot;, lastName = &quot;Diamond&quot;, age = 43}
True
</code></pre>
<p>Read 和 Show 能实现类型和字符串间的相互转化，当我们使用 Read 时，需要指定结果的类型</p>
<pre><code class="language-haskell">ghci&gt; read &quot;Person {firstName =\&quot;Michael\&quot;, lastName =\&quot;Diamond\&quot;, age = 43}&quot; :: Person
Person {firstName = &quot;Michael&quot;, lastName = &quot;Diamond&quot;, age = 43}
</code></pre>
<p>偶们也能够读取参数化类型（parameterized types），但是必须填上类型</p>
<pre><code class="language-haskell">-- So we can't do
read &quot;Just 't'&quot; :: Maybe a
-- but we can do
read &quot;Just 't'&quot; :: Maybe Char
</code></pre>
<h4 id="742-实现一些-typeclasses"><a class="header" href="#742-实现一些-typeclasses">7.4.2 实现一些 Typeclasses</a></h4>
<ol>
<li>
<p>Ord 的比较规则，在前面的比较小，与 Char 比较无关</p>
<pre><code class="language-haskell">data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum)

ghci&gt; Saturday &gt; Friday
True
</code></pre>
</li>
</ol>
<h4 id="743-类型同义词"><a class="header" href="#743-类型同义词">7.4.3 类型同义词</a></h4>
<p><strong>Type synonyms</strong></p>
<p>就是换个名而已</p>
<pre><code class="language-haskell">-- 下面是 String 的定义
type String = [Char]

type IntMap v = Map Int v
type IntMap = Map Int
</code></pre>
<p>需要分清类型构造器和值构造器（type constructors and value constructors）的区别</p>
<h4 id="744-either"><a class="header" href="#744-either">7.4.4 Either</a></h4>
<p>下面我们在介绍一种类型 Either</p>
<pre><code class="language-haskell">-- 定义
data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)
</code></pre>
<blockquote>
<p>So far, we've seen that Maybe a was mostly used to represent the results of computations that could have either failed or not. But somtimes, Maybe a isn't good enough because Nothing doesn't really convey much information other than that something has  failed. That's cool for functions that can fail in only one way or if  we're just not interested in how and why they failed. A Data.Map lookup fails only if the key we were looking for wasn't in the map, so  we know exactly what happened. However, when we're interested in how  some function failed or why, we usually use the result type of Either a b, where a is some sort of type that can tell us something about the possible failure and b is the type of a successful computation. Hence, errors use the Left value constructor while results use Right.</p>
</blockquote>
<p>Maybe 不能满足所有的需要，Either 通常用于错误处理，左值一般表示错误原因，右值一般是正确的结果</p>
<p>下面给除了一个例子</p>
<pre><code class="language-haskell">import qualified Data.Map as Map

-- declear LockerMap
data LockerState = Taken | Free deriving (Show, Eq)
type Code = String
type LockerMap = Map.Map Int (LockerState, Code)

-- give a LoockerLookUp function
lockerLookUp :: Int -&gt; LockerMap -&gt; Either String Code
lockerLookUp lockerNum map = case Map.lookup lockerNum map of
        Nothing  -&gt; Left $ &quot;Locker Number&quot; ++ show lockerNum ++ &quot;doesn't exist&quot;
        Just (lockerState, code) -&gt; if lockerState == Taken
                                 then Left $ &quot;Locker Number&quot; ++ show lockerNum ++ &quot;is already taken!&quot;
                                 else Right code

main = do
    let lockers = Map.fromList[(1, (Taken, &quot;aaa&quot;)),(2, (Free, &quot;bbb&quot;)),(3, (Taken, &quot;ccc&quot;))]
    print $ lockerLookUp 1 lockers
    print $ lockerLookUp 2 lockers
    print $ lockerLookUp 3 lockers
    print $ lockerLookUp 4 lockers

</code></pre>
<h4 id="745-递归"><a class="header" href="#745-递归">7.4.5 递归</a></h4>
<p>下面的例子实现了一个 List 和一个 Tree</p>
<pre><code class="language-haskell">infixr 5 :-:
data List a = Empty | a :-: (List a) deriving (Show, Read, Ord, Eq)
-- 或者是 record syntex
-- data Lsit = Empty | Cons {listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)

-- infixr 5 ++
-- (++) :: [a] -&gt; [a] -&gt; [a]
-- [] ++ ys = ys
-- (x:xs) ++ ys = x:(xs ++ ys)
infixr 5 .++
(.++) :: List a -&gt; List a -&gt; List a
Empty .++ ys = ys
(x :-: xs) .++ ys = x :-: (xs .++ ys)

data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq, Ord)

singleton :: a -&gt; Tree a
singleton x = Node x EmptyTree EmptyTree

treeInsert :: (Ord a) =&gt; a -&gt; Tree a -&gt; Tree a
treeInsert x EmptyTree = singleton x
treeInsert x (Node a left right)
    | x == a = Node x left right
    | x  &lt; a = Node a (treeInsert x left) right
    | x  &gt; a = Node a left (treeInsert x right)

treeElem :: (Ord) a =&gt; a -&gt; Tree a -&gt; Bool
treeElem x EmptyTree = False
treeElem x (Node a left right)
    | x == a = True
    | x &lt; a = treeElem x left
    | x &gt; a = treeElem x right


main = do
    putStrLn &quot;start...&quot;
    let a = 3 :-: 4 :-: 5 :-: Empty
    print a
    let b = 6 :-: 7 :-: Empty
    print(a .++ b)
    let nums = [8, 6, 4, 1, 3, 5]
    let numsTree = foldr treeInsert EmptyTree nums
    print numsTree
    print $ treeElem 4 numsTree
    putStrLn &quot;end...&quot;

</code></pre>
<h4 id="746-typeclasses-102"><a class="header" href="#746-typeclasses-102">7.4.6 Typeclasses 102</a></h4>
<blockquote>
<p>A quick recap on typeclasses: typeclasses are like interfaces. A  typeclass defines some behavior (like comparing for equality, comparing  for ordering, enumeration) and then types that can behave in that way  are made instances of that typeclass. The behavior of typeclasses is  achieved by defining functions or just type declarations that we then  implement. So when we say that a type is an instance of a typeclass, we  mean that we can use the functions that the typeclass defines with that  type.</p>
</blockquote>
<p>对 typeclasses 的简要回顾：typeclasses 就像接口。一个 typeclasses 定义了一些行为（比如比较，排序），可以实现这些行为的类型就是这些 typeclass 的实例，通过定义函数或者声明去实现这些行为，因此，当我们说类型是类型的一个类型的实例时，我们的意思是我们可以使用 TypeClass 定义该类型的函数。</p>
<pre><code class="language-haskell">-- 使用 :info Num 可以查看 typeclass 定义
Prelude&gt; :info Num
type Num :: * -&gt; Constraint
class Num a where
  (+) :: a -&gt; a -&gt; a
  (-) :: a -&gt; a -&gt; a
  (*) :: a -&gt; a -&gt; a
  negate :: a -&gt; a
  abs :: a -&gt; a
  signum :: a -&gt; a
  fromInteger :: Integer -&gt; a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
        -- Defined in ‘GHC.Num’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’

</code></pre>
<p><strong>1. 定义 typeclasses</strong></p>
<p>下面是 Eq 在标准库的定义</p>
<pre><code class="language-haskell">class Eq a where
    (==) :: a -&gt; a -&gt; Bool
    (/=) :: a -&gt; a -&gt; Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
</code></pre>
<p>class 定义了一个 typeclass，Eq 是名字，a 是实例，a 只要是一个小写的单词就行</p>
<p>接着我们定义了一些函数，在 class 里实现函数不是强制的，只需要一个定义就够了</p>
<blockquote>
<p>Some people might understand this better if we wrote class Eq equatable where and then specified the type declarations like <code>(==) :: equatable -&gt; equatable -&gt; Bool</code>.</p>
<p>这种写法可能更好理解：<code>(==) :: equatable -&gt; equatable -&gt; Bool</code></p>
</blockquote>
<blockquote>
<p>If we have say class Eq a where and then define a type declaration within that class like (==) :: a -&gt; -a -&gt; Bool, then when we examine the type of that function later on, it will have the type of <code>(Eq a) =&gt; a -&gt; a -&gt; Bool</code>.</p>
<p>当我们在 class 中定义这个函数后，在查看这个函数的类型时，就会显示出 typeclasses</p>
</blockquote>
<p><strong>2. 实现 typeclass</strong></p>
<p>下面我们实现一个 <code>TrafficLight</code></p>
<pre><code class="language-haskell">data TrafficLight = Red | Yellow | Green
-- 实现比较
instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False
-- 手动实现字符串转换
instance Show TrafficLight where
    show Red = &quot;Red light&quot;
    show Yellow = &quot;Yellow light&quot;
    show Green = &quot;Green light&quot;
main = do
    putStrLn &quot;start...&quot;
    print $ Red == Red
    print $ show [Red, Yellow, Green]
</code></pre>
<p><strong>3. subtypeclasses</strong></p>
<p>下面是 Num 在标准库中的定义（第一行）</p>
<pre><code class="language-haskell">class (Eq a) =&gt; Num a where
</code></pre>
<p>在实现 Num 前，必须保证 a 实现了 Eq</p>
<p><strong>对于多态类型</strong></p>
<pre><code class="language-haskell">instance Eq (Maybe m) where
    Just x == Just y = x == y
    Nothing == Nothing = True
    _ == _ = False

</code></pre>
<p>上面的例子好像解决了问题，但是不能确定 m 的类型实现了 Eq，所以我们应该修改上面的声明：</p>
<pre><code class="language-haskell">instance (Eq m) =&gt; Eq (Maybe m) where
	Just x == Just y = x == y
	Nothing == Nothing = True
	_ == _ = False
</code></pre>
<p>这次我们增加了一个类型限定，我们限定了所有 Maybe m 类型都是 Eq，除非 m 也是 Eq</p>
<p>🍏</p>
<blockquote>
<p>Take into account that the type you're trying to make an instance of will replace the parameter in the <em>class</em> declaration. The a from class Eq a where will be replaced with a real type when you make an instance, so try  mentally putting your type into the function type declarations as well. (==) :: Maybe -&gt; Maybe -&gt; Bool doesn't make much sense but (==) :: (Eq m) =&gt; Maybe m -&gt; Maybe m -&gt; Bool does. But this is just something to think about, because == will always have a type of (==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool, no matter what instances we make.</p>
<p>一定要 注意 'a' 在实现时需要被替换为 concrete type</p>
</blockquote>
<p><strong>4. 实现一个玩具</strong></p>
<p>在 js 中，任何非空类型都被当成是 true</p>
<pre><code class="language-js">if (0) alert(&quot;YEAH!&quot;) else alert(&quot;NO!&quot;)
if (&quot;&quot;) alert (&quot;YEAH!&quot;) else alert(&quot;NO!&quot;)
if (false) alert(&quot;YEAH&quot;) else alert(&quot;NO!)
//etc. and all of these will throw an alert of NO!. If you do
if (&quot;WHAT&quot;) alert (&quot;YEAH&quot;) else alert(&quot;NO!&quot;)
// it will alert a &quot;YEAH!&quot;
</code></pre>
<p><em>A yesno typeclass</em></p>
<pre><code class="language-haskell">class YesNo a where
    yesno :: a -&gt; Bool

instance YesNo Int where
    yesno 0 = False
    yesno _ = True

instance YesNo [a] where
    yesno [] = False
    yesno _ = True

-- Bool 也不要忘了
instance YesNo Bool where
    yesno = id

-- 因为我们并不关心 Maybe 包含什么类型，只要他有东西就行了，所以没有加类型限定
instance YesNo (Maybe a) where
    yesno (Just _) = True
    yesno Nothing = False

-- 仿照着写一个 if
yesnoIf :: (YesNo a) =&gt; a -&gt; b -&gt; b -&gt; b
yesnoIf a onyes onno = if yesno a then onyes else onno

main :: IO ()
main = do
    putStrLn &quot;start...&quot;
    print $ length []
    print $ yesno [0]
    print $ yesno Nothing
    print $ yesno True
    putStrLn $ yesnoIf (Just 1) &quot;yes !&quot; &quot;No -_-&quot;

</code></pre>
<h4 id="747-functor-和-kinds"><a class="header" href="#747-functor-和-kinds">7.4.7 Functor 和 Kinds</a></h4>
<p><strong>1. 什么是 Kind</strong></p>
<blockquote>
<p>We used :k on a type to get its kind, just like we can use :t on a value to get its type. Like we said, types are the labels of  values and kinds are the labels of types and there are parallels between the two.</p>
</blockquote>
<p>我们能用 <code>:t</code> 查看一个值 (value) 的类型 (type)</p>
<pre><code class="language-haskell">-- '=&gt;'是类型限定 !!!
Prelude&gt; :t 1
1 :: Num p =&gt; p

Prelude&gt; :t [1, 2]
[1, 2] :: Num a =&gt; [a]

Prelude&gt; :t Just 1
Just 1 :: Num a =&gt; Maybe a
</code></pre>
<p>也能用 <code>:k</code> 查看一个类型 (type) 的 Kind</p>
<pre><code class="language-haskell">Prelude&gt; :k Int
Int :: *

Prelude&gt; :k Num
Num :: * -&gt; Constraint

Prelude&gt; :k Maybe
Maybe :: * -&gt; *

Prelude&gt; :k Either
Either :: * -&gt; * -&gt; *

Prelude&gt; :k Functor
Functor :: (* -&gt; *) -&gt; Constraint
</code></pre>
<p><strong>'*' 是什么</strong></p>
<blockquote>
<p>A * means that the type is a concrete type. A concrete type is a type that doesn't take any type parameters and  values can only have types that are concrete types. If I had to read * out loud (I haven't had to do that so far), I'd say <em>star</em> or just <em>type</em>.</p>
</blockquote>
<p><code>*</code> 就是一个固定的类型，不能携带 Type parameter</p>
<p><code>* -&gt; *</code> 就是接受一个 type parameter，返回一个类型，比如 Maybe 和 Maybe Int</p>
<p><code>* -&gt; * -&gt; *</code> 同理</p>
<p>所以 Functor 的类型就好理解了</p>
<pre><code class="language-haskell">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p><strong>2. 什么是 Functor</strong></p>
<p>看一眼 fmap 的定义，实现了 Functor 的类型，fmap 能够把这些类型<em>里面</em>的东西转换到另一种东西，就是说 fmap 只作用于 box 里面的东西</p>
<pre><code class="language-haskell">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>这个是 map 的定义</p>
<pre><code class="language-haskell">map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>
<p>map 就是特殊化的 fmap ,只能用于 [],不能用于 Maybe, Ehther 等类型</p>
<blockquote>
<p>anything like a box that can hold something can impl Functor, lsuch as Maybe, [], Tree = Empty | Tree a left rght, Either</p>
</blockquote>
<p>所有能够承载其他类型的东西都能实现 Functor，比如 Maybe, [], Tree, Either</p>
<p>下面是关于 Either 的 Functor 实现</p>
<pre><code class="language-haskell">instance Functor (Either a) where
    fmap f (Right x) = Right (f x)
    fmap f (Left x) = Left x
-- (b -&gt; c) -&gt; Either a b -&gt; Ether a c
-- 和下面的一样
-- (b -&gt; c) -&gt; (Either a) b -&gt; (Either a) c
</code></pre>
<blockquote>
<p>-- in this case, we only mapped the right value constructor,
-- well, if we look at the define of Either:
-- data Either a b = Left a | Right b
-- we can't make sure f can handle both type a and type b
-- Another example is Map.Map, where fmap just map a function v -&gt; v' over a Map k v, and return Map k v'</p>
</blockquote>
<p>在这个例子里，我们只 map 了 Either 的右值，因为不能保证 Either a b 的类型相同，Map.Map 也是，只有 value 改变</p>
<p><strong>3. 实现一个 Tofu</strong></p>
<pre><code class="language-haskell">class Tofu t where
    tofu :: j a -&gt; t a j

data Frank a b = Frank {frankField :: b a} deriving (Show)

instance Tofu Frank where
    tofu x = Frank x

data Barry t k p = Barry { yabba :: p, dabba :: t k }

instance Functor (Barry a b) where
    fmap f (Barry { yabba = x, dabba = y }) = Barry {yabba = f x, dabba = y }

main :: IO ()
main = do
    let a = Frank { frankField = Just 'c' }
    print a
    let b = tofu (Just 'a') :: Frank Char Maybe
    print b
    let c = tofu [&quot;Hello&quot;] :: Frank [Char] []
    print c
    putStrLn &quot;start...&quot;
</code></pre>
<h2 id="8-io"><a class="header" href="#8-io">8. IO</a></h2>
<h3 id="81-cmd-参数"><a class="header" href="#81-cmd-参数">8.1 cmd 参数</a></h3>
<pre><code class="language-haskell">import System.Environment
import Data.List

main = do
    -- 获取参数
    args &lt;- getArgs
    -- 获取名字
    progName &lt;- getProgName
    putStrLn progName
    mapM_ putStrLn args

</code></pre>
<h3 id="82-输入"><a class="header" href="#82-输入">8.2 输入</a></h3>
<ol>
<li>
<p>获取输入</p>
<pre><code class="language-haskell">main = do
    putStrLn &quot;start...&quot;
    -- 获取输入数据
    line &lt;- getLine
    -- 判断不为空就反转
    if null line
        then return ()
        else do
            putStrLn $ reverseWords line
            main
reverseWords :: String -&gt; String
reverseWords = unwords . map reverse . words
</code></pre>
</li>
<li>
<p>文件交互</p>
</li>
</ol>
<ul>
<li>openFile (fileName, openMode): 打开文件返回 handle 对象</li>
<li>hGetContents (handle)：读取文件内容</li>
<li>with 语法</li>
<li>appendFile(fileName, content)：追加内容</li>
<li>readBuffer: 设置缓冲区</li>
</ul>
<pre><code class="language-haskell">import System.IO

main = do
    handle &lt;- openFile &quot;haiku.txt&quot; ReadMode
    -- Lazy, don't read and stored in memory an once
    contents &lt;- hGetContents handle
    putStrLn contents
    hClose handle

    withFile &quot;haiku.txt&quot; ReadMode (\handle -&gt; do
    contents &lt;- hGetContents handle
    putStrLn contents)

    -- withOpen's define
    -- openFle :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a
    -- openFile path mode f = do
    --     handle &lt;- openFile path mode
    --     result &lt;- f handle
    --     hClose f
    --     return result

    -- More function
    -- hGetLine hPutStr hPutStrLn hGetChar
    contents &lt;- readFile &quot;todo.txt&quot;
    putStrLn contents

    todo &lt;- getLine
    appendFile &quot;todo.txt&quot; $ todo ++ &quot;\n&quot;

    -- set buffering manualy
    -- BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)
    withFile &quot;todo.txt&quot; ReadMode (\handle -&gt; do
        hSetBuffering handle $ BlockBuffering (Just 2)
        contents &lt;- hGetContents handle
        putStrLn contents)
    -- read file in big chunks can help to minimize disk access or when our file is actually a slow network resource
</code></pre>
<h3 id="83-循环"><a class="header" href="#83-循环">8.3. 循环</a></h3>
<ol>
<li>forever(loop)</li>
</ol>
<pre><code class="language-haskell">import Control.Monad
import Data.Char

main = forever $ do
    putStr &quot;Give a input: &quot;
    l &lt;- getLine
    putStrLn $ map toUpper l
</code></pre>
<ol start="2">
<li>when(while)</li>
</ol>
<pre><code class="language-haskell">import Control.Monad

main = do
  return ()
  -- aaa &lt;- return &quot;aaavvv&quot;
  -- putStrLn aaa

  c &lt;- getChar
  when (c /= ' ') $ do
    putChar c
    main
</code></pre>
<h3 id="84-map-io-action"><a class="header" href="#84-map-io-action">8.4 map IO action</a></h3>
<p>mapM &amp; mapM_ &amp; sequence</p>
<pre><code class="language-haskell">main = do
  -- 1.1 sequence can run erery IO action in it, and return their result as a list
  -- rs &lt;- sequence [getLine, getLine, getLine]
  -- print rs

  -- 1.2
  -- map print [1, 2, 3]
  -- [print 1, print 2, print 3]
  res &lt;- sequence $ map print [1, 2, 3]
  -- `print 1` just return a `()`
  -- so res is [(), (), ()]
  print res

  -- 2.1 mapM can be used to map a function that return IO action
  mapm &lt;- mapM print [1, 2, 3]
  print mapm
  -- 2.2 mapM_ just abundon the results
  mapm_ &lt;- mapM_ print [1, 2, 3]
  print mapm_
</code></pre>
<h3 id="86-todo-list"><a class="header" href="#86-todo-list">8.6 todo list</a></h3>
<pre><code class="language-haskell">import Data.List
import System.Directory
import System.Environment
import System.IO

dispatch :: [(String, [String] -&gt; IO ())]
dispatch =
  [ (&quot;add&quot;, add),
    (&quot;view&quot;, view),
    (&quot;remove&quot;, remove)
  ]

main = do
  (command : args) &lt;- getArgs
  let (Just action) = lookup command dispatch
  action args

add :: [String] -&gt; IO ()
add [fileName, todoItem] = appendFile fileName (todoItem ++ &quot;\n&quot;)
add _ = putStrLn &quot;Plz input [filename, todoItem]&quot;

view :: [String] -&gt; IO ()
view [fileName] = do
  contents &lt;- readFile fileName
  let todoTasks = lines contents
      numberedTasks = zipWith (\n line -&gt; show n ++ &quot; - &quot; ++ line) [0 ..] todoTasks
  putStr $ unlines numberedTasks
view _ = putStrLn &quot;Plz input [filename]&quot;

remove :: [String] -&gt; IO ()
remove [fileName, numberString] = do
  handle &lt;- openFile fileName ReadMode
  (tempName, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot;
  contents &lt;- hGetContents handle
  let number = read numberString
      todoTasks = lines contents
      newTodoItems = delete (todoTasks !! number) todoTasks
  hPutStr tempHandle $ unlines newTodoItems
  hClose handle
  hClose tempHandle
  removeFile fileName
  renameFile tempName fileName
remove _ = putStrLn &quot;Plz input [filename, numberString]&quot;
</code></pre>
<h3 id="87-error-handle"><a class="header" href="#87-error-handle">8.7 Error Handle</a></h3>
<ol>
<li>try &amp; catch</li>
</ol>
<pre><code class="language-haskell">import Control.Exception
import System.Environment
import System.IO
import System.IO.Error

main = toTry `catch` handler

toTry :: IO ()
toTry = do
  (fileName : _) &lt;- getArgs
  contents &lt;- readFile fileName
  putStrLn $ &quot;The file has &quot; ++ show (length (lines contents)) ++ &quot; lines!&quot;

handler :: IOError -&gt; IO ()
handler e = putStrLn &quot;Whoops, had some trouble!&quot;

-- main = do
--   toTry `catch` handler1
--   thenTryThis `catch` handler2
--   launchRockets
</code></pre>
<ol start="2">
<li>error kind</li>
</ol>
<pre><code class="language-haskell">
import System.Environment
import System.IO
import System.IO.Error
import Control.Exception

main = toTry `catch` handler

toTry :: IO ()
toTry = do (fileName:_) &lt;- getArgs
           contents &lt;- readFile fileName
           putStrLn $ &quot;The file has &quot; ++ show (length (lines contents)) ++ &quot; lines!&quot;

handler :: IOError -&gt; IO ()
handler e
    | isDoesNotExistError e = putStrLn &quot;The file doesn't exist!&quot;
    | otherwise = ioError e

-- isAlreadyExistsError
-- isDoesNotExistError
-- isAlreadyInUseError
-- isFullError
-- isEOFError
-- isIllegalOperation
-- isPermissionError
-- isUserError
</code></pre>
<h2 id="9-solve-some-problems"><a class="header" href="#9-solve-some-problems">9. Solve Some Problems</a></h2>
<h3 id="91-计算后缀表达式"><a class="header" href="#91-计算后缀表达式">9.1 计算后缀表达式</a></h3>
<pre><code class="language-haskell">import Data.List

solveRPN :: (Num a, Read a) =&gt; String -&gt; a
solveRPN = head . foldl foldingFunction [] . words
    where
        foldingFunction (x:y:ys) &quot;*&quot; = (x * y):ys
        foldingFunction (x:y:ys) &quot;+&quot; = (x + y):ys
        foldingFunction (x:y:ys) &quot;-&quot; = (x - y):ys
        foldingFunction xs numString = read numString:xs

solveRPN2 :: (Num a, Read a, Floating a) =&gt; String -&gt; a
solveRPN2 = head . foldl foldingFunction [] . words
    where
        foldingFunction (x:y:ys) &quot;*&quot; = (x * y):ys
        foldingFunction (x:y:ys) &quot;+&quot; = (x + y):ys
        foldingFunction (x:y:ys) &quot;-&quot; = (x - y):ys
        foldingFunction (x:y:ys) &quot;/&quot; = (y / x):ys
        foldingFunction (x:y:ys) &quot;^&quot; = (y ** x):ys
        foldingFunction (x:xs) &quot;ln&quot; = log x:xs
        foldingFunction xs &quot;sum&quot; = [sum xs]
        foldingFunction xs numString = read numString:xs


main :: IO ()
main = do
    putStrLn &quot;start...&quot;
    print $ solveRPN &quot;90 34 12 33 55 66 + * - + -&quot;
    putStrLn &quot;end...&quot;
</code></pre>
<h3 id="92-计算最短路"><a class="header" href="#92-计算最短路">9.2 计算最短路</a></h3>
<pre><code class="language-haskell">-- newtype Road = Road Int Node
-- newtype Node = Node Road Road | EndNode Road

-- newtype Road = Road Int Node
-- newtype Node = Node Road (Maybe Road)

data Section = Section
  { getA :: Int,
    getB :: Int,
    getC :: Int
  }
  deriving (Show)

type RoadSystem = [Section]

headthrowToLondon :: RoadSystem
headthrowToLondon = [Section 50 10 30, Section 5 90 20, Section 40 2 25, Section 10 8 0]

data Label = A | B | C deriving (Show)

type Path = [(Label, Int)]

roadStep :: (Path, Path) -&gt; Section -&gt; (Path, Path)
roadStep (pathA, pathB) (Section a b c) =
  let priceA = sum $ map snd pathA
      priceB = sum $ map snd pathB
      forwardPriceToA = priceA + a
      crossPriceToA = priceB + b + c
      forwardPriceToB = priceB + b
      crossPriceToB = priceA + a + c
      newPathToA =
        if forwardPriceToA &lt;= crossPriceToA
          then (A, a) : pathA
          else (C, c) : (B, b) : pathB
      newPathToB =
        if forwardPriceToB &lt;= crossPriceToB
          then (B, b) : pathB
          else (C, c) : (A, a) : pathA
   in (newPathToA, newPathToB)

optimalPath :: RoadSystem -&gt; Path
optimalPath roadSystem =
  let (bestAPath, bestBPath) = foldl roadStep ([], []) roadSystem
   in if sum (map snd bestAPath) &lt;= sum (map snd bestBPath)
        then reverse bestAPath
        else reverse bestBPath

main :: IO ()
main = do
  print $ roadStep ([], []) (head headthrowToLondon)
  print $ optimalPath headthrowToLondon


  contents &lt;- getContents
  let threes = groupOf 3 (map read $ lines contents)
      roadSystem = map (\[a,b,c] -&gt; Section a b c) threes
      path = optimalPath roadSystem
      pathString = concat $ map (show . fst) path
      pathPrice = sum $ map snd path
  putStrLn $ &quot;The best path to take is: &quot; ++ pathString
  putStrLn $ &quot;The price is: &quot; ++ show pathPrice


groupOf :: Int -&gt; [a] -&gt; [[a]]
groupOf 0 _ = undefined
groupOf _ [] = []
groupOf n xs = take n xs : groupOf n (drop n xs)
</code></pre>
<h2 id="10-functors-applicative-functors-and-monoids"><a class="header" href="#10-functors-applicative-functors-and-monoids">10. Functors, Applicative Functors and Monoids</a></h2>
<p>极度建议参考下面的文章，图文解释十分直观
<a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a></p>
<h3 id="101-functor"><a class="header" href="#101-functor">10.1 Functor</a></h3>
<pre><code class="language-haskell">fmap (+3) (Just 2)
</code></pre>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202022316684.png" alt="" /></p>
<h3 id="102-applicatives"><a class="header" href="#102-applicatives">10.2 Applicatives</a></h3>
<pre><code class="language-haskell">Just (+3) &lt;*&gt; Just 2 == Just 5

&gt; [(*2), (+3)] &lt;*&gt; [1, 2, 3]
[2, 4, 6, 4, 5, 6]
</code></pre>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202022317350.png" alt="" /></p>
<h3 id="103-monads"><a class="header" href="#103-monads">10.3 Monads</a></h3>
<p>判断一个数的奇偶</p>
<pre><code class="language-haskell">half x = if even x
           then Just (x `div` 2)
           else Nothing
</code></pre>
<p>加入 x 现在是一个 wrapped 的比如说 Maybe，这里引入一个新的操作符 <code>&gt;&gt;=</code></p>
<pre><code class="language-haskell">&gt; Just 3 &gt;&gt;= half
Nothing
&gt; Just 4 &gt;&gt;= half
Just 2
&gt; Nothing &gt;&gt;= half
Nothing
</code></pre>
<p>之所以能像上面一样操作是因为，Maybe 是个 Monad</p>
<pre><code class="language-haskell">instance Monad Maybe where
    Nothing &gt;&gt;= func = Nothing
    Just val &gt;&gt;= func  = func val
</code></pre>
<p>Just
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202022324827.png" alt="" />
Nothing
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202022324432.png" alt="" /></p>
<h3 id="104-总结"><a class="header" href="#104-总结">10.4 总结</a></h3>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202022325497.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bash"><a class="header" href="#bash">Bash</a></h1>
<h2 id="set-指令"><a class="header" href="#set-指令">set 指令</a></h2>
<pre><code class="language-sh"># 写法一
set -euxo pipefail

# 写法二
set -eux
set -o pipefail
</code></pre>
<p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p>
<pre><code class="language-sh">bash -euxo pipefail script.sh
</code></pre>
<ul>
<li><code>-e</code></li>
</ul>
<p>等价于：<code>-o errexit</code></p>
<p>它使得脚本只要发生错误，就终止执行。</p>
<p><code>set +e</code> 可以关闭 <code>-e</code> 选项，之后你可以使用 <code>set -e</code> 重新打开</p>
<p>还有一种方法是使用 <code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p>
<ul>
<li><code>-u</code></li>
</ul>
<p>等价于：<code>set -o nounset</code></p>
<p>遇到不存在的变量就会报错，并停止执行。</p>
<pre><code class="language-sh">$ bash script.sh
bash: script.sh:行4: a: 未绑定的变量
</code></pre>
<ul>
<li><code>-x</code></li>
</ul>
<p>等价于：<code>set -o xtrace</code></p>
<p>打印当前执行的命令</p>
<pre><code class="language-sh">$ bash -c &quot;set -x; echo a; echo b; echo 3&quot;
- echo a
a
- echo b
b
- echo 3
3
</code></pre>
<ul>
<li><code>set -o pipefail</code></li>
</ul>
<p><code>set -e</code> 不适用于管道命令。只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，set -e 就失效了。</p>
<p>例如：<code>foo | echo a</code></p>
<p><code>set -o pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p>
<ul>
<li>不加参数</li>
</ul>
<p>如果命令行下不带任何参数，直接运行 set，会显示所有的环境变量和 Shell 函数。</p>
<h2 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h2>
<p>如果脚本里面有运行失败的命令（返回值非 0），执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p>
<p>如果某个命令失败，需要脚本停止执行，一般采用下面的写法。</p>
<pre><code class="language-sh">command || exit 1
</code></pre>
<p>上面的写法表示只要 command 有非零返回值，脚本就会停止执行。</p>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p>
<pre><code class="language-sh"># 写法一
command || { echo &quot;command failed&quot;; exit 1; }

# 写法二
if ! command; then echo &quot;command failed&quot;; exit 1; fi

# 写法三
command
if [ &quot;$?&quot; -ne 0 ]; then echo &quot;command failed&quot;; exit 1; fi
</code></pre>
<p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p>
<pre><code class="language-sh">command1 &amp;&amp; command2
</code></pre>
<h2 id="变量"><a class="header" href="#变量">变量</a></h2>
<h3 id="定义"><a class="header" href="#定义">定义</a></h3>
<pre><code class="language-sh"># 普通变量
myUrl=&quot;abcd&quot;

# 只读变量
readonly myUrl=&quot;abcd&quot;
</code></pre>
<p>注意事项</p>
<ul>
<li>
<p>变量定义的等号两边<strong>不能有空格</strong></p>
</li>
<li>
<p>使用变量时 变量名外面的花括号是可选的</p>
<pre><code class="language-sh">for skill in Ada Coffee Action Java; do
  echo &quot;I am good at ${skill}Script&quot;
done
</code></pre>
</li>
<li>
<p>使用 <code>unset</code> 删除变量</p>
</li>
</ul>
<h3 id="字符串-1"><a class="header" href="#字符串-1">字符串</a></h3>
<ul>
<li>获取长度</li>
</ul>
<pre><code class="language-sh">echo &quot;length: ${#myUrl}&quot;
</code></pre>
<ul>
<li>获取切片</li>
</ul>
<pre><code class="language-sh">echo &quot;length: ${myUrl:1:4}&quot;
</code></pre>
<ul>
<li>第一次出现的索引</li>
</ul>
<pre><code class="language-sh">string=&quot;runoob is a great site&quot;
echo `expr index &quot;$string&quot; r`  # 输出 1
echo `expr index &quot;$string&quot; u`  # 输出 2
echo `expr index &quot;$string&quot; un`  # 输出 2
</code></pre>
<h3 id="数组-1"><a class="header" href="#数组-1">数组</a></h3>
<pre><code class="language-sh">array=(value0 garabe value2 value3)
array[1]=value1

echo ${array[1]}
echo ${array[@]} # 读取所有

# 读取长度
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
</code></pre>
<p>bash 里的数组和字典较为类似，如果不指定，那么每个元素对应的键就是索引</p>
<pre><code class="language-sh">dict=()
# declare dict
# declare -A dict
dict[&quot;a&quot;]=1
echo ${dict[&quot;a&quot;]}
# 1
</code></pre>
<h2 id="参数"><a class="header" href="#参数">参数</a></h2>
<h3 id="-相关"><a class="header" href="#-相关"><code>$</code> 相关</a></h3>
<ol>
<li>
<p>参数相关</p>
<ul>
<li>
<p><strong><code>$#</code></strong>:传递到脚本的参数个数</p>
<p>下面两个常用来遍历所有参数</p>
</li>
<li>
<p><strong><code>$@</code></strong>: 与 <strong><code>$*</code></strong> 相同，但是使用时加引号，并在引号中返回每个参数。</p>
<p>如 <code>$@</code> 用 <code>「&quot;」</code> 括起来的情况、以 <code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</p>
<pre><code class="language-sh">for i in &quot;$*&quot;; do
    echo $i
done
# 1 2 3

for i in &quot;$@&quot;; do
    echo $i
done

# 1
# 2
# 3
</code></pre>
</li>
<li>
<p><code>$_</code>: 拼接所有参数并返回。</p>
<p>如 <code>$_</code> 用 <code>「&quot;」</code> 括起来的情况、以 <code>&quot;$1 $2 … $n&quot;</code> 的形式输出所有参数。</p>
</li>
</ul>
</li>
<li>
<p>进程 ID 相关</p>
<ul>
<li><code>$$</code>: 脚本运行的当前进程 ID 号</li>
<li><code>$!</code>: 后台运行的最后一个进程的 ID 号</li>
<li><code>$-</code>: 显示 Shell 使用的当前选项，与 set 命令功能相同。</li>
<li><code>$?</code>: 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。</li>
</ul>
</li>
</ol>
<h2 id="运算符"><a class="header" href="#运算符">运算符</a></h2>
<p>原生 bash 不支持数学运算，但是可以通过其他命令实现，例如 awk 和 expr</p>
<pre><code class="language-sh">val=`expr 2 + 2`
echo &quot;两数之和为 : $val&quot;
</code></pre>
<h3 id="算数运算符"><a class="header" href="#算数运算符">算数运算符</a></h3>
<p><code>+ - * / % = == !=</code></p>
<p><strong>注意 :</strong></p>
<ul>
<li>
<p>表达式和运算符之间必须有空格</p>
</li>
<li>
<p>表达式必须要被 `` 包含</p>
</li>
<li>
<p>注意要转义 <code>*</code> 号</p>
<pre><code class="language-sh">val=`expr $a \* $b`
echo &quot;a * b : $val&quot;
</code></pre>
<blockquote>
<p>在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 &quot;*&quot; 不需要转义符号 &quot;&quot; 。</p>
</blockquote>
</li>
<li>
<p>判断的中括号两侧必须有空格</p>
<pre><code class="language-sh">if [ $a == $b ]
then
  echo &quot;a 等于 b&quot;
fi
if [ $a != $b ]
then
  echo &quot;a 不等于 b&quot;
fi
</code></pre>
</li>
</ul>
<h3 id="关系运算符"><a class="header" href="#关系运算符">关系运算符</a></h3>
<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p><code>-eq -ne -gt -lt -ge -le</code></p>
<h3 id="布尔运算符"><a class="header" href="#布尔运算符">布尔运算符</a></h3>
<p><code>! (非)  -o (或)  -a (与)</code></p>
<h3 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h3>
<p><code>&amp;&amp; ||</code></p>
<h3 id="字符串运算符"><a class="header" href="#字符串运算符">字符串运算符</a></h3>
<ul>
<li>
<p><code>==</code>: 相等</p>
</li>
<li>
<p><code>!=</code>: 不相等</p>
</li>
<li>
<p><code>$</code>: 字符串是否不为空</p>
<pre><code class="language-sh">if [ $a ]
</code></pre>
</li>
<li>
<p><code>-z</code>: 长度是否为 0</p>
<pre><code class="language-sh">if [ -z $a ]
</code></pre>
</li>
<li>
<p><code>-n</code>: 长度是否不为 0</p>
</li>
</ul>
<h3 id="文件测试运算符"><a class="header" href="#文件测试运算符">文件测试运算符</a></h3>
<p>常用</p>
<ul>
<li>
<p><code>-e</code>: 检测文件（包括目录）是否存在</p>
</li>
<li>
<p><code>-s</code>: 检测文件是否为空（文件大小是否大于 0）</p>
</li>
<li>
<p><code>-f</code>: 检测文件是否是普通文件（既不是目录，也不是设备文件）</p>
</li>
<li>
<p><code>-d</code>: 检测文件是否是目录</p>
</li>
<li>
<p><code>-r</code>: 检测文件是否可读</p>
</li>
<li>
<p><code>-w</code>: 检测文件是否可写</p>
</li>
<li>
<p><code>-x</code>: 检测文件是否可执行</p>
</li>
</ul>
<p>其他</p>
<ul>
<li><code>-b</code>: 检测文件是否是块设备文件</li>
<li><code>-c</code>: 检测文件是否是字符设备文件</li>
<li><code>-g</code>: 检测文件是否设置了 SGID 位</li>
<li><code>-k</code>: 检测文件是否设置了粘着位 (Sticky Bit)</li>
<li><code>-p</code>: 检测文件是否是有名管道</li>
<li><code>-u</code>: 检测文件是否设置了 SUID 位</li>
<li><code>-S</code>: 判断某文件是否 socket。</li>
<li><code>-L</code>: 检测文件是否存在并且是一个符号链接。</li>
</ul>
<h2 id="流程控制"><a class="header" href="#流程控制">流程控制</a></h2>
<h3 id="if"><a class="header" href="#if">if</a></h3>
<p>if 语句语法格式：</p>
<pre><code class="language-sh">if [ &quot;$a&quot; -gt &quot;$b&quot; ]; then
    command1
elif (( a &gt; b )); then
    command2
else
    commandN
fi
</code></pre>
<ul>
<li>if else 的 <code>[...]</code> 判断语句中大于使用 <code>-gt</code>，小于使用 <code>-lt</code>。</li>
<li>如果使用 <code>((...))</code> 作为判断语句，大于和小于可以直接使用 <code>&gt;</code> 和 <code>&lt;</code>。</li>
<li>也可以使用 test</li>
</ul>
<blockquote>
<p>注意：所有分支都不能为空</p>
</blockquote>
<p>写成一行（适用于终端命令提示符）：</p>
<pre><code class="language-sh">if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi
</code></pre>
<h3 id="for-循环"><a class="header" href="#for-循环">for 循环</a></h3>
<pre><code class="language-sh">for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
</code></pre>
<p>写成一行：</p>
<pre><code class="language-sh">for var in item1 item2 ... itemN; do command1; command2… done;
</code></pre>
<p>支持 break 和 continue 语句</p>
<pre><code class="language-sh">while : # 无限循环
do
    echo -n &quot;输入 1 到 5 之间的数字:&quot;
    read aNum # 获取用户输入
    case $aNum in
        # 可以匹配多个模式
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;
            break
        ;;
    esac
done
</code></pre>
<p>示例</p>
<pre><code class="language-sh">for loop in 1 2 3 4 5
do
    echo &quot;The value is: $loop&quot;
done

for str in This is a string
do
    echo $str
done
</code></pre>
<h3 id="while"><a class="header" href="#while">while</a></h3>
<pre><code class="language-sh">int=1
while(( $int&lt;=5 ))
do
    echo $int
    let &quot;int++&quot;
done
</code></pre>
<blockquote>
<p>let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量</p>
</blockquote>
<h3 id="无限循环"><a class="header" href="#无限循环">无限循环</a></h3>
<p>无限循环语法格式：</p>
<pre><code class="language-sh">while :
do
    command
done
</code></pre>
<p>或者</p>
<pre><code class="language-sh">while true
do
    command
done
</code></pre>
<p>或者</p>
<pre><code class="language-sh">for (( ; ; ))
</code></pre>
<h3 id="until-循环"><a class="header" href="#until-循环">until 循环</a></h3>
<p>until 循环执行一系列命令直至条件为 true 时停止。</p>
<p>与 while 循环在处理方式上刚好相反。</p>
<p>until 语法格式：</p>
<pre><code class="language-sh">until condition
do
  command
done
</code></pre>
<p>输出 0-9</p>
<pre><code class="language-sh">a=0

until [ ! $a -lt 10 ]
do
   echo $a
   a=`expr $a + 1`
done
</code></pre>
<h3 id="case-语句"><a class="header" href="#case-语句">case 语句</a></h3>
<ul>
<li><code>;;</code>: 表示 break</li>
<li><code>*</code>: 如果没有匹配就会走 <code>*</code></li>
</ul>
<pre><code class="language-sh">aNum=1
case $aNum in
    1|2)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac
</code></pre>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<p>bash 的函数类似于进程</p>
<p>参数传递直接跟在函数名之后，参数获取使用 <code>$</code> 获取</p>
<pre><code class="language-sh">funWithParam(){
    echo &quot;第一个参数为 $1 !&quot;
    echo &quot;第二个参数为 $2 !&quot;
    echo &quot;第十个参数为 $10 !&quot;
    echo &quot;第十个参数为 ${10} !&quot;
    echo &quot;第十一个参数为 ${11} !&quot;
    echo &quot;参数总数有 $# 个!&quot;
    echo &quot;作为一个字符串输出所有参数 $* !&quot;
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
</code></pre>
<ul>
<li>
<p>返回值可选 return，如果不加 return，会以最后一条命令的返回值作为返回值。</p>
</li>
<li>
<p>命令的返回值仅仅表示是否出错，返回值为 0 就是成功，其他值为出错</p>
<blockquote>
<p>要注意的是，和 C 语言不同，shell 语言中 0 代表 true，0 以外的值代表 false。</p>
</blockquote>
</li>
<li>
<p>必须使用 <code>$?</code> 拿到真正的返回值</p>
</li>
</ul>
<pre><code class="language-sh">function demoFun2(){
 echo &quot;这是我的第二个 shell 函数!&quot;
 expr 1 + 1
}

demoFun2
echo $?
</code></pre>
<h2 id="重定向"><a class="header" href="#重定向">重定向</a></h2>
<ul>
<li>
<p>将 stdout 重定向到 file：<code>command &gt; file</code></p>
</li>
<li>
<p>将 stdin 重定向到 file：<code>command &lt; file</code></p>
</li>
<li>
<p>stderr 重定向到 file： <code>command 2&gt;file</code></p>
<blockquote>
<p>注意：这里的 2 和 &gt; 之间不可以有空格，2&gt; 是一体的时候才表示错误输出。</p>
</blockquote>
</li>
<li>
<p>stderr <strong>追加</strong>到 file 文件末尾：<code>command 2&gt;&gt;file</code></p>
</li>
<li>
<p>将 stdout 和 stderr 合并后重定向到 file: <code>command &gt; file 2&gt;&amp;1</code> 或 <code>command &gt;&gt; file 2&gt;&amp;1</code></p>
</li>
<li>
<p>对 stdin 和 stdout 都重定向：<code>command &lt; file1 &gt;file2</code></p>
<p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p>
</li>
</ul>
<p>执行某个命令，但不在屏幕上显示输出结果，那么可以将输出重定向到 <em>/dev/null</em>：</p>
<pre><code class="language-sh">command &gt; /dev/null
</code></pre>
<p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃。如果尝试从该文件读取内容，那么什么也读不到。</p>
<p>将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。如果希望屏蔽 stdout 和 stderr，可以这样写：</p>
<pre><code class="language-sh">command &gt; /dev/null 2&gt;&amp;1
</code></pre>
<h2 id="import"><a class="header" href="#import">import</a></h2>
<p>Shell 也可以包含外部脚本</p>
<pre><code class="language-sh">#使用 . 号来引用test1.sh 文件
. ./test1.sh

# 或者使用以下包含文件代码
# source ./test1.sh
</code></pre>
<h2 id="其他-2"><a class="header" href="#其他-2">其他</a></h2>
<h3 id="echo"><a class="header" href="#echo">echo</a></h3>
<ul>
<li>
<p>执行命令（反引号）</p>
<pre><code class="language-sh">echo `date`
</code></pre>
</li>
<li>
<p>结果重定向</p>
<pre><code class="language-sh">echo &quot;It is a test&quot; &gt; myfile
</code></pre>
</li>
<li>
<p>原样输出字符串，不进行转义或取变量 (用单引号)</p>
<pre><code class="language-sh">echo '$name\&quot;'
</code></pre>
</li>
<li>
<p><code>-e</code> 开启转义</p>
<pre><code class="language-sh">echo -e &quot;OK! \n&quot; # -e 开启转义 \n 换行

echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行
</code></pre>
</li>
</ul>
<h3 id="test"><a class="header" href="#test">test</a></h3>
<pre><code class="language-sh">if [ $a == $b ]

if test $a == $b
</code></pre>
<h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<p><code>SomeThing</code> 可以是任何东西</p>
<pre><code class="language-sh">:&lt;&lt;SomeThing
注释内容...
注释内容...
注释内容...
SomeThing
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="原子操作与内存顺序"><a class="header" href="#原子操作与内存顺序">原子操作与内存顺序</a></h1>
<p>原子操作能够用来实现无🔓并发</p>
<h2 id="程序运行问题"><a class="header" href="#程序运行问题">程序运行问题</a></h2>
<p>下面列举了影响代码执行顺序的诸多原因</p>
<h3 id="1-编译器重排"><a class="header" href="#1-编译器重排">1. 编译器重排</a></h3>
<p>编译器会尽可能优化代码，在单线程下一般不会出现问题</p>
<pre><code class="language-js">x = 1;
y = 3;
x = 2;
</code></pre>
<p>上面的代码可能被优化为下面的样子</p>
<pre><code class="language-py">x = 2;
y = 3;
</code></pre>
<p>但是在多线程下可能会有问题</p>
<h3 id="2指令重排"><a class="header" href="#2指令重排">2.指令重排</a></h3>
<p>类似于上面的，下面的代码中 y = 200 可能会先于 x = 100 执行，打印出的 x 可能是 0 或 100 例 1:</p>
<pre><code class="language-cpp">    int x = 0;     // global variable
    int y = 0;     // global variable

    Thread-1:           Thread-2:
    x = 100;            while (y != 200) {};
    y = 200;            std::cout &lt;&lt; x;
</code></pre>
<p>例 2:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>初始状态: x = 0, y = 1
线程 1        线程 2
y = 3;      if x == 1 {
x = 1;          y *= 2;
            }
<span class="boring">}
</span></code></pre></pre>
<p>这段程序实际上有两种可能的结果：</p>
<ul>
<li>y = 3：线程 2 在线程 1 完成之前检查了 x 的值</li>
<li>y = 6：线程 2 在线程 1 完成之后检查了 x 的值</li>
<li>y = 2：线程 2 看到了 x = 1，但是没看到 y = 3，接下来用计算结果覆盖了 y = 3</li>
</ul>
<h3 id="3-cpu-cache"><a class="header" href="#3-cpu-cache">3. CPU Cache</a></h3>
<p>由于一次复制操作涉及到 move(内存 -&gt; 寄存器) add mov(寄存器 -&gt; 内存) 三条汇编指令，在 add
操作完成后，数据还没有被拷贝到内存时，另一个线程可能读取到此时还没有被修改的数据，或者是两个线程同时修改，结果某一个线程修改的结果被另一个线程覆盖</p>
<h2 id="术语"><a class="header" href="#术语">术语</a></h2>
<p>下列术语定义了多线程和单线程中各个变量操作之间的关系 这些关系只是我们期望的，想要确保下面的关系在活动中是正常的，就需要内存顺序了</p>
<h3 id="1-happens-before"><a class="header" href="#1-happens-before"><strong>1. happens-before</strong></a></h3>
<p>先于，或者说 B 能看到 A 操作的结果，AB 分别在两个线程里</p>
<h3 id="2-sequenced-before"><a class="header" href="#2-sequenced-before">2. sequenced-before</a></h3>
<p>同上 A,B 在一个线程内</p>
<h3 id="3-synchronized-with"><a class="header" href="#3-synchronized-with"><strong>3. synchronized-with</strong></a></h3>
<p>x 是支持原子操作的变量 A 写入 (store)x，B 读取 (load)x，分别在两个线程内，则 A((store) 就是
synchornized-with B(load) 的</p>
<h3 id="4-inter-thread"><a class="header" href="#4-inter-thread">4. inter-thread</a></h3>
<p>跨线程 第三点说到 A：store synchornized-with B: load 那么 A happens-before B 多线程中写入先于读取</p>
<h2 id="内存顺序"><a class="header" href="#内存顺序">内存顺序</a></h2>
<h3 id="1-relaxed"><a class="header" href="#1-relaxed">1. Relaxed</a></h3>
<p>只保证在同一个线程中满足 Happens-before，这是最宽松的规则，他对编译器和 CPU 不做任何限制，可以乱需，因此下面的例子不保证会成功</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn to_relaxed() {
    let x: &amp;'static _ = Box::leak(Box::new(AtomicUsize::new(0)));
    let y: &amp;'static _ = Box::leak(Box::new(AtomicUsize::new(0)));
    let t1 = thread::spawn(move || {
        // 读取 x 存到 y 里
        let r1 = y.load(Ordering::Relaxed);
        x.store(r1, Ordering::Relaxed);
        r1
    });
    let t2 = thread::spawn(move || {
        // 读取 y 存到 x 里
        let r2 = x.load(Ordering::Relaxed); // 下面两行可能会被重排
        y.store(42, Ordering::Relaxed);
        r2
    });

    let r1 = t1.join().unwrap();
    let r2 = t2.join().unwrap();
    // 可能出现 r1 == r2 == 42
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="2-acquire-release"><a class="header" href="#2-acquire-release">2. Acquire-Release</a></h3>
<p><strong>Release 释放</strong> ，设定内存屏障 (Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面
<strong>Acquire 获取</strong> , 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和
<code>Release</code>在不同线程中联合使用 <strong>AcqRel</strong>: Acquire 和 Release 的结合，同时拥有它们俩提供的保证。比如你要对一个
atomic 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序</p>
<p>这两个操作通常成对使用，对 store 使用 Release，对 load 使用 Acquire 先后顺序具体看下面的代码</p>
<pre><pre class="playground"><code class="language-rust">fn write_x_then_y() {
    X.store(true, Ordering::Relaxed);
    Y.store(true, Ordering::Release);
}

fn read_y_then_x() {
    while !Y.load(Ordering::Acquire) {}
    if X.load(Ordering::Relaxed) {
        Z.fetch_add(1, Ordering::SeqCst);
    }
}

fn main() {
    let t1 = thread::spawn(move || {
        write_x_then_y();
    });

    let t2 = thread::spawn(move || {
        read_y_then_x();
    });

    t1.join().unwrap();
    t2.join().unwrap();

    assert_ne!(Z.load(Ordering::SeqCst), 0);
}
</code></pre></pre>
<h3 id="3-sequence"><a class="header" href="#3-sequence">3. Sequence</a></h3>
<p>顺序一致性，强制所有线程看到一致的原子操作，完全的分界点，SeqCst 就像是 AcqRel
的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到 SeqCst 的原子操作，线程中该 SeqCst 操作前的数据操作绝对不会被重新排在该
SeqCst 操作之后，且该 SeqCst 操作后的数据操作也绝对不会被重新排在 SeqCst 操作前。下面的例子，只有使用 SeqCst
ordering，才能保证 Z 最后的值不为 0</p>
<pre><pre class="playground"><code class="language-rust">fn write_x() {
    X.store(true, Ordering::SeqCst);    // 1
}

fn write_y() {
    Y.store(true, Ordering::SeqCst);    // 2
}

fn read_x_then_y() {
    while !X.load(Ordering::SeqCst) {}
    if Y.load(Ordering::SeqCst) {       // 3
        Z.fetch_add(1, Ordering::SeqCst);
    }
}

fn read_y_then_x() {
    while !Y.load(Ordering::SeqCst) {}
    if X.load(Ordering::SeqCst) {       // 4
        Z.fetch_add(1, Ordering::SeqCst);
    }
}

fn main() {
        let t1 = thread::spawn(move || {
        write_x();
    });

    let t2 = thread::spawn(move || {
        write_y();
    });

    let t3 = thread::spawn(move || {
        read_x_then_y();
    });

    let t4 = thread::spawn(move || {
        read_y_then_x();
    });

    t1.join().unwrap();
    t2.join().unwrap();
    t3.join().unwrap();
    t4.join().unwrap();

    assert_ne!(Z.load(Ordering::SeqCst), 0);
}
</code></pre></pre>
<h3 id="4-fence"><a class="header" href="#4-fence">4. Fence</a></h3>
<p>fence 是支持 synchornized-with 的另一种方式，可以和 Acquire-Release 对比一下</p>
<p>例 1：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn producer() -&gt; JoinHandle&lt;()&gt; {
    thread::spawn(move || {
        unsafe {
            DATA = 100;                                 // A
        }
        READY.store(true, Ordering::Release);           // B: 内存屏障 ↑
    })
}

fn consumer() -&gt; JoinHandle&lt;()&gt; {
    thread::spawn(move || {
        while !READY.load(Ordering::Acquire) {}         // C: 内存屏障 ↓

        assert_eq!(100, unsafe { DATA });               // D
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>例 2：</p>
<pre><pre class="playground"><code class="language-rust">fn write_x_then_y() {
    X.store(true, Ordering::Relaxed); // 1
    fence(Ordering::Release);         // 2
    Y.store(true, Ordering::Relaxed); // 3
}

fn read_y_then_x() {
    while !Y.load(Ordering::Relaxed) {}  // 4
    fence(Ordering::Acquire);            // 5
    if X.load(Ordering::Relaxed) {       // 6
        Z.fetch_add(1, Ordering::SeqCst);
    }
}

fn main() {
    let t1 = thread::spawn(move || {
        write_x_then_y();
    });

    let t2 = thread::spawn(move || {
        read_y_then_x();
    });

    t1.join().unwrap();
    t2.join().unwrap();

    assert_ne!(Z.load(Ordering::SeqCst), 0);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/sync/atomic/fn.fence.html">fence 的官方文档</a> An atomic
fence. Depending on the specified order, a fence prevents the compiler and CPU
from reordering certain types of memory operations around it. That creates
synchronizes-with relationships between it and atomic operations or fences in
other threads.</p>
<p>A fence ‘A’ which has (at least) Release ordering semantics, synchronizes with a
fence ‘B’ with (at least) Acquire semantics, if and only if there exist
operations X and Y, both operating on some atomic object ‘M’ such that A is
sequenced before X, Y is synchronized before B and Y observes the change to M.
This provides a happens-before dependence between A and B.</p>
<pre><code>    Thread 1                                          Thread 2

fence(Release);      A --------------
x.store(3, Relaxed); X ---------    |
                               |    |
                               |    |
                               -------------&gt; Y  if x.load(Relaxed) == 3 {
                                    |-------&gt; B      fence(Acquire);
                                                     ...
                                                 }
</code></pre>
<h2 id="其他-3"><a class="header" href="#其他-3">其他</a></h2>
<h3 id="1-tips"><a class="header" href="#1-tips">1. Tips</a></h3>
<ul>
<li>不知道怎么选择时，优先使用 SeqCst，虽然会稍微减慢速度，但是慢一点也比出现错误好</li>
<li>多线程只计数 fetch_add 而不使用该值触发其他逻辑分支的简单使用场景，可以使用 Relaxed 参考
<a href="https://stackoverflow.com/questions/30407121/which-stdsyncatomicordering-to-use">Which std::sync::atomic::Ordering to use?</a></li>
<li>在多线程环境中要使用 Atomic 需要配合 Arc</li>
</ul>
<h3 id="2-atomic-能替代锁吗"><a class="header" href="#2-atomic-能替代锁吗">2. Atomic 能替代锁吗？</a></h3>
<p>那么原子类型既然这么全能，它可以替代锁吗？答案是不行：</p>
<ul>
<li>对于复杂的场景下，锁的使用简单粗暴，不容易有坑</li>
<li>std::sync::atomic 包中仅提供了数值类型的原子操作：AtomicBool, AtomicIsize, AtomicUsize,
AtomicI8, AtomicU16 等，而锁可以应用于各种类型</li>
<li>在有些情况下，必须使用锁来配合，例如上一章节中使用 Mutex 配合 Condvar</li>
</ul>
<h3 id="3-atomic-的应用场景"><a class="header" href="#3-atomic-的应用场景">3. Atomic 的应用场景</a></h3>
<p>事实上，Atomic 虽然对于用户不太常用，但是对于高性能库的开发者、标准库开发者都非常常用，它是并发原语的基石，除此之外，还有一些场景适用：</p>
<ul>
<li>无锁 (lock free) 数据结构</li>
<li>全局变量，例如全局自增 ID，在后续章节会介绍</li>
<li>跨线程计数器，例如可以用于统计指标</li>
</ul>
<h2 id="引用-1"><a class="header" href="#引用-1">引用</a></h2>
<ul>
<li><a href="https://www.jianshu.com/p/511cde6b62a6">Rust 并发编程 - Memory Ordering (siddontang
)</a></li>
<li><a href="https://www.zhihu.com/question/24301047">知乎</a></li>
<li><a href="http://senlinzhan.github.io/2017/12/04/cpp-memory-order/">理解 C++ 的 Memory Order (Senlin's Blog)</a></li>
<li><a href="https://skyao.io/learning-rust/std/sync/atomic-type.html">Rust 学习笔记</a></li>
<li><a href="https://course.rs/advance/concurrency-with-threads/sync2.html">rust 语言圣经</a></li>
<li><a href="https://learnku.com/docs/nomicon/2018/83-atomic-operation/4742">Rust 高级编程</a></li>
</ul>
<h2 id="资料-1"><a class="header" href="#资料-1">资料</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/343688629">C 语言丨深入理解 volatile 关键字</a></li>
<li><a href="https://www.jianshu.com/p/765e3abbe89a">Java volatile 三大特性详解</a></li>
<li><a href="https://juejin.cn/post/6844904177856937991">Java CAS 实现原理</a></li>
<li><a href="https://monkeysayhi.github.io/2017/12/28/%E4%B8%80%E6%96%87%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/">一文解决内存屏障</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-多路复用"><a class="header" href="#io-多路复用">IO 多路复用</a></h1>
<h2 id="rust-使用-epoll"><a class="header" href="#rust-使用-epoll">Rust 使用 Epoll</a></h2>
<pre><code class="language-rs">use std::{
    collections::HashMap,
    io::{self, Read, Write},
    net::{TcpListener, TcpStream},
    os::unix::prelude::{AsRawFd, RawFd},
};

#[allow(unused_macros)]
macro_rules! syscall {
    ($fn: ident ( $($arg: expr),* $(,)* ) ) =&gt; {{
        let res = unsafe { libc::$fn($($arg, )*) };
        if res == -1 {
            Err(std::io::Error::last_os_error())
        } else {
            Ok(res)
        }
    }};
}

const HTTP_RESP: &amp;[u8] = b&quot;HTTP/1.1 200 OK
content-type: text/html
content-length: 5

Hello&quot;;

const READ_FLAGS: i32 = libc::EPOLLONESHOT | libc::EPOLLIN;
const WRITE_FLAGS: i32 = libc::EPOLLONESHOT | libc::EPOLLOUT;

#[derive(Debug)]
pub struct RequestContext {
    pub stream: TcpStream,
    pub content_length: usize,
    pub buf: Vec&lt;u8&gt;,
}

impl RequestContext {
    fn new(stream: TcpStream) -&gt; Self {
        Self {
            stream,
            buf: Vec::new(),
            content_length: 0,
        }
    }

    fn read_cb(&amp;mut self, key: u64, epoll_fd: RawFd) -&gt; io::Result&lt;()&gt; {
        let mut buf = [0u8; 4096];
        // 这里 stream 应该不会阻塞，因为我们是在被通知后才调用的
        match self.stream.read(&amp;mut buf) {
            Ok(_) =&gt; {
                if let Ok(data) = std::str::from_utf8(&amp;buf) {
                    // 如果这段数据是开始，就能设置 Content-length.
                    // 如果是 data 的一部分，那就什么也不做，安心读取就完事了
                    self.parse_and_set_content_length(data);
                }
            }
            Err(e) if e.kind() == io::ErrorKind::WouldBlock =&gt; {}
            Err(e) =&gt; {
                return Err(e);
            }
        }

        // 把临时缓冲区的内容追加到结构体上下文里
        self.buf.extend_from_slice(&amp;buf);

        // 判断以下读没读完，如果没有读完，就重新注册为读，下次接着读。否则注册为写，给客户端回复
        if self.buf.len() &gt;= self.content_length {
            println!(&quot;got all data: {} bytes&quot;, self.buf.len());
            modify_interest(epoll_fd, self.stream.as_raw_fd(), listener_write_event(key))?;
        } else {
            println!(&quot;read not end: {} bytes&quot;, self.buf.len());
            modify_interest(epoll_fd, self.stream.as_raw_fd(), listener_read_event(key))?;
        }
        Ok(())
    }

    fn parse_and_set_content_length(&amp;mut self, data: &amp;str) {
        println!(&quot;{}&quot;, data);
        if data.contains(&quot;HTTP&quot;) {
            if let Some(content_length) = data
                .lines()
                .find(|x| x.to_lowercase().starts_with(&quot;content-length: &quot;))
            {
                if let Some(len) = content_length
                    .to_lowercase()
                    .strip_prefix(&quot;content-length: &quot;)
                {
                    self.content_length = len.parse::&lt;usize&gt;().expect(&quot;content-length is valid&quot;);
                    println!(&quot;set content length: {} bytes&quot;, self.content_length);
                }
            } else {
                println!(&quot;没读到 Content-Length&quot;);
            }
        }
        println!(&quot;不是 HTTP&quot;);
    }

    fn write_cb(&amp;mut self, key: u64, epoll_fd: RawFd) -&gt; io::Result&lt;()&gt; {
        match self.stream.write(HTTP_RESP) {
            Ok(_) =&gt; println!(&quot;answered from request {}&quot;, key),
            Err(e) =&gt; eprintln!(&quot;could not answer to request {}, {}&quot;, key, e),
        }
        self.stream.shutdown(std::net::Shutdown::Both)?;
        let fd = self.stream.as_raw_fd();
        remove_interest(epoll_fd, fd)?;
        unsafe { close(fd) };
        Ok(())
    }
}

fn main() -&gt; io::Result&lt;()&gt; {
    let mut listener = TcpListener::bind(&quot;127.0.0.1:8080&quot;).expect(&quot;绑定端口失败&quot;);
    // 设置为非阻塞模式
    // 当我们 accept 时，如果 socket 没有准备好，会阻塞。
    // 而现在会直接返回一个 io::ErrorKind::WouldBlock
    listener
        .set_nonblocking(true)
        .expect(&quot;set non-block failed&quot;);
    let listener_fd = listener.as_raw_fd();

    // 创建一个 epoll，并返回它的 fd
    // 有了这个 fd，我们就能对事件进行操作，包括读取、添加、修改、移除。
    let epoll_fd = epoll_create().expect(&quot;创建 epoll 失败&quot;);

    // 向 epoll 中注册 listener，并设置我们感兴趣的事件是读
    let mut key = 100;
    add_interst(epoll_fd, listener_fd, listener_read_event(key))?;

    // 现在我们有了 epoll，也注册了事件，下一步就是事件循环
    let mut events: Vec&lt;libc::epoll_event&gt; = Vec::with_capacity(1024);
    let mut request_contexts: HashMap&lt;u64, RequestContext&gt; = HashMap::new();
    loop {
        events.clear();
        // epoll_wait 发生阻塞的条件：
        // - 有事件发生
        // - 信号把它打断
        // - 超时了
        //      - 我们可以把超时事件设置为 -1，这样 epoll_wait 会一只阻塞，直到前两种情况发生
        // 当 epoll_wait 返回时，它会返回事件的数量
        let res = match syscall!(epoll_wait(
            epoll_fd,
            events.as_mut_ptr() as *mut libc::epoll_event,
            1024,
            1000 as libc::c_int, // 超时时间，毫秒为单位
        )) {
            Ok(v) =&gt; v,
            Err(e) =&gt; panic!(&quot;在等待 epoll 时发生错误：{}&quot;, e),
        };

        // 设置 events 的容量
        unsafe { events.set_len(res as usize) };

        // 处理请求
        for event in events.iter() {
            // 因为没有 fd，我们需要通过 key 去判断，这个事件是那个 fd 的。
            match event.u64 {
                // 如果是 100，就说明我们的 server 接收到了新的连接。
                100 =&gt; {
                    match listener.accept() {
                        Ok((stream, addr)) =&gt; {
                            // 将客户端设置为非阻塞的，给他一个 key，并添加到到 epoll 中
                            stream
                                .set_nonblocking(true)
                                .expect(&quot;这里在此设置了 non-blocking&quot;);
                            println!(&quot;new client: {}&quot;, addr);
                            key += 1;
                            add_interst(epoll_fd, stream.as_raw_fd(), listener_read_event(key))
                                .expect(&quot;发生什么是了，客户端裂开了？&quot;);
                            // 这里
                            request_contexts.insert(key, RequestContext::new(stream));
                        }
                        Err(e) =&gt; eprintln!(&quot;couldn't accept: {}&quot;, e),
                    }
                    // 因为我们使用的是 ONESHORT 事件监听器，所以我们必须重新注册 server
                    modify_interest(epoll_fd, listener_fd.as_raw_fd(), listener_read_event(100))
                        .expect(&quot;重置 server 失败&quot;);
                }
                // 如果不是 key 不是 100，那就是其他的客户端连接。
                key =&gt; {
                    // 用 hashmap 去匹配是那个连接
                    if let Some(context) = request_contexts.get_mut(&amp;key) {
                        let events = event.events;
                        match events {
                            // 如果可读，就去读，如果没读完，就重新注册读，读完了将兴趣点改为写
                            v if v as i32 &amp; libc::EPOLLIN == libc::EPOLLIN =&gt; {
                                // 读取数据
                                context.read_cb(key, epoll_fd)?;
                            }
                            // 返回数据，close(fd), shutdown(stream), remove_interest(epoll_fd, fd)
                            v if v as i32 &amp; libc::EPOLLOUT == libc::EPOLLOUT =&gt; {
                                context.write_cb(key, epoll_fd)?;
                                // 同时移出 hashmap
                                request_contexts.remove(&amp;key);
                            }
                            v =&gt; println!(&quot;unexpected events: {}&quot;, v),
                        }
                    }
                }
            }
        }
    }
    println!(&quot;Hello, world!&quot;);
    Ok(())
}

/// 向 epoll 中传入一个感兴趣的连接
///
/// epoll_fd: epoll 的 fd
/// fd：将要被 epoll 管理的 fd
/// event：被通知事件类型。
///
/// 当 fd 上有事件发生时，比如读或者是写，这个事件发生后 epoll 就会通知我们，并将 fd 从 epoll 中删除
/// 因此如果我们需要继续读取，我们需要重新注册这个 fd
fn add_interst(epoll_fd: RawFd, fd: RawFd, mut event: libc::epoll_event) -&gt; io::Result&lt;()&gt; {
    syscall!(epoll_ctl(epoll_fd, libc::EPOLL_CTL_ADD, fd, &amp;mut event))?;
    Ok(())
}
fn modify_interest(epoll_fd: RawFd, fd: RawFd, mut event: libc::epoll_event) -&gt; io::Result&lt;()&gt; {
    // 改用 EPOLL_CTL_MOD 标志，因为之前已经被添加过
    syscall!(epoll_ctl(epoll_fd, libc::EPOLL_CTL_MOD, fd, &amp;mut event))?;
    Ok(())
}
fn close(fd: RawFd) {
    let _ = syscall!(close(fd));
}
fn remove_interest(epoll_fd: RawFd, fd: RawFd) -&gt; io::Result&lt;()&gt; {
    // 改用 EPOLL_CTL_MOD 标志，因为之前已经被添加过
    syscall!(epoll_ctl(
        epoll_fd,
        libc::EPOLL_CTL_DEL,
        fd,
        std::ptr::null_mut()
    ))?;
    Ok(())
}

/// 生成一个事件类型
///
/// key 是我们为该事件设置的 id
///
/// 对于 listener，我们只对读事件感兴趣，因此这里只有 READ_FLAG
fn listener_read_event(key: u64) -&gt; libc::epoll_event {
    libc::epoll_event {
        events: READ_FLAGS as u32,
        u64: key,
    }
}

fn listener_write_event(key: u64) -&gt; libc::epoll_event {
    libc::epoll_event {
        events: WRITE_FLAGS as u32,
        u64: key,
    }
}

fn epoll_create() -&gt; io::Result&lt;RawFd&gt; {
    let fd = syscall!(epoll_create1(0))?;
    if let Ok(flags) = syscall!(fcntl(fd, libc::F_GETFD)) {
        let _ = syscall!(fcntl(fd, libc::F_SETFD, flags | libc::FD_CLOEXEC));
    }
    Ok(fd)
}

#[cfg(test)]
mod test {
    #[test]
    fn test() {
        let a = [232, 183, 159];
        let s = std::str::from_utf8(&amp;a[..]).unwrap();
        dbg!(s);
    }
}
</code></pre>
<h2 id="其他-4"><a class="header" href="#其他-4">其他</a></h2>
<h3 id="errnoh"><a class="header" href="#errnoh">errno.h</a></h3>
<h4 id="定义-1"><a class="header" href="#定义-1">定义</a></h4>
<p>该头文件定义了一个 int 类型的左值，errno，包含了任何函数使用 errno 功能时会产生的错误码</p>
<ul>
<li>EINTR：表示被中断的系统调用</li>
</ul>
<h4 id="修改-errno-的值"><a class="header" href="#修改-errno-的值">修改 errno 的值</a></h4>
<p>errno 的默认值为 0, 当	调用系统调用时，可能会接受到某个信号导致调用退出，并返回一个错误码，并修改 errno 的值，可以通过 errno 判断系统调用是否失败，</p>
<h4 id="错误码对不同函数有不同意义"><a class="header" href="#错误码对不同函数有不同意义">错误码对不同函数有不同意义</a></h4>
<ul>
<li>
<p>write: 由于信号中断，没写成功任何数据。</p>
<blockquote>
<p>The call was interrupted by a signal before any data was written.</p>
</blockquote>
</li>
<li>
<p>read: 由于信号中断，没读到任何数据。</p>
<blockquote>
<p>The call was interrupted by a signal before any data was read.</p>
</blockquote>
</li>
<li>
<p>sem_wait: 函数调用被信号处理函数中断</p>
<blockquote>
<p>The call was interrupted by a signal handler.</p>
</blockquote>
</li>
<li>
<p>recv: 由于信号中断返回，没有任何数据可用。</p>
<blockquote>
<p>function was interrupted by a signal that was caught, before any data was
available.</p>
</blockquote>
</li>
</ul>
<h4 id="如何应对"><a class="header" href="#如何应对">如何应对</a></h4>
<p>当碰到 EINTR 错误的时候，可以采取有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。例如：accept、read、write、select、和 open 之类的函数来说，是可以进行重启的。不过对于套接字编程中的 connect 函数我们是不能重启的，若 connect 函数返回一个 EINTR 错误的时候，我们不能再次调用它，否则将立即返回一个错误。针对 connect 不能重启的处理方法是，必须调用 select 来等待连接完成。</p>
<p>系统中断不一定被当作错误</p>
<ul>
<li>
<p>如果错误码为 EINTR 则 <strong>重新调用系统调用</strong> ,例如 Postgresql 中有一段代码：</p>
<pre><code class="language-c">retry1:
if (send(port-&gt;sock, &amp;SSLok, 1, 0) != 1)
{
    if (errno == EINTR)
        goto retry1; /* if interrupted, just retry */
}
</code></pre>
</li>
<li>
<p><strong>重新定义系统调用</strong>,忽略错误码为 EINTR 的情况。例如，Cherokee 中的一段代码：</p>
<pre><code class="language-c">int cherokee_stat (const char *restrict path, struct stat *buf)
{
  int re;
  do {
     re = stat (path, buf);
  } while ((re == -1) &amp;&amp; (errno == EINTR));
  return re;
}
</code></pre>
</li>
</ul>
<h4 id="如何保证线进程安全"><a class="header" href="#如何保证线进程安全">如何保证线/进程安全</a></h4>
<blockquote>
<p>一般而言，编译器会自动保证 errno 的安全性，但是为了妥善期间，我们希望在写 makefile 的时 候把 _LIBC_REENTRANT 宏定义，比
如我们在检查 &lt;bits/errno.h&gt; 文件中发现如下的定义：</p>
</blockquote>
<pre><code class="language-c"># ifndef __ASSEMBLER__
/* Function to get address of global `errno' variable. */
extern int *__errno_location (void) __THROW __attribute__ ((__const__));


# if !defined _LIBC || defined _LIBC_REENTRANT
/* When using threads, errno is a per-thread value. */
# define errno (*__errno_location ())
# endif
# endif /* !__ASSEMBLER__ */
#endif /* _ERRNO_H */
</code></pre>
<blockquote>
<p>也就是说，在没有定义 __LIBC 或者定义 _LIBC_REENTRANT 的时候，errno 是多线程 / 进程安全的。一般而言，
<strong>ASSEMBLER</strong>, _LIBC 和 _LIBC_REENTRANT 都不会被编译器定义，但是如果我们定义 _LIBC_REENTRANT
一次又何妨那？为了检测一下你编译器是否定义上述变量，不妨使用下面一个简单程序。</p>
</blockquote>
<p>希望读者在进行移植的时候，读一下相关的 unix 版本的 &lt;bits/errno.h&gt; 文 件，来确定应该定义什么宏。不同的 unix
版本可能存在着一些小的差别！</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

int main(void)
{
   #ifndef __ASSEMBLER__
   printf( &quot;Undefine __ASSEMBLER__\n&quot; );
   #else
   printf( &quot;define __ASSEMBLER__\n&quot; );
   #endif

   #ifndef __LIBC
   printf( &quot;Undefine __LIBC\n&quot; );
   #else
   printf( &quot;define __LIBC\n&quot; );
   #endif

   #ifndef _LIBC_REENTRANT
   printf( &quot;Undefine _LIBC_REENTRANT\n&quot; );
   #else
   printf( &quot;define _LIBC_REENTRANT\n&quot; );
   #endif

   return 0;
}
</code></pre>
<p>参考：https://blog.csdn.net/hnlyyk/article/details/51444617</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cicd"><a class="header" href="#cicd">CI/CD</a></h1>
<p>🤤这东西简直太棒了！</p>
<h2 id="自动部署-github-page"><a class="header" href="#自动部署-github-page">自动部署 Github Page</a></h2>
<ul>
<li>这里使用 source 分支作为写文档的分支</li>
<li>push 后自动 build (这里使用<code>borales/actions-yarn@v2.3.0</code>，如果使用 npm，需要<code>set-node</code>)</li>
<li>将打包好的文件发布到 master 分支上 (使用<code>peaceiris/actions-github-pages@v3.1.12</code>)</li>
</ul>
<pre><code class="language-yml">name: Github Page

on:
  push:
    branches:
     - source

jobs:
  build-and-deploy:
    # 运行环境
    runs-on: ubuntu-latest
    # 开始 job
    steps:
      # from [actions/checkout](https://github.com/actions/checkout#checkout-v2)
      # This action checks-out your repository under $GITHUB_WORKSPACE, so your workflow can access it.
      # 属于是必要选项了，能够拿到当前分支，对应这里就是 source 分支
      - uses: actions/checkout@v2

      # 使用 yarn

      # 安装依赖
      - name: Install dependencies
        uses: borales/actions-yarn@v2.3.0
        with:
          cmd: install # will run `yarn install` command

      - name: Build
        uses: borales/actions-yarn@v2.3.0
        with:
          cmd: build # will run `yarn build` command

      # 把 disk 文件发布到另一个 branch
      - name: Deploy with &lt;GitHub Pages v3&gt;
        uses: peaceiris/actions-github-pages@v3.1.12
        with:
          # 发布到当前仓库
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # 的 main 分支
          publish_branch: main
          # 要发布的文件夹
          publish_dir: ./docs/.vuepress/dist
</code></pre>
<h2 id="自动-release"><a class="header" href="#自动-release">自动 Release</a></h2>
<ul>
<li>实例使用 dev 作为开发分支</li>
<li>当 push 有标签时，把 release 的文件自动发布 (<code>softprops/action-gh-release@v1</code>)</li>
<li>同时把分支同步到 <code>master</code> 上 (<code>tretuna/sync-branches@1.4.0</code>)</li>
</ul>
<pre><code class="language-yml">name: Release

on:
  push:
    branches: [ dev ]
    tags:
      - &quot;v*&quot;

env:
  CARGO_TERM_COLOR: always

jobs:
  release:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Build
      run: cargo build --verbose

    - name: Run tests
      run: cargo test --verbose

    - name: Release
      uses: softprops/action-gh-release@v1
      with:
        files: ./target/debug/yarm

    - name: Opening pull request
      uses: tretuna/sync-branches@1.4.0
      with:
        GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
        FROM_BRANCH: &quot;dev&quot;
        TO_BRANCH: &quot;master&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文件系统"><a class="header" href="#文件系统">文件系统</a></h1>
<h2 id="1-inode"><a class="header" href="#1-inode">1. inode</a></h2>
<h3 id="11-什么是-inode"><a class="header" href="#11-什么是-inode">1.1 什么是 inode</a></h3>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021258963.png" alt="" />
文件存储在硬盘上，硬盘的最小存储单元是扇区，硬盘会按照多个扇区按块读取扇区，一个文件的数据就被存储在多个块中，
同时我们还需要有一个地方存储文件的元信息。这种存储文件元信息的区域就叫做 inode（索引节点）。</p>
<h3 id="12-inode-的内容"><a class="header" href="#12-inode-的内容">1.2 inode 的内容</a></h3>
<p>每一个文件都有对应的 inode 我们可以通过 <code>stat xxx</code> 去查看，主要包括：</p>
<ul>
<li>文件大小</li>
<li>文件的拥有者</li>
<li>文件的 Group ID</li>
<li>文件的读写执行权限</li>
<li>文件的时间戳，ctime：创建时间，mtime：修改时间，atime：打开时间</li>
<li>链接数：比如创建软链接，再次查看就会多 1</li>
<li>数据块的位置</li>
</ul>
<p>不过单单没有文件名就离谱</p>
<pre><code class="language-sh">[trthg@trthg--manjaro ioclub]$ stat package.json
  File: package.json
  Size: 1006            Blocks: 8          IO Block: 4096   regular file
Device: 0,39    Inode: 4528790     Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/   trthg)   Gid: ( 1001/   trthg)
Access: 2021-11-01 22:00:54.464935992 +0800
Modify: 2021-11-01 22:00:54.464935992 +0800
Change: 2021-11-01 22:00:54.464935992 +0800
 Birth: 2021-11-01 22:00:54.464935992 +0800
</code></pre>
<h3 id="13-inode-的大小"><a class="header" href="#13-inode-的大小">1.3 inode 的大小</a></h3>
<ol>
<li>inode 与 数据块本身会储存在不同的区域，硬盘格式化时，操作系统就会把硬盘分为两个区，数据区和 inode 区</li>
<li>inode 节点的大小一般在格式化时就给定，一般是 128 或 256 字节</li>
<li>一般每 1-2kb 就会设置一个 inode，假定在一块 1GB 的硬盘中，每个 inode 节点的大小为 128 字节，每 1KB 就设置一个 inode，那么 inode
table 的大小就会达到 128MB，占整块硬盘的 12.8%。</li>
</ol>
<p>查看每个硬盘分区的 inode 总数，和已经使用的数量</p>
<pre><code class="language-sh">[trthg@trthg--manjaro ioclub]$ df -i
Filesystem     Inodes IUsed IFree IUse% Mounted on
dev              1.9M   585  1.9M    1% /dev
run              1.9M  1.1K  1.9M    1% /run
/dev/nvme0n1p2      0     0     0     - /
tmpfs            1.9M   175  1.9M    1% /dev/shm
/dev/nvme0n1p2      0     0     0     - /home
/dev/nvme0n1p2      0     0     0     - /var/cache
/dev/nvme0n1p2      0     0     0     - /var/log
tmpfs            400K  3.8K  397K    1% /tmp
/dev/nvme0n1p1      0     0     0     - /boot/efi
tmpfs            386K   303  386K    1% /run/user/1000
</code></pre>
<p>查看 inode 大小</p>
<p>没找到</p>
<h3 id="14-inode-号码"><a class="header" href="#14-inode-号码">1.4 inode 号码</a></h3>
<p>每个 inode 都有一个 id 相当与，操作系统用这个 id 来识别文件</p>
<pre><code class="language-sh">[trthg@trthg--manjaro ioclub]$ ls -i package.json
4528790 package.json
</code></pre>
<h3 id="15-目录文件"><a class="header" href="#15-目录文件">1.5 目录文件</a></h3>
<p>目录文件也是一种文件，目录文件本身结构简单，它存储的是一个列表，列表中存储目录项</p>
<p>目录项存储的：</p>
<ul>
<li>文件名</li>
<li>文件的 inode 号</li>
</ul>
<p>可以用 <code>ls -i dir</code> 查看该目录下所有文件的文件名和 inode</p>
<p>目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和 inode 号码，读取 inode 节点内的信息需要目录文件的执行权限（x），
所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在 inode 节点中，而</p>
<h3 id="16-硬链接"><a class="header" href="#16-硬链接">1.6 硬链接</a></h3>
<p>有了上面的知识就能理解了，硬链接就是指多个文件名可以指向同一个 inode 号， <code>.</code> 和 <code>..</code> 就是硬链接，加了一个硬链接，原文件的 LINK 数就会
+1</p>
<h3 id="17-软链接"><a class="header" href="#17-软链接">1.7 软链接</a></h3>
<p>软链接指的是一个文件的内容存储的是另一个文件的路径，访问 A 就会自动导向 B</p>
<p><code>ln -s</code></p>
<h3 id="18-其他"><a class="header" href="#18-其他">1.8 其他</a></h3>
<p><strong>八、inode 的特殊作用</strong></p>
<p>由于 inode 号码与文件名分离，这种机制导致了一些 Unix/Linux 系统特有的现象。</p>
<ol>
<li>
<p>有时，文件名包含特殊字符，无法正常删除。这时，直接删除 inode 节点，就能起到删除文件的作用。</p>
</li>
<li>
<p>移动文件或重命名文件，只是改变文件名，不影响 inode 号码。</p>
</li>
<li>
<p>打开一个文件以后，系统就以 inode 号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从 inode 号码得知文件名。</p>
</li>
</ol>
<p>第 3 点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过 inode 号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的 inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的 inode 则被回收。</p>
<h2 id="2-文件描述符"><a class="header" href="#2-文件描述符">2. 文件描述符</a></h2>
<blockquote>
<p>Advanced Programming in the UNIX® Environment: Second Edition By W. Richard
Stevens, Stephen A. Rago</p>
<p><a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.458.2318&amp;rep=rep1&amp;type=pdf">书里有更详细的解释</a></p>
</blockquote>
<h3 id="21-与-inode-的区别"><a class="header" href="#21-与-inode-的区别">2.1 与 inode 的区别</a></h3>
<p>inode 本身只是对应没一个文件，但是一个文件能被多个人打开，因此需要有 fd 去记录文件的打开状态</p>
<p>内核维护一个内核级文件描述符表，存储了主要包括：</p>
<ul>
<li>文件偏移量</li>
<li>文件的打开状态</li>
<li>inode 指针</li>
</ul>
<p>这些是全部</p>
<pre><code>1. 当前文件偏移量（调用 read() 和 write() 时更新，或使用 lseek() 直接修改）
2. 打开文件时所使用的状态标识（即，open() 的 flags 参数）
3. 文件访问模式（如调用 open() 时所设置的只读模式、只写模式或读写模式）
4. 与信号驱动相关的设置
5. 对该文件 i-node 对象的引用
6. 文件类型（例如：常规文件、套接字或 FIFO）和访问权限
7. 一个指针，指向该文件所持有的锁列表
8. 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳
</code></pre>
<p>只要有进程打开一个文件，内核就会产生这个去记录文件打开状态，接着向进程返回这个记录的索引位置，就是 fd</p>
<p>进程本身维护一个进程级的文件描述符表，存储了：</p>
<ul>
<li>文件描述符</li>
<li>文件指针</li>
</ul>
<p>查看进程占用的 fd 数目</p>
<pre><code class="language-bash">// 226889 是进程的 PID， 可以通过 lsof -i：6379 查看
ls /proc/226889/fd | wc -w                                                       ✔
9
</code></pre>
<h3 id="22-不同级别的表的对应关系"><a class="header" href="#22-不同级别的表的对应关系">2.2 不同级别的表的对应关系</a></h3>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021301758.png" alt="" /></p>
<ol>
<li>在进程 A 中，文件描述符 1 和 30 都指向了同一个打开的文件句柄（标号 23）。这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数而形成的。</li>
<li>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个打开的文件句柄（标号 73）。这种情形可能是在调用 fork() 后出现的（即，进程 A、B 是父子进程关系），或者当某进程通过 UNIX 域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用 open 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</li>
<li>此外，进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件句柄，但这些句柄均指向 i-node 表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。</li>
</ol>
<p>不同文件描述符存储的内容</p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021301124.png" alt="" /></p>
<h3 id="23-fd-的限制"><a class="header" href="#23-fd-的限制">2.3 fd 的限制</a></h3>
<ol>
<li>
<p>系统级限制</p>
<p>文件描述符是系统的一个重要资源，<strong>虽然说系统内存有多少就可以打开多少的文件描述符</strong>，但是在实际实现过程中内核是会做相应的处理的，一般最大打开文件数会是系统内存的 10%（以 KB 来计算）</p>
<p>查看方式：<code>sysctl -a | grep fs.file-max</code></p>
</li>
<li>
<p>用户级限制</p>
<p>与此同时，内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理，默认值一般是 1024，使用 <code>ulimit -n</code>
命令可以查看。</p>
</li>
</ol>
<p>一般可以通过修改限制优化系统</p>
<h2 id="3-使用-fd"><a class="header" href="#3-使用-fd">3. 使用 fd</a></h2>
<h3 id="31-open--read"><a class="header" href="#31-open--read">3.1 open / read</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int main (void){
    int fd;
    int numbytes;
    char path[] = &quot;file&quot;;
    char buf[256];

    /*
     * O_CREAT:如果文件不存在则创建
     * O_RDONLY:以只读模式打开文件
     */
    fd = open(path, O_CREAT | O_RDONLY, 0644);
    if(fd &lt; 0){
        perror(&quot;open()&quot;);
        exit(EXIT_FAILURE);
    }

    memset(buf, 0x00, 256);
    while((numbytes = read(fd, buf, 255)) &gt; 0){
        printf(&quot;%d bytes read: %s&quot;, numbytes, buf);
        memset(buf, 0x00, 256);
    }
    close (fd);
    exit(EXIT_SUCCESS);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="大数据"><a class="header" href="#大数据">大数据</a></h1>
<h2 id="使用-vm-搭建-hadoop-集群"><a class="header" href="#使用-vm-搭建-hadoop-集群">使用 VM 搭建 hadoop 集群</a></h2>
<h3 id="1-准备"><a class="header" href="#1-准备">1. 准备</a></h3>
<ul>
<li>centos7.5 镜像</li>
<li>JDK8</li>
<li>Hadoop</li>
<li><a href="https://www.cnblogs.com/aeolian/p/8882790.html">参考链接</a></li>
</ul>
<h3 id="2-安装-hadoop101-虚拟机"><a class="header" href="#2-安装-hadoop101-虚拟机">2. 安装 hadoop101 虚拟机</a></h3>
<ul>
<li>软件选择：最小安装是纯命令行</li>
<li>安装位置：选择手动和以自由配置盘符配置及大小，设备类型 (LVM 相比于标准分区能自由扩缩容)</li>
<li>KDUMP 可以暂时不要</li>
<li>设置用户名密码：示例 username: hadoop101 password: 000000</li>
</ul>
<h3 id="3-配置本机网络环境"><a class="header" href="#3-配置本机网络环境">3. 配置本机网络环境</a></h3>
<ol>
<li>关闭防火墙</li>
<li>VM 配置 VMnet8 编辑 -&gt; 虚拟网络编辑器</li>
<li>Windows 配置 VMnet8</li>
</ol>
<h3 id="4-配置虚拟机网络环境"><a class="header" href="#4-配置虚拟机网络环境">4. 配置虚拟机网络环境</a></h3>
<ol>
<li>关闭虚拟机防火墙：<code>systemctl disable firewalld.service</code></li>
<li>关闭 NetworkManage:</li>
</ol>
<ul>
<li><code>systemctl stop NetworkManager</code></li>
<li><code>systemctl disable NetworkManager</code></li>
</ul>
<ol start="3">
<li>!!! 修改网卡配置：</li>
</ol>
<ul>
<li><code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></li>
</ul>
<pre><code>BOOTPROTO=static  #启用静态 IP 地址 ,默认为 dhcp
IPADDR=192.168.182.3  #设置 IP 地址 (这台虚拟机想要的 ip)
NETMASK=255.255.225.0  #设置子网掩码
GATEWAY=192.168.182.2  #设置网关 (和外部的网关相同)
</code></pre>
<ol start="4">
<li>重启网卡：<code>service  network restart</code> 可以通过 <code>ping 8.8.8.8</code>检测是否通</li>
</ol>
<h3 id="5-克隆前"><a class="header" href="#5-克隆前">5. 克隆前</a></h3>
<ol>
<li>安装辅助包管理器：<code>yum install -y epel-release</code></li>
<li>未知：<code>kill -9 3030</code></li>
<li>卸载系统自带 JDK:</li>
</ol>
<ul>
<li>查看：<code>rpm -qa | grep java</code></li>
<li>卸载：<code>sudo yum remove packagename</code></li>
</ul>
<ol start="4">
<li>修改虚拟机 host</li>
</ol>
<ul>
<li>修改 hostname 如下：<code>nano /etc/hostname</code></li>
</ul>
<pre><code>hadoop101
</code></pre>
<ul>
<li>修改 hosts 如下：<code>nano /etc/hosts</code></li>
</ul>
<pre><code>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

192.168.93.21 hadoop101
192.168.93.22 hadoop102
192.168.93.23 hadoop103
</code></pre>
<h3 id="6-克隆-完整克隆-后"><a class="header" href="#6-克隆-完整克隆-后">6. 克隆 (完整克隆) 后</a></h3>
<ol>
<li>通过 vmware 进行 clone 出 n 台相同的虚拟机</li>
</ol>
<ul>
<li>修改每台克隆出的网卡 IPADDR: <code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></li>
<li>修改 hostname: <code>nano /etc/hostname</code></li>
</ul>
<h3 id="7-安装及配置环境变量"><a class="header" href="#7-安装及配置环境变量">7. 安装及配置环境变量</a></h3>
<ol>
<li>安装软件 为了方便统一管理</li>
</ol>
<ul>
<li>压缩包目录：<code>/opt/software</code></li>
<li>解压目录：<code>/opt/module</code> 解压：</li>
<li>给权限：<code>chmod 777 /opt/software</code></li>
<li>解压 (-C 指定解压目录): <code>tar -zxvf jdk-8u212-linux-x64.tar.gz -C /opt/module/</code></li>
</ul>
<ol start="2">
<li>修改环境变量 为了永久修改环境变量：修改文件 <code>sudo nano /etc/profile.d/users.sh</code>如下</li>
</ol>
<pre><code class="language-shell">#JAVA
export JAVA_HOME=/opt/module/jdk1.8.0_212
export PATH=$PATH:$JAVA_HOME/bin
#HADOOP
export HADOOP_HOME=/opt/module/hadoop-3.1.3
export PATH=$PATH:$HADOOP_HOME/bin
export PATH=$PATH:$HADOOP_HOME/sbin
</code></pre>
<ol start="3">
<li>重置 <code>source /etc/profile</code> ::: warning 使用 <code>export PATH=$PATH:xxxxx</code>会在终端关闭后失效
:::</li>
</ol>
<h3 id="8-配置集群分发脚本和免密登录"><a class="header" href="#8-配置集群分发脚本和免密登录">8. 配置集群分发脚本和免密登录</a></h3>
<ol>
<li>scp 服务器间拷贝</li>
</ol>
<pre><code class="language-shell"># 将当前服务器的/opt/module/jdk1.8.0_212 目录拷贝到 hadoop102 服务器的/opt/module 目录下
# 值得注意的是，hadoop102 服务器下的/opt/module 目录必须存在
# -r 指递归复制整个目录
# root 是指 hadoop102 的用户
scp -r /opt/module/jdk1.8.0_212 root@hadoop102:/opt/module
</code></pre>
<ol start="2">
<li>rsync 远程同步工具</li>
</ol>
<pre><code class="language-shell"># 值得注意的是，每个服务器都需要安装
yum -y install rsync

# -a 表示归档拷贝
# -v 表示显示拷贝过程
rsync -av /opt/module/hadoop-3.1.3/ root@hadoop102:/opt/module/hadoop-3.1.3/
# 让两个文件夹同步
</code></pre>
<ol start="3">
<li>分发脚本 (起名:xsync)</li>
</ol>
<pre><code class="language-shell">#!/bin/bash
#1. 判断参数个数
if [ $# -lt 1 ]
then
 echo Not Enough Arguement!
 exit;
fi
#2. 遍历集群所有机器
for host in hadoop101 hadoop102 hadoop103
    do
    echo ==================== $host ====================
    #3. 遍历所有目录，挨个发送

    for file in $@
    do
        #4. 判断文件是否存在
        if [ -e $file ]
        then
            #5. 获取父目录
            pdir=$(cd -P $(dirname $file); pwd)
            #6. 获取当前文件的名称
            fname=$(basename $file)
            ssh $host &quot;mkdir -p $pdir&quot;
            rsync -av $pdir/$fname $host:$pdir
        else
            echo $file does not exists!
        fi
    done
done
</code></pre>
<p>::: danger</p>
<blockquote>
<p>空格必须加：<code>if [ -e $file ]</code> 等号两边的空格必不能加：<code>pdir=$(cd -P $(dirname $file); pwd)</code>
$@返回所有命令行参数，所以可以一次同步多个文件 (夹)</p>
</blockquote>
<p>:::</p>
<ol start="4">
<li>后续处理 文件创建在/bin/下：<code>/bin/xsync</code>方便直接调用</li>
</ol>
<pre><code class="language-shell"># 给运行权限
chmod +x xsync
# 测试同步环境变量
xsync /etc/profile.d/
</code></pre>
<ol start="5">
<li>免密登录</li>
</ol>
<pre><code class="language-shell">cd /root/.ssh
# 生成私钥公钥
ssh-keygen -t rsa
# 分发密钥
ssh-copy-id hadoop101
ssh-copy-id hadoop102
ssh-copy-id hadoop103
</code></pre>
<h3 id="9"><a class="header" href="#9">9</a></h3>
<h2 id="hdfs"><a class="header" href="#hdfs">HDFS</a></h2>
<p>日志型，只允许追加</p>
<h2 id="hbase"><a class="header" href="#hbase">HBase</a></h2>
<p>基于 HDFS，不会将旧数据删除</p>
<h3 id="数据模型"><a class="header" href="#数据模型">数据模型</a></h3>
<p>HBase 是一个稀疏的 (不同时间没有数据)，多维度 (4 个维度在能限定到一个单元格) 的，排序的映射表
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241641728.png" alt="" /></p>
<h4 id="概念视图"><a class="header" href="#概念视图">概念视图</a></h4>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241634039.png" alt="" />
不同时间可能没有数据，体现了 HBase 是稀疏表</p>
<h4 id="物理视图"><a class="header" href="#物理视图">物理视图</a></h4>
<p>列标识并没有区分
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241635344.png" alt="" /></p>
<h4 id="按行按列的区分"><a class="header" href="#按行按列的区分">按行按列的区分</a></h4>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241637049.png" alt="" /></p>
<p>按行：</p>
<ul>
<li>不便于读取某一列数据，必须扫描所有行，并把每行的某个字段取出来</li>
</ul>
<p>按列：</p>
<ul>
<li>压缩性能好，按列存，数据类型相同，能够更好的压缩</li>
</ul>
<h3 id="实现原理"><a class="header" href="#实现原理">实现原理</a></h3>
<h4 id="服务器划分"><a class="header" href="#服务器划分">服务器划分</a></h4>
<ul>
<li>master 服务器负责管理写请求，负载均衡等</li>
<li>客户端并不依赖 master 服务去找到数据位置</li>
<li>用户直接访问的是 region 服务器
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241654144.png" alt="" /></li>
</ul>
<h4 id="物理存储"><a class="header" href="#物理存储">物理存储</a></h4>
<ul>
<li>不同的 region 不许存储在同一个服务器上，一个服务器可以存储多个 region(1-2G, 10-1000 个)</li>
<li>region 太大了就会垂直分裂 (操作指针，速度较快)，分裂时用户读取的依然是之前的
region，当服务器经过合并，写入新的文件之后，新来的用户彩绘访问新的 region
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241657033.png" alt="" /></li>
</ul>
<h4 id="索引结构"><a class="header" href="#索引结构">索引结构</a></h4>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241701862.png" alt="" />
各个层次的作用
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241702112.png" alt="" />
3 层结构完全足够使用，对于经常访问的可以增加缓存</p>
<ul>
<li>如何解决缓存失效，缓存失效的话数据就找不到了</li>
</ul>
<h3 id="运行架构"><a class="header" href="#运行架构">运行架构</a></h3>
<h4 id="架构图"><a class="header" href="#架构图">架构图</a></h4>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241709216.png" alt="" />
master:</p>
<ul>
<li>对数据表进行增删改查</li>
<li>负载均衡，把负载大的服务器上的 region 表拿到其他负载小的服务器上</li>
<li>管理 region 的分裂合并操作之后的发布</li>
<li>重新分配故障服务器上的 region</li>
</ul>
<h4 id="region-写入-hdfs"><a class="header" href="#region-写入-hdfs">region 写入 HDFS</a></h4>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241715580.png" alt="" />
对于单个 region 服务器，上面存储了多个 region 块，每个列族被划分为一个 store</p>
<p>锁与 resion 块共用一个 Hlog 文件</p>
<p>region 将数据写入 HDFS 会线写入 memStore 中 (缓存)，缓存满了之后，刷入 StoreFile 中，StoreFile 就是 HFile,
HDFS 中的数据格式</p>
<h4 id="用户写入-region"><a class="header" href="#用户写入-region">用户写入 Region</a></h4>
<p>用户写入请求被分配给 region</p>
<ul>
<li>写入缓存</li>
<li>写入日志 (Hlog), 必须写入磁盘才算成功</li>
<li>系统将缓存周期性刷入磁盘，并在 Hlog 写入标记</li>
<li>每次刷写都会生成一个 StoreFile</li>
<li>多个 StoreFile 会合并为大文件，太大就会引发 StoreFile 的分裂，region 就分裂了</li>
</ul>
<p>zookeeper 监听 Region 服务器，如果 Region 服务器发生故障，就会通知 Master 服务武器，Master 服务器将 Region
服务器上的 Hlog 文件拉取过来，并根据日志文件将所有 Region 分配到其他可用的 Region 服务器</p>
<h3 id="优化存储"><a class="header" href="#优化存储">优化存储</a></h3>
<ul>
<li>
<p>时间靠近的数据存在一起：</p>
<p>用<code>Long.Max_VALUE - timestamp</code>作为行键，最新的数据能够快速命中</p>
</li>
<li>
<p>提升读写性能</p>
<p>设置<code>HColumnDescriptor.setlnMemory = true</code>, 将 Region 服务器的 Region 放入缓存中</p>
</li>
<li>
<p>删除旧版本数据 设置<code>HColumnDescriptr.setMaxVersionsMaxVersions = true</code>，只会保留最新版本</p>
</li>
<li>
<p>过期自动清除 设置<code>setTimeToLive(2 * 24 * 60 * 60)</code>超过两天就自动清除</p>
</li>
</ul>
<h3 id="二级索引"><a class="header" href="#二级索引">二级索引</a></h3>
<p>Hindex: 依赖触发器在插入数据后同时插入索引表 HBase + Redis: 将索引暂时存入 redis，之后在刷入 HBase Solr +
HBase: 高性能全文索引，由 Solr 构建索引得到数据的 RowKey</p>
<h2 id="nosql"><a class="header" href="#nosql">NoSQL</a></h2>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203311248917.png" alt="" /></p>
<h3 id="键值数据库"><a class="header" href="#键值数据库">键值数据库</a></h3>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203311253870.png" alt="" /></p>
<h3 id="列族数据库"><a class="header" href="#列族数据库">列族数据库</a></h3>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203311257861.png" alt="" /></p>
<h3 id="文档数据库"><a class="header" href="#文档数据库">文档数据库</a></h3>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203311302289.png" alt="" /></p>
<h2 id="mapreduce"><a class="header" href="#mapreduce">MapReduce</a></h2>
<p>分布式并行编程模型，相比与传统的并行编程框架的区别</p>
<h3 id="模型简介"><a class="header" href="#模型简介">模型简介</a></h3>
<table>
  <tr>
    <td>
      传统的计算方法是数据向计算靠拢
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204070954311.png" alt="" /></p>
</td>
<td> MapReduce 计算项数据靠拢
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204070954635.png" alt="" /></p>
</td>
</tr>
</table>
<h3 id="体系结构"><a class="header" href="#体系结构">体系结构</a></h3>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204071239586.png" alt="" /></p>
<h4 id="client"><a class="header" href="#client">Client</a></h4>
<ul>
<li>用户将编写的程序提交到 Client</li>
<li>通过 Client 提供的借口查看作业的运行状态</li>
</ul>
<h4 id="jobtracker"><a class="header" href="#jobtracker">JobTracker</a></h4>
<ul>
<li>负责资源监控</li>
<li>负责作业调度 (依靠 TaskSchedular 决定任务应该分发给那个 Taskracker)</li>
<li>监测底层其他 Taskracker 以及当前运行的 Job 的状况</li>
<li>如果检测到失败，需要把 Job 转移到其他节点，并继续追踪</li>
</ul>
<h4 id="tasktracker"><a class="header" href="#tasktracker">TaskTracker</a></h4>
<ul>
<li>执行具体的相关任务，一般是 JobTracker 发来的命令</li>
<li>把自己的资源使用情况，任务运行进度通过心跳的方式发送给 JobTracker</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="go-语言"><a class="header" href="#go-语言">Go 语言</a></h1>
<p>###./ 基础</p>
<h4 id="格式化"><a class="header" href="#格式化">格式化</a></h4>
<pre><code class="language-go">fmt.Printf(&quot;type %T value %v \n&quot;, a, a)
</code></pre>
<h4 id="循环"><a class="header" href="#循环">循环</a></h4>
<pre><code class="language-go">if num := 10; num &gt; 0 {
    fmt.Println(num)
}

for i := 1; i &lt; 10; i++ {
    fmt.Println(i)
    if i == 3 {
        break
    }
}

finger := 2
switch finger {
case 1:
    fmt.Println(1)
case 2:
    fmt.Println(2)
    fallthrough
default:
    println(&quot;sss&quot;)
}

dd := 1
switch {
case dd &gt; 0:
    println(0)
case dd &gt; -1:
    println(-1)
}
</code></pre>
<h4 id="数组-2"><a class="header" href="#数组-2">数组</a></h4>
<p>数组有固定大小，数组的大小是类型的一部分，因此 [5]int 和 [25]int 是不同类型</p>
<pre><code class="language-go">a := []int{2}
a[0] = 1
fmt.Println(a)

var b [3][2]int
b = [3][2]int{
    {1, 2},
    {1, 2},
    {1, 2},
}
fmt.Println(b)

veggies := []string{&quot;potatoes&quot;, &quot;tomatoes&quot;, &quot;brinjal&quot;}
fruits := []string{&quot;oranges&quot;, &quot;apples&quot;}
food := append(veggies, fruits...)
fmt.Println(&quot;food:&quot;, veggies, fruits, food)
fmt.Println(&quot;food:&quot;, cap(veggies), cap(fruits), cap(food))
fmt.Println(&quot;food:&quot;, len(veggies), len(fruits), len(food))
nums := []int{1, 2}
change(nums...)
pln(nums...)
</code></pre>
<h4 id="map-2"><a class="header" href="#map-2">map</a></h4>
<pre><code class="language-go">// map 的零值为 nil，必须使用 make 初始化
// map 是 引用类型，当 map 被赋值给另一个变量是后，他们共享一个
// map 不能使用==判断，==只能用来判断 map 是否为 nil，应该遍历字典元素去比较两个字典
var mm map[string]int
// mm[&quot;s&quot;] = 1                    // 回报错，map is nil
// fmt.Printf(&quot;%T %v \n&quot;, mm, mm) // 这里虽然能打印出 map[]，但是无济于事
if mm == nil {
    mm = make(map[string]int)
    mm[&quot;s&quot;] = 1
    fmt.Printf(&quot;%T %v \n&quot;, mm, mm)
}
mmm := map[string]int{
    &quot;aaa&quot;: 1,
}
if v, ok := mmm[&quot;aa&quot;]; ok == true {
    fmt.Println(v)
    delete(mmm, &quot;aa&quot;)
} else {
    fmt.Println(&quot;no such key&quot;)
    fmt.Println(len(mmm))
    for k, v := range mmm {
        fmt.Println(k, v)
    }
}
</code></pre>
<h4 id="字符串-与-切片"><a class="header" href="#字符串-与-切片">字符串 与 切片</a></h4>
<pre><code class="language-go">// 字符串
name := &quot;Señor&quot;
for i := 0; i &lt; len(name); i++ {
    fmt.Printf(&quot;%c&quot;, name[i])
}
fmt.Printf(&quot;\n&quot;)
for _, v := range name {
    fmt.Printf(&quot;%c&quot;, v)
}
fmt.Printf(&quot;\n&quot;)
name_ := []rune(name)
for i := 0; i &lt; len(name_); i++ {
    fmt.Printf(&quot;%c&quot;, name_[i])
}
</code></pre>
<p>当对切片调用<code>append(slice, ...elems)</code>是，如果超出切片的 cap，就会重新分配内存空间，因此必须需要用变量接受返回值</p>
<pre><code class="language-go">//关于切片
// a[x] 是 (*a)[x] 的简写形式
// arr := [3]int{1, 2, 3}
// modify(&amp;arr)
// modify(arr[:]) 这种更常用
// arr++ 这种直接进行指针操作不被允许
func modify1(arr *[3]int) {
	(*arr)[0] = 90
}
func modify2(arr *[3]int) {
	arr[0] = 90
}

func change(elems ...int) {
	for i, v := range elems {
		v += 1        // 无效
		elems[i] += 1 // 有效
	}
}

func pln(elems ...int) {
	for i, v := range elems {
		fmt.Printf(&quot;index: %v value %v\n&quot;, i, v)
	}
}
</code></pre>
<h3 id="结构体-1"><a class="header" href="#结构体-1">结构体</a></h3>
<ul>
<li>结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。如果两个结构体变量的对应字段相等，则这两个变量也是相等的。</li>
<li>如果结构体包含不可比较的字段，则结构体变量也不可比较。</li>
</ul>
<h4 id="书写"><a class="header" href="#书写">书写</a></h4>
<ul>
<li>
<p>匿名结构体：string,int 就是字段名，字段不能重复</p>
<pre><code class="language-go">type Person struct {
    string
    int
}
person := Person{&quot;aa&quot;, 1}
fmt.Println(person.int, person.string)
</code></pre>
</li>
<li>
<p>提升字段：嵌入的结构体，可以直接调用里面的字段</p>
<pre><code class="language-go">type Group struct {
    string
    int
    Person
}
</code></pre>
</li>
<li>
<p>匿名 + 提升，向上面的情况</p>
<p>匿名的类型可以重复，但是会以自身的为准</p>
<pre><code class="language-go">group := Group{&quot;bb&quot;, 1, person}
fmt.Print(group.string, group.string)
</code></pre>
</li>
</ul>
<h4 id="结构体-tag"><a class="header" href="#结构体-tag">结构体 Tag</a></h4>
<p><strong>格式</strong> 空格分割的键值对</p>
<p><strong>使用</strong> 示例：json 库能够反序列化结构体</p>
<ul>
<li>如果加上 omitepty，当结构体为空是就会被忽略</li>
<li>如果不加，为空的字段会被解析为空字符串&quot;&quot;</li>
</ul>
<pre><code class="language-go">type Person struct {
    Name string `json:&quot;name&quot;`
	Age  int    `json:&quot;age&quot;`
	Addr string `json:&quot;addr&quot;` // ,omitempty
}

func main() {
    p1 := Person{
		Name: &quot;Jack&quot;,
		Age:  22,
	}
	data1, _ := json.Marshal(p1)
	fmt.Printf(&quot;%s\n&quot;, data1)
}
</code></pre>
<p><strong>可以通过反射读取 tag</strong></p>
<pre><code class="language-go">// 三种获取 field
field := reflect.TypeOf(obj).FieldByName(&quot;Name&quot;)
field := reflect.ValueOf(obj).Type().Field(i)  // i 表示第几个字段
field := reflect.ValueOf(&amp;obj).Elem().Type().Field(i)  // i 表示第几个字段

// 获取 Tag
tag := field.Tag

// 获取键值对
labelValue := tag.Get(&quot;label&quot;)  // 获取不到就会返回 &quot;&quot;
labelValue,ok := tag.Lookup(&quot;label&quot;)
</code></pre>
<ul>
<li>获取键值对，有 Get 和 Lookup 两种方法，但其实 Get 只是对 Lookup 函数的简单封装而已，当没有获取到对应 tag
的内容，会返回空字符串。
<pre><code class="language-go">func (tag StructTag) Get(key string) string {
    v, _ := tag.Lookup(key)
    return v
}
</code></pre>
</li>
<li>空 Tag 和不设置 Tag 效果是一样的</li>
</ul>
<h3 id="方法--函数"><a class="header" href="#方法--函数">方法 &amp; 函数</a></h3>
<h4 id="结构体上的方法"><a class="header" href="#结构体上的方法">结构体上的方法</a></h4>
<ul>
<li>结构体方法：不管是一个值，还是一个可以解引用的指针，调用这样的方法都是合法的。或者说：用<strong>一个指针</strong>或者<strong>一个可取得地址的值</strong>来调用都是合法的</li>
<li>匿名字段的方法：属于结构体的匿名字段的方法可以被直接调用，就好像这些方法是属于定义了匿名字段的结构体一样。</li>
</ul>
<pre><code class="language-go">type rectangle struct {
	length int
	width  int
}

func (r *rectangle) area() {
	r.length += 1
}

// func (r rectangle) area() {
// 	r.length += 1
// }

r := rectangle{
    length: 10,
    width:  5,
}

r.area()
(&amp;r).area()
// {12, 5}
// 如果改为 不带*的方法，{10, 5}
</code></pre>
<p>那么什么时候使用指针接收器，什么时候使用值接收器？</p>
<ul>
<li>一般来说，指针接收器可以使用在：对方法内部的接收器所做的改变应该对调用者可见时。</li>
<li>指针接收器也可以被使用在如下场景：当拷贝一个结构体的代价过于昂贵时。考虑下一个结构体有很多的字段。在方法内使用这个结构体做为值接收器需要拷贝整个结构体，这是很昂贵的。在这种情况下使用指针接收器，结构体不会被拷贝，只会传递一个指针到方法内部使用。</li>
<li>在其他的所有情况，值接收器都可以被使用。</li>
</ul>
<h4 id="孤儿规则"><a class="header" href="#孤儿规则">孤儿规则🐶</a></h4>
<p>下面的不允许，因为 int 类型和这个方法，不再同一个包里</p>
<pre><code class="language-go">func (a int) add(b int) {
}
</code></pre>
<p>解决方法</p>
<ul>
<li>定义类型别名</li>
</ul>
<pre><code class="language-go">type myInt int

func (a myInt) add(b myInt) myInt {
    return a + b
}
</code></pre>
<ul>
<li>wrapper 包装</li>
</ul>
<h4 id="函数-1"><a class="header" href="#函数-1">函数</a></h4>
<p><strong>匿名函数</strong></p>
<pre><code class="language-go">func main() {
    func(n string) {
        fmt.Println(&quot;Welcome&quot;, n)
    }(&quot;Gophers&quot;)
}
</code></pre>
<p><strong>自定义函数类型</strong></p>
<pre><code class="language-go">type add func(a int, b int) int

func main() {
    var a add = func(a int, b int) int {
        return a + b
    }
    s := a(5, 6)
    fmt.Println(&quot;Sum&quot;, s)
}
</code></pre>
<p><strong>高阶函数</strong></p>
<pre><code class="language-go">// 接受函数
func simple(a func(a, b int) int) {
    fmt.Println(a(60, 7))
}

// 返回函数
func simple() func(a, b int) int {
    f := func(a, b int) int {
        return a + b
    }
    return f
}
</code></pre>
<h3 id="接口"><a class="header" href="#接口">接口</a></h3>
<p>类似于 dyn Train</p>
<pre><code class="language-go">type SalaryCalculator interface {
    CalculateSalary() int
}
employees := []SalaryCalculator{pemp1, pemp2, cemp1}
</code></pre>
<h4 id="接口的断言"><a class="header" href="#接口的断言">接口的断言</a></h4>
<ul>
<li>类型断言</li>
</ul>
<pre><code class="language-go">func assert(i interface{}) {
    v, ok := i.(int)
    fmt.Println(v, ok)
    // 如果不是 int 类型，v 就会被赋为 T 的零值
}
func main() {
    var s interface{} = 56
    assert(s)
    var i interface{} = &quot;Steven Paul&quot;
    assert(i)
}
</code></pre>
<ul>
<li>switch type 注意：把变量传递到函数中后会自动转换类型到 interface，因此调用函数能行，但是下面直接 switch 就不行</li>
<li>回报错：a (variable of type int) is not an interface</li>
</ul>
<pre><code class="language-go">func findType(i interface{}) {
    switch i.(type) {
    case string:
        fmt.Printf(&quot;I am a string and my value is %s\n&quot;, i.(string))
    case int:
        fmt.Printf(&quot;I am an int and my value is %d\n&quot;, i.(int))
    default:
        fmt.Printf(&quot;Unknown type\n&quot;)
    }
}

func main() {
	a := 1
	findType(a)

	switch interface{}(a).(type) {
	case string:
		fmt.Printf(&quot;I am a string and my value is %s\n&quot;, interface{}(a).(string))
	case int:
		fmt.Printf(&quot;I am an int and my value is %d\n&quot;, interface{}(a).(int))
	default:
		fmt.Printf(&quot;Unknown type\n&quot;)
	}
}
</code></pre>
<h4 id="接口类型变量"><a class="header" href="#接口类型变量">接口类型变量</a></h4>
<p>声明一个变量是接口类型，那么这个变量可以被赋值为，任何实现了接口的类型</p>
<pre><code class="language-go">type Describer interface {
    Describe()
}
type Person struct {
    name string
    age  int
}
type Address struct {
    state   string
    country string
}
</code></pre>
<p>现在还不能赋值，接下来为两个 struct 我们实现接口</p>
<p>为 person 实现 describe，使用<strong>值</strong>接受者，下面两种赋值都可以，也都能调用方法</p>
<pre><code class="language-go">func (p Person) Describe() { // 使用值接受者实现
    fmt.Printf(&quot;%s is %d years old\n&quot;, p.name, p.age)
}
var d1 Describer
p1 := Person{&quot;Sam&quot;, 25}
d1 = p1
d1.Describe()
p2 := Person{&quot;James&quot;, 32}
d1 = &amp;p2
d1.Describe()
</code></pre>
<p>为 Address 实现 describer，使用<strong>指针</strong>接受者，下面就比较特殊 d =
a 不能直接赋值，如果是在结构体的方法中，下面的两种赋值都是可以的，但是在接口中不行</p>
<p>其原因是：对于使用指针接受者的方法，用<strong>一个指针</strong>或者<strong>一个可取得地址的值</strong>来调用都是合法的。但接口中存储的具体值（Concrete
Value）并不能取到地址，因此在下面的例子中，对于编译器无法自动获取 a 的地址，于是程序报错。</p>
<pre><code class="language-go">func (a *Address) Describe() { // 使用指针接受者实现
    fmt.Printf(&quot;State %s Country %s&quot;, a.state, a.country)
}
var d Describer
a := Address{&quot;Washington&quot;, &quot;USA&quot;}

//d = a  // 这是不合法的，会报错：Address does not implement Describer

d = &amp;a // 这是合法的，Address 类型的指针实现了 Describer 接口
d.Describe()
</code></pre>
<h4 id="接口可以嵌套"><a class="header" href="#接口可以嵌套">接口可以嵌套</a></h4>
<p>类似于匿名结构体的嵌套 一个结构体实现了 A，B，那就说它也实现了 C</p>
<pre><code class="language-go">type A interface {
    foo()
}

type B interface {
    bar() int
}

type C interface {
    A
    B
}
</code></pre>
<h4 id="接口的零值"><a class="header" href="#接口的零值">接口的零值</a></h4>
<p>接口的零值是 nil，同时其底层值（Underlying Value）和具体类型（Concrete Type）都为 nil。调用方法会 panic</p>
<h4 id="接口的坑"><a class="header" href="#接口的坑">接口的坑</a></h4>
<ul>
<li>不能把 interface 赋值为别的类型
<pre><code class="language-go">func main() {
    // 声明 a 变量，类型 int，初始值为 1
    var a int = 1

    // 声明 i 变量，类型为 interface{}, 初始值为 a，此时 i 的值变为 1
    var i interface{} = a

    // 声明 b 变量，尝试赋值 i
    var b int = i
}
</code></pre>
</li>
<li>切片也不能再分
<pre><code class="language-go">func main() {
    sli := []int{2, 3, 5, 7, 11, 13}

    var i interface{}
    i = sli

    g := i[1:3]
    fmt.Println(g)
}
</code></pre>
</li>
</ul>
<h3 id="channel"><a class="header" href="#channel">channel</a></h3>
<h4 id="特性"><a class="header" href="#特性">特性</a></h4>
<ul>
<li>go 的 channel 默认是双向的，既可以 send，也可以 recv</li>
<li>channel 必须有发送端和接收端，否则就 panic</li>
<li>make(chan int, n) n 表示缓冲区大小，可以省略，默认为 0
<ul>
<li>而对于无缓冲 channel，接受和发送都要在不同携程之间，不让两个人互相阻塞</li>
<li>对于有缓冲区 channel，在缓冲区大小内，两个不会互相阻塞，可以在同一协程内</li>
<li>如果超过缓冲区大小，就会 panic，所以超过缓冲区大小的还是必须在其他的协程中处理</li>
</ul>
</li>
<li>缓冲区也有 len 和 cap 的概念</li>
<li>对于 rust，如果超出缓冲区大小 send 就会返回 Error</li>
</ul>
<pre><code class="language-go">func sendData(sendch chan&lt;- int) {
    sendch &lt;- 10
}

func main() {
    cha1 := make(chan int)
    go sendData(cha1)
    fmt.Println(&lt;-cha1)
}
</code></pre>
<h4 id="单向-channel"><a class="header" href="#单向-channel">单向 channel</a></h4>
<pre><code class="language-go">// 声明参数是一个只能发送的 ch
func sendData(sendch chan&lt;- int) {
    sendch &lt;- 10
}

func main() {
    // 声明一个只能发送的 channel，下面使用它去接受就会 panic
    // 如果声明为 chan int，下面的接受不会 panic，在 sendData 会被转换为只能发送的 channel，而 main 中的仍然是双向的
    sendch := make(chan&lt;- int)
    go sendData(sendch)
    fmt.Println(&lt;-sendch)
}
</code></pre>
<h4 id="关闭-channel"><a class="header" href="#关闭-channel">关闭 channel</a></h4>
<p>不能一直 send 或者一直 recv，处理完及时把一端 close 了</p>
<pre><code class="language-go">func producer(chnl chan int) {
    for i := 0; i &lt; 10; i++ {
        chnl &lt;- i
    }
    // 发送完成后，使用 send 函数显式关闭 channel
    close(chnl)
}

func main() {
    ch := make(chan int)
    go producer(ch)
    for {
        // 通过 ok 判断 channel 是否关闭
        v, ok := &lt;-ch
        if ok == false {
            break
        }
        fmt.Println(&quot;Received &quot;, v, ok)
    }
}
</code></pre>
<h4 id="waitgroup"><a class="header" href="#waitgroup">waitGroup</a></h4>
<p>等待一群协程结束</p>
<p>注意一定要使用指针</p>
<h4 id="工作池"><a class="header" href="#工作池">工作池</a></h4>
<pre><code class="language-go">// 模拟耗时的计算
func calculate(number int) int {
	time.Sleep(2 * time.Second)
	return number
}

// 生产者，分发工作
func produceJobs(jobs chan&lt;- Job, n int) {
	for i := 0; i &lt; n; i++ {
		// fmt.Printf(&quot;sending %d \n&quot;, i)
		jobs &lt;- Job{
			id:     i,
			number: i,
		}
	}
	close(jobs)
}

// 消费者，接受工作，干完活就通知以下管理员
func consumeFunc(jobs &lt;-chan Job, results chan&lt;- int, wg *sync.WaitGroup) {
	// 每个 worker 都在抢工作，真积极啊
	for job := range jobs {
		// fmt.Printf(&quot;id: %d\n&quot;, job.id)
		results &lt;- calculate(job.number)
	}
	wg.Done()
}

// 管理员，等待所有工人都通知他，每次被通知，计数器就减 1，当计数器为 0 是就不再阻塞
func consumeJobs(jobs &lt;-chan Job, results chan&lt;- int, worker_number int) {
	// 等待一批 goroutine 结束，类似于 join
	var wg sync.WaitGroup
	// 为每一个工作开启一个 goroutine
	for i := 0; i &lt; worker_number; i++ {
		wg.Add(1)
		go consumeFunc(jobs, results, &amp;wg)
	}
	wg.Wait() // 阻塞当前 goroutine 直到计数器归 0，所有 job 都应该做完了，result 应该也都发送出去了
	close(results)
}

type Job struct {
	id     int
	number int
}

func main() {
	startTime := time.Now()

	jobs := make(chan Job, 10)
	results := make(chan int, 10)

	// 发送 work, jobs send
	go produceJobs(jobs, 100)
	// jobs recv | results send
	go consumeJobs(jobs, results, 50)
	// results recv
	a := 0
	for res := range results {
		a += res
	}
	fmt.Print(&quot;res: &quot;, a)

	endTime := time.Now()
	diff := endTime.Sub(startTime)
	fmt.Println(&quot;total time taken &quot;, diff.Seconds(), &quot;seconds&quot;)

}
</code></pre>
<h4 id="select"><a class="header" href="#select">select</a></h4>
<p>用法挺普通</p>
<ul>
<li>channel 不限制 send/recv，只要是对 channel 的操作就行</li>
<li>如果有多个 channel 准备就绪，就随机选择一个执行</li>
<li>死锁与默认情况：如果 select 一直没有命中，就会触发死锁，导致 panic，空 select 一样也会导致 panic</li>
<li>可以准备一个 timeout chan，到时间就 send 作为超时信号</li>
</ul>
<pre><code class="language-go">func main() {
    ch := make(chan string)
    select {
    case &lt;-ch:
    default:
        fmt.Println(&quot;default case executed&quot;)
    }
}
</code></pre>
<h3 id="并发-1"><a class="header" href="#并发-1">并发</a></h3>
<p>goroutine 不能保证并发安全，下面是一些解决方法</p>
<ul>
<li>总体说来，当 Go 协程需要与其他协程通信时，可以使用 channel。而当只允许一个协程访问临界区时，可以使用 Mutex。</li>
<li>就我们上面解决的问题而言，我更倾向于使用 Mutex，因为该问题并不需要协程间的通信。所以 Mutex 是很自然的选择。</li>
</ul>
<h4 id="mutex"><a class="header" href="#mutex">mutex</a></h4>
<pre><code class="language-go">func aa(wg *sync.WaitGroup, m *sync.Mutex) {
	m.Lock()
	x += 1
	m.Unlock()
	wg.Done()
}

func main() {
    var wg sync.WaitGroup
    var m sync.Mutex
    for i := 0; i &lt; 1000; i++ {
        wg.Add(1)
        go aa(&amp;wg, &amp;m)
    }
    wg.Wait()
    fmt.Print(x)
}
</code></pre>
<h4 id="channel-1"><a class="header" href="#channel-1">channel</a></h4>
<p>使用缓冲为 1 的 channel 实现</p>
<pre><code class="language-go">func aa(wg *sync.WaitGroup, ch chan bool) {
	ch &lt;- true
	x += 1
	&lt;-ch
	wg.Done()
}

func main() {
	startTime := time.Now()
	var wg sync.WaitGroup
	var ch = make(chan bool, 1)
	for i := 0; i &lt; 1000; i++ {
		wg.Add(1)
		go aa(&amp;wg, ch)
	}
	wg.Wait()
	fmt.Print(x)
}
</code></pre>
<h3 id="defer"><a class="header" href="#defer">defer</a></h3>
<h4 id="实参求值"><a class="header" href="#实参求值">实参求值</a></h4>
<p>当执行 defer 语句的时候，就会对延迟函数的实参进行求值。</p>
<pre><code class="language-go">func printA(a int) {
    fmt.Println(&quot;value of a in deferred function&quot;, a)
}
func main() {
    a := 5
    defer printA(a)
    a = 10
}
// value of a in deferred function 5
</code></pre>
<h4 id="defer-栈"><a class="header" href="#defer-栈">defer 栈</a></h4>
<p>当一个函数内多次调用 defer 时，Go 会把 defer 调用放入到一个栈中，随后按照后进先出（Last In First Out, LIFO）的顺序执行。</p>
<p>下面的程序，使用 defer 栈，将一个字符串逆序打印。</p>
<pre><code class="language-go">func main() {
    name := &quot;Naveen&quot;
    for _, v := range []rune(name) {
        defer fmt.Printf(&quot;%c&quot;, v)
    }
}
// 倒叙输出：neevaN
</code></pre>
<h4 id="defer-在-return-后执行"><a class="header" href="#defer-在-return-后执行">defer 在 return 后执行</a></h4>
<pre><code class="language-go">import &quot;fmt&quot;

var name string = &quot;go&quot;

func myfunc() string {
    defer func() {
        name = &quot;python&quot;
    }()

    fmt.Printf(&quot;myfunc 函数里的 name：%s\n&quot;, name) // go
    return name
}

func main() {
    myname := myfunc()
    fmt.Printf(&quot;main 函数里的 name: %s\n&quot;, name) // python
    fmt.Println(&quot;main 函数里的 myname: &quot;, myname) // go
}
</code></pre>
<h4 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h4>
<pre><code class="language-go">func (r rect) area(wg *sync.WaitGroup) {
    // defer wg.Done() // 代替下面的 3 个 return 中的 wg.Done()
    if r.length &lt; 0 {
        fmt.Printf(&quot;rect %v's length should be greater than zero\n&quot;, r)
        wg.Done()
        return
    }
    if r.width &lt; 0 {
        fmt.Printf(&quot;rect %v's width should be greater than zero\n&quot;, r)
        wg.Done()
        return
    }
    area := r.length * r.width
    fmt.Printf(&quot;rect %v's area %d\n&quot;, r, area)
    wg.Done()
}
</code></pre>
<h3 id="错误处理-1"><a class="header" href="#错误处理-1">错误处理</a></h3>
<h4 id="错误接口"><a class="header" href="#错误接口">错误接口</a></h4>
<p>在标准库里的定义</p>
<pre><code class="language-go">type error interface {
    Error() string
}
</code></pre>
<p>open 函数的设计</p>
<pre><code class="language-go">type PathError struct {
    Op   string
    Path string
    Err  error
}

func (e *PathError) Error() string { return e.Op + &quot; &quot; + e.Path + &quot;: &quot; + e.Err.Error() }
</code></pre>
<h4 id="错误类型断言"><a class="header" href="#错误类型断言">错误类型断言</a></h4>
<p>通过类型断言拿到错误信息</p>
<pre><code class="language-go">func main() {
    f, err := os.Open(&quot;/test.txt&quot;)
    if err, ok := err.(*os.PathError); ok {
        fmt.Println(&quot;File at path&quot;, err.Path, &quot;failed to open&quot;)
        return
    }
    fmt.Println(f.Name(), &quot;opened successfully&quot;)
}
</code></pre>
<h4 id="子错误类型"><a class="header" href="#子错误类型">子错误类型</a></h4>
<pre><code class="language-go">type DNSError struct {
    ...
}

func (e *DNSError) Error() string {
    ...
}
func (e *DNSError) Timeout() bool {
    ...
}
func (e *DNSError) Temporary() bool {
    ...
}

func main() {
    addr, err := net.LookupHost(&quot;golangbot123.com&quot;)
    if err, ok := err.(*net.DNSError); ok {
        if err.Timeout() {
            fmt.Println(&quot;operation timed out&quot;)
        } else if err.Temporary() {
            fmt.Println(&quot;temporary error&quot;)
        } else {
            fmt.Println(&quot;generic error: &quot;, err)
        }
        return
    }
    fmt.Println(addr)
}
</code></pre>
<h4 id="panic-和-recover"><a class="header" href="#panic-和-recover">panic 和 recover</a></h4>
<p>下面使用 recover 去恢复 panic</p>
<ul>
<li>注意：Go 协程中调用 recover 才管用。recover 不能恢复一个不同协程的 panic。</li>
</ul>
<pre><code class="language-go">func recoverName() {
    if r := recover(); r!= nil {
        fmt.Println(&quot;recovered from &quot;, r)
    }
}

func fullName(firstName *string, lastName *string) {
    defer recoverName()
    if firstName == nil {
        panic(&quot;runtime error: first name cannot be nil&quot;)
    }
    if lastName == nil {
        panic(&quot;runtime error: last name cannot be nil&quot;)
    }
    fmt.Printf(&quot;%s %s\n&quot;, *firstName, *lastName)
    fmt.Println(&quot;returned normally from fullName&quot;)
}
</code></pre>
<h4 id="恢复后获得堆栈"><a class="header" href="#恢复后获得堆栈">恢复后获得堆栈</a></h4>
<pre><code class="language-go">import (
    &quot;runtime/debug&quot;
)

func r() {
    if r := recover(); r != nil {
        fmt.Println(&quot;Recovered&quot;, r)
        debug.PrintStack()
    }
}
</code></pre>
<h3 id="反射"><a class="header" href="#反射">反射</a></h3>
<p><strong>基础</strong></p>
<pre><code class="language-go">type order struct {
	ordId      int
	customerId int
}

func play(q interface{}) {
	t := reflect.TypeOf(q)
	k := t.Kind()

	v := reflect.ValueOf(q)
	fieldsNum := v.NumField()
	fmt.Println(&quot;Type: &quot;, t, &quot;Kind: &quot;, k)
	fmt.Println(&quot;Value: &quot;, v, &quot;FieldNum: &quot;, fieldsNum)
	for i := 0; i &lt; fieldsNum; i++ {
		fmt.Println(t.Field(i).Name, v.Field(i).Type(), v.Field(i))
	}
}

func createQuery(q interface{}) {
    // 拿到类型
    if reflect.TypeOf(q).Kind() != reflect.Struct {
		return
	}
    // 拿到类型名称
	t := reflect.TypeOf(q).Name()
	query := fmt.Sprintf(&quot;insert into %s values(&quot;, t)
    // 拿到值
	v := reflect.ValueOf(q)
    // 拿到字段数量
	for i := 0; i &lt; v.NumField(); i++ {
        // 拿到字段类型，字段名称，字段值
		switch v.Field(i).Kind() {
		case reflect.Int:
			if i == 0 {
				query = fmt.Sprintf(&quot;%s%d&quot;, query, v.Field(i).Int())
			} else {
				query = fmt.Sprintf(&quot;%s, %d&quot;, query, v.Field(i).Int())
			}
		case reflect.String:
			if i == 0 {
				query = fmt.Sprintf(&quot;%s\&quot;%s\&quot;&quot;, query, v.Field(i).String())
			} else {
				query = fmt.Sprintf(&quot;%s, \&quot;%s\&quot;&quot;, query, v.Field(i).String())
			}
		default:
			fmt.Println(&quot;unsupported field type&quot;)
			return
		}
	}
	query = fmt.Sprintf(&quot;%s)&quot;, query)
	fmt.Println(query)
	return
}

func main() {
	o := order{
		ordId:      456,
		customerId: 56,
	}
	play(o)
	println(&quot;----------------------------------------&quot;)
	createQuery(o)

	var a int = 1
	b := reflect.ValueOf(a).String()
	fmt.Println(reflect.TypeOf(b))
}
</code></pre>
<p><strong>修改类型</strong></p>
<pre><code class="language-go">func main() {
    var age interface{} = 25
    v := reflect.ValueOf(age)
    // 从反射对象到接口变量
    i := v.Interface().(int)
}
</code></pre>
<p><strong>可写性</strong></p>
<pre><code class="language-go">func main() {
    var name string = &quot;Go 编程时光&quot;
    v1 := reflect.ValueOf(&amp;name)
    fmt.Println(&quot;v1 可写性为：&quot;, v1.CanSet())

    v2 := v1.Elem()
    fmt.Println(&quot;v2 可写性为：&quot;, v2.CanSet())
}
</code></pre>
<h2 id="进阶"><a class="header" href="#进阶">进阶</a></h2>
<h3 id="变量-1"><a class="header" href="#变量-1">变量</a></h3>
<h4 id="make"><a class="header" href="#make">make</a></h4>
<p>make 函数创建 slice、map 或 chan 类型变量</p>
<p><strong>和 new 的区别</strong></p>
<ul>
<li>
<p>new：为所有的类型分配内存，并初始化为零值，返回指针。</p>
</li>
<li>
<p>make：只能为 slice，map，chan 分配内存，并初始化，返回的是类型 (指针)。因为这三个本身就是引用类型</p>
</li>
<li>
<p>slice、map 和 chan 是 Go 中的引用类型，它们的创建和初始化，一般使用 make。特别的，chan 只能用 make。slice 和 map
还可以简单的方式：</p>
</li>
</ul>
<pre><code class="language-go">slice := []int{0, 0}
m := map[string]int{}
</code></pre>
<h4 id="匿名变量"><a class="header" href="#匿名变量">匿名变量</a></h4>
<ul>
<li>不分配内存，不占用内存空间</li>
</ul>
<h4 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h4>
<p>浮点数转二进制时丢失了精度，计算完再转回十进制时和理论结果不同。</p>
<ul>
<li>f32: 1 8</li>
<li>f64: 1 11</li>
</ul>
<h4 id="作用域"><a class="header" href="#作用域">作用域</a></h4>
<p><strong>分类</strong></p>
<ul>
<li>内置作用域：不需要自己声明，所有的关键字和内置类型、函数都拥有全局作用域</li>
<li>包级作用域：必須函数外声明，在该包内的所有文件都可以访问</li>
<li>文件级作用域：不需要声明，导入即可。一个文件中通过 import 导入的包名，只在该文件内可用</li>
<li>局部作用域：在自己的语句块内声明，包括函数，for、if 等语句块，或自定义的 {} 语句块形成的作用域，只在自己的局部作用域内可用</li>
</ul>
<p><strong>作用规则</strong></p>
<ul>
<li>低层作用域，可以访问高层作用域</li>
<li>同一层级的作用域，是相互隔离的</li>
<li>低层作用域里声明的变量，会覆盖高层作用域里声明的变量</li>
</ul>
<p><strong>动态作用域</strong></p>
<p>下面的 bash 脚本中，func02 在 func01 内部可以访问到 value，但在 func01 外面不能，属于动态作用域</p>
<pre><code class="language-shell">#!/bin/bash
func01() {
    local value=1
    func02
}
func02() {
    echo &quot;func02 sees value as ${value}&quot;
}

# 执行函数
func01
func02
</code></pre>
<h3 id="协程池"><a class="header" href="#协程池">协程池</a></h3>
<pre><code class="language-go">type Pool struct {
	work chan func()   // 任务
	sem  chan struct{} // 使用缓冲区大小控制工人数量
}

func New(size int) *Pool {
	return &amp;Pool{
		work: make(chan func()),
		sem:  make(chan struct{}, size),
	}
}
func (p *Pool) worker(task func()) {
	defer func() { &lt;-p.sem }()
	for {
		task()
		task = &lt;-p.work
	}
}
func (p *Pool) NewTask(task func()) {
	// 第一次加新任务时，work 缓冲区大小为 0，发出去也没人接受，所以一定会走第二个
	// 相当于找到了第一个工人处理任务，worker 本身是个 for 循环，它处理完第一个任务后会继续接受新任务
	// 第二次加入时，就被第一个工人处理了，
	// 如果第三个加入，因为 sem 缓冲区大小的限制，不会继续产生新的 worker
	select {
	case p.work &lt;- task:
	case p.sem &lt;- struct{}{}:
		go p.worker(task)
	}
}
func main() {
	pool := New(2)
	for i := 0; i &lt; 5; i++ {
		pool.NewTask(func() {
			time.Sleep(1 * time.Second)
			fmt.Println(time.Now())
		})
	}
	time.Sleep(4 * time.Second)
}
</code></pre>
<h3 id="动态类型"><a class="header" href="#动态类型">动态类型</a></h3>
<p>接口分为两种<code>iface</code>和<code>eface</code></p>
<p>所有的变量都实现了空接口 (eface)</p>
<pre><code class="language-go">// 定义静态类型
i := (int)(25)
i = &quot;Go 编程时光&quot; // 会报错

// 定义动态类型
i := (interface{})(25)
var i interface{}
i = 18

i = &quot;Go 编程时光&quot; // 上面三种都行，不会报错
</code></pre>
<pre><code class="language-go">var reader io.Reader

tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}

reader = tty
</code></pre>
<p>第一行代码结束后，reader 的静态类型为<code>io.Reader</code>还没有动态类型
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203060928375.png" alt="" />
被赋值为 tty 后，reader 的动态类型变为<code>*os.File</code>
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203060936153.png" alt="" /></p>
<pre><code class="language-go">//不带函数的 interface
var empty interface{}

tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}

empty = tty
</code></pre>
<p>刚开始 empty 是 eface，<code>_type</code>为 nil
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203060938295.png" alt="" />
被赋值后，<code>_type</code>的<strong>静态类型</strong>为<code>*os.File</code>
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203060938635.png" alt="" /></p>
<h3 id="导入"><a class="header" href="#导入">导入</a></h3>
<p>导入方式：</p>
<ul>
<li>绝对导入：从 <code>$GOPATH/src</code> 或 <strong><code>$GOROOT</code></strong> 或者 <code>$GOPATH/pkg/mod</code> 目录下搜索包并导入</li>
<li>相对导入：从当前目录中搜索包并开始导入。就像下面这样</li>
</ul>
<p>注意：</p>
<ul>
<li>导入时，是按照目录导入。导入目录后，可以使用这个目录下的所有包。</li>
<li>只要不是<code>.</code>或<code>..</code>开头，全都是绝对路径</li>
</ul>
<h3 id="context"><a class="header" href="#context">context</a></h3>
<p>当一个 goutine 开启后，只能通过 channel 的通知实现管理，使用 context 更方便了</p>
<p>当你把 Context 传递给多个 goroutine 使用时，只要执行一次 cancel 操作，所有的 goroutine 就可以收到
取消的信号，Context 是线程安全的，可以放心地在多个 goroutine 中使用。</p>
<p>context 创建依赖于 4 个函数</p>
<ul>
<li>withCancel 最普通，只能使用 cancel 去结束</li>
<li>withDeadline 和 WithDeadline 会在超时后自动 cancel，传递的是绝对时间和相对时间</li>
<li>withValue 能够携带一些键值对 (键应该是可比的，值必须是线程安全的)</li>
</ul>
<pre><code class="language-go">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
func WithValue(parent Context, key, val interface{}) Context
</code></pre>
<pre><code class="language-go">func monitor(ctx context.Context, number int)  {
    for {
        select {
        case &lt;- ctx.Done():
            fmt.Printf(&quot;监控器%v，监控结束。\n&quot;, number)
            return
        default:
            fmt.Printf(&quot;监控器%v，正在监控中...\n&quot;, number)
            time.Sleep(2 * time.Second)
        }
    }
}

func main() {
    ctx01, cancel := context.WithCancel(context.Background())
    ctx02, cancel := context.WithDeadline(ctx01, time.Now().Add(1 * time.Second))

    defer cancel()

    for i :=1 ; i &lt;= 5; i++ {
        go monitor(ctx02, i)
    }

    time.Sleep(5  * time.Second)
    if ctx02.Err() != nil {
        fmt.Println(&quot;监控器取消的原因：&quot;, ctx02.Err())
    }

    fmt.Println(&quot;主程序退出！！&quot;)
}
</code></pre>
<h2 id="参考-1"><a class="header" href="#参考-1">参考</a></h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651439981&amp;idx=4&amp;sn=b1ad1fd6e9ddf4618b0db904b067f7f6&amp;scene=19#wechat_redirect">2020 重学 Go 系列：34. 图解静态类型与动态类型</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="协程与异步"><a class="header" href="#协程与异步">协程与异步</a></h1>
<h2 id="协程的-c-实现"><a class="header" href="#协程的-c-实现">协程的 C 实现</a></h2>
<p><a href="https://github.com/xiaobing94/coroutine">C 语言协程的简单实现</a></p>
<p>linux
下在头文件<code>ucontext.h</code>提供了<code>getcontext(),setcontext(),makecontext(),swapcontext()</code>四个函数和<code>mcontext_t 和 ucontext_t</code>结构体。</p>
<p>这 4 个函数能够实现保存，获取，设置，切换上下文，是协程实现的核心，也是 yield 的核心</p>
<p>结构体则保留了协程的 id，运行堆栈等信息</p>
<ul>
<li>
<p>不同协程保存在队列中，由一个调度器进行推进各个协程</p>
</li>
<li>
<p>调度器会依次执行每个协程，每当某一个协程进行了 yield 操作 (<code>swapcontext()</code>), 调度器就会切换到另一个协程的上下文，继续推进</p>
</li>
<li>
<p>当所有协程都执行完成，就结束</p>
</li>
</ul>
<p>下面的图片是阅读了上面代码后的整理
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203262211252.png" alt="" /></p>
<h2 id="reactor-机制"><a class="header" href="#reactor-机制">Reactor 机制</a></h2>
<h1 id="异步"><a class="header" href="#异步">异步</a></h1>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202205122110854.png" alt="" />
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202205122111319.png" alt="" />
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202205122112837.png" alt="" />
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202205122112604.png" alt="" />
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202205122112493.png" alt="" />
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202205122112531.png" alt="" /></p>
<h2 id="rust-异步原理"><a class="header" href="#rust-异步原理">Rust 异步原理</a></h2>
<h3 id="future-特征"><a class="header" href="#future-特征">Future 特征</a></h3>
<pre><code class="language-rs">trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context)
        -&gt; Poll&lt;Self::Output&gt;;
}

enum Poll&lt;T&gt; {
    Pending,
    Ready(T),
}
</code></pre>
<h3 id="编译异步代码时发生了什么"><a class="header" href="#编译异步代码时发生了什么">编译异步代码时发生了什么</a></h3>
<p>下面是一段异步代码，它向 server 异步请求了一段数据，接着把结果进行格式转换，最后将数据通过 stream 异步发送出去：</p>
<pre><code class="language-rs">async fn handle_request(
    server: &amp;RpcServer,
    mut stream: TcpStream,
    id: i32,
) -&gt; impl Future&lt;Output = ()&gt; {
    let row = get_row(&amp;server, id).await;

    let encoded = json::encode(&amp;row);

    stream.write_all(encoded.as_bytes()).await;
}
</code></pre>
<p>编译器会为为这个异步函数创建一个对象，能够表现当前异步操作的状态：</p>
<pre><code class="language-rs">struct RequestHandler {
    server: &amp;RpcServer,
    stream: TcpStream,
    id: i32,
}
</code></pre>
<p>接着需要为它实现 Future 特征</p>
<p>在 poll 方法内部就是一个状态机，每次调用 poll 就会尝试推进异步任务，并根据状态作出对应的活动</p>
<pre><code class="language-rs">impl Future for RequestHandler {
    type Output = ();
    fn poll(&amp;mut self, cx: &amp;mut Context) -&gt; Pool&lt;()&gt; {
        loop {
            match self.state {
                ...
            }
        }
    }
}
</code></pre>
<h3 id="状态机"><a class="header" href="#状态机">状态机</a></h3>
<p>现在我们要为它手动编写一个状态机</p>
<p>首先为了能够跟踪请求的状态，我们要为结构体添加一个 state 字段：</p>
<pre><code class="language-rs">struct RequestHandler {
    ...
    state: RHState
}
</code></pre>
<p>接着 match 状态，并执行对应的行为。</p>
<ul>
<li>第一个状态是 <code>Unpolled</code>，此时这个异步函数还没有被 poll 过，它要进行一些初始化操作</li>
<li>第二个状态是 <code>GettingRow</code>，我们等待从数据库获取数据</li>
<li>第三个状态是 <code>Writing</code>，等待写入 tcpstream</li>
<li>第四个状态是 <code>Ready</code>，完成并准备返回结果</li>
</ul>
<h4 id="unpolled"><a class="header" href="#unpolled">Unpolled</a></h4>
<p>我们首先调用 get_row 函数，因为它是异步的，所以并不会立即执行，而是返回一个 future 对象。</p>
<pre><code class="language-rs">match self.state {
    Unpolled =&gt; {
        self.row_fut = Some(get_row(&amp;self.server, self.id));
        self.state = GettingRow
    }
}
</code></pre>
<p>同时我们在结构体中添加一个字段保存这个 future</p>
<pre><code class="language-rs">struct RequestHandler {
    ...
    row_fut: Option&lt;RowGet&gt;,
}
</code></pre>
<h4 id="gettingrow"><a class="header" href="#gettingrow">GettingRow</a></h4>
<p>第二阶段我们就要开始尝试推进异步任务，如果任务完成的话就把需要的变量赋值到结构体，并初始化下一个 future 任务，推进状态。</p>
<pre><code class="language-rs">match self.state {
    ...
    GettingRow =&gt; {
        match self.row_fut.unwrap().poll(cx) {
            Poll::Pending =&gt; return Poll::Pending,
            Poll::Ready(row) =&gt; {
                self.row_fut = None;
                self.encoded = json::encode(row);
                self.write_fut = Some(self.stream.write_all(
                    self.encoded.as_bytes()));
                self.state = Writing;
            }
        }
    }
}
</code></pre>
<p>结构体需要添加 encoded 字段，和下一个 future 任务：</p>
<pre><code class="language-rs">struct RequestHandler {
    ...
    encoded: String,
    write_fut: Option&lt;WriteAll&gt;,
}
</code></pre>
<h4 id="writing"><a class="header" href="#writing">Writing</a></h4>
<p>第三阶段任务很简单，如果写入完成就推进状态：</p>
<pre><code class="language-rs">match self.state {
    ...
    Writing =&gt; {
        match self.row_fut.unwrap().poll(cx) {
            Poll::Pending =&gt; return Poll::Pending,
            Poll::Ready(_) =&gt; self.state = Ready,
        }
    }
}
</code></pre>
<h4 id="ready"><a class="header" href="#ready">Ready</a></h4>
<p>最后就返回异步函数真正的的运行结果</p>
<pre><code class="language-rs">match self.state {
    ...
    Ready =&gt; return Poll::Ready(())
}
</code></pre>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204110021532.png" alt="" /></p>
<h3 id="使用-enum-节省内存"><a class="header" href="#使用-enum-节省内存">使用 enum 节省内存</a></h3>
<p>使用 struct 保存异步任务时，我们不得不为所有变量和异步任务都提前分配好内存。</p>
<p>下图是这个结构体的内存布局
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204110022570.png" alt="" />
如果两个异步任务不会同时运行，那么这两个阶段的异步任务应该能够复用同一块内存，就像下图里那样：
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202204110025475.png" alt="" />
假设异步任务里面还嵌套着其他的异步任务，那么这个结构体就会变得更大，嵌套层级越深，内存占用就越大</p>
<h3 id="性能"><a class="header" href="#性能">性能</a></h3>
<h4 id="drop"><a class="header" href="#drop">drop</a></h4>
<pre><code class="language-rs">async fn do_stuff(context: Arc&lt;Context&gt;) {
    info!(&quot;running foo with context {}&quot;, context);
    foo().await;
} // &lt;- std::mem::drop(context);
</code></pre>
<p>对于上面的异步函数有一个小小的性能问题，每当一个变量超出作用域时，Rust 都会隐式的在函数末尾插入 drop，所以直到函数运行结束 context
变量才会被释放。但是我们在打完日志之后就不需要 context 了，没必要等到 foo 执行完在释放掉 context</p>
<p>其中一个解决方法时将 context 移动到函数的内部作用域：</p>
<pre><code class="language-rs">async fn do_stuff(context: Arc&lt;Context&gt;) {
    {
        let context = context;
        info!(&quot;running foo with context {}&quot;, context);
    } // &lt;- std::mem::drop(context);
    foo().await;
}
</code></pre>
<p>drop 会被移动到内部作用域的末尾，但是这样依然不完美。future 在被 poll 之前什么都不会做，函数开始的任何一行都不会执行，所以在没有 poll
时我们还是一只持有着 context 变量。</p>
<p>解决问题的最好办法实际上是脱糖：</p>
<pre><code class="language-rs">fn do_stuff(context: Arc&lt;Context&gt;) -&gt; impl Future&lt;Output = ()&gt; {
    info!(&quot;running foo with context {}&quot;, context);
    async {
        foo().await;
    }
}
</code></pre>
<p>这样 context 根本就不会被保存在我们的状态机里，我们也永远不会持有对 context 的引用</p>
<h4 id="大数据-1"><a class="header" href="#大数据-1">大数据</a></h4>
<p>另一个注意的点是，当你在 await 一个非常大的临时变量或者表达式</p>
<pre><code class="language-rs">struct Big([u8; 1024]);

impl Drop for Big { /* print &quot;GOODBYE&quot; */ }

async fn foo(x: usize) -&gt; usize { /* ... */ }

async fn bar() -&gt; usize {
    let result = foo(Big::new().0.len()).await;
    result
}
</code></pre>
<p>如果你尝试打印 bar 的大小：</p>
<pre><code class="language-rs">fn main() {
    dng!(std::mem::size_of_val(&amp;bar())); // 1024
}
</code></pre>
<p>结果会非常大，那是因为 Rust 会在状态机里插入 Big 的副本。原因是 只要你在语句中创建临时变量，都会在语句的最后调用该临时变量的 <code>drop</code>
函数。因此在 <code>.await</code> 运行后，<code>drop</code> 函数里的打印会执行。</p>
<p>异步函数里的临时变量都会存活到 <code>.await</code> 之后。</p>
<p>解决方法：让获取 len 和 调用 foo 方法之间插入一个分号</p>
<pre><code class="language-rs">async fn bar() -&gt; usize {
    let len = Big::new().0.len();
    let result = foo(len).await;
    result
}
</code></pre>
<p>当然，你也可以写成这样：</p>
<pre><code class="language-rs">async fn bar() -&gt; usize {
    let fut = foo(Big::new().0.len());
    let result = fut.await;
    result
}
</code></pre>
<p>因为我们不再需要在状态机中保存 Big 的副本，所以现在 bar 就小的多了：</p>
<pre><code class="language-rs">fn main() {
    dng!(std::mem::size_of_val(&amp;bar())); // 24
}
</code></pre>
<p>如果你没有为 Big 实现 Drop，编译器应该为此做出一些优化，不过这个现在不谈</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="magic-1"><a class="header" href="#magic-1">magic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="软件架构"><a class="header" href="#软件架构">软件架构</a></h1>
<h2 id="六边形架构-1"><a class="header" href="#六边形架构-1">六边形架构</a></h2>
<p>六边形架构，是一种软件设计模式。依照这种架构创建的程序，能够在没有 UI
或数据库的情况下正常工作。所以即使没有数据库你依然可以进行开发和运行自动化测试，而且无需其他用户参与。</p>
<h3 id="端口与适配器-2"><a class="header" href="#端口与适配器-2">端口与适配器</a></h3>
<p>六边形架构也叫做端口与适配器架构。</p>
<p><img src="https://alistair.cockburn.us/wp-content/uploads/2018/02/Hexagonal-architecture-complex-example.gif" alt="" /></p>
<p>什么是端口？</p>
<p>端口指的是六边形的边，属于应用程序的内部，是我们应用程序的入口和出口。它定义了一个接口，表示设备如何使用我们的用例。在 Rust 里就是由一个
Trait，以及一些 DTO 组成</p>
<p>什么是适配器？</p>
<p>适配器围绕着端口编写，能够将输入转化为符合端口的类型，并把输入转化为用用程序内部的方法调用。换句话说就是 <code>controller</code> 或者是命令行一条命令处理器。</p>
<p>当任何外部设备 (比如：WEB，APP，终端，测试...)
想要访问输入端口时，首先这个输入会被该设备对应的输入适配器，转化为符合要求的可用的方法调用，或者是消息，然后再传递给我们的应用程序。</p>
<p>当我们的应用程序需要向外发送数据时，首先它会把数据通过输出端口传递给输出适配器，然后再传递给输出对象 (比如：数据库，mock，API，邮件，消息队列...)</p>
<p>因此我们的应用程序外部是完全隔离的。</p>
<h3 id="应用程序核心-2"><a class="header" href="#应用程序核心-2">应用程序核心</a></h3>
<p>使用六边形架构之后，我们应用程序的核心部分通常被称作域，域中有三个核概念：</p>
<ul>
<li>实体 (Entities)：只是简单的定义了对象。</li>
<li>交互器 (Interactors)：实现复杂的业务逻辑，在本文里我们会将其称为用例 Usecase。</li>
<li>存储库 (Repositories)：只定义了操作实体的方法。</li>
</ul>
<h3 id="优点-2"><a class="header" href="#优点-2">优点</a></h3>
<p>在传统的分层架构中，只能从上往下调用。</p>
<p>而现在我们把接口保留在域中，域不再依赖外部的外部实现。保证了外部设备是可替换的。当业务逻辑需要用到数据存储时，直接调用抽象接口即可。</p>
<h3 id="参考-2"><a class="header" href="#参考-2">参考</a></h3>
<ul>
<li><a href="https://alexis-lozano.com/hexagonal-architecture-in-rust-1/">Hexagonal architecture in Rust</a></li>
</ul>
<h2 id="干净架构"><a class="header" href="#干净架构">干净架构</a></h2>
<p><em>The Clean Architecture</em></p>
<ul>
<li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Uncle Bob 原文</a>
文章不太长，</li>
<li>很好的翻译 + 总结</li>
</ul>
<h3 id="参考-3"><a class="header" href="#参考-3">参考</a></h3>
<p><a href="https://blog.jaggerwang.net/clean-architecture-in-practice/">干净架构最佳实践</a>
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202061150405.png" alt="" /></p>
<h3 id="分层架构"><a class="header" href="#分层架构">分层架构</a></h3>
<p>起始和上面的差不多，思路都一样，三层架构基本对应</p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202061222034.png" alt="" /></p>
<ul>
<li>User Interface 层：
系统对外暴露的接口层 (API) 层。主要功能是接收外部的调用，调用底层的服务，然后将底层服务返回的数据返回给调用者。这一层只包含对外的 DTO 对象的声明，接口声明，DTO 对象转换，日志打印等。不能包含因为逻辑。</li>
<li>Application 层：对应到系统用例层。它描述了整个系统的全部功能，它是对底层领域层对象的组织和编排，通过对领域层对象的编排，实现了用例。Application 层不实现业务逻辑，它只对底层的领域对象进行编排以实现用例。一般在这一层里使用仓储对数据进行读取和保存。事务处理一般也在这一层。这一层主要包括 Service，用来调用 Domain 层的对象完成一个业务。访问第三方的远程调用一般也是在这一层。</li>
<li>Domain 层：核心业务逻辑层。包含实体、值对象和领域服务等领域对象等。实现所有的业务逻辑。业务逻辑就是存在于问题域即业务领域中的实体、概念、规则和策略等，与具体的实现技术无关，主要包含：1）业务实体（领域对象）。2）业务规则：例如借记卡取款数额不得超过账户余额等等。3) 业务策略：
例如机票预订的超订策略等。4) 完整性约束：
例如账户的账号不得为空。5）业务流程：比如，”下单“是一个业务流程，它包括“用户登录 - 选择商品 - 结算 - 下订单 - 付款”这一系列的动作。
Infrastructure 层：负责所有的对外的交互。比如数据库访问层实现，RPC 接口，MQ 等。</li>
</ul>
<h3 id="目录结构"><a class="header" href="#目录结构">目录结构</a></h3>
<p>下面是一个实例目录 (较上面的结构有修改)</p>
<pre><code>.
├── adapter # 适配层
│   ├── api # API 交互接口，将用例适配为 Rest API                    # controller
│   ├── dao # 数据库访问，实现 usecase/port/dao 下的接口             # dao_impl
│   └── usecase # 第三方服务，实现 usecase/port/service 下的接口     # usecase_impl
│   ├── cli # 命令行交互接口，将用例适配为命令
│   ├── gui # 图形交互接口，将用例适配为图形界面操作
├── entity # 实体层
│   ├── ...
│   └── user # 用户实体                                           # model/do
└── usecase # 用例层
    ├── ...
    ├── UserUsecases.java # 用户模块相关用例                       # usecase | dao
    ├── exception # 用例层异常
    └── port # 用例层依赖的外部服务接口定义
</code></pre>
<p>或者抽出一个 domain 代替 entity 和 usecase</p>
<pre><code>.
├── api
│   ├── user # 包含 controller，实现了 dao 和 usecase
│   │   ├── usecase
│   │   ├── dao # 可替换，例如提供 mysql，postgra 等不同实现
│   │   └── handler
│   └── article
│
└── domain
    └── user # 包含了 model | usecase | dao
    └── article
</code></pre>
<h3 id="参考-4"><a class="header" href="#参考-4">参考</a></h3>
<ul>
<li><a href="https://blog.jaggerwang.net/clean-architecture-in-practice/">干净架构最佳实践</a></li>
<li><a href="https://github.com/bxcodec/go-clean-arch">go-clean-arch</a></li>
<li><a href="https://lailin.xyz/post/go-training-week4-project-layout.html">Go 工程化 (二) 项目目录结构</a></li>
<li><a href="https://go-kratos.dev/blog/go-project-layout/">Go 工程化 - Project Layout 最佳实践</a></li>
</ul>
<h2 id="关于-dodtobo-等对象的关系图解"><a class="header" href="#关于-dodtobo-等对象的关系图解">关于 DO，DTO，BO 等对象的关系图解</a></h2>
<h3 id="概念"><a class="header" href="#概念">概念</a></h3>
<p>POJO（Plain Ordinary Java Object）：在本规约中，POJO 专指只有 setter/getter/toString 的简单类，包括
DO/DTO/BO/VO 等。</p>
<blockquote>
<p>【参考】分层领域模型规约：—《阿里巴巴 Java 开发规约》</p>
</blockquote>
<ul>
<li>DO（Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li>
<li>DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</li>
<li>BO（Business Object）：业务对象。可以由 Service 层输出的封装业务逻辑的对象。</li>
<li>Query：数据查询对象，各层接收上层的查询请求。额外规定：【强制】超过 2 个参数的查询封装，禁止使用 Map 类来传输。</li>
<li>VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li>
</ul>
<h3 id="说人话就是"><a class="header" href="#说人话就是">说人话就是</a></h3>
<ul>
<li>
<p>DAO：封装对数据库的访问，常规的增删改查（CRUD 操作）都通过 DAO 来实现。</p>
</li>
<li>
<p>PO/DO: 跟数据库表是一一对应的，一个 PO/DO 数据是表的一条记录。PO / DO 只是数据的对象，不包含任何的操作。举个例子，学生表是
StudentDO，对学生表的增删改查等操作就是 StudentDAO。</p>
</li>
<li>
<p>DTO：</p>
<ul>
<li>在分布式系统中，系统之间可以通过 DTO
进行数据传输；https://www.google.com/search?q=&amp;oq=DDD+%E5%92%8C+%E5%B9%B2%E5%87%80%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB&amp;aqs=chrome..69i57.9554j0j1&amp;sourceid=chrome&amp;ie=UTF-8</li>
<li>DTO 也可以在应用内部，核心层和应用层之间传递数据，DTO 只是简单的数据传输，没有业务逻辑的处理；</li>
<li>有的场景，比如数据库表有 10 个字段，id(唯一 id)、version(版本号)，gmt_create(记录创建时间) 这些字段不需要对外提供，所以
DTO 可以只取有含义的业务字段，DO 是和数据库记录的一一映射，但是 DTO 只需要按照业务需要定义需要的字段。</li>
</ul>
</li>
<li>
<p>BO: 包含 PO/DO 和 DAO，有点类似于 domain(entity, usecase) 的概念，BO
主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象，还能够完成 DO - DTO 之间的转换</p>
</li>
<li>
<p>VO: 对应页面显示（web 页面/移动端 H5/Native 视图）的数据对象。举个例子，DTO 中时间 Date 格式，或者是
yyyyMMddHHmmss 的字符串，但是 VO 需要的是前端展示的格式，需要转成”yyyy 年 MM 月 dd 月&quot;；</p>
</li>
</ul>
<h3 id="图解"><a class="header" href="#图解">图解</a></h3>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202061126981.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="riscv"><a class="header" href="#riscv">riscv</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common"><a class="header" href="#common">common</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pgsql"><a class="header" href="#pgsql">PgSQL</a></h1>
<h2 id="-2"><a class="header" href="#-2"></a></h2>
<h2 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h2>
<h3 id="version"><a class="header" href="#version">version()</a></h3>
<pre><code class="language-sql">SELECT version();
</code></pre>
<h3 id="current_date"><a class="header" href="#current_date">current_date</a></h3>
<pre><code class="language-sql">SELECT CURRENT_DATE;
</code></pre>
<h3 id="crud"><a class="header" href="#crud">CRUD</a></h3>
<pre><code class="language-sql">SELECT 2 + 2;

DROP TABLE IF EXISTS weather;

DROP TABLE IF EXISTS cities;

-- internal commands, starts with '\'
-- create table
-- smallint, real, double precision, char(N), varchar(N), date, time, timestamp, and interval, as well as other types of general utility and a rich set of geometric types.
CREATE TABLE weather (
  city varchar(80),
  temp_lo int, -- low temperature
  temp_hi int, -- high temperature
  prcp real, -- precipitation
  date date
);

CREATE TABLE cities (
  name varchar(80),
  location point
);

INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');

INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');

INSERT INTO weather (city, temp_lo, temp_hi, prcp, date) VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');

INSERT INTO weather (date, city, temp_hi, temp_lo) VALUES ('1994-11-29', 'Hayward', 54, 37);

SELECT * FROM weather;

SELECT
  city,
  temp_lo,
  temp_hi,
  prcp,
  date
FROM
  weather;
</code></pre>
<h3 id="-3"><a class="header" href="#-3"><code>/</code></a></h3>
<pre><code class="language-sql">SELECT
  city,
  (temp_hi + temp_lo) / 2 AS temp_avg,
  date
FROM
  weather;

</code></pre>
<h3 id="-4"><a class="header" href="#-4"><code>&gt;</code></a></h3>
<pre><code class="language-sql">SELECT
  *
FROM
  weather
WHERE
  city = 'San Francisco'
  AND prcp &gt; 0.0;
</code></pre>
<h3 id="order-by"><a class="header" href="#order-by">ORDER BY</a></h3>
<pre><code class="language-sql">SELECT
  *
FROM
  weather
ORDER BY
  city;

SELECT
  *
FROM
  weather
ORDER BY
  city,
  temp_lo;
</code></pre>
<h3 id="distinct"><a class="header" href="#distinct">DISTINCT</a></h3>
<pre><code class="language-sql">SELECT DISTINCT
  city
FROM
  weather;

SELECT DISTINCT
  city
FROM
  weather
ORDER BY
  city;
</code></pre>
<h3 id="where"><a class="header" href="#where">WHERE</a></h3>
<pre><code class="language-sql">SELECT
  *
FROM
  weather,
  cities
WHERE
  city = name;
</code></pre>
<h3 id="join"><a class="header" href="#join">JOIN</a></h3>
<pre><code class="language-sql">SELECT
  *
FROM
  weather
  JOIN cities ON city = name;
</code></pre>
<pre><code class="language-sql">SELECT
  weather.city,
  weather.temp_lo,
  weather.temp_hi,
  weather.prcp,
  weather.date,
  cities.location
FROM
  weather
  JOIN cities ON weather.city = cities.name;
</code></pre>
<h3 id="join-on"><a class="header" href="#join-on">JOIN ON</a></h3>
<pre><code class="language-sql">SELECT
  *
FROM
  weather
  LEFT OUTER JOIN cities ON weather.city = cities.name;
</code></pre>
<pre><code class="language-sql">SELECT
  w1.city,
  w1.temp_lo AS low,
  w1.temp_hi AS high,
  w2.city,
  w2.temp_lo AS low,
  w2.temp_hi AS high
FROM
  weather w1
  JOIN weather w2 ON w1.temp_lo &lt; w2.temp_lo
    AND w1.temp_hi &gt; w2.temp_hi;
</code></pre>
<pre><code class="language-sql">SELECT
  *
FROM
  weather w
  JOIN cities c ON w.city = c.name;
</code></pre>
<h3 id="max"><a class="header" href="#max">MAX</a></h3>
<p>ERROR:</p>
<pre><code class="language-sql">SELECT city FROM weather WHERE temp_lo = max(temp_lo);     WRONG
</code></pre>
<pre><code class="language-sql">SELECT
  max(temp_lo)
FROM
  weather;
</code></pre>
<pre><code class="language-sql">SELECT
  city
FROM
  weather
WHERE
  temp_lo = (
    SELECT
      max(temp_lo)
    FROM
      weather);
</code></pre>
<pre><code class="language-sql">SELECT
  city,
  max(temp_lo),
  count(*) FILTER (WHERE temp_lo &lt; 30)
FROM
  weather
WHERE
  city LIKE 'S%' -- (1)
GROUP BY
  city
HAVING
  max(temp_lo) &lt; 40;
</code></pre>
<h3 id="update"><a class="header" href="#update">UPDATE</a></h3>
<pre><code class="language-sql">-- update
UPDATE
  weather
SET
  temp_hi = temp_hi - 2,
  temp_lo = temp_lo - 2
WHERE
  date &gt; '1994-11-28';
</code></pre>
<h3 id="delete"><a class="header" href="#delete">DELETE</a></h3>
<pre><code class="language-sql">DELETE FROM weather
WHERE city = 'Hayward';
</code></pre>
<h2 id="高级功能"><a class="header" href="#高级功能">高级功能</a></h2>
<h3 id="view"><a class="header" href="#view">VIEW</a></h3>
<p>大量使用视图是良好的 SQL 数据库设计的一个关键方面。视图允许将表的结构细节封装在一致的接口后面，这些细节可能会随着应用程序的发展而改变。</p>
<p>视图几乎可以用在任何可以使用真实表的地方。在其他视图上建立视图的情况并不少见。</p>
<pre><code class="language-sql">CREATE VIEW myview AS
SELECT
  name,
  temp_lo,
  temp_hi,
  prcp,
  date,
  location
FROM
  weather,
  cities
WHERE
  city = name;
</code></pre>
<pre><code class="language-sql">SELECT
  *
FROM
  myview;
</code></pre>
<h3 id="copy"><a class="header" href="#copy">COPY</a></h3>
<pre><code class="language-sql">COPY weather
FROM
  '/home/user/weather.txt';
</code></pre>
<h3 id="foreign-key"><a class="header" href="#foreign-key">FOREIGN KEY</a></h3>
<p>外键的行为可以根据你的应用进行细微的调整。</p>
<pre><code class="language-sql">CREATE TABLE cities (
        name     varchar(80) primary key,
        location point
);

CREATE TABLE weather (
        city      varchar(80) references cities(name),
        temp_lo   int,
        temp_hi   int,
        prcp      real,
        date      date
);
</code></pre>
<p>running</p>
<pre><code class="language-sql">INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');
</code></pre>
<p>should be</p>
<pre><code class="language-txt">ERROR:  insert or update on table &quot;weather&quot; violates foreign key constraint &quot;weather_city_fkey&quot;
DETAIL:  Key (city)=(Berkeley) is not present in table &quot;cities&quot;.

</code></pre>
<h3 id="transactions"><a class="header" href="#transactions">Transactions</a></h3>
<pre><code class="language-sql">BEGIN;
UPDATE accounts SET balance = balance - 100.00 WHERE name = 'Alice';
SAVEPOINT my_savepoint;
UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Bob';
-- oops ... forget that and use Wally's account
ROLLBACK TO my_savepoint;
UPDATE accounts SET balance = balance + 100.00 WHERE name = 'Wally';
COMMIT;
</code></pre>
<h3 id="window-functions"><a class="header" href="#window-functions">Window Functions</a></h3>
<h4 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h4>
<p>求所在部门的平均工资</p>
<pre><code class="language-sql">SELECT
  depname, empno, salary, avg(salary)
OVER (PARTITION BY depname)
FROM empsalary;
</code></pre>
<pre><code class="language-txt">  depname  | empno | salary |          avg
-----------+-------+--------+-----------------------
 develop   |    11 |   5200 | 5020.0000000000000000
 develop   |     7 |   4200 | 5020.0000000000000000
 develop   |     9 |   4500 | 5020.0000000000000000
 develop   |     8 |   6000 | 5020.0000000000000000
 develop   |    10 |   5200 | 5020.0000000000000000
 personnel |     5 |   3500 | 3700.0000000000000000
 personnel |     2 |   3900 | 3700.0000000000000000
 sales     |     3 |   4800 | 4866.6666666666666667
 sales     |     1 |   5000 | 4866.6666666666666667
 sales     |     4 |   4800 | 4866.6666666666666667
(10 rows)
</code></pre>
<p>每个部门的工资排名：</p>
<pre><code class="language-sql">SELECT depname, empno, salary,
       rank() OVER (PARTITION BY depname ORDER BY salary DESC)
FROM empsalary;
</code></pre>
<p>rank 函数为当前行的分区中每个不同的 ORDER BY 值产生一个数字等级，使用 ORDER BY 子句定义的顺序。rank 不需要明确的参数，因为其行为完全由 OVER 子句决定。</p>
<pre><code class="language-txt">  depname  | empno | salary | rank
-----------+-------+--------+------
 develop   |     8 |   6000 |    1
 develop   |    10 |   5200 |    2
 develop   |    11 |   5200 |    2
 develop   |     9 |   4500 |    4
 develop   |     7 |   4200 |    5
 personnel |     2 |   3900 |    1
 personnel |     5 |   3500 |    2
 sales     |     1 |   5000 |    1
 sales     |     4 |   4800 |    2
 sales     |     3 |   4800 |    2
(10 rows)
</code></pre>
<h4 id="order-by-1"><a class="header" href="#order-by-1">ORDER BY</a></h4>
<p>ORDER BY</p>
<pre><code class="language-sql">SELECT salary, sum(salary) OVER () FROM empsalary;
</code></pre>
<pre><code class="language-txt"> salary |  sum
--------+-------
   5200 | 47100
   5000 | 47100
   3500 | 47100
   4800 | 47100
   3900 | 47100
   4200 | 47100
   4500 | 47100
   4800 | 47100
   6000 | 47100
   5200 | 47100
(10 rows)
</code></pre>
<pre><code class="language-sql">SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;
</code></pre>
<pre><code class="language-txt"> salary |  sum
--------+-------
   3500 |  3500
   3900 |  7400
   4200 | 11600
   4500 | 16100
   4800 | 25700
   4800 | 25700
   5000 | 30700
   5200 | 41100
   5200 | 41100
   6000 | 47100
(10 rows)
</code></pre>
<h4 id="不能使用的情况"><a class="header" href="#不能使用的情况">不能使用的情况</a></h4>
<p>窗口函数只允许在查询的 SELECT 和 ORDER BY 子句中使用。其他地方例如 GROUP BY、HAVING 和 WHERE 子句中是禁止的。</p>
<p>这是因为它们在逻辑上是在这些子句的处理之后执行的。</p>
<p>另外，窗口函数在非窗口聚合函数之后执行。这意味着在一个窗口函数的参数中包含一个聚合函数的调用是有效的，但反之则无效。</p>
<p>如果需要在窗口计算执行后对行进行过滤或分组，你可以使用一个子选择。例如。</p>
<pre><code class="language-sql">SELECT depname, empno, salary, enroll_date
FROM
  (SELECT depname, empno, salary, enroll_date,
          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos
     FROM empsalary
  ) AS ss
WHERE pos &lt; 3;
</code></pre>
<h4 id="多个窗口函数"><a class="header" href="#多个窗口函数">多个窗口函数</a></h4>
<p>上述查询只显示内部查询中排名小于 3 的记录。</p>
<p>当一个查询涉及到多个窗口函数时，可以用一个单独的 OVER 子句来写出每一个窗口函数。</p>
<p>但是如果几个函数需要相同的窗口行为，这样做是重复和容易出错的。</p>
<p>相反，可以在 WINDOW 子句中命名每个窗口行为，然后在 OVER 中引用。比如说。</p>
<pre><code class="language-sql">SELECT sum(salary) OVER w, avg(salary) OVER w
  FROM empsalary
  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);
</code></pre>
<h3 id="inheritance-继承"><a class="header" href="#inheritance-继承">Inheritance 继承</a></h3>
<p>创建两个表。一张城市表和一张首都表。当然，首都也是城市，</p>
<p>我们希望在列出所有城市时，能以隐含的方式显示首都。下面是一些备选方案。</p>
<p>使用视图实现：</p>
<pre><code class="language-sql">CREATE TABLE capitals (
  name       text,
  population real,
  elevation  int,    -- (in ft)
  state      char(2)
);

CREATE TABLE non_capitals (
  name       text,
  population real,
  elevation  int     -- (in ft)
);

CREATE VIEW cities AS
  SELECT name, population, elevation FROM capitals
    UNION
  SELECT name, population, elevation FROM non_capitals;
</code></pre>
<p>使用继承实现：</p>
<p>在 PostgreSQL 中，一个表可以从零个或多个其他表继承。</p>
<pre><code class="language-sql">CREATE TABLE cities (
  name       text,
  population real,
  elevation  int     -- (in ft)
);

CREATE TABLE capitals (
  state      char(2) UNIQUE NOT NULL
) INHERITS (cities);
</code></pre>
<p>capitals 继承了城市的所有列（名称、人口和海拔）。capitals 表有一个额外的列，state。</p>
<blockquote>
<p>name 列的类型是 text，这是 PostgreSQL 的原生类型，用于可变长度的字符串。</p>
</blockquote>
<p>继承会自动从子表中查询</p>
<pre><code class="language-sql">SELECT name, elevation
  FROM cities
  WHERE elevation &gt; 500;
</code></pre>
<p>你可以使用 ONLY 避免自动查询</p>
<pre><code class="language-sql">SELECT name, elevation
    FROM ONLY cities
    WHERE elevation &gt; 500;
</code></pre>
<h2 id="sql-语言"><a class="header" href="#sql-语言">SQL 语言</a></h2>
<h3 id="常量"><a class="header" href="#常量">常量</a></h3>
<ul>
<li>字符串，用单引号</li>
</ul>
<p>两个仅由至少一个换行的空白处隔开的字符串常量被连接起来，并有效地处理，就像字符串被写成一个常量一样。比如说</p>
<pre><code class="language-sql">SELECT 'foo'
'bar';
</code></pre>
<p>和</p>
<pre><code class="language-sql">SELECT 'foobar';
</code></pre>
<p>相等</p>
<p>但是</p>
<pre><code class="language-sql">SELECT 'foo'      'bar';
</code></pre>
<p>是不合法的</p>
<p>g</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<h2 id="远程仓库"><a class="header" href="#远程仓库">远程仓库</a></h2>
<h3 id="本地创建远程仓库"><a class="header" href="#本地创建远程仓库">本地创建远程仓库</a></h3>
<p><a href="https://hub.github.com/">hub-git 命令行插件</a></p>
<pre><code>hub create
</code></pre>
<h3 id="添加远程仓库"><a class="header" href="#添加远程仓库">添加远程仓库</a></h3>
<pre><code>git remote add origin(远程仓库名，随意) git@github.com:trdthg/trdthg.github.io.git
</code></pre>
<h3 id="追踪远程分支"><a class="header" href="#追踪远程分支">追踪远程分支</a></h3>
<pre><code>本地分支名可省略，默认为当前分支
git branch -u origin/remote_branch_name  &lt;local_branch_name&gt;

创建分支时追踪
git checkout -b local_branch_name --track origin/remote_branch_name

-u 选项是--set-upstream-to 的简写
git branch --set-upstream-to=origin/remote_branch_name  local_branch_name
</code></pre>
<h2 id="分支"><a class="header" href="#分支">分支</a></h2>
<h3 id="删除远程分支"><a class="header" href="#删除远程分支">删除远程分支</a></h3>
<pre><code>git push origin --delete xxx
</code></pre>
<h3 id="删除本地分支"><a class="header" href="#删除本地分支">删除本地分支</a></h3>
<pre><code>git branch -d xxx
git branch -D xxx
</code></pre>
<h3 id="缓存当前修改"><a class="header" href="#缓存当前修改">缓存当前修改</a></h3>
<pre><code>git stash

git stash list

git stash pop
</code></pre>
<h2 id="仓库管理"><a class="header" href="#仓库管理">仓库管理</a></h2>
<h3 id="拆分仓库"><a class="header" href="#拆分仓库">拆分仓库</a></h3>
<ol>
<li>将 src/locale 目录拆分到一个新分支里</li>
</ol>
<pre><code>git subtree split -P src/locale -b my-locale
</code></pre>
<blockquote>
<p>必须从仓库根目录下执行</p>
</blockquote>
<ol start="2">
<li>从另一个仓库里拉取上面的分支</li>
</ol>
<pre><code>cd ..
mkdir repo
cd repo
git init

git pull ../dayjs my-locale
</code></pre>
<h2 id="打标签"><a class="header" href="#打标签">打标签</a></h2>
<h3 id="共享标签"><a class="header" href="#共享标签">共享标签</a></h3>
<p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。
这个过程就像共享远程分支一样——你可以运行 git push origin tagname。</p>
<pre><code>git push origin v1.5
</code></pre>
<p>如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<pre><code>git push origin --tags
</code></pre>
<h3 id="创建标签"><a class="header" href="#创建标签">创建标签</a></h3>
<p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<pre><code>附注标签
在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 tag 命令时指定 -a 选项
-m 选项指定了一条将会存储在标签中的信息。

git tag -a v1.4 -m &quot;my version 1.4&quot;

轻量标签
另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：

git tag v1.4-lw
</code></pre>
<h3 id="忘记打标签"><a class="header" href="#忘记打标签">忘记打标签？</a></h3>
<p>加上分支即可</p>
<pre><code>git tag -a v1.2 9fceb02
</code></pre>
<h3 id="删除标签"><a class="header" href="#删除标签">删除标签</a></h3>
<pre><code>git tag -d v1.4-lw
</code></pre>
<h2 id="git-hook"><a class="header" href="#git-hook">git hook</a></h2>
<p>git hook 的所有类型都在<code>.git/hooks</code>文件夹下</p>
<pre><code>applypatch-msg.sample      post-update.sample     pre-merge-commit.sample    pre-rebase.sample        update.sample
commit-msg.sample          pre-applypatch.sample  prepare-commit-msg.sample  pre-receive.sample
fsmonitor-watchman.sample  pre-commit.sample      pre-push.sample            push-to-checkout.sample
</code></pre>
<p>不过一般可以使用 <a href="https://github.com/typicode/husky">husky</a> 这个插件去具体使用</p>
<h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<p>npm install husky -D</p>
<h3 id="生成-husky-配置文件夹"><a class="header" href="#生成-husky-配置文件夹">生成 ./husky 配置文件夹</a></h3>
<pre><code>npm set-script prepare &quot;husky install&quot;
npm run prepare
</code></pre>
<h3 id="add-a-hook"><a class="header" href="#add-a-hook">Add a hook:</a></h3>
<p>下面可以直接把要执行的脚本写在 <code>./husky/pre-commit</code> 中</p>
<pre><code>npx husky add .husky/pre-commit &quot;npm test&quot;
git add .husky/pre-commit
</code></pre>
<h3 id="测试"><a class="header" href="#测试">测试：</a></h3>
<pre><code>git commit -m &quot;Keep calm and commi
</code></pre>
<h2 id="gitignore"><a class="header" href="#gitignore">.gitignore</a></h2>
<h3 id="基本规则"><a class="header" href="#基本规则">基本规则</a></h3>
<pre><code>.idea/          # 忽略仓库中所有.idea (目录)
/.idea/         # 忽略仓库中 (根) 目录下的.idea (目录)
/.settings      # 忽略仓库中 (根) 目录下的 .settings (文件或目录)
~'$'*.docx      # office 打开时生成的 (临时文件)

!etc/eclipse/.checkstyle    # (不忽略) .checkstyle 文件或目录
</code></pre>
<h3 id="glob-模式-正则"><a class="header" href="#glob-模式-正则">glob 模式 (正则)</a></h3>
<pre><code>doc/*.txt           # 忽略 doc 目录下一级的所有 (以 `.txt` 结尾) 的 (文件或目录)
doc/**/*.pdf        # 忽略 doc (目录下所有的) .pdf 文件或目录

debug?.log          # 忽略 debug?.log 文件或目录，其中 ? 为任意一个字符

debug[0-9].log      # 忽略 debug0.log、debug2.log 等，但不忽略 debuga.log 文件
debug[01].log       # 仅忽略 debug0.log、debug1.log
debug[!01].log      # 不忽略 debug0.log、debug1.log
</code></pre>
<h3 id="特性-1"><a class="header" href="#特性-1">特性</a></h3>
<ul>
<li>从上到下，后面覆盖前面的</li>
<li>以上规则仅适用于未被缓存或加入版本控制的文件 如果忽略失效，可以尝试
<pre><code>.gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore 是无效的。
那么解决方法就是先把本地缓存删除（改变成未 track 状态），然后再提交。

git rm -r --cached .

git add .
git commit -m 'update .gitignore'
</code></pre>
</li>
</ul>
<h2 id="其他-5"><a class="header" href="#其他-5">其他</a></h2>
<h3 id="pull"><a class="header" href="#pull">pull</a></h3>
<p><a href="https://www.runoob.com/git/git-pull.html">菜鸟</a> git pull 其实就是 git fetch 和 git
merge FETCH_HEAD 的简写。命令格式如下：</p>
<pre><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</code></pre>
<h3 id="amend"><a class="header" href="#amend">amend</a></h3>
<p>覆盖最近一次 commit 信息</p>
<pre><code>git commit --amend  -m &quot;:bug: Fix: xxx&quot; -s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-不常用命令"><a class="header" href="#linux-不常用命令">Linux 不常用命令</a></h1>
<ol>
<li><code>command &amp;</code> 让进程在后台运行，比如：<code>sleep 1000 &amp;</code></li>
<li>jobs 查看后台运行的进程</li>
<li>fg %n 让后台运行的进程 n 到前台来</li>
<li>bg %n 让进程 n 到后台去；</li>
</ol>
<h1 id="errno"><a class="header" href="#errno">errno</a></h1>
<p>当系统调用被信号阻断时会返回 EINTR，为了重新执行系统调用你可以使用 while 循环判断 errno 不等于 EINTR，或者是为信号指定 SA_RESTART，使系统调用可以自动重新运行，但是对某一些特定的系统调用没有影响</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h1>
<h2 id="二叉搜索树"><a class="header" href="#二叉搜索树">二叉搜索树</a></h2>
<h3 id="初始化-1"><a class="header" href="#初始化-1">初始化</a></h3>
<pre><code class="language-cpp">typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
} Node;

typedef struct Tree {
    int init;
    int length;
    Node* root;
} Tree;

Node* initNode() {
    Node* p = (Node*)malloc(sizeof(Node));
    p -&gt; left = NULL;
    p -&gt; right = NULL;
    p -&gt; data = 0;
    return p;
}

Tree* initTree() {
    Tree* p = (Tree*)malloc(sizeof(Tree));
    p-&gt;root = initNode();
    p-&gt;init = 0;
    return p;
}
</code></pre>
<h3 id="遍历"><a class="header" href="#遍历">遍历</a></h3>
<pre><code class="language-cpp">void preorderTraversal(Node* node) {
    if (node != NULL) {
        printf(&quot;%d &quot;, node-&gt;data);
        preorderTraversal(node-&gt;left);
        preorderTraversal(node-&gt;right);
    }
}

void inorderTraversal(Node* node) {
    if (node != NULL) {
        inorderTraversal(node-&gt;left);
        printf(&quot;%d &quot;, node-&gt;data);
        inorderTraversal(node-&gt;right);
    }
}

void postorderTraversal(Node* node) {
    if (node != NULL) {
        postorderTraversal(node-&gt;left);
        postorderTraversal(node-&gt;right);
        printf(&quot;%d &quot;, node-&gt;data);
    }
}

void levalorderTraversal(Tree* tree) {
    printf(&quot;%d\n&quot;, tree-&gt;length);
    int arr[100];
    int i=0, j=0; // i 记录已经加入的元素数，j 记录最后输出的节点
    int size = 1; // 记录实际元素个数
    Node* nodes[100] = {NULL};
    Node* node = tree-&gt;root;
    nodes[0] = node;
    while (size &gt; 0) {
        printf(&quot;%d &quot;, nodes[j]-&gt;data);
        printf(&quot;%d  &quot;, node-&gt;data);
        j += 1;
        size -= 1;
        if (node-&gt;left != NULL)  {
            i += 1;
            nodes[i] = node-&gt;left;
            size += 1;
        }
        if (node-&gt;right != NULL) {
            i += 1;
            nodes[i] = node-&gt;right;
            size += 1;
        }
        node = nodes[j];
    }
}
</code></pre>
<h3 id="crud-1"><a class="header" href="#crud-1">CRUD</a></h3>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;


Node* add(Tree* tree, int data) {
    Node* current = tree-&gt;root;
    Node* parent;
    tree-&gt;length += 1;
    if (tree-&gt;init == 0) {
        tree-&gt;init = 1;
        tree-&gt;root-&gt;data = data;
    } else {
        Node* node = initNode();
        node-&gt;data = data;
        while (1) {
            parent = current;
            if (data &lt;= current-&gt;data) {
                current = current-&gt;left;
                if (current == NULL) {
                    parent-&gt;left = node;
                    break;
                }
            } else {
                current = current-&gt;right;
                if (current == NULL) {
                    parent-&gt;right = node;
                    break;
                }
            }
        }
    }
    return 0;
}


Node* findMax(Node* node) {
    if (node-&gt;right != NULL) {
        findMax(node-&gt;right);
    } else {
        return node;
    }
}


Node* findMin(Node* node) {
    if (node-&gt;left != NULL) {
        findMax(node-&gt;left);
    } else {
        return node;
    }
}

int find(Node* node, int data) {
    if (node != NULL) {
        if (node-&gt;data == data) return node-&gt;data;
        else if (data &lt; node-&gt;data) find(node-&gt;left, data);
        else find(node-&gt;right, data);
    } else {
        return -1;
    }
}

int delete(Node* root, Node* node, int data) {
    Node* parent = node;
    // if (node == root &amp;&amp; data == root-&gt;data) {
    //     return 0;
    // }
    if (node != NULL &amp;&amp; node != root) {
        if (data &lt; node-&gt;data) {
            node = node-&gt;left;
        } else {
            node = node-&gt;right;
        }
    }
    if (data == node-&gt;data) {
        if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) {
            if (data &lt;= parent-&gt;data) parent-&gt;left = NULL; else parent-&gt;right = NULL;
        } else if (node-&gt;left == NULL) {
            if (data &gt; parent-&gt;data) parent-&gt;right = node-&gt;right; else parent-&gt;left = node-&gt;right;
        } else if (node-&gt;right == NULL) {
            if (data &lt; parent-&gt;data) parent-&gt;left = node-&gt;left; else parent-&gt;right = node-&gt;left;
        } else {
            Node* innerparent = node;
            Node* innernode = node-&gt;right;
            while (innernode-&gt;left != NULL) {
                innerparent = innernode;
                innernode = node-&gt;left;
            }
            node-&gt;data = innernode-&gt;data;
            if (innerparent == node) {
                node-&gt;right = innernode-&gt;right;
            } else {
                innerparent-&gt;left = NULL;
            }
        }
        return 1;
    } else if (data &lt; node-&gt;data) {
        delete(root, node, data);
    } else {
        delete(root, node, data);
    }
}
</code></pre>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<pre><code class="language-cpp">int main(void) {
    Tree* tree = initTree();
    add(tree, 8);
    add(tree, 10);
    add(tree, 5);
    add(tree, 42);
    add(tree, 6);
    add(tree, 3);
    add(tree, 2);
    add(tree, 4);
    add(tree, 7);
    preorderTraversal(tree-&gt;root);
    printf(&quot;\n&quot;);
    inorderTraversal(tree-&gt;root);
    printf(&quot;\n&quot;);
    postorderTraversal(tree-&gt;root);
    printf(&quot;\n&quot;);
    levalorderTraversal(tree);
    printf(&quot;\n&quot;);
    printf(&quot;max: %d min: %d\n&quot;, findMax(tree-&gt;root)-&gt;data, findMin(tree-&gt;root)-&gt;data);
    printf(&quot;find 3: %d \n&quot;, find(tree-&gt;root, 3));
    printf(&quot;delete: %d \n&quot;, delete(tree-&gt;root, tree-&gt;root, 8));
    preorderTraversal(tree-&gt;root);
    return 0;
}
</code></pre>
<h2 id="avl-树-自平衡二叉搜索树"><a class="header" href="#avl-树-自平衡二叉搜索树">AVL 树 (自平衡二叉搜索树)</a></h2>
<h3 id="初始化-2"><a class="header" href="#初始化-2">初始化</a></h3>
<p>同二叉搜索树，只是多了一个 height 属性</p>
<pre><code class="language-cpp">Node* initNode() {
    Node* p = (Node*)malloc(sizeof(Node));
    p-&gt;left = NULL;
    p-&gt;right = NULL;
    p-&gt;value = 0;
    p-&gt;height = 1;
    return p;
}
Tree* initTree() {
    Tree* p = (Tree*)malloc(sizeof(Tree));
    p-&gt;root = initNode();
    p-&gt;init = 0;
    p-&gt;length = 0;
    return p;
}
Node* addCheck(Tree* tree, int value) {
    if (tree-&gt;init == 0) {
        tree-&gt;init = 1;
        tree-&gt;root-&gt;value = value;
        return tree-&gt;root;
    } else {
        return add(tree-&gt;root, value);
    }
}
void removeChect(Tree* tree, int value) {
    if (tree-&gt;init == 0) {
    } else {
        removeNode(tree-&gt;root, value);
    }
}
</code></pre>
<h3 id="旋转"><a class="header" href="#旋转">旋转</a></h3>
<ol>
<li>右旋</li>
</ol>
<pre><code class="language-cpp">Node* RightRotation(Node* node) {
    Node* res = node-&gt;left;
    node-&gt;left = node-&gt;left-&gt;right;
    res-&gt;right = node;
    node-&gt;height = getHeight(node);
    res-&gt;height = getHeight(res);
    return res;
}
</code></pre>
<ol start="2">
<li>左旋</li>
</ol>
<pre><code class="language-cpp">Node* LeftRotation(Node* node) {
    Node* res = node-&gt;right;
    node-&gt;right = node-&gt;right-&gt;left;
    res-&gt;left = node;
    node-&gt;height = getHeight(node);
    // res-&gt;height = getHeight(res);
    return res;
}
</code></pre>
<p>::: warning 注意 先旋的节点是 node 的子节点，不是 node 本身 ::: 3. 先左后右</p>
<pre><code class="language-cpp">Node* LeftRightRotation(Node* node) {
    node-&gt;left = LeftRotation(node-&gt;left);
    return RightRotation(node);
}
</code></pre>
<ol start="4">
<li>先右后左</li>
</ol>
<pre><code class="language-cpp">Node* RightLeftRotation(Node* node) {
    node-&gt;right = RightRotation(node-&gt;right);
    return LeftRotation(node);
}
</code></pre>
<h3 id="add"><a class="header" href="#add">add</a></h3>
<p><strong>注意事项</strong></p>
<ol>
<li>相对于普通的二叉搜索树，AVL 树要记录并更新 height，必须用递归才能在添加节点后重回老路，更新走过的的节点</li>
<li>在判断是否平衡时需要确保 height 及时被更新</li>
<li>判断旋转方式的条件</li>
</ol>
<pre><code class="language-cpp">Node* add(Node* node, int value) {
    if (node == NULL) {
        Node* newNode = initNode();
        newNode-&gt;value = value;
        return newNode;
    } else if (value &lt; node-&gt;value) {
        node-&gt;left = add(node-&gt;left, value);
        node-&gt;height = getHeight(node);
        if (getBalanceFactor(node) == 2) {
            if (value &lt; node-&gt;left-&gt;value) {
                node = RightRotation(node);
            } else {
                node = LeftRightRotation(node);
            }
        }
    } else {
        node-&gt;right  = add(node-&gt;right, value);
        node-&gt;height = getHeight(node);
        if (getBalanceFactor(node) == -2) {
            if (value &lt; node-&gt;right-&gt;value) {
                node = LeftRotation(node);
            } else {
                node = RightLeftRotation(node);
            }
        }
    }
    node-&gt;height = getHeight(node);
    return node;
}
</code></pre>
<h3 id="remove-1"><a class="header" href="#remove-1">remove</a></h3>
<p><strong>注意事项</strong> 4. 注意旋转条件</p>
<pre><code class="language-cpp">Node* removeNode(Node* node, int value) {
    if (node == NULL) {
        return NULL;
    }
    if (value == node-&gt;value) {
        if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL) {
            return NULL;
        } else if (node-&gt;right == NULL) {
            return node-&gt;left;
        } else if (node-&gt;left == NULL) {
            return node-&gt;right;
        } else {
            Node* newNode = reHeightRight(node-&gt;right);
            node-&gt;value = newNode-&gt;value;
            node-&gt;right = newNode-&gt;right;
        }
    } else if (value &lt; node-&gt;value) {
        node-&gt;left = removeNode(node-&gt;left, value);
        node-&gt;height = getHeight(node);
        if (getBalanceFactor(node) == -2) {
            if (getHeight(node-&gt;left) &gt; 0) {
                node = RightRotation(node);
            } else {
                node = RightLeftRotation(node);
            }
        }
    } else {
        node-&gt;right = removeNode(node-&gt;right, value);
        node-&gt;height = getHeight(node);
        if (getBalanceFactor(node) == 2) {
            if (getHeight(node-&gt;left) &gt; 0) {
                node = LeftRightRotation(node);
            } else {
                node = LeftRotation(node);
            }
        }
    }
    node-&gt;height = getHeight(node);
}
</code></pre>
<h3 id="工具方法"><a class="header" href="#工具方法">工具方法</a></h3>
<ol>
<li>getHeight</li>
</ol>
<pre><code class="language-cpp">int getHeight(Node* node) {
    if (node == NULL) {
        return 0;
    }
    int hl, hr;
    if (node-&gt;left == NULL) {
        hl = 0;
    } else {
        hl = node-&gt;left-&gt;height;
    }
    if (node-&gt;right == NULL) {
        hr = 0;
    } else {
        hr = node-&gt;right-&gt;height;
    }
    return 1 + max(hl, hr);
}
</code></pre>
<ol start="2">
<li>reHeight 配合 remove 使用，保证当有两个子节点的 node 被 remove 后，node.right 的 min 被删除后，
node.right 的 height 被更新</li>
</ol>
<pre><code class="language-cpp">Node* reHeightRight(Node* node) {
    Node* parent = node;
    if (node-&gt;left != NULL) {
        node = node-&gt;left;
        Node* newNode = reHeightRight(node);
        node-&gt;height = getHeight(node);
        return newNode;
    } else {
        return node;
    }
}
</code></pre>
<ol start="3">
<li>getBalanceFactor 获取平衡因子</li>
</ol>
<pre><code class="language-cpp">int getBalanceFactor(Node* node) {
    // 获取平衡因子 (左子树 - 右子树，注意保留负号)
    if (node == NULL) {
        return 0;
    }
    int a = getHeight(node-&gt;left) - getHeight(node-&gt;right);
    return a;
}
</code></pre>
<h3 id="已知问题"><a class="header" href="#已知问题">已知问题</a></h3>
<ol>
<li>旋转条件有待确认</li>
<li>当根节点被旋转时，tree.root 无法及时更新 已解决：remove 方法多传一个 Tree* tree，判断 node==tree-&gt;root,
如果是，则 tree-&gt;root = temp</li>
</ol>
<pre><code class="language-cpp">if (getBalanceFactor(node) == 2) {
    Node* temp = NULL;
    if (getHeight(node-&gt;left) &gt; 0) {
        temp = LeftRightRotation(node);
    } else {
        temp = LeftRotation(node);
    }
    if (node == tree-&gt;root) {
        tree-&gt;root = temp;
    } else {
        node = temp;
    }
}
</code></pre>
<h2 id="红黑树"><a class="header" href="#红黑树">红黑树</a></h2>
<p>::: tip 建议 不建议用递归，建议用 while 循环实现，不是顺序回退，而是跳连的 :::
<img src="https://rbtree.phpisfuture.com/" alt="红黑树在线演示" /></p>
<h3 id="第二版"><a class="header" href="#第二版">第二版</a></h3>
<h3 id="初始化-3"><a class="header" href="#初始化-3">初始化</a></h3>
<pre><code class="language-cpp">typedef struct Node {
    int key;
    int value;
    int color; // 红为 1，黑为 0
    struct Node* parent;
    struct Node* left;
    struct Node* right;
} Node;

typedef struct Tree {
    int init;
    Node* root;
} Tree;

void preorderTraversal(Node* node) {
    if (node != NULL) {
        printf(&quot;%d %s &quot;, node-&gt;value, node-&gt;color ? &quot;r&quot; : &quot;b&quot;);
        preorderTraversal(node-&gt;left);
        preorderTraversal(node-&gt;right);
    }
}

Node* initNode() {
    Node* p = (Node*)malloc(sizeof(Node));
    p-&gt;key = 0;
    p-&gt;value = 0;
    p-&gt;color = red;
    p-&gt;parent = NULL;
    p-&gt;left = NULL;
    p-&gt;right = NULL;
    return p;
}

Tree* initTree() {
    Tree* p = (Tree*)malloc(sizeof(Tree));
    p-&gt;root = initNode();
    p-&gt;init = 0;
    return p;
}
</code></pre>
<h3 id="旋转-1"><a class="header" href="#旋转-1">旋转</a></h3>
<p>::: tip 注意 左/右旋与变色是分开的，这里只有旋转，变色需要在调用前实现 左右/右左旋的第一次不需要变色，第二次旋转前的变色已经嵌入两次旋转之间
:::</p>
<ol>
<li>右旋</li>
</ol>
<pre><code class="language-cpp">Node* RightRotation(Node* node, Tree* tree) {
    Node* res = node-&gt;left;
    node-&gt;left = res-&gt;right;
    if (res-&gt;right != NULL)
        res-&gt;right-&gt;parent = node;
    res-&gt;right = node;
    res-&gt;parent = node-&gt;parent;
    if (node-&gt;parent == NULL) {
        tree-&gt;root = res;
    } else {
        if (node-&gt;parent-&gt;left == node)
            node-&gt;parent-&gt;left = res;
        else
            node-&gt;parent-&gt;right = res;
    }
    node-&gt;parent = res;
    // if (node == tree-&gt;root) {
    //     tree-&gt;root = res;
    // }
    return res;
}
</code></pre>
<ol start="2">
<li>左旋</li>
</ol>
<pre><code class="language-cpp">Node* LeftRotation(Node* node, Tree* tree) {
    Node* res = node-&gt;right;
    node-&gt;right = res-&gt;left;
    if (res-&gt;left != NULL)
        res-&gt;left-&gt;parent = node;
    res-&gt;left = node;
    res-&gt;parent = node-&gt;parent;
    if (node-&gt;parent == NULL) {
        tree-&gt;root = res;
    } else {
        if (node-&gt;parent-&gt;left == node)
            node-&gt;parent-&gt;left = res;
        else
            node-&gt;parent-&gt;right = res;
    }
    node-&gt;parent = res;
    // if (node == tree-&gt;root) {
    //     tree-&gt;root = res;
    // }
    return res;
}
</code></pre>
<ol start="3">
<li>左右旋</li>
</ol>
<pre><code class="language-cpp">Node* LeftRightRotation(Node* node, Tree* tree) {
    node-&gt;left = LeftRotation(node-&gt;left, tree);
    node-&gt;color = red;
    node-&gt;left-&gt;color = black;
    RightRotation(node, tree);
}
</code></pre>
<ol start="4">
<li>右左旋</li>
</ol>
<pre><code class="language-cpp">Node* RightLeftRotation(Node* node, Tree* tree) {
    node-&gt;right = RightRotation(node-&gt;right, tree);
    node-&gt;color = red;
    node-&gt;right-&gt;color = black;
    LeftRotation(node, tree);
}
</code></pre>
<h3 id="add-1"><a class="header" href="#add-1">add</a></h3>
<p>这里只需要找到正确的位置插入即可，fixUp() 传入的是新插入的 node</p>
<pre><code class="language-cpp">Node* put(Node* node, int key, int value) {
    Node* parent = NULL;
    Node* newNode = initNode();
    newNode-&gt;key = key; newNode-&gt;value = value;
    // 1.添加新节点
    while (node != NULL) {
        parent = node;
        if (value &lt; node-&gt;value) {
            node = node-&gt;left;
            if (node == NULL) {
                parent-&gt;left = newNode;
                newNode-&gt;parent = parent;
                break;
            }
        }
        else {
            node = node-&gt;right;
            if (node == NULL) {
                parent-&gt;right = newNode;
                newNode-&gt;parent = parent;
                break;
            }
        }
    }
    return newNode;
}

void putCheck(Tree* tree, int key, int value) {
    if (tree-&gt;init == 0) {
        tree-&gt;root-&gt;key = key;
        tree-&gt;root-&gt;value = value;
        tree-&gt;init = 1;
        tree-&gt;root-&gt;color = 0;
    } else {
        fixUp(put(tree-&gt;root, key, value), tree);
        tree-&gt;root-&gt;color = black;
    }
}
</code></pre>
<h4 id="remove-2"><a class="header" href="#remove-2">remove</a></h4>
<p>删除较为复杂，这里先把代码一节两半，以下为文字叙述：</p>
<ol>
<li>while 循环目的是找到要删除的点</li>
</ol>
<h4 id="第一部分若有两个子节点"><a class="header" href="#第一部分若有两个子节点">第一部分，若有两个子节点</a></h4>
<ol>
<li>把点进行对接，一共可以拆分为 4 块</li>
<li>若被删除的点是黑色则进 fixUp(), 传入的是被删去节点的右子树的最小节点右节点</li>
</ol>
<pre><code class="language-cpp">Node* removes(Node* node, int key, int value, Tree* tree) {
    Node* parent = NULL;  // 这个 parent 是指 replace 的 parent
    Node* child = NULL;
    Node* replace = NULL;
    int color;
    while (node != NULL) {
        // 找到了那个点
        if (node-&gt;value == value) {
            // 两个子节点都不为空
            /*
            *共有四次对接过程
            * 1. replace(移动后) 和 replace.father
            * 2. replace(移动前).right 和 replace.father
            * 3. replace(移动后) 和 node.right
            * 4. replace(移动前) 和 node.left
            */
            if (node-&gt;left != NULL &amp;&amp; node-&gt;right != NULL) {
                replace = node-&gt;right;
                while (replace-&gt;left != NULL) {
                    replace = replace-&gt;left;
                }
                // 1.1
                if (node-&gt;parent != NULL) {
                    if (node-&gt;parent-&gt;left == node) {
                        node-&gt;parent-&gt;left = replace;
                    } else {
                        node-&gt;parent-&gt;right = replace;
                    }
                } else {
                    tree-&gt;root = replace;
                }
                child = replace-&gt;right;
                parent = replace-&gt;parent;
                color = replace-&gt;color;
                // 2.
                if (parent == node) {
                    parent = replace;
                } else {
                    // 被替换的节点的兄弟节点要被接到 replace.parent 上
                    if (child != NULL) {child-&gt;parent = parent;}
                    parent-&gt;left = child;
                    // 3.
                    replace-&gt;right = node-&gt;right;
                    node-&gt;right-&gt;parent = replace;
                }
                // 1.2
                replace-&gt;parent = node-&gt;parent;
                replace-&gt;color = node-&gt;color;
                // 4.
                replace-&gt;left = node-&gt;left;
                node-&gt;left-&gt;parent = replace;

                if (color == black) {
                    if (child != NULL) {
                        fixUp(child, tree);
                    } else {
                        fixUp(parent, tree);
                    }
                }
                node = NULL;
                return NULL;
            }
</code></pre>
<h4 id="第二部分若最多有一个子节点"><a class="header" href="#第二部分若最多有一个子节点">第二部分，若最多有一个子节点</a></h4>
<pre><code class="language-cpp">            // 获取 node 的子节点
            if (node-&gt;left != NULL) {
                child = node-&gt;left;
            } else {
                child = node-&gt;right;
            }
            if (child != NULL) {
                child-&gt;parent = node-&gt;parent;
            }
            parent = node-&gt;parent;
            color = node-&gt;color;
            // node.子节点要被接到 node.parent 上
            if (parent != NULL) {
                if (parent-&gt;left == node) {
                    parent-&gt;left = child;
                } else {
                    parent-&gt;right = child;
                }
            } else {
                // 特殊处理若去掉的节点是根节点
                tree-&gt;root = child;
            }
            // 若果删去的点是黑色的，需要修复
            node = NULL;
            if (child != NULL) {
                fixUp(child, tree);
            } else {
                fixUp(parent, tree);
            }
            return NULL;
        }
        // 继续找到要去除的点
        if (value &lt; node-&gt;value) {
            node = node-&gt;left;
        } else {
            node = node-&gt;right;
        }
    }
    return NULL;
}
</code></pre>
<h3 id="fixup"><a class="header" href="#fixup">fixUp</a></h3>
<p>这里是核心：注意回退的跳跃性</p>
<ol>
<li>若只是变色，则 node = grandparent</li>
<li>若只是左旋或右旋，则 node = parent</li>
<li>若是左右旋或右左旋，则 node = grandparent</li>
</ol>
<pre><code class="language-cpp">Node* fixUp(Node* node, Tree* tree) {
    Node* parent;
    Node* grandparent;
    Node* uncle;
    while (node-&gt;parent != NULL &amp;&amp; node-&gt;parent-&gt;color == red) {
        parent = node-&gt;parent;
        grandparent = parent-&gt;parent;
        if (grandparent == NULL) return NULL;
        if (parent == grandparent-&gt;left) {
            uncle = grandparent-&gt;right;
        } else {
            uncle = grandparent-&gt;left;
        }
        if (uncle != NULL &amp;&amp; uncle-&gt;color == red) {
            uncle-&gt;color = black;
            parent-&gt;color = black;
            grandparent-&gt;color = red;
            node = grandparent;
            continue;
        } else if (uncle == NULL || uncle-&gt;color == black) {
            if (grandparent-&gt;left == parent) {
                if (parent-&gt;left == node) {
                    parent-&gt;color = black;
                    grandparent-&gt;color = red;
                    RightRotation(grandparent, tree);
                } else {
                    LeftRightRotation(grandparent, tree);
                    node = node-&gt;parent;
                }
            } else {
                if (parent-&gt;left == node) {
                    RightLeftRotation(grandparent, tree);
                    node = node-&gt;parent;
                } else {
                    parent-&gt;color = black;
                    grandparent-&gt;color = red;
                    RightRotation(grandparent, tree);
                }
            }
        }
    }
}
</code></pre>
<h3 id="测试样例"><a class="header" href="#测试样例">测试样例</a></h3>
<pre><code class="language-cpp">int main(void) {
    Tree* tree = initTree();
    putCheck(tree, 1, 80);
    putCheck(tree, 1, 40);
    putCheck(tree, 1, 160);
    putCheck(tree, 1, 20);
    putCheck(tree, 1, 60);
    // 1.单右旋
    // putCheck(tree, 10);
    // putCheck(tree, 5);
    // 2.左右旋
    // putCheck(tree, 5); putCheck(tree, 11);
    // 3.右左旋
    // putCheck(tree, 30);
    // putCheck(tree, 25);
    // 4.红红
    putCheck(tree, 1, 10);
    putCheck(tree, 1, 30);
    putCheck(tree, 1, 25);
    // 5. 暂时就这样了，明天再说
    preorderTraversal(tree-&gt;root);
    printf(&quot;\n&quot;);
    // 6. 负载测试
    putCheck(tree, 1, 28);
    putCheck(tree, 1, 22);
    preorderTraversal(tree-&gt;root);
    printf(&quot;\n&quot;);
    putCheck(tree, 1, 23);
    putCheck(tree, 1, 24);
    preorderTraversal(tree-&gt;root);
    printf(&quot;\n&quot;);
    // 删除
    removeChect(tree, 1, 23);
    preorderTraversal(tree-&gt;root);
    return 0;
}
</code></pre>
<p><img src="https://www.cnblogs.com/skywang12345/p/3624343.html" alt="参考文章" /></p>
<h3 id="失败的写了一半第一版"><a class="header" href="#失败的写了一半第一版">失败的写了一半第一版</a></h3>
<h4 id="初始化-4"><a class="header" href="#初始化-4">初始化</a></h4>
<ol>
<li>相比于 AVL 树，红黑树不再强调高度，转为由红黑判断是否旋转或变色</li>
<li>因为高度不用改变，所以用 while 循环代替递归会更好更容易</li>
</ol>
<pre><code class="language-cpp">typedef struct Node {
    int value;
    int color; // 红为 1，黑为 0
    struct Node* parent;
    struct Node* left;
    struct Node* right;
} Node;

typedef struct Tree {
    int init;
    Node* root;
} Tree;

Node* initNode() {
    Node* p = (Node*)malloc(sizeof(Node));
    p-&gt;value = 0;
    p-&gt;color = red;
    p-&gt;parent = NULL;
    p-&gt;left = NULL;
    p-&gt;right = NULL;
    return p;
}

Tree* initTree() {
    Tree* p = (Tree*)malloc(sizeof(Tree));
    p-&gt;root = initNode();
    p-&gt;init = 0;
    return p;
}
</code></pre>
<h4 id="add-2"><a class="header" href="#add-2">add</a></h4>
<pre><code class="language-cpp">Node* add(Node* node, int value, Tree* tree) {
    // 判断是否递归到 nil，并创建新节点
    if (node == NULL) {
        Node* newNode = initNode();
        newNode-&gt;value = value;
        return newNode;
    }
    // 👈
    if (value &lt; node-&gt;value) {
        Node* newNode = add(node-&gt;left, value, tree);
        // 判断是否发生旋转，若果旋转了则递归的 node 与 newNode 父子关系会发生改变，要判断并及时继续回退，知道父子关系正常
        if (newNode == tree-&gt;root) {
            return newNode;
        }
        // 若父子关系正常，则纠正父子关系，好像只在新建新子节点时真正发挥作用，待证实，
        // 用递归写真难受
        newNode-&gt;parent = node;
        node-&gt;left = newNode;
        // 判断是否需要旋转或变色
        // 父节点为红色
        // node-&gt;parent != tree-&gt;root 这个待大量测试
        if (node-&gt;color != black &amp;&amp; node != tree-&gt;root  &amp;&amp; node-&gt;parent != tree-&gt;root) {
            Node* newNode = reNode(node, leftdirctction, tree);
            // 如果只换颜色则结构没有调整，按正常递归走
            if (newNode == NULL) {return node;}
            // 判断根是否被转走了
            else if (newNode-&gt;right == tree-&gt;root) {
                newNode-&gt;parent = NULL;
                newNode-&gt;color = black;
                tree-&gt;root = newNode;
            } else {
                // 只要进了船，就不走寻常路
                return newNode;
            }
        }
    } else { // 👉
        Node* newNode = add(node-&gt;right, value, tree);
        if (newNode == tree-&gt;root) {
            return newNode;
        } else if (node-&gt;parent == newNode) {
            return newNode;
        }
        newNode-&gt;parent = node;
        node-&gt;right = newNode;
        if (node-&gt;color != black &amp;&amp; node != tree-&gt;root) {
            Node* newNode = reNode(node, rightdirctction, tree);
            if (newNode == NULL) {return node;}
            else if (newNode-&gt;right == tree-&gt;root) {
                newNode-&gt;parent = NULL;
                newNode-&gt;color = black;
                tree-&gt;root = newNode;
            } else {
                return newNode;
            }
        }
    }
    return node;
}



Node* addCheck(Tree* tree, int value) {
    if (tree-&gt;init == 0) {
        tree-&gt;init = 1;
        tree-&gt;root-&gt;value = value;
        tree-&gt;root-&gt;color = black;
        return tree-&gt;root;
    } else {
        return add(tree-&gt;root, value, tree);
    }
}
</code></pre>
<h4 id="renode"><a class="header" href="#renode">reNode</a></h4>
<p>用于旋转或变色，配合图片酌情观看 (＞﹏＜)</p>
<ol>
<li>单旋的情况</li>
</ol>
<pre><code class="language-cpp">Node* reNode(Node* node, int isleftdirection, Tree* tree) {
    Node* res = NULL; // 声明返回值
    // 找到需要用得到的节点，father(node) 和 gradfather
    Node* grandfather = node-&gt;parent;
    Node* brother = NULL;
    // isleft 父节点是不是爷节点的左支，isleftdirection 子节点是不是父节点的左支
    int isleft = node-&gt;value &lt; grandfather-&gt;value;
    if (isleft) brother = grandfather-&gt;right; else brother = grandfather-&gt;left;
    // 若兄弟节点为红色则只换颜色
    if (brother != NULL &amp;&amp; brother-&gt;color == red) {
        brother-&gt;color = black;
        node-&gt;color = black;
        grandfather-&gt;color = red;
        return NULL;
    } else {
        // 若爷节点和父节点均为红色，需要把当前节点设为爷节点，这里用 while 循环会方便得多，在此处暂时只处理父节点和爷节点同为红色，如果再有更高辈的节点，这里不写了
        if (grandfather-&gt;parent == NULL) {
            return node;
        } else if (grandfather-&gt;color == red) {
            grandfather = grandfather-&gt;parent;
            // 单旋就行
            if (isleft) {
                res = RightRotation(grandfather);
            } else {
                res = LeftRotation(grandfather);
            }
        } else {
            if (isleft) {
                if (isleftdirection) {  // 左左 右旋
                    res = RightRotation(grandfather);
                } else {  // 左右 左右旋
                    res = LeftRightRotation(grandfather);
                }
            } else {
                if (isleftdirection) { // 右右 左旋
                    res = RightLeftRotation(grandfather);
                } else { // 右左 右左旋
                    res = LeftRotation(grandfather);
                }
            }
            return res;
        }
    }
}
</code></pre>
<h2 id="待续-13"><a class="header" href="#待续-13">待续...</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<h2 id="1-镜像"><a class="header" href="#1-镜像">1 镜像</a></h2>
<h3 id="11-获取镜像"><a class="header" href="#11-获取镜像">1.1 获取镜像</a></h3>
<p><code>docker pull</code></p>
<p>没必要，直接 docker run 就行了</p>
<h3 id="12-列出镜像"><a class="header" href="#12-列出镜像">1.2 列出镜像</a></h3>
<ol>
<li>
<p>列出所有： <code>docker image list</code></p>
</li>
<li>
<p>列出所有虚悬镜像： <code>docker image list -f dangling=true</code></p>
<p>这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code></p>
</li>
</ol>
<h3 id="13-删除镜像"><a class="header" href="#13-删除镜像">1.3 删除镜像</a></h3>
<ol>
<li>
<p>删除： <code>docker image rm xxx</code></p>
<p>xxx 可以是 镜像短 ID、镜像长 ID、镜像名、或者镜像摘要</p>
</li>
<li>
<p>删除所有虚悬镜像： <code>docker image prune</code></p>
</li>
<li>
<p>删除所有仓库名为 redis 的镜像：<code>docker image rm $(docker image ls -q redis)</code></p>
</li>
</ol>
<h3 id="14-docker-drag"><a class="header" href="#14-docker-drag">1.4 docker-drag</a></h3>
<p>https://github.com/NotGlop/docker-drag</p>
<p>使用方法：</p>
<pre><code class="language-sh">python docker_pull.py hello-world

python docker_pull.py mysql/mysql-server:8.0

python docker_pull.py mcr.microsoft.com/mssql-tools

python docker_pull.py consul@sha256:6ba4bfe1449ad8ac5a76cb29b6c3ff54489477a23786afb61ae30fb3b1ac0ae9
</code></pre>
<p>加载镜像：<code>docker image load -i xxx.tar</code></p>
<h2 id="2-容器"><a class="header" href="#2-容器">2 容器</a></h2>
<h3 id="20-列出容器"><a class="header" href="#20-列出容器">2.0 列出容器</a></h3>
<p><code>docker container ls -a</code></p>
<p><code>docker ps -a</code></p>
<h3 id="21-启动容器"><a class="header" href="#21-启动容器">2.1 启动容器</a></h3>
<p>新建容器： <code>docker run -d -it ubuntu:18.04 /bin/bash</code></p>
<h3 id="22-重启容器"><a class="header" href="#22-重启容器">2.2 重启容器</a></h3>
<p><code>docker container start</code></p>
<h3 id="23-终止容器"><a class="header" href="#23-终止容器">2.3 终止容器</a></h3>
<p><code>docker container stop</code></p>
<p><code>docker container restart</code></p>
<h3 id="24-进入容器"><a class="header" href="#24-进入容器">2.4 进入容器</a></h3>
<p><code>docker exec -it ubuntu:18.04 /bin/bash</code></p>
<h3 id="25-导入导出"><a class="header" href="#25-导入导出">2.5 导入导出</a></h3>
<ol>
<li>
<p>导出：<code>docker export 7691a814370e &gt; ubuntu.tar</code></p>
</li>
<li>
<p>导入：</p>
<ul>
<li>从文件：<code>cat ubuntu.tar | docker import - test/ubuntu:v1.0</code></li>
<li>从路径：<code>docker import http://example.com/exampleimage.tgz example/imagerepo</code></li>
</ul>
</li>
</ol>
<h3 id="26-删除容器"><a class="header" href="#26-删除容器">2.6 删除容器</a></h3>
<ul>
<li>
<p>删除已经关闭的一个容器： <code>docker container rm</code></p>
</li>
<li>
<p>删除所有已经关闭的容器：<code>docker container prune</code></p>
</li>
</ul>
<h2 id="3-dockerfile"><a class="header" href="#3-dockerfile">3 Dockerfile</a></h2>
<p>这里会将一个 Dockerfile 的构建过程</p>
<h3 id="env--arg"><a class="header" href="#env--arg">ENV &amp; ARG</a></h3>
<p>ARG 用于设置环境变量</p>
<ul>
<li><strong>只在 build 期间生效，run 期无效</strong></li>
<li>在构建镜像的时候使用 <code>--build-arg</code> 进行传递，会 <strong>覆盖</strong> Dockerfile 中指定的同名参数</li>
</ul>
<blockquote>
<p>灵活使用 ARG 指令，可以在不修改 Dockerfile 的情况下，构建不同镜像。我们可以在构建镜像的时候，给参数传递不同的值，构建出不同的镜像</p>
</blockquote>
<p>ENV 指令和 ARG 指令特别相似</p>
<ul>
<li>ARG 在 build 的时候生效，ENV 在 run 的时候生效，都可以直接使用这里定义的环境变量。</li>
<li><code>docker run --env</code> 可以修改这些值</li>
</ul>
<h3 id="add--copy"><a class="header" href="#add--copy">ADD &amp; COPY</a></h3>
<p>COPY</p>
<ul>
<li>支持通配符</li>
<li>可以改变用户和组</li>
</ul>
<pre><code class="language-dockerfile">COPY package.json /usr/src/app/
COPY hom* /mydir/
COPY hom?.txt /mydir/
COPY --chown=55:mygroup files* /mydir/
</code></pre>
<ul>
<li>如果 src 是 URL，并且 dest 不以斜杠结尾，则从 URL 下载文件并将其复制到 dest。</li>
<li>如果 dest 以斜杠结尾，将自动推断出 url 的名字（保留最后一部分），保存到 dest</li>
<li>如果 src 是目录，则将复制目录的整个内容，包括文件系统元数据。</li>
</ul>
<p>ADD</p>
<ul>
<li>源路经是 URL 会尝试下载</li>
<li>源路径是压缩文件 (gzip, bzip2 以及 xz), 会自动解压</li>
</ul>
<h3 id="expose"><a class="header" href="#expose">EXPOSE</a></h3>
<p>指定容器向外部暴露的端口，但并不会自动映射到宿主机，使用<code>-P</code>后会将这些端口随机映射到宿主机</p>
<pre><code class="language-dockerfile">EXPOSE 8080
EXPOSE 7000-8000
</code></pre>
<h3 id="run"><a class="header" href="#run">RUN</a></h3>
<pre><code class="language-dockerfile">RUN cd /app
RUN echo &quot;hello&quot; &gt; world.txt
</code></pre>
<p>上面的两个<code>RUN</code>并不是在同一个环境下运行的，他们不是一个容器，他们的工作目录当然也不一样</p>
<p>可以通过<code>WORKDIR</code>去同步不同命令的工作目录</p>
<pre><code class="language-dockerfile">WORKDIR /app
RUN echo &quot;hello&quot; &gt; world.txt
</code></pre>
<p>多个<code>WORKDIR</code>之间是有联系的</p>
<pre><code class="language-dockerfile">WORKDIR /a
WORKDIR b
WORKDIR c

RUN pwd
# /a/b/c
</code></pre>
<h3 id="entrypoint"><a class="header" href="#entrypoint">ENTRYPOINT</a></h3>
<p>ENTRYPOINT 配置容器启动时的执行命令</p>
<ul>
<li>不会被忽略，<strong>一定会被执行</strong>，即使运行 docker run 时指定了其他命令</li>
</ul>
<h3 id="volume"><a class="header" href="#volume">VOLUME</a></h3>
<p>挂载主机目录 / 挂载数据卷</p>
<pre><code class="language-dockerfile">VOLUME: HostPath:ContainerPath
</code></pre>
<p>挂载匿名卷，匿名卷中的数据不会持久化</p>
<pre><code class="language-dockerfile">VOLUME /data
</code></pre>
<p>命令行挂载</p>
<pre><code>--mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \
</code></pre>
<table><thead><tr><th>key</th><th>value</th></tr></thead><tbody>
<tr><td>type</td><td>bind, volume, or tmpfs</td></tr>
<tr><td>source/src</td><td>Docker Host 上的一个目录或者文件</td></tr>
<tr><td>destination/dst/target</td><td>被挂载容器上的一个目录或者文件</td></tr>
<tr><td>readonly</td><td>挂载为只读</td></tr>
</tbody></table>
<h3 id="格式"><a class="header" href="#格式">格式</a></h3>
<ol>
<li>
<p>指定基础镜像</p>
<p>定制一个镜像，需要以一个镜像为基础</p>
<pre><code class="language-dockerfile">FROM alpine:latest
</code></pre>
</li>
<li>
<p>RUN 执行命令 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</p>
</li>
<li>
<p>ENTRYPOINT 添加 prefix</p>
<p><code>ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://myip.ipip.net&quot; ]</code></p>
<p>从外部运行<code>docker run myip -i</code>，就相当于<code>docker run myip curl -s http://myip.ipip.net -i</code></p>
</li>
</ol>
<h3 id="build"><a class="header" href="#build">build</a></h3>
<pre><code class="language-sh">docker build -t xxx .
</code></pre>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<h4 id="curl-自动查询-ip"><a class="header" href="#curl-自动查询-ip">curl 自动查询 ip</a></h4>
<pre><code class="language-sh">FROM ubuntu:18.04

RUN apt-get update \
    &amp;&amp; apt-get install -y curl \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

CMD [&quot;curl&quot;, &quot;-s&quot;, &quot;http://&quot;]
</code></pre>
<h4 id="redis--redis-json--redis-search"><a class="header" href="#redis--redis-json--redis-search">redis + redis-json + redis-search</a></h4>
<pre><code class="language-sh">FROM alpine:latest

COPY ./cargo-config /cargo-config

RUN mkdir -p ~/.cargo &amp;&amp; mv /cargo-config ~/.cargo/config \
\
        &amp;&amp; sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories \
        &amp;&amp; apk add --no-cache \
        redis \
        openssh \
        sudo \
        libgcc \
\
        clang-libs \
        git \
        bash \
        python3 \
        py3-setuptools \
        py3-pip \
        unzip \
        wget \
        alpine-sdk \
        cmake \
        cargo \
\
        &amp;&amp; mkdir -p /opt/build /opt/redis-modules \
\
        &amp;&amp; cd /opt/build \
        &amp;&amp; git clone https://github.com/RedisJSON/RedisJSON \
        &amp;&amp; cd RedisJSON \
        &amp;&amp; git submodule update --init --recursive \
        &amp;&amp; cd .. \
        &amp;&amp; git clone https://github.com/RediSearch/RediSearch \
\
        &amp;&amp; cd /opt/build/RedisJSON \
        &amp;&amp; make build shell=/bin/bash \
        &amp;&amp; cp target/release/librejson.so /opt/redis-modules \
\
        &amp;&amp; cd /opt/build/RediSearch \
        &amp;&amp; cmake . -DCMAKE_INSTALL_PREFIX=&quot;/opt/redis-modules&quot; -Bbuild \
        &amp;&amp; cmake --build build \
        &amp;&amp; cp build/redisearch.so /opt/redis-modules \
\
        &amp;&amp; rm -rf /opt/build \
        &amp;&amp; rm -rf ~/.cargo \
        &amp;&amp; strip /opt/redis-modules/*.so \
        &amp;&amp; apk del --purge alpine-sdk cmake cargo python3 py3-setuptools py3-pip unzip wget bash git clang-libs \
        &amp;&amp; adduser -D -s /bin/ash admin

USER admin
VOLUME [&quot;/home/admin&quot;]
WORKDIR /home/admin
EXPOSE 6379
CMD [&quot;redis-server&quot;, &quot;--loadmodule&quot;, &quot;/opt/redis-modules/librejson.so&quot;, &quot;--loadmodule&quot;, &quot;/opt/redis-modules/redisearch.so&quot;]
</code></pre>
<h2 id="4-自动化"><a class="header" href="#4-自动化">4 自动化</a></h2>
<h3 id="pass-凭证管理"><a class="header" href="#pass-凭证管理">pass 凭证管理</a></h3>
<ul>
<li>pass</li>
<li>docker-credential-pass</li>
</ul>
<p><img src="https://blog.csdn.net/Rambo_Yang/article/details/108294632" alt="Docker Login 登录凭证安全存储" /></p>
<h3 id="坑-1"><a class="header" href="#坑-1">坑</a></h3>
<p>gpg2 一定不要使用 sudo 执行，docker 也要加到 group 里</p>
<ul>
<li>
<p>注意<code>docker login</code>登陆的 url 是什么，这个 url 需要时 jib 白名单里有的</p>
<p><code>docker login</code>默认登陆的 url 是<code>index.docker.io/v1</code></p>
<p>如果 jib 无法识别，可以尝试使用 <code>docker login registry.hub.docker.com</code></p>
<p>现在有的凭证可以通过<code>docker-credential-pass list</code>查看</p>
<pre><code>»»»» docker-credential-pass list
{&quot;https://index.docker.io/v1/&quot;:&quot;trdthg&quot;,&quot;registry.hub.docker.com&quot;:&quot;trdthg&quot;}
</code></pre>
</li>
<li>
<p>jib 自动 push 需要从白名单 url 中一个个尝试，<code>docker login</code></p>
</li>
</ul>
<h3 id="jib"><a class="header" href="#jib">jib</a></h3>
<p><img src="https://github.com/GoogleContainerTools/jib" alt="Jib" /></p>
<p>登陆成功会有下面的提示</p>
<pre><code>[INFO] Using credentials from Docker config (/home/trdthg/.docker/config.json) for adoptopenjdk/openjdk8
</code></pre>
<h2 id="5-docker-compose"><a class="header" href="#5-docker-compose">5 docker-compose</a></h2>
<h3 id="限制资源"><a class="header" href="#限制资源">限制资源</a></h3>
<pre><code class="language-yml">redis:
  image: redis:alpine
  container_name: redis
  deploy:
    resources:
      limits:
        cpus: '0.50'
        memory: 50M
</code></pre>
<p><code>--compatibility</code>: 以兼容模式运行，将 v3 的语法转化为 v2 的语法，而不需要将 compose 文件改为 v2 的版本</p>
<pre><code class="language-shell">docker-compose --compatibility up -d
</code></pre>
<h3 id="完整配置参考"><a class="header" href="#完整配置参考">完整配置参考</a></h3>
<pre><code class="language-yml">version: &quot;3&quot;  # 指定 docker-compose 语法版本
services:    # 从以下定义服务配置列表
  server_name:   # 可将 server_name 替换为自定义的名字，如 mysql/php 都可以
    container_name: container_name  # 指定实例化后的容器名，可将 container_name 替换为自定义名
    image: xxx:latest # 指定使用的镜像名及标签
    build:  # 如果没有现成的镜像，需要自己构建使用这个选项
      context: /xxx/xxx/Dockerfile  # 指定构建镜像文件的路径
      dockerfile: ....     # 指定 Dockerfile 文件名，上一条指定，这一条就不要了
    ports:
      - &quot;00:00&quot;  # 容器内的映射端口，本地端口：容器内端口
      - &quot;00:00&quot;  # 可指定多个
    volumes:
      - test1:/xx/xx  # 这里使用 managed volume 的方法，将容器内的目录映射到物理机，方便管理
      - test2:/xx/xx  # 前者是 volumes 目录下的名字，后者是容器内目录
      - test3:/xx/xx  # 在文件的最后还要使用 volumes 指定这几个 tests
    volumes_from:  # 指定卷容器
       - volume_container_name  # 卷容器名
    restarts: always  # 设置无论遇到什么错，重启容器
    depends_on:       # 用来解决依赖关系，如这个服务的启动，必须在哪个服务启动之后
      - server_name   # 这个是名字其他服务在这个文件中的 server_name
      - server_name1  # 按照先后顺序启动
    links:  # 与 depend_on 相对应，上面控制容器启动，这个控制容器连接
      - mysql  # 值可以是 - 服务名，比较复杂，可以在该服务中使用 links 中 mysql 代替这个 mysql 的 ip
    networks: # 加入指定的网络，与之前的添加网卡名类似
      - my_net  # bridge 类型的网卡名
      - myapp_net # 如果没有网卡会被创建，建议使用时先创建号，在指定
    environment: # 定义变量，类似 dockerfile 中的 ENV
      - TZ=Asia/Shanghai  # 这里设置容器的时区为亚洲上海，也就解决了容器通过 compose 编排启动的 时区问题！！！！解决了容器的时区问题！！！
      变量值：变量名   # 这些变量将会被直接写到镜像中的/etc/profile
    command: [                        #使用 command 可以覆盖容器启动后默认执行的命令
            '--character-set-server=utf8mb4',            #设置数据库表的数据集
            '--collation-server=utf8mb4_unicode_ci',    #设置数据库表的数据集
            '--default-time-zone=+8:00'                    #设置 mysql 数据库的 时区问题！！！！而不是设置容器的时区问题！！！！
    ]
  server_name2:  # 开始第二个容器
    server_name:
      stdin_open: true # 类似于 docker run -d
      tty: true  # 类似于 docker run -t
volumes:   # 以上每个服务中挂载映射的目录都在这里写入一次，也叫作声明 volume
  test1:
  test2:
  test3:
networks:  # 如果要指定 ip 网段，还是创建好在使用即可，声明 networks
  my_net:
    driver: bridge  # 指定网卡类型
  myapp_net:
    driver: bridge
</code></pre>
<h3 id="spring-boot--mysql"><a class="header" href="#spring-boot--mysql">spring-boot + mysql</a></h3>
<h4 id="doocker-composeyml"><a class="header" href="#doocker-composeyml">doocker-compose.yml</a></h4>
<p>网络：</p>
<ul>
<li>
<p>如果不特殊指明，所有的 service 都会自动加入 default 网络里</p>
</li>
<li>
<p>host 会被 service 的名称代替 <code>tguio.club =&gt; mysql</code></p>
</li>
<li>
<p>端口号会被容器暴露的端口代替 <code>4205 =&gt; 3306</code></p>
</li>
<li>
<p>容器之间可以通过自己暴露的端口互相访问</p>
</li>
<li>
<p>宿主机还是需要通过绑定到宿主机上的端口访问</p>
</li>
</ul>
<pre><code class="language-yml">services:
  web:
    build: .
    ports:
      - &quot;8848:8848&quot;
    depends_on:
      - mysql
      - redis
  mysql:
    image: mysql:latest
    environment:
      MYSQL_DATABASE: dev
      MYSQL_USER: admin
      MYSQL_PASSWORD: admin
      MYSQL_ROOT_PASSWORD: 2022A22db
    ports:
      - &quot;4205:3306&quot;
    restart: always

  redis:
    image: &quot;redis:alpine&quot;
    ports:
      - &quot;5470:6379&quot;
</code></pre>
<pre><code class="language-yml">server:
  port: 8848
spring:
  datasource:
#    url: jdbc:mysql://tguio.club:4205/dev?serverTimezone=UTC&amp;useSSL=false&amp;autoReconnect=true&amp;tinyInt1isBit=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;allowPublicKeyRetrieval=true
    url: jdbc:mysql://mysql:3306/dev?serverTimezone=UTC&amp;useSSL=false&amp;autoReconnect=true&amp;tinyInt1isBit=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;allowPublicKeyRetrieval=true
    username: admin
    password: admin
  jpa:
    properties:
      hibernate:
        format_sql: true
#        show_sql: true
        hbm2ddl:
          auto: update
  redis:
#    host: tguio.club
    host: redis
    port: 5470
    pool:
      max-active: 8
      max-wait: -1
      max-idle: 4
      min-idle: 1
#    timeout: 5
</code></pre>
<h2 id="5-其他"><a class="header" href="#5-其他">5 其他</a></h2>
<h3 id="端口映射"><a class="header" href="#端口映射">端口映射</a></h3>
<ul>
<li>一对一指定：<code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code></li>
<li>一对一随机：
<ul>
<li><code>-P 80</code> 把容器的 80 端口随机映射宿主机上</li>
</ul>
</li>
<li>多对多指定：
<ul>
<li><code>-p 1000-2000:1000-2000</code> 容器的 1000-2000 的所有端口，映射到宿主机端口 1000-2000</li>
</ul>
</li>
<li>多对多随机：
<ul>
<li><code>docker run --expose=1000-2000</code> 容器的 1000-2000 的所有端口，随机映射到宿主机</li>
<li><code>docker run -P</code> 把容器暴露的所有端口都随机映射宿主机上</li>
</ul>
</li>
</ul>
<h3 id="正则匹配用法"><a class="header" href="#正则匹配用法">正则匹配用法</a></h3>
<ul>
<li>
<p>删除容器</p>
<p><code>sudo docker ps -a | awk '{print $1, $2}' | grep &quot;jdk&quot; | xargs -t sudo docker rm</code></p>
</li>
<li>
<p>删除镜像
<code>sudo docker images | awk '{print $1, $2}' | grep &quot;jdk&quot; | awk '{print $1}' | xargs -t sudo docker rmi</code></p>
<p>awk 能够且分为一行，print 能选择字段</p>
</li>
</ul>
<h3 id="重命名"><a class="header" href="#重命名">重命名</a></h3>
<pre><code>           镜像 id   名称  tag(可省略)
docker tag e49db activemp:1.5.5
</code></pre>
<h3 id="添加sudo权限"><a class="header" href="#添加sudo权限">添加<code>sudo</code>权限</a></h3>
<pre><code class="language-shell"># 如果 docker 组不存在，则添加之：
sudo groupadd docker

# 将当前用户添加到 docker 组
sudo gpasswd -a trdthg docker

# 添加访问和执行权限
sudo chmod a+rw /var/run/docker.sock
</code></pre>
<h3 id="推送到-dockerhub"><a class="header" href="#推送到-dockerhub">推送到 dockerhub</a></h3>
<ol>
<li>登陆</li>
</ol>
<pre><code>docker login -u xxx
Password: 输入 token
</code></pre>
<ol start="2">
<li>推送 注意：需要修改 image 名称为 <code>{username}/{image-name}:{tag}</code></li>
</ol>
<pre><code>docker push `{username}/{image-name}:{tag}`
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="连路追踪--性能监测"><a class="header" href="#连路追踪--性能监测">连路追踪 / 性能监测</a></h1>
<h2 id="全连路追踪"><a class="header" href="#全连路追踪">全连路追踪</a></h2>
<h3 id="skywalking"><a class="header" href="#skywalking">skywalking</a></h3>
<p>这里使用探针实现信息收集，使用默认的 H2 存储</p>
<h4 id="springboot-配置"><a class="header" href="#springboot-配置">springboot 配置</a></h4>
<pre><code class="language-yml">server:
  port: 8848
spring:
  datasource:
    url: jdbc:mysql://mysql:3306/dev?serverTimezone=UTC&amp;useSSL=false&amp;autoReconnect=true&amp;tinyInt1isBit=false&amp;useUnicode=true&amp;characterEncoding=utf8&amp;allowPublicKeyRetrieval=true
    username: admin
    password: admin
  jpa:
    properties:
      hibernate:
        format_sql: true
        hbm2ddl:
          auto: update
  redis:
    host: redis
    port: 6379
    pool:
      max-active: 8
      max-wait: -1
      max-idle: 4
      min-idle: 1
</code></pre>
<h4 id="dockerfile-配置"><a class="header" href="#dockerfile-配置">Dockerfile 配置</a></h4>
<ol>
<li>
<p><code>ADD /target/decsion-engine-0.1.5.jar app.jar</code></p>
<ul>
<li>拷贝项目打包好的 jar 包</li>
</ul>
</li>
<li>
<p><code>ADD ./agent agent</code></p>
<ul>
<li>注意：agent 需要和 jar 包放一起，不仅仅是 skywalking-agent.jar，</li>
<li>config 下是 skywalking 的默认配置文件，其中的参数可以被 java 传递的参数覆盖</li>
<li>log 下存储了日志，一般监测信息没有可以尝试查看该文件夹</li>
<li>plugin 下存储了对不同进程的信息采集工具，必须依赖他们才能正常监测</li>
</ul>
</li>
<li>
<p><code>java xxx</code></p>
<ul>
<li>xxx 指服务的名字，随意</li>
<li>backend_service 指的是 skywalking 的链接
<ul>
<li>可以是 docker-compose 定义的 (oap:port1)</li>
<li>也可以是宿主机的 ip 端口 (192.168.xxx:port2)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>完整</p>
</li>
</ol>
<pre><code class="language-yml">FROM adoptopenjdk/openjdk8
VOLUME [&quot;/tmp&quot;, &quot;/logs&quot;]
EXPOSE 8848
ADD /target/decsion-engine-0.1.5.jar app.jar
ADD ./agent agent
# ADD ./skywalking-agent.jar skywalking-agent.jar # 这个不对

CMD java -javaagent:agent/skywalking-agent.jar -Dskywalking.agent.service_name=xxx -Dskywalking.collector.backend_service=192.168.31.226:11800 -jar app.jar

# 下面的一样，不影响，如果没成功，一定是别的地方写错了😅
# ENTRYPOINT [&quot;java&quot;, &quot;-javaagent:agent/skywalking-agent.jar&quot;, &quot;-Dskywalking.agent.service_name=xxx&quot;, &quot;-Dskywalking.collector.backend_service=192.168.31.226:11800&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]
</code></pre>
<h4 id="docker-composeyml"><a class="header" href="#docker-composeyml">docker-compose.yml</a></h4>
<p>需要注意的点</p>
<ul>
<li>服务的先后顺序
<ul>
<li>通过设置 restart 不断重试，直到依赖的服务启动完成</li>
</ul>
</li>
<li>ip(host), 端口号 (port)
<ul>
<li>容器之间通过可以直接用<code>${container_name}:${container_port}</code>互相访问：<code>mysql:3306</code></li>
<li>也可以直接用<code>${host_ip}:${host_port}</code>互相访问：<code>192.168.31.226:4205</code></li>
</ul>
</li>
</ul>
<pre><code class="language-yml">services:
  web:
#    image: &quot;trdthg/decision-engine:latest&quot;
    build: .
    ports:
      - &quot;8848:8848&quot;
    depends_on:
      - mysql
      - redis
      - oap
      - skywaling-ui
    restart: always
  mysql:
    image: mysql:latest
    environment:
      MYSQL_DATABASE: dev
      MYSQL_USER: admin
      MYSQL_PASSWORD: admin
      MYSQL_ROOT_PASSWORD: 2022A22db
    ports:
      - &quot;4205:3306&quot;
    logging:
      driver: &quot;none&quot;
    restart: always

  redis:
    image: &quot;redis:alpine&quot;
    ports:
      - &quot;5470:6379&quot;
    logging:
      driver: &quot;none&quot;
  oap:
    image: apache/skywalking-oap-server:8.4.0-es6
    container_name: oap
    restart: always
    ports:
      - 11800:11800 # agent 上报数据的端口，这是 gRPC 端口
      - 12800:12800 # ui 读取数据的端口，这是 http 端口
    # logging:
    #   driver: &quot;none&quot;
  skywaling-ui:
    image: apache/skywalking-ui:8.4.0
    container_name: ui
    depends_on:
      - oap
    links:
      - oap
    ports:
      - 8088:8080
    environment:
      - SW_OAP_ADDRESS=http://oap:12800
    logging:
      driver: &quot;none&quot;
</code></pre>
<h4 id="参考-5"><a class="header" href="#参考-5">参考</a></h4>
<ul>
<li><a href="https://segmentfault.com/a/1190000039836624">使用 docker 部署 spring boot 并接入 skywalking</a></li>
</ul>
<h2 id="火焰图"><a class="header" href="#火焰图">火焰图</a></h2>
<h3 id="火焰图简明教程"><a class="header" href="#火焰图简明教程">火焰图简明教程</a></h3>
<h4 id="arthas"><a class="header" href="#arthas">arthas</a></h4>
<p>arthas 是 Alibaba 开源的 Java
诊断工具，其中整合了很多实用的工具，例如查看当前 JVM 的线程堆栈信息、查看和修改 JVM 的系统属性、方法执行数据观测、生成火焰图等。最大的优点是对监控应用无代码侵入，也不需要重启监控应用或者添加启动参数就可以随意 attach 到目标 JVM 进程然后进行各种操作。
此处重点提到的是 arthas 中的 profiler 功能，实际上是对 async-profiler 的封装，可以对 JVM 应用进行采样后输出各种类型的火焰图。</p>
<h4 id="基本使用-1"><a class="header" href="#基本使用-1">基本使用</a></h4>
<h5 id="1-安装启动"><a class="header" href="#1-安装启动">1. 安装启动</a></h5>
<p>启动 profiler 采样后，需要选择对应的进程</p>
<pre><code class="language-shell">wget https://alibaba.github.io/arthas/arthas-boot.jar
java -jar arthas-boot.jar
</code></pre>
<h5 id="2-开始采集"><a class="header" href="#2-开始采集">2. 开始采集</a></h5>
<h6 id="21-基于-cpu-使用率采样-适用于-cpu-密集型"><a class="header" href="#21-基于-cpu-使用率采样-适用于-cpu-密集型">2.1 基于 CPU 使用率采样 (适用于 CPU 密集型)</a></h6>
<p>async-profiler 支持对多种事件做采样分析，例如 cpu、alloc、lock、cache-misses 等，常用的采样事件为 cpu 和 wall。其中火焰图采样未指定事件时默认对 cpu 事件进行采样，即 On-CPU 火焰图，仅包含 JVM 在 CPU 执行时的采样，而不包含 CPU 等待时的采样。</p>
<pre><code class="language-hell">$ profiler start
Started [cpu] profiling
</code></pre>
<h6 id="22-基于样本采样可估算耗时-适用于-io-密集型"><a class="header" href="#22-基于样本采样可估算耗时-适用于-io-密集型">2.2 基于样本采样，可估算耗时 (适用于 IO 密集型)</a></h6>
<p>如果需要分析 IO 密集型应用，比较适合对 wall 事件进行采样，如下官方描述，wall 事件会对所有任意状态的线程进行采样，既包含 CPU 执行时的采样，也包含了 CPU 等待时的采样，可以用来更显著地分析线程在各个方法上的耗时分布。</p>
<pre><code class="language-shell">$ profiler start -e wall
Started [wall] profiling
</code></pre>
<h5 id="3-查看状态"><a class="header" href="#3-查看状态">3. 查看状态</a></h5>
<p>获取已采集的 sample 的数量</p>
<pre><code class="language-shell">$ profiler getSamples
</code></pre>
<p>查看 profiler 状态</p>
<pre><code class="language-shell">$ profiler status
[cpu] profiling is running for 4 seconds
</code></pre>
<h5 id="4-生成结果"><a class="header" href="#4-生成结果">4. 生成结果</a></h5>
<p>生成 svg 格式结果</p>
<pre><code class="language-shell">$ profiler stop --file xxx.svg --format svg
profiler output file: /tmp/demo/arthas-output/20191125-135546.svg
OK
</code></pre>
<h5 id="5-demo"><a class="header" href="#5-demo">5. demo</a></h5>
<pre><code class="language-java">@RestController
@RequestMapping
public class IndexController {@GetMapping(&quot;/&quot;)
    public String index() throws InterruptedException {
        long start = System.currentTimeMillis();
        cpuHandler();
        long time1 = System.currentTimeMillis();
        timeHandler();
        long time2 = System.currentTimeMillis();
        normalHandler();
        long time3 = System.currentTimeMillis();

        return String.format(&quot;%d %d %d&quot;, time1 - start, time2 - time1, time3 - time2);
    }

    private int cpuHandler() {
        int value = 0;
        int max = (int)(Math.random() * 100_000_000);
        for (int i = 0; i &lt; max; i++) {
            value += i;
        }
        return value;
    }

    private void timeHandler() throws InterruptedException {
        Thread.sleep(10);
    }

    private void normalHandler() {
        Random random = new Random();
        random.nextInt(100);
    }

}
</code></pre>
<ul>
<li>
<p>cpu 事件采样</p>
<p>由图可以明细的看出来，index 方法中 cpuHandler 事件采样占比最高，即 On-CPU 中 cpuHandler 方法占用的 CPU 最高。如果因为应用占用 CPU 消耗高，需要进行优化，那么通过该火焰图很容易分析出来需要对 cpuHandler 方法优化来降低 CPU 消耗。</p>
</li>
<li>
<p>wall 事件采样</p>
<p>由图可以明细的看出来，index 方法中 timeHandler 事件采样占比最高，即 timeHandler 方法占用线程耗时时间最高。如果因为 index 方法耗时较长，需要进行优化，那么通过该火焰图很容易分析出来需要对 timeHandler 方法优化来降低线程耗时时间</p>
</li>
</ul>
<p>直接观察&quot;平顶&quot;（plateaus）往往不能快速定位性能问题，因为顶部记录的多半是对底层库函数的调用情况。我认为，要快速定位性能问题，首先应该观察的是业务函数在火焰图中的宽度，然后在往顶部找到第一个库函数来缩小范围，而不是直接就看平顶。</p>
<h2 id="prometheus"><a class="header" href="#prometheus">prometheus</a></h2>
<p>被监控的进程需要向<code>prometheus</code>发送固定格式的信息，因为格式固定，可以根据<code>prometheus</code>的查询语句去筛选数据，并导出图标</p>
<h3 id="promql"><a class="header" href="#promql">PromQL</a></h3>
<p>一条完整的查询语句主要有</p>
<ul>
<li>匹配数据源</li>
<li>运算</li>
<li>函数 这三部分组成</li>
</ul>
<ol>
<li>查询内存占用</li>
</ol>
<p>数据源：</p>
<pre><code># HELP node_memory_MemFree_bytes Memory information field MemFree_bytes.
# TYPE node_memory_MemFree_bytes gauge
node_memory_MemFree_bytes 4.85957632e+08
# HELP node_memory_MemTotal_bytes Memory information field MemTotal_bytes.
# TYPE node_memory_MemTotal_bytes gauge
node_memory_MemTotal_bytes 1.6170528768e+10
</code></pre>
<p>计算：(总内存 - 空闲内存) / 总内存 * 100</p>
<pre><code>(
  (
    node_memory_MemTotal_bytes{instance=&quot;$node&quot;,job=&quot;$job&quot;}
    - node_memory_MemFree_bytes{instance=&quot;$node&quot;,job=&quot;$job&quot;}
  ) / (node_memory_MemTotal_bytes{instance=&quot;$node&quot;,job=&quot;$job&quot;} )) * 100
</code></pre>
<ol start="2">
<li>查询 cpu 总占用</li>
</ol>
<p>各个内核的数据</p>
<pre><code># HELP node_cpu_seconds_total Seconds the CPUs spent in each mode.
# TYPE node_cpu_seconds_total counter
node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;idle&quot;} 134248.98
node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;iowait&quot;} 94.73
node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;irq&quot;} 0
node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;nice&quot;} 2.6
node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;softirq&quot;} 4554.64
node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;steal&quot;} 0
node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;system&quot;} 3190.14
node_cpu_seconds_total{cpu=&quot;0&quot;,mode=&quot;user&quot;} 6843.42

node_cpu_seconds_total{cpu=&quot;1&quot;,mode=&quot;idle&quot;} 12962.19
node_cpu_seconds_total{cpu=&quot;1&quot;,mode=&quot;iowait&quot;} 12.3
node_cpu_seconds_total{cpu=&quot;1&quot;,mode=&quot;irq&quot;} 0
node_cpu_seconds_total{cpu=&quot;1&quot;,mode=&quot;nice&quot;} 2.05
node_cpu_seconds_total{cpu=&quot;1&quot;,mode=&quot;softirq&quot;} 464.51
node_cpu_seconds_total{cpu=&quot;1&quot;,mode=&quot;steal&quot;} 0
node_cpu_seconds_total{cpu=&quot;1&quot;,mode=&quot;system&quot;} 2174.27
node_cpu_seconds_total{cpu=&quot;1&quot;,mode=&quot;user&quot;} 5931.27

node_cpu_seconds_total{cpu=&quot;10&quot;,mode=&quot;idle&quot;} 12798.81
node_cpu_seconds_total{cpu=&quot;10&quot;,mode=&quot;iowait&quot;} 16.9
node_cpu_seconds_total{cpu=&quot;10&quot;,mode=&quot;irq&quot;} 0
node_cpu_seconds_total{cpu=&quot;10&quot;,mode=&quot;nice&quot;} 2.27
node_cpu_seconds_total{cpu=&quot;10&quot;,mode=&quot;softirq&quot;} 39.99
node_cpu_seconds_total{cpu=&quot;10&quot;,mode=&quot;steal&quot;} 0
node_cpu_seconds_total{cpu=&quot;10&quot;,mode=&quot;system&quot;} 2554.07

100 - (
  # 取平均值
  avg(
    # rate 函数能够求 counter 类型数据的增长率，类似于加速度，能够反映变化的剧烈程度
    rate(
      # 只匹配 mode 为 idle 的行，
      node_cpu_seconds_total{instance=~&quot;$node&quot;,mode=&quot;idle&quot;}[$interval])
  ) * 100
)
</code></pre>
<h3 id="配置文件"><a class="header" href="#配置文件">配置文件</a></h3>
<pre><code class="language-yml">global:
  scrape_interval: 15s # 全局默认刷新时间
  external_labels:
    monitor: 'codelab-monitor'

scrape_configs:
  - job_name: 'service1' # 一个 job 可以监控多个实例，实例可以分组
    scrape_interval: 5s
    static_configs:
      # - targets: ['localhost:8080', 'localhost:8081']
      #   labels:
      #     group: 'production'

      - targets: [&quot;service1:9100&quot;]
        labels:
          group: 'node'

  - job_name: 'jmeter' # jmeter 运行过程中会在 9270 端口，可以监控
    scrape_interval: 5s
    static_configs:
      - targets: [&quot;jmeter:9270&quot;]
        labels:
          group: 'jmeter'
</code></pre>
<h3 id="监测-springboot"><a class="header" href="#监测-springboot">监测 springboot</a></h3>
<h2 id="jmeter"><a class="header" href="#jmeter">jmeter</a></h2>
<h3 id="运行测试"><a class="header" href="#运行测试">运行测试</a></h3>
<pre><code>JVM_ARGS=&quot;-Xms1g -Xmx1g&quot; jmeter.sh -n -t benchmark.jmx
</code></pre>
<h3 id="参数-1"><a class="header" href="#参数-1">参数</a></h3>
<pre><code>-n 命令行模式

-t 指定 jmx 脚本地址（地址可以是相对路径，可以是绝对路径）

-h 查看帮助
-v 查看版本
-p 指定读取 jmeter 属性文件，比如 jmeter.properties 文件中设置的
-l 记录测试结果的文件，通常结果文件为 jtl 格式（文件可以是相对路径，可以是绝对路径）
-s 以服务器方式运行（也是远程方式，启动 Agent）
-H 设置代理，一般填写代理 IP
-P 设置代理端口
-u 代理账号
-a 代理口令
-J 定义 jmeter 属性，等同于在 jmeter.properties 中进行设置
-G 定义 jmeter 全局属性，等同于在 Global.properties 中进行设置，线程间可以共享）
-D 定义系统属性，等同于在 system.properties 中进行设置
-S 加载系统属性文件，可以通过此参数指定加载一个系统属性文件，此文件可以用户自己定义
-L 定义 jmeter 日志级别，如 debug、info、error 等
-j 制定执行日志路径。（参数为日志路径，不存在不会自动创建，将日志输出到命行控制台）
-r 开启远程负载机，远程机器列表在 jmeter.properties 中指定
-R 开启远程负载机，可以指定负载机 IP，会覆盖 jmeter.properties 中 remote_hosts 的设置
-d 指定 Jmeter Home 目录
-X 停止远程执行
-g 指定测试结果文件路径，仅用于生成测试报表，参数是 csv 结果文件
-e 设置测试完成后生成测试报表
-o 指定测试报告生成文件夹（文件夹必须存在且为空文件夹）
</code></pre>
<h3 id="插件"><a class="header" href="#插件">插件</a></h3>
<p>下载后放到<code>lib/ext</code>目录下即可</p>
<ul>
<li><a href="https://github.com/johrstrom/jmeter-prometheus-plugin/releases">prometheus</a></li>
</ul>
<h3 id="导入-influxdb20"><a class="header" href="#导入-influxdb20">导入 influxdb2.0</a></h3>
<ol>
<li>配置 influxdb</li>
</ol>
<p>新建账号，配置 token</p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203172000131.png" alt="" /></p>
<ol start="2">
<li>配置 jmeter</li>
</ol>
<p>在线程组内添加一个后端控制器</p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203171959109.png" alt="" /></p>
<ol start="3">
<li>在 influxdb UI 查看结果</li>
</ol>
<p>可以通过途中的可视化界面选择，也可以转换为 Flux 查询语句</p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203171957424.png" alt="" /></p>
<h2 id="gafana"><a class="header" href="#gafana">gafana</a></h2>
<h3 id="连接-prometheus"><a class="header" href="#连接-prometheus">连接 prometheus</a></h3>
<ol>
<li>配置数据源</li>
<li>添加查询语句 (promQL)</li>
<li>选择合适的图标类型，定制一些图标的样式
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203172108901.png" alt="" /></li>
</ol>
<h3 id="连接-influxdb"><a class="header" href="#连接-influxdb">连接 influxdb</a></h3>
<ol>
<li>配置数据源 注意 url，这个 url 需要是 docker 的，不是本机的<code>http://172.20.0.5:8086</code></li>
</ol>
<pre><code>docker container inspect f65 | grep -i ipaddress
</code></pre>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203172005301.png" alt="" /></p>
<ol start="2">
<li>导入查询语句 (Flux)</li>
</ol>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203172003871.png" alt="" /></p>
<h3 id="参考-6"><a class="header" href="#参考-6">参考</a></h3>
<ul>
<li><a href="https://docs.influxdata.com/influxdb/v2.1/tools/grafana/">Use Grafana with InfluxDB OSS</a></li>
<li><a href="https://qainsights.com/jmeter-integration-with-influxdb-2-0/#Grafana_Integration">jmeter + influxdb + grafuna</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oci-规范"><a class="header" href="#oci-规范">OCI 规范</a></h1>
<h2 id="运行时规范"><a class="header" href="#运行时规范">运行时规范</a></h2>
<h3 id="容器格式"><a class="header" href="#容器格式">容器格式</a></h3>
<p>一个标准的 container bundle 包含加载和运行容器所需的所有信息，包括</p>
<ol>
<li>
<p><code>config.json</code>: 包含配置数据</p>
</li>
<li>
<p><code>rootfs</code>: 容器的根文件系统</p>
<p><code>config.json</code>中的<code>route.path</code>字段指定，默认为<code>rootfs</code></p>
</li>
</ol>
<h3 id="运行时和生命周期"><a class="header" href="#运行时和生命周期">运行时和生命周期</a></h3>
<h4 id="状态"><a class="header" href="#状态">状态</a></h4>
<p>包含以下属性</p>
<ul>
<li>
<p>ociVersion(string, REQUIRED): 遵守的 OCI 运行时规范规范的版本。</p>
</li>
<li>
<p>id(string, REQUIRED): 是容器的 ID. 这在此主机上的所有容器中必须是唯一的。不要求它在主机之间是唯一的。</p>
</li>
<li>
<p>status(string, REQUIRED): 是容器的运行时状态。该值可以是以下之一：</p>
<ul>
<li>creating：正在创建容器（生命周期中的第 2 步）</li>
<li>created: 运行时已经完成创建操作（生命周期第 2 步之后）,容器进程既没有退出也没有执行用户指定的程序</li>
<li>running: 容器进程已经执行了用户指定的程序但还没有退出（在生命周期的第 8 步之后）</li>
<li>stopped：容器进程已退出（生命周期中的第 10 步）附加值可以由运行时定义，但是，它们必须用于表示上面未定义的新运行时状态。</li>
</ul>
</li>
<li>
<p>pid(int, REQUIRED when status is created or running on Linux, OPTIONAL 在其他平台)
是容器进程的 ID。对于在运行时命名空间中执行的钩子，它是运行时看到的 pid。对于在容器命名空间中执行的钩子，它是容器看到的 pid。</p>
</li>
<li>
<p>bundle(string, REQUIRED) 是容器包目录的绝对路径。这是为了可以在主机上找到容器的配置和根文件系统。</p>
</li>
<li>
<p>annotations(map, OPTIONAL) 包含与容器关联的注释列表。如果未提供注释，则此属性可能不存在或为空映射。</p>
</li>
</ul>
<p>在 json 序列化中必须表现为</p>
<pre><code class="language-json">{
    &quot;ociVersion&quot;：&quot;0.2.0&quot;,
    &quot;id&quot;：&quot;oci-container1&quot;,
    &quot;status&quot;：&quot;running&quot;,
    &quot;pid&quot;：4422,
    &quot;bundle&quot;：&quot;/containers/redis&quot;,
    &quot;annotations&quot;: {
        &quot;我的钥匙&quot;：&quot;我的价值&quot;
    }
}
</code></pre>
<h4 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h4>
<ol>
<li><strong>调用 create</strong>,指定 ID 和 bundle 路径</li>
<li>运行时必须根据<code>config.json</code>创建容器的运行环境。
<ul>
<li>如果创建失败必须抛出错误。</li>
<li>当<code>config.json</code>中规定的资源正在被创建时，用户定义的行为一定不能被执行。</li>
<li>之后对<code>config.json</code>的更新不会影响到容器。</li>
</ul>
</li>
<li>调用<code>prestart hooks</code>.(已经弃用，被 457 代替)</li>
<li>调用<code>createRuntime hooks</code></li>
<li>调用<code>createContainer hooks</code></li>
<li><strong>调用 start</strong>, 指定容器 ID</li>
<li>调用<code>startContainer hooks</code></li>
<li>运行时运行用户指定的进程</li>
<li>调用<code>postStart hooks</code>(warning if failed)</li>
<li>容器进程退出。这可能是由于出错、退出、崩溃或运行时的 kill 操作被调用而发生。</li>
<li><strong>调用 delete</strong></li>
<li>通过撤销在步骤 2 中的操作来销毁容器</li>
<li>调用<code>postStop hooks</code>(warning if failed)</li>
</ol>
<p>上述钩子除了 9、13 外，如果调用失败，运行时必须抛出错误，停止容器，执行第 12 步</p>
<h4 id="对于-linux-系统的特殊配置"><a class="header" href="#对于-linux-系统的特殊配置">对于 linux 系统的特殊配置</a></h4>
<p><strong>文件描述符</strong> 默认情况下，运行时只会将<code>stdin, stdout and stderr</code>的文件描述符设置为开启状态</p>
<p>运行时可以传递额外的描述符去支持 socket 等功能</p>
<p>一些描述符可能会被重定向到<code>/dev/null</code> <strong>Dev symbolic links</strong> 在生命周期的第二步中，当 mount
过程结束如果下面的文件存在，就要创建对应的<code>symlinks</code></p>
<pre><code>Source	Destination
/proc/self/fd	/dev/fd
/proc/self/fd/0	/dev/stdin
/proc/self/fd/1	/dev/stdout
/proc/self/fd/2	/dev/stderr
</code></pre>
<h3 id="配置文件-1"><a class="header" href="#配置文件-1">配置文件</a></h3>
<h4 id="oci-版本"><a class="header" href="#oci-版本">OCI 版本</a></h4>
<pre><code class="language-json">&quot;ociVersion&quot;: &quot;0.1.0&quot;
</code></pre>
<h4 id="root"><a class="header" href="#root">ROOT</a></h4>
<pre><code class="language-json">&quot;root&quot;: {
    &quot;path&quot;: &quot;rootfs&quot;,
    &quot;readonly&quot;: true
}
</code></pre>
<h4 id="mounts"><a class="header" href="#mounts">Mounts</a></h4>
<p>指定了 root 之外的其他挂载点</p>
<ul>
<li>type: linux 专有，文件系统类型，比如 ext4 等</li>
<li>options: 可选，man page 中 mount 部分规定</li>
</ul>
<pre><code class="language-json">&quot;mounts&quot;: [
    {
        &quot;destination&quot;: &quot;/tmp&quot;,
        &quot;type&quot;: &quot;tmpfs&quot;,
        &quot;source&quot;: &quot;tmpfs&quot;,
        &quot;options&quot;: [&quot;nosuid&quot;,&quot;strictatime&quot;,&quot;mode=755&quot;,&quot;size=65536k&quot;]
    },
    {
        &quot;destination&quot;: &quot;/data&quot;,
        &quot;type&quot;: &quot;none&quot;,
        &quot;source&quot;: &quot;/volumes/testing&quot;,
        &quot;options&quot;: [&quot;rbind&quot;,&quot;rw&quot;]
    }
]
</code></pre>
<h4 id="process"><a class="header" href="#process">Process</a></h4>
<p>指定容器运行的进程的参数</p>
<p><strong>通用</strong></p>
<ul>
<li>terminal (bool, OPTIONAL): 是否为进程分配一个为终端</li>
<li>consoleSize (object, OPTIONAL): 终端的大小
<ul>
<li>height (uint, REQUIRED)</li>
<li>width (uint, REQUIRED)</li>
</ul>
</li>
<li>cwd (string, REQUIRED): 进程运行所在的根目录</li>
<li>env (array of strings, OPTIONAL): 环境变量</li>
<li>args (array of strings, OPTIONAL): 进程运行需要的参数</li>
</ul>
<p><strong>POSIX</strong></p>
<ul>
<li>rlimits (array of objects, OPTIONAL) : 可以为进程设置资源限制，有效值在 man page getrlimit(2)
<ul>
<li>type(string, REQUIRED) linux 或 solaris</li>
<li>soft(uint64, REQUIRED) 对相应资源实施的限制值。rlim.rlim_cur 必须匹配配置的值。</li>
<li>hard(uint64, REQUIRED) 可以由非特权进程设置的软限制的上限。rlim.rlim_max 必须匹配配置的值。只有特权进程（例如有
CAP_SYS_RESOURCE 能力的进程）才能提高硬限制。</li>
</ul>
</li>
<li>user
<ul>
<li>uid(int, REQUIRED) 指定容器命名空间中的用户 ID。</li>
<li>gid(int, REQUIRED) 指定容器命名空间中的组 ID。</li>
<li>umask(int, OPTIONAL) 指定用户的 umask</li>
<li>additionalGids（整数数组，可选）指定要添加到进程的容器命名空间中的其他组 ID。</li>
</ul>
</li>
</ul>
<p><strong>Linux</strong></p>
<ul>
<li>apparmorProfile（字符串，可选）不知</li>
<li>capabilities(object, OPTIONAL) 是一个包含数组的对象，制定了一个进程拥有的能力
<ul>
<li>effective（字符串数组，可选）该 effective 字段是为流程保留的有效功能数组。</li>
<li>bounding（字符串数组，可选）该 bounding 字段是为进程保留的边界能力数组。</li>
<li>inheritable（字符串数组，可选）该 inheritable 字段是为进程保留的可继承功能数组。</li>
<li>permitted（字符串数组，可选）该 permitted 字段是为进程保留的允许功能的数组。</li>
<li>ambient（字符串数组，可选）该 ambient 字段是为进程保留的环境功能数组。</li>
</ul>
</li>
<li>noNewPrivileges(bool, OPTIONAL) 设置 noNewPrivileges 为 true 可以防止进程获得额外的权限。</li>
<li>oomScoreAdj (int, OPTIONAL) 不知</li>
<li>selinuxLabel(string, OPTIONAL) 不知</li>
</ul>
<pre><code class="language-json">&quot;process&quot;: {
    &quot;terminal&quot;: true,
    &quot;consoleSize&quot;: {
        &quot;height&quot;: 25,
        &quot;width&quot;: 80
    },
    &quot;user&quot;: {
        &quot;uid&quot;: 1,
        &quot;gid&quot;: 1,
        &quot;umask&quot;: 63,
        &quot;additionalGids&quot;: [5, 6]
    },
    &quot;env&quot;: [
        &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;,
        &quot;TERM=xterm&quot;
    ],
    &quot;cwd&quot;: &quot;/root&quot;,
    &quot;args&quot;: [
        &quot;sh&quot;
    ],
    &quot;apparmorProfile&quot;: &quot;acme_secure_profile&quot;,
    &quot;selinuxLabel&quot;: &quot;system_u:system_r:svirt_lxc_net_t:s0:c124,c675&quot;,
    &quot;noNewPrivileges&quot;: true,
    &quot;capabilities&quot;: {
        &quot;bounding&quot;: [
            &quot;CAP_AUDIT_WRITE&quot;,
            &quot;CAP_KILL&quot;,
            &quot;CAP_NET_BIND_SERVICE&quot;
        ],
       &quot;permitted&quot;: [
            &quot;CAP_AUDIT_WRITE&quot;,
            &quot;CAP_KILL&quot;,
            &quot;CAP_NET_BIND_SERVICE&quot;
        ],
       &quot;inheritable&quot;: [
            &quot;CAP_AUDIT_WRITE&quot;,
            &quot;CAP_KILL&quot;,
            &quot;CAP_NET_BIND_SERVICE&quot;
        ],
        &quot;effective&quot;: [
            &quot;CAP_AUDIT_WRITE&quot;,
            &quot;CAP_KILL&quot;
        ],
        &quot;ambient&quot;: [
            &quot;CAP_NET_BIND_SERVICE&quot;
        ]
    },
    &quot;rlimits&quot;: [
        {
            &quot;type&quot;: &quot;RLIMIT_NOFILE&quot;,
            &quot;hard&quot;: 1024,
            &quot;soft&quot;: 1024
        }
    ]
}
</code></pre>
<h4 id="hostname"><a class="header" href="#hostname">Hostname</a></h4>
<p>容器看到的主机名</p>
<pre><code class="language-json">&quot;hostname&quot;：&quot;mrsdalloway&quot;
</code></pre>
<h4 id="特定与-linux-平台的配置"><a class="header" href="#特定与-linux-平台的配置">特定与 linux 平台的配置</a></h4>
<pre><code class="language-json">&quot;linux&quot;: {
    &quot;namespaces&quot;: [
        {
            &quot;type&quot;: &quot;pid&quot;
        }
    ]
}
</code></pre>
<h4 id="hooks"><a class="header" href="#hooks">Hooks</a></h4>
<ul>
<li>prestart（已弃用）</li>
<li>createRuntime: 在创建运行时环境之后但是在 pivot_root 或任何等效操作之前。</li>
<li>createContainer: 同上，一般在 mount 之后，pivot_root 之前</li>
<li>startContainer: 容器启动后，运行用户进程之前</li>
<li>poststart: 运行用户进程之后，操作返回之前。</li>
<li>poststop: 容器被删除之后，删除操作返回之前。</li>
</ul>
<pre><code class="language-json">&quot;hooks&quot;: {
    &quot;prestart&quot;: [
        {
            &quot;path&quot;: &quot;/usr/bin/fix-mounts&quot;,
            &quot;args&quot;: [&quot;fix-mounts&quot;, &quot;arg1&quot;, &quot;arg2&quot;],
            &quot;env&quot;:  [ &quot;key1=value1&quot;]
        },
        {
            &quot;path&quot;: &quot;/usr/bin/setup-network&quot;
        }
    ],
    &quot;createRuntime&quot;: [
        {
            &quot;path&quot;: &quot;/usr/bin/fix-mounts&quot;,
            &quot;args&quot;: [&quot;fix-mounts&quot;, &quot;arg1&quot;, &quot;arg2&quot;],
            &quot;env&quot;:  [ &quot;key1=value1&quot;]
        },
        {
            &quot;path&quot;: &quot;/usr/bin/setup-network&quot;
        }
    ],
    &quot;createContainer&quot;: [
        {
            &quot;path&quot;: &quot;/usr/bin/mount-hook&quot;,
            &quot;args&quot;: [&quot;-mount&quot;, &quot;arg1&quot;, &quot;arg2&quot;],
            &quot;env&quot;:  [ &quot;key1=value1&quot;]
        }
    ],
    &quot;startContainer&quot;: [
        {
            &quot;path&quot;: &quot;/usr/bin/refresh-ldcache&quot;
        }
    ],
    &quot;poststart&quot;: [
        {
            &quot;path&quot;: &quot;/usr/bin/notify-start&quot;,
            &quot;timeout&quot;: 5
        }
    ],
    &quot;poststop&quot;: [
        {
            &quot;path&quot;: &quot;/usr/sbin/cleanup.sh&quot;,
            &quot;args&quot;: [&quot;cleanup.sh&quot;, &quot;-f&quot;]
        }
    ]
}
</code></pre>
<h2 id="linux-容器配置"><a class="header" href="#linux-容器配置">linux 容器配置</a></h2>
<h3 id="默认文件系统"><a class="header" href="#默认文件系统">默认文件系统</a></h3>
<p><code>Linux ABI</code>包含系统调用和一些特殊的文件路径，下面的文件路径应该是可用的 |Path |	Type| | ---- | --- | |/proc
|proc| |/sys	 |sysfs| |/dev/pts|	devpts| |/dev/shm|	tmpfs|</p>
<h3 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h3>
<ul>
<li>
<p>type (string, REQUIRED) - 命名空间类型。应该支持以下命名空间类型：</p>
<ul>
<li>pid: 容器内的进程将只能看到同一容器内或同一 pid 命名空间内的其他进程。</li>
<li>network: 容器将有自己的网络堆栈。</li>
<li>mount: 容器将有一个隔离的安装表。</li>
<li>ipc: 容器内的进程将只能通过系统级 IPC 与同一容器内的其他进程通信。</li>
<li>uts: 容器将能够拥有自己的主机名和域名。</li>
<li>user: 容器将能够将用户和组 ID 从主机重新映射到容器内的本地用户和组。</li>
<li>cgroup: 容器将具有 cgroup 层次结构的隔离视图。</li>
</ul>
</li>
<li>
<p>path (string, OPTIONAL) - 命名空间文件路径。此值必须是运行时挂载命名空间中的绝对路径。</p>
<p>如果 path 未指定，运行时必须创建一个类型为 的新容器命名空间 type。</p>
</li>
</ul>
<pre><code class="language-json">&quot;namespaces&quot;: [
    {
        &quot;type&quot;: &quot;pid&quot;,
        &quot;path&quot;: &quot;/proc/1234/ns/pid&quot;
    },
    {
        &quot;type&quot;: &quot;network&quot;,
        &quot;path&quot;: &quot;/var/run/netns/neta&quot;
    },
    {
        &quot;type&quot;: &quot;mount&quot;
    },
    {
        &quot;type&quot;: &quot;ipc&quot;
    },
    {
        &quot;type&quot;: &quot;uts&quot;
    },
    {
        &quot;type&quot;: &quot;user&quot;
    },
    {
        &quot;type&quot;: &quot;cgroup&quot;
    }
]
</code></pre>
<h3 id="用户命名空间映射"><a class="header" href="#用户命名空间映射">用户命名空间映射</a></h3>
<ul>
<li>
<p>uidMappings（对象数组，可选）描述从主机到容器的用户命名空间 uid 映射。</p>
<p>每个条目具有以下结构：</p>
<ul>
<li>containerID (uint32, REQUIRED) - 是容器中的起始 uid/gid。</li>
<li>hostID (uint32, REQUIRED) - 是主机上要映射到 containerID 的起始 uid/gid。</li>
<li>size (uint32, REQUIRED) - 是要映射的 id 数。</li>
</ul>
</li>
</ul>
<p>运行时不应该修改引用文件系统的所有权来实现映射。请注意，映射条目的数量可能受内核限制。</p>
<pre><code class="language-json">&quot;uidMappings&quot;: [
    {
        &quot;containerID&quot;: 0,
        &quot;hostID&quot;: 1000,
        &quot;size&quot;: 32000
    }
],
&quot;gidMappings&quot;: [
    {
        &quot;containerID&quot;: 0,
        &quot;hostID&quot;: 1000,
        &quot;size&quot;: 32000
    }
]
</code></pre>
<h3 id="设备"><a class="header" href="#设备">设备</a></h3>
<ul>
<li>devices（对象数组，可选）列出容器中必须可用的设备。运行时可以根据自己的喜好提供它们（mknod 通过从运行时挂载命名空间绑定挂载，使用符号链接等）。
<ul>
<li>type (string, REQUIRED) - 设备类型：c, b,u 或 p. 参考 mknod(1)</li>
<li>path (string, REQUIRED) - 容器内设备的完整路径。如果已经存在与请求的设备不匹配的文件，则运行时必须生成错误。</li>
<li>major, minor (int64, REQUIRED unless type is p) - 设备的主要、次要编号。</li>
<li>fileMode (uint32, OPTIONAL) - 设备的文件模式。您还可以使用<code>cgroups</code>控制对设备的访问。</li>
<li>uid（uint32，可选）- 容器命名空间中设备所有者的 ID。</li>
<li>gid (uint32, OPTIONAL) -容器命名空间中设备组的 id。</li>
</ul>
</li>
</ul>
<p>相同 type，major 并且 minor 不应该用于多个设备。</p>
<pre><code class="language-json">&quot;devices&quot;: [
    {
        &quot;path&quot;: &quot;/dev/fuse&quot;,
        &quot;type&quot;: &quot;c&quot;,
        &quot;major&quot;: 10,
        &quot;minor&quot;: 229,
        &quot;fileMode&quot;: 438,
        &quot;uid&quot;: 0,
        &quot;gid&quot;: 0
    },
    {
        &quot;path&quot;: &quot;/dev/sda&quot;,
        &quot;type&quot;: &quot;b&quot;,
        &quot;major&quot;: 8,
        &quot;minor&quot;: 0,
        &quot;fileMode&quot;: 432,
        &quot;uid&quot;: 0,
        &quot;gid&quot;: 0
    }
]
</code></pre>
<h4 id="默认设备"><a class="header" href="#默认设备">默认设备</a></h4>
<pre><code>/dev/null
/dev/zero
/dev/full
/dev/random
/dev/urandom
/dev/tty
/dev/console is set up if terminal is enabled in the config by bind mounting the pseudoterminal pty to /dev/console.
/dev/ptmx. A bind-mount or symlink of the container's /dev/pts/ptmx.
</code></pre>
<h4 id="控制组-control-groups"><a class="header" href="#控制组-control-groups">控制组 (Control groups)</a></h4>
<ul>
<li>cgroupsPath (string, OPTIONAL) cgroups 的路径</li>
<li>resources
<ul>
<li>
<p>devices: 可用设备列表</p>
<ul>
<li>allow (boolean, REQUIRED) - 输入是允许还是拒绝。</li>
<li>type (string, OPTIONAL) - 设备类型：a(all), c(char), or
b(block)。未设置的值表示“全部”，映射到 a.</li>
<li>major, minor (int64, OPTIONAL) -设备的主要、次要编号。未设置的值表示“全部”，映射到*文件系统 API 中。</li>
<li>access（字符串，可选）- 设备的 cgroup 权限。r(read)、w(write) 和 m(mknod) 的组合。</li>
</ul>
</li>
<li>
<p>memory: 内存</p>
<ul>
<li>limit (int64, OPTIONAL) - 设置内存使用限制</li>
<li>reservation (int64, OPTIONAL) - 设置内存使用的软限制</li>
<li>swap (int64, OPTIONAL) - 设置内存 + 交换使用限制</li>
<li>kernel (int64, OPTIONAL, NOT RECOMMENDED) - 设置内核内存的硬限制</li>
<li>kernelTCP (int64, OPTIONAL, NOT RECOMMENDED) - 设置内核 TCP 缓冲内存的硬限制</li>
</ul>
<p>以下属性不指定内存限制，但由 memory 控制器覆盖：</p>
<ul>
<li>swappiness (uint64, OPTIONAL) - 设置 vmscan 的 swappiness 参数（参见 sysctl 的
vm.swappiness）值是从 0 到 100。更高意味着更多的 swappy。</li>
<li>disableOOMKiller (bool, OPTIONAL) - 超过内存限制的进程会被杀死</li>
<li>useHierarchy (bool, OPTIONAL) - 未知</li>
</ul>
</li>
<li>
<p>cpu: CPU</p>
<ul>
<li>shares (uint64, OPTIONAL) - 指定 cgroup 中任务可用的 CPU 时间的相对份额</li>
<li>quota (int64, OPTIONAL) - 指定一个 cgroup 中的所有任务在一个时间段内可以运行的总时间（以微秒为单位）（定义
period 如下）</li>
<li>period (uint64, OPTIONAL) - 以微秒为单位指定一个 cgroup 对 CPU 资源的访问应该重新分配的频率（仅限 CFS
调度程序）</li>
<li>realtimeRuntime (int64, OPTIONAL) - 指定 cgroup 中的任务可以访问 CPU
资源的最长连续时间段（以微秒为单位）</li>
<li>realtimePeriod (uint64, OPTIONAL) - 与实时调度程序相同 period 但仅适用于实时调度程序</li>
<li>cpus（字符串，可选）- 容器将在其中运行的 CPU 列表</li>
<li>mems（字符串，可选）- 容器将在其中运行的内存节点列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-json">{
&quot;cgroupsPath&quot;: &quot;/myRuntime/myContainer&quot;,
&quot;resources&quot;: {
    &quot;memory&quot;: {
        &quot;limit&quot;: 536870912,
        &quot;reservation&quot;: 536870912,
        &quot;swap&quot;: 536870912,
        &quot;kernel&quot;: -1,
        &quot;kernelTCP&quot;: -1,
        &quot;swappiness&quot;: 0,
        &quot;disableOOMKiller&quot;: false
    },
    &quot;devices&quot;: [
        &quot;devices&quot;: [
            {
                &quot;allow&quot;: false,
                &quot;access&quot;: &quot;rwm&quot;
            },
            {
                &quot;allow&quot;: true,
                &quot;type&quot;: &quot;c&quot;,
                &quot;major&quot;: 10,
                &quot;minor&quot;: 229,
                &quot;access&quot;: &quot;rw&quot;
            },
            {
                &quot;allow&quot;: true,
                &quot;type&quot;: &quot;b&quot;,
                &quot;major&quot;: 8,
                &quot;minor&quot;: 0,
                &quot;access&quot;: &quot;r&quot;
            }
        ]
    ]
}
}
</code></pre>
<h3 id="其他-6"><a class="header" href="#其他-6">其他</a></h3>
<ul>
<li>Block IO 不同设备的 IO 权重</li>
<li>Network</li>
<li>Huge page limits</li>
<li>PIDs
<ul>
<li>pids 设置任务最大数量
<pre><code class="language-json">&quot;pids&quot;: {
    &quot;limit&quot;: 32771
}
</code></pre>
</li>
</ul>
</li>
<li>RDMA</li>
<li>Unified</li>
<li>IntelRdt</li>
<li>Sysctl: 允许在容器运行时修改内核参数</li>
<li>Seccomp</li>
<li>The Container Process State</li>
<li>Rootfs Mount Propagation</li>
<li>Masked Paths</li>
<li>Readonly Paths</li>
<li>Mount Label</li>
<li>Personality</li>
</ul>
<pre><code class="language-json">&quot;linux&quot;: {
    &quot;devices&quot;: [
        {
            &quot;path&quot;: &quot;/dev/fuse&quot;,
            &quot;type&quot;: &quot;c&quot;,
            &quot;major&quot;: 10,
            &quot;minor&quot;: 229,
            &quot;fileMode&quot;: 438,
            &quot;uid&quot;: 0,
            &quot;gid&quot;: 0
        },
        {
            &quot;path&quot;: &quot;/dev/sda&quot;,
            &quot;type&quot;: &quot;b&quot;,
            &quot;major&quot;: 8,
            &quot;minor&quot;: 0,
            &quot;fileMode&quot;: 432,
            &quot;uid&quot;: 0,
            &quot;gid&quot;: 0
        }
    ],
    &quot;uidMappings&quot;: [
        {
            &quot;containerID&quot;: 0,
            &quot;hostID&quot;: 1000,
            &quot;size&quot;: 32000
        }
    ],
    &quot;gidMappings&quot;: [
        {
            &quot;containerID&quot;: 0,
            &quot;hostID&quot;: 1000,
            &quot;size&quot;: 32000
        }
    ],
    &quot;sysctl&quot;: {
        &quot;net.ipv4.ip_forward&quot;: &quot;1&quot;,
        &quot;net.core.somaxconn&quot;: &quot;256&quot;
    },
    &quot;cgroupsPath&quot;: &quot;/myRuntime/myContainer&quot;,
    &quot;resources&quot;: {
        &quot;network&quot;: {
            &quot;classID&quot;: 1048577,
            &quot;priorities&quot;: [
                {
                    &quot;name&quot;: &quot;eth0&quot;,
                    &quot;priority&quot;: 500
                },
                {
                    &quot;name&quot;: &quot;eth1&quot;,
                    &quot;priority&quot;: 1000
                }
            ]
        },
        &quot;pids&quot;: {
            &quot;limit&quot;: 32771
        },
        &quot;hugepageLimits&quot;: [
            {
                &quot;pageSize&quot;: &quot;2MB&quot;,
                &quot;limit&quot;: 9223372036854772000
            },
            {
                &quot;pageSize&quot;: &quot;64KB&quot;,
                &quot;limit&quot;: 1000000
            }
        ],
        &quot;memory&quot;: {
            &quot;limit&quot;: 536870912,
            &quot;reservation&quot;: 536870912,
            &quot;swap&quot;: 536870912,
            &quot;kernel&quot;: -1,
            &quot;kernelTCP&quot;: -1,
            &quot;swappiness&quot;: 0,
            &quot;disableOOMKiller&quot;: false
        },
        &quot;cpu&quot;: {
            &quot;shares&quot;: 1024,
            &quot;quota&quot;: 1000000,
            &quot;period&quot;: 500000,
            &quot;realtimeRuntime&quot;: 950000,
            &quot;realtimePeriod&quot;: 1000000,
            &quot;cpus&quot;: &quot;2-3&quot;,
            &quot;mems&quot;: &quot;0-7&quot;
        },
        &quot;devices&quot;: [
            {
                &quot;allow&quot;: false,
                &quot;access&quot;: &quot;rwm&quot;
            },
            {
                &quot;allow&quot;: true,
                &quot;type&quot;: &quot;c&quot;,
                &quot;major&quot;: 10,
                &quot;minor&quot;: 229,
                &quot;access&quot;: &quot;rw&quot;
            },
            {
                &quot;allow&quot;: true,
                &quot;type&quot;: &quot;b&quot;,
                &quot;major&quot;: 8,
                &quot;minor&quot;: 0,
                &quot;access&quot;: &quot;r&quot;
            }
        ],
        &quot;blockIO&quot;: {
            &quot;weight&quot;: 10,
            &quot;leafWeight&quot;: 10,
            &quot;weightDevice&quot;: [
                {
                    &quot;major&quot;: 8,
                    &quot;minor&quot;: 0,
                    &quot;weight&quot;: 500,
                    &quot;leafWeight&quot;: 300
                },
                {
                    &quot;major&quot;: 8,
                    &quot;minor&quot;: 16,
                    &quot;weight&quot;: 500
                }
            ],
            &quot;throttleReadBpsDevice&quot;: [
                {
                    &quot;major&quot;: 8,
                    &quot;minor&quot;: 0,
                    &quot;rate&quot;: 600
                }
            ],
            &quot;throttleWriteIOPSDevice&quot;: [
                {
                    &quot;major&quot;: 8,
                    &quot;minor&quot;: 16,
                    &quot;rate&quot;: 300
                }
            ]
        }
    },
    &quot;rootfsPropagation&quot;: &quot;slave&quot;,
    &quot;seccomp&quot;: {
        &quot;defaultAction&quot;: &quot;SCMP_ACT_ALLOW&quot;,
        &quot;architectures&quot;: [
            &quot;SCMP_ARCH_X86&quot;,
            &quot;SCMP_ARCH_X32&quot;
        ],
        &quot;syscalls&quot;: [
            {
                &quot;names&quot;: [
                    &quot;getcwd&quot;,
                    &quot;chmod&quot;
                ],
                &quot;action&quot;: &quot;SCMP_ACT_ERRNO&quot;
            }
        ]
    },
    &quot;namespaces&quot;: [
        {
            &quot;type&quot;: &quot;pid&quot;
        },
        {
            &quot;type&quot;: &quot;network&quot;
        },
        {
            &quot;type&quot;: &quot;ipc&quot;
        },
        {
            &quot;type&quot;: &quot;uts&quot;
        },
        {
            &quot;type&quot;: &quot;mount&quot;
        },
        {
            &quot;type&quot;: &quot;user&quot;
        },
        {
            &quot;type&quot;: &quot;cgroup&quot;
        }
    ],
    &quot;maskedPaths&quot;: [
        &quot;/proc/kcore&quot;,
        &quot;/proc/latency_stats&quot;,
        &quot;/proc/timer_stats&quot;,
        &quot;/proc/sched_debug&quot;
    ],
    &quot;readonlyPaths&quot;: [
        &quot;/proc/asound&quot;,
        &quot;/proc/bus&quot;,
        &quot;/proc/fs&quot;,
        &quot;/proc/irq&quot;,
        &quot;/proc/sys&quot;,
        &quot;/proc/sysrq-trigger&quot;
    ],
    &quot;mountLabel&quot;: &quot;system_u:object_r:svirt_sandbox_file_t:s0:c715,c811&quot;
},
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsorted"><a class="header" href="#unsorted">Unsorted</a></h1>
<h2 id="vitual-camera"><a class="header" href="#vitual-camera">Vitual Camera</a></h2>
<p><a href="https://rmsol.de/2020/04/25/v4l2/">Vitual Camera</a></p>
<pre><code class="language-sh">sudo modprobe -r v4l2loopback

sudo modprobe v4l2loopback devices=1 video_nr=21 exclusive_caps=1 card_label=&quot;Virtual Webcam&quot;

v4l2-ctl --list-devices

ffmpeg -re -i ~/Downloads/example.mp4 -f v4l2 /dev/video21
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oauth-20-流程分析"><a class="header" href="#oauth-20-流程分析">OAuth 2.0 流程分析</a></h1>
<p><a href="https://www.oauth.com/">www.oauth.com</a></p>
<h2 id="1-getting-ready-开始"><a class="header" href="#1-getting-ready-开始">1. Getting ready 开始</a></h2>
<h3 id="11-creating-an-application一般需要-sign-up-as-a-developer"><a class="header" href="#11-creating-an-application一般需要-sign-up-as-a-developer">1.1 Creating an Application(一般需要 sign up as a developer)</a></h3>
<p>user -&gt; entering basic information such as the name, website, logo, etc. server
-&gt; return a <strong>client_id</strong> (and a <strong>client_secret</strong> in some cases)</p>
<h3 id="12-redirect-urls-and-state"><a class="header" href="#12-redirect-urls-and-state">1.2 Redirect URLs and State</a></h3>
<ol>
<li>为了使同一个 clientID 同时拥有多个状态，Some services may allow you to register multiple
redirect URLs 比如：</li>
</ol>
<ul>
<li>Web app and Mobile app</li>
<li>development service and production service</li>
</ul>
<ol start="2">
<li>为了保证安全：必须使用 https 防止在认证过程中 code 被拦截</li>
</ol>
<ul>
<li>大多数服务 (service) 需要路由完全匹配，这意味着<a href="https://example.com/auth">https://example.com/auth</a> 的重定向 URL 将与
<a href="https://example.com/auth?destination=account">https://example.com/auth?destination=account</a> 不匹配。所以最佳做法是不在 url 里使用 query
string parameters</li>
<li>少部分服务需要可以从多种 url 发起认证，可以选择注册多个重定向 url，或者改变这些请求的重定向 url，但是 oauth2 提供了一种机制=&gt;
状态参数 (State) State 的特点</li>
</ul>
<ol start="3">
<li>State</li>
</ol>
<ul>
<li>可以用来作为加密的 salt</li>
<li>可以是某种随机数据</li>
<li>对与 service 来说是不可见的 -&gt; 在初始化认证请求时 (initial authorization request) 传入的任何 State
都会在用户授权给 app(user authorizes the application) 后被返回</li>
</ul>
<blockquote>
<p>state 用于额外的安全检查，当 github 返回数据时可以确认不是攻击者发出的请求，比如将攻击者的 authorization token 发送给
github, as well as SCRF attack</p>
</blockquote>
<p>比如：你可以将一个重定向的 url 经过 encode 后 like JWT，在用户返回 app 后解析这个 JWT 将用户带回合适的位置</p>
<h2 id="2-accessing-data-获取数据-github-为例"><a class="header" href="#2-accessing-data-获取数据-github-为例">2. Accessing data 获取数据 (github 为例)</a></h2>
<pre><code class="language-php">$out_app = &quot;在 github 填的 homepage&quot;

$authorizeURL = 'https://github.com/login/oauth/authorize';
// This is the endpoint we'll request an access token from
$tokenURL = 'https://github.com/login/oauth/access_token';
// This is the GitHub base URL for API requests
$apiURLBase = 'https://api.github.com/';
// The URL for this script, used as the redirect URL
$baseURL = 'https://' . $_SERVER['SERVER_NAME'] . $_SERVER['PHP_SELF'];
</code></pre>
<ol>
<li>获取登录凭证 (access_token)</li>
</ol>
<pre><code class="language-php">   开始
    |
    | 从某处发起 HttpRequest 重定向到 authorizeURL(不一定是 our-app)
    | 携带
    | {
    |     'response_type'= 'code',
    |     'client_id' = $githubClientID,
    |     'redirect_uri' = $baseURL,
    |     'scope' = 'user public_repo',
    |     'status'= 'random_string(10)'
    | }
    ∨
github 认证界面
    |
    | 点击确认
    | if status_send == status_resp:
    |     携带 code 和 status 重定向到 app 界面
    ∨
our-app
    |
    | exchange the authorization code for an access token.
    | 携带
    | {
    |     'grant_type' =&gt; 'authorization_code',
    |     'client_id' =&gt; $githubClientID,
    |     'client_secret' =&gt; $githubClientSecret,
    |     'redirect_uri' =&gt; $baseURL,
    |     'code' =&gt; $_GET['code']
    | }
    | 再次请求 tokenURL 使用 code 交换 token
    | {
    |     &quot;access_token&quot;: &quot;e2f8c8e136c73b1e909bb1021b3b4c29&quot;,
    |     &quot;token_type&quot;: &quot;Bearer&quot;,
    |     &quot;scope&quot;: &quot;public_repo,user&quot;
    | }
    | 重定向到 homepage(baseURL)，用户成功登录
    ∨
appHomePage
    |
    | 把 access_token 存入 session，下次进入 app 时就能通过 access_token 进入登录成功后的界面
    ∨
   End
</code></pre>
<ol start="2">
<li>利用 access_token 获取数据 直接在 header 里添加 access_token 请求 apiURLBase 就完事了</li>
</ol>
<h2 id="3-signing-in-with-google"><a class="header" href="#3-signing-in-with-google">3. Signing in with Google</a></h2>
<h3 id="31-如何获取用户信息"><a class="header" href="#31-如何获取用户信息">3.1 如何获取用户信息</a></h3>
<p>两个关键词</p>
<ul>
<li>authorization 鉴权：trying to gain access or modify something that belongs to
the user.</li>
<li>authentication 校验：just verifying who the user is OAuth is designed as a
authorization protocol(授权协议), 所以 access_token 不能被用来判断用户是谁 有以下几种不同 services 为
app 提供的方法可以判断用户是谁</li>
</ul>
<ol>
<li>a simple way: 让 api 顺便返回一些 profile_info(用户信息), 不包含在 OAuth 标准里</li>
<li>a advanced approach: use OpenID Connect(an OAuth2.0 extension)
<ul>
<li>利用 id_token</li>
<li>使用 access_token 如何选择获取 user_info 的方法 A: For performance-sensitive
applications where you might be reading ID tokens on every request or using
them to maintain a session, you should definitely validate the ID token
locally rather than making a network
request.<a href="https://developers.google.com/identity/protocols/OpenIDConnect#validatinganidtoken">https://developers.google.com/identity/protocols/OpenIDConnect#validatinganidtoken</a>
B: just for find the user’s name and email after they sign in, then
extracting the data from the ID token and storing it in your application
session</li>
</ul>
</li>
</ol>
<h3 id="32-下面以-google-提供的-api-为例"><a class="header" href="#32-下面以-google-提供的-api-为例">3.2 下面以 Google 提供的 api 为例</a></h3>
<pre><code class="language-php">$authorizeURL = 'https://accounts.google.com/o/oauth2/v2/auth';
// This is Google's OpenID Connect token endpoint
$tokenURL = 'https://www.googleapis.com/oauth2/v4/token';
// The URL for this script, used as the redirect URL
$baseURL = 'https://' . $_SERVER['SERVER_NAME'] . $_SERVER['PHP_SELF'];
</code></pre>
<p>与 github 的不同</p>
<ol>
<li>Google 的认证界面只能选择使用那个帐号 (用户), 没有点击授权的按钮</li>
<li>请求 access_token 的返回值</li>
</ol>
<pre><code class="language-json">{
  &quot;access_token&quot;: &quot;ya29.Glins-oLtuljNVfthQU2bpJVJPTu&quot;,
  &quot;token_type&quot;: &quot;Bearer&quot;,
  &quot;expires_in&quot;: 3600,
  &quot;id_token&quot;: &quot;eyJhbGciOiJSUzI1NiIsImtpZCI6ImFmZmM2MjkwN
  2E0NDYxODJhZGMxZmE0ZTgxZmRiYTYzMTBkY2U2M2YifQ.eyJhenAi
  OiIyNzIxOTYwNjkxNzMtZm81ZWI0MXQzbmR1cTZ1ZXRkc2pkdWdzZX
  V0ZnBtc3QuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQi
  OiIyNzIxOTYwNjkxNzMtZm81ZWI0MXQzbmR1cTZ1ZXRkc2pkdWdzZX
  V0ZnBtc3QuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIi
  OiIxMTc4NDc5MTI4NzU5MTM5MDU0OTMiLCJlbWFpbCI6ImFhcm9uLn
  BhcmVja2lAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUs
  ImF0X2hhc2giOiJpRVljNDBUR0luUkhoVEJidWRncEpRIiwiZXhwIj
  oxNTI0NTk5MDU2LCJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2ds
  ZS5jb20iLCJpYXQiOjE1MjQ1OTU0NTZ9.ho2czp_1JWsglJ9jN8gCg
  WfxDi2gY4X5-QcT56RUGkgh5BJaaWdlrRhhN_eNuJyN3HRPhvVA_KJ
  Vy1tMltTVd2OQ6VkxgBNfBsThG_zLPZriw7a1lANblarwxLZID4fXD
  YG-O8U-gw4xb-NIsOzx6xsxRBdfKKniavuEg56Sd3eKYyqrMA0DWnI
  agqLiKE6kpZkaGImIpLcIxJPF0-yeJTMt_p1NoJF7uguHHLYr6752h
  qppnBpMjFL2YMDVeg3jl1y5DeSKNPh6cZ8H2p4Xb2UIrJguGbQHVIJ
  vtm_AspRjrmaTUQKrzXDRCfDROSUU-h7XKIWRrEd2-W9UkV5oCg&quot;
}
</code></pre>
<p>下面是前两端的解码信息段</p>
<pre><code class="language-json">{
  &quot;alg&quot;: &quot;RS256&quot;,
  &quot;kid&quot;: &quot;affc62907a446182adc1fa4e81fdba6310dce63f&quot;
}
{
  &quot;azp&quot;: &quot;272196069173-fo5eb41t3nduq6uetdsjdugseutfpmst.apps.googleusercontent.com&quot;,
  &quot;aud&quot;: &quot;272196069173-fo5eb41t3nduq6uetdsjdugseutfpmst.apps.googleusercontent.com&quot;,
  &quot;sub&quot;: &quot;117847912875913905493&quot;,
  &quot;email&quot;: &quot;aaron.parecki@gmail.com&quot;,
  &quot;email_verified&quot;: true,
  &quot;at_hash&quot;: &quot;iEYc40TGInRHhTBbudgpJQ&quot;,
  &quot;exp&quot;: 1524599056,
  &quot;iss&quot;: &quot;https://accounts.google.com&quot;,
  &quot;iat&quot;: 1524595456
}
</code></pre>
<p>access_token should be tracted as opaque(不透明), 因为里面没有重要信息 一般来说，提取 id_token
中的信息之前进行校验是很重要的，防止这个 token 是有其他人下发的，在上面的示例中，我们使用了 https 以确保 token 确实来自 Google
sub 是用户的标识符，与帐号绑定，即使更换邮箱也不会变</p>
<blockquote>
<p>下面是一些解释 azp: 授权演示者的 client_id。仅当请求 ID 令牌的一方与 ID 令牌的受众不同时才需要此声明。aud: 此 ID
令牌的目标受众。它必须是您应用程序的 OAuth 2.0 客户端 ID 之一。</p>
</blockquote>
<h2 id="4-server-side-apps"><a class="header" href="#4-server-side-apps">4 Server-Side Apps</a></h2>
<ol>
<li>请求 code 时的 queryString</li>
</ol>
<ul>
<li>response_type: 想要获取的返回值类型</li>
<li>client_id: app 的 identifier</li>
<li>redirect_url(optional): 授权完成后的跳转页面 (需要在注册 app 时设置)</li>
<li>scope(optional): Include one or more scope values (space-separated) to request
additional levels of access. The values will depend on the particular
service.(用空格分隔)</li>
<li>status: 会被服务端完整返回，can be used to letyour app persist data between the user
being directed to the authorization server and back again，</li>
</ul>
<blockquote>
<p>比如 using it as session_key to indicate what action the app to perform after
authorization is complete(比如重定向的链接) 如果每次 request 的 status 都是随机生成的，status
也能用来保护 from CSRF</p>
</blockquote>
<ol start="2">
<li>交换 access_token 的 queryString</li>
</ol>
<ul>
<li>grant_type(required): 必须要设置为 authorization_code</li>
<li>code(required): will be in the query string parameter “code” in this request.</li>
<li>redirect_uri (possibly required)</li>
<li>Client Authentication (required): 一般是 client_id 和 client_secret</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim"><a class="header" href="#vim">vim</a></h1>
<h2 id="1-批量注释与反注释"><a class="header" href="#1-批量注释与反注释">1. 批量注释与反注释</a></h2>
<p>在使用 vim 编写代码的时候，经常需要用到批量注释与反注释一段代码。下面简要介绍其操作。</p>
<h3 id="11-块选择模式"><a class="header" href="#11-块选择模式">1.1 块选择模式</a></h3>
<p>插入注释：</p>
<ul>
<li>
<p>用 v 进入 virtual 模式</p>
</li>
<li>
<p>用上下键选中需要注释的行数</p>
</li>
<li>
<p>按 Control+v（win 下面 ctrl+q）进入列模式</p>
</li>
<li>
<p>按大些“I”进入插入模式，输入注释符“#”或者是&quot;//&quot;，然后立刻按下 ESC（两下）</p>
</li>
</ul>
<p>取消注释：</p>
<ul>
<li>Ctrl + v 进入块选择模式，选中你要删除的行首的注释符号，注意// 要选中两个，选好之后按 d 即可删除注释</li>
</ul>
<h3 id="12-替换命令"><a class="header" href="#12-替换命令">1.2 替换命令</a></h3>
<p>批量注释：</p>
<ul>
<li>:起始行号，结束行号 s/^/注释符/g</li>
</ul>
<p>取消注释：</p>
<ul>
<li>:起始行号，结束行号 s/^注释符//g</li>
</ul>
<p>实例演示：</p>
<pre><code>在 27 - 30 行添加 // 注释
:27,30s#^#//#g

在 27 - 30 行删除 // 注释
:27,30s#^//##g

在 10 - 20 行添加 # 注释
:10,20s/^/#/g

在 10 - 20 行删除 # 注释
:10,20s/^/#/g
</code></pre>
<p>注意例子中正则的分割符使用的是相反的符号，如果匹配// 那么使用 #作分隔符这样不需要对/作转义处理，节省输入次数。</p>
<h2 id="2-复制粘贴"><a class="header" href="#2-复制粘贴">2. 复制粘贴</a></h2>
<p>Vim 中如何全选并复制？（区分大小写！！！）</p>
<ul>
<li>全部删除：按 esc 键后，先按 gg（到达顶部），然后 dG</li>
<li>全部复制：按 esc 键后，先按 gg，然后 ggyG</li>
<li>全选高亮显示：按 esc 键后，先按 gg，然后 ggvG 或者 ggVG</li>
<li>单行复制：按 esc 键后，然后 yy</li>
<li>单行删除：按 esc 键后，然后 dd</li>
<li>粘贴：按 esc 键后，然后 p</li>
</ul>
<p>vim 只能粘贴 50 行的问题：</p>
<p>在当前用户主目录（~）编辑~/.vimrc（如果不存在，新建这个文件），添加一行</p>
<pre><code class="language-text">:set viminfo='1000,&lt;500
</code></pre>
<p>至于为什么要输入输入’1000，这个其实不重要，最主要的是输入&lt;500，它是设置寄存器保存的行数的，即最大值为 500。</p>
<h2 id="3-格式化"><a class="header" href="#3-格式化">3. 格式化</a></h2>
<p>1，gg 跳转到第一行</p>
<p>2，shift+v 转到可视模式</p>
<p>3，shift+g 全选</p>
<p>4，按下神奇的 =</p>
<h4 id="4-批量替换"><a class="header" href="#4-批量替换">4. 批量替换</a></h4>
<p><code>%s/原变量名/要修改后的变量名/g</code></p>
<p>加个 c 就有 u 修改确认提示</p>
<p><code>%s/原变量名/要修改后的变量名/gc</code></p>
<p>如果是替换一个函数中的变量名，可以用 v 命令选中函数，然后替换；如果是替换若干文件中的变量（或函数）名，需要先选定 args 列表，然后用 argdo
%s//new_name/g | w 来修改加保存。</p>
<h3 id="5-查询关键字"><a class="header" href="#5-查询关键字">5. 查询关键字</a></h3>
<p><code>/key</code></p>
<p>不需要<code>：</code></p>
<p>n 下一个，N 上一个</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<h2 id="venv"><a class="header" href="#venv">venv</a></h2>
<ul>
<li>安装
<ul>
<li><code>pip install virtualenv</code></li>
</ul>
</li>
<li>创建
<ul>
<li><code>python -m venv {myenv}</code></li>
<li>myenv 是虚拟环境的名字 (其实是路径)</li>
<li>会在路径下创建一个文件夹</li>
</ul>
</li>
<li>进入
<ul>
<li><code>source /home/trdthg/myproject/bigdata20/venv/bin/activate</code></li>
<li>其实就是执行 venv 下的名字为 activate 的 shell 脚本</li>
</ul>
</li>
<li>退出
<ul>
<li>运行 <code>deactivate</code></li>
</ul>
</li>
<li>其他虚拟工具
<ul>
<li>pipenv</li>
</ul>
</li>
</ul>
<h2 id="requirementstxt"><a class="header" href="#requirementstxt">requirements.txt</a></h2>
<ul>
<li>生成项目依赖
<ul>
<li>venv
<ul>
<li><code>pip3 freeze &gt; requirements.txt</code></li>
<li>注意：如果不是在虚拟环境下执行，会把全局的依赖也加进去</li>
</ul>
</li>
<li>pipenv
<ul>
<li>略过</li>
</ul>
</li>
<li>非虚拟环境 pipreqs
<ul>
<li><code>pipreqs /path/to/project</code></li>
</ul>
</li>
</ul>
</li>
<li>使用 requirements.txt
<ul>
<li><code>pip install -r requirements.txt</code></li>
</ul>
</li>
</ul>
<h2 id="setuppy"><a class="header" href="#setuppy">setup.py</a></h2>
<p>感觉不好用</p>
<ul>
<li><a href="https://towardsdatascience.com/requirements-vs-setuptools-python-ae3ee66e28af">requirements.txt vs setup.py in Python</a></li>
</ul>
<h2 id="scrapy"><a class="header" href="#scrapy">scrapy</a></h2>
<h3 id="ip-池"><a class="header" href="#ip-池">IP 池</a></h3>
<pre><code>docker run --network host --env DB_CONN=redis://:@localhost:6379/0 -p 5010:5010 jhao104/proxy_pool:2.4.0
</code></pre>
<pre><code class="language-py">class ProxyMiddleware(object):
    def __init__(self, proxy_url):
        self.proxy_url = proxy_url

    def get_random_proxy(self):
        try:
            print(&quot;-&quot;*100)
            print(&quot;请求随机代理&quot;)
            response = requests.get(&quot;http://127.0.0.1:5010/get?type=https&quot;)
            if response.status_code == 200:
                proxy = response.json()['proxy']
                return proxy
        except requests.ConnectionError:
            return False

    def process_request(self, request, spider):
        if request.meta.get('retry_times'):
            proxy = self.get_random_proxy()
            if proxy:
                uri = f'https://{proxy}'
                print(' 使用代理 ' + proxy)
                request.meta['proxy'] = uri

    @classmethod
    def from_crawler(cls, crawler):
        settings = crawler.settings
        return cls(proxy_url=settings.get('PROXY_URL'))
</code></pre>
<h3 id="随机下载延迟"><a class="header" href="#随机下载延迟">随机下载延迟</a></h3>
<pre><code class="language-py">class RandomDelayMiddleware(object):
    def __init__(self, delay):
        self.delay = delay

    @classmethod
    def from_crawler(cls, crawler):
        delay = crawler.spider.settings.get(&quot;RANDOM_DELAY&quot;, 10)
        if not isinstance(delay, int):
            raise ValueError(&quot;RANDOM_DELAY need a int&quot;)
        return cls(delay)

    def process_request(self, request, spider):
        delay = random.randint(0, self.delay)
        print('-'*100)
        print(&quot;下载延迟：&quot;, delay, &quot;秒&quot;)
        time.sleep(delay)
</code></pre>
<h2 id="micropython"><a class="header" href="#micropython">MicroPython</a></h2>
<h3 id="micropython-----esp8266"><a class="header" href="#micropython-----esp8266">MicroPython --- esp8266</a></h3>
<h4 id="运行"><a class="header" href="#运行">运行</a></h4>
<ol>
<li>准备项目</li>
</ol>
<ul>
<li>下载 win10usb-series 的驱动</li>
<li>下载基于 ESP8266 的 MicroPython
固件<a href="https://micropython.org/download/#esp8266">MicroPython 的官网</a></li>
<li>下载串口工具<a href="https://www.putty.org/">Putty</a></li>
<li>下载<a href="https://www.espressif.com/en/support/download/other-tools">烧录工具</a></li>
<li>下载<a href="https://github.com/micropython/webrepl">webrepl 客户端</a></li>
</ul>
<ol start="2">
<li>烧录连接</li>
</ol>
<ul>
<li>烧写固件把该固件烧写到 0x0 位置即可。</li>
<li>上电打印出现下例表示成功</li>
</ul>
<pre><code class="language-java">MicroPython v1.8.6-7-gefd0927 on 2016-11-10; ESP module with ESP8266
Type &quot;help()&quot; for more information.
&gt;&gt;&gt;
</code></pre>
<p>::: warning 注意 putty 连接时，若键盘无法输入，尝试设置 (Connection -&gt; Serial -&gt; Flow control =
None) :::</p>
<h4 id="连接-wifi"><a class="header" href="#连接-wifi">连接 WiFi</a></h4>
<ul>
<li>连接</li>
</ul>
<pre><code class="language-python">import network
sta_if = network.WLAN(network.STA_IF)
sta_if.active(True)
sta_if.scan()                             # Scan for available access points
sta_if.connect(&quot;&lt;wifiname&gt;&quot;, &quot;&lt;password&gt;&quot;) # Connect to an AP
sta_if.isconnected()                      # Check for successful connection
</code></pre>
<ul>
<li>设置上电自动连接 MicroPython 初始化后都会自动执行 main.py 文件，所以我们只需要设置该文件即可上电自动连接
WiFi。打开自己常用的编辑器，输入下面代码，并保存为 main.py 文件：</li>
</ul>
<pre><code class="language-python"># main.py
import network
import webrepl
import time

SSIDs = [(&quot;602&quot;, &quot;4602yyds&quot;)]

def do_connect():
    import network
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    if not wlan.isconnected():
        print('connecting to network...')
        wlan.connect(SSIDs[0][0], SSIDs[0][1])

    start = time.time()
    while not wlan.isconnected():
        time.sleep(1)
        if time.time()-start &gt; 5:
            print(&quot;connect timeout!&quot;)
            break

    if wlan.isconnected():
        print(&quot;successfully connected!&quot;)
        print('network config:', wlan.ifconfig())

def main():
    do_connect()
main()
</code></pre>
<h4 id="webrepl-上传文件"><a class="header" href="#webrepl-上传文件">WebREPL 上传文件</a></h4>
<p>webrepl 是 MicroPython 官方提供的文件管理工具。并且有一个 webrepl 客户端工具，使用它可以通过浏览器来访 ESP8266。</p>
<ol>
<li>初始化 (putty)</li>
</ol>
<pre><code class="language-python">import webrepl_setup
</code></pre>
<ol start="2">
<li>启动 (putty)</li>
</ol>
<pre><code class="language-python">import webrepl
webrepl.start()
</code></pre>
<ol start="3">
<li>连接 (webrepl 客户端)</li>
</ol>
<ul>
<li>ESP8266 连接好 WiFi 后，输入 sta_if.ifconfig() 查看连接信息，返回的元组第一个 IP 就是无线路由器分配给 ESP8266
的 IP。</li>
<li>如果你的电脑和 ESP8266 在同一个局域网，修改 WebREPL 要连接的地址为 ESP8266 的 IP，点击「Connect」，返回「Welcome
to MicroPython!」说明连接成功，根据提示输入密码（密码默认不显示）。回车后显示「WebREPL connected」表示登录成功。</li>
<li>之后就可以用这个客户端上传下载文件了。</li>
</ul>
<h4 id="待续-14"><a class="header" href="#待续-14">待续...</a></h4>
<h2 id="conda"><a class="header" href="#conda">Conda</a></h2>
<h3 id="基本操作-1"><a class="header" href="#基本操作-1">基本操作</a></h3>
<pre><code class="language-shell"># 安装 PYTHON 指定环境
conda create -n $name python=$version
# 列出所有环境
conda env list
# 进入环境
conda activate $name
# 退出环境
conda deactivate $name
# 删除环境
conda env remove -n $name
</code></pre>
<p>::: warning 若不进入环境，默认在 base 环境进行所有操作 :::</p>
<h3 id="待续-15"><a class="header" href="#待续-15">待续...</a></h3>
<h2 id="模拟输入"><a class="header" href="#模拟输入">模拟输入</a></h2>
<h3 id="pyuserinput"><a class="header" href="#pyuserinput">PyUserInput</a></h3>
<ol>
<li>安装</li>
</ol>
<ul>
<li>安装 PyHook: <a href="https://www.lfd.uci.edu/%7Egohlke/pythonlibs/">PyHook</a> 找到 PyHook 目录，
找到对应的 python 版本，下载后直接<code>pip install pyHook‑1.5.1‑cp35‑cp35m‑win_amd64.whl</code></li>
<li>安装 PyUserInput: <code>pip install PyUserput</code></li>
</ul>
<ol start="2">
<li>基本操作</li>
</ol>
<pre><code class="language-python">from pymouse import *     # 模拟鼠标所使用的包
from pykeyboard import *   # 模拟键盘所使用的包
import time   # 连续进行两个动作可能太快而效果不明显，因此加入暂停时间

m = PyMouse()   # 鼠标的实例 m
k = PyKeyboard()   # 键盘的实例 k
x_dim, y_dim = m.screen_size()     # 获取屏幕尺寸（一般为电脑屏幕的分辨率，如 1920*1080）
# 估计需要点击的位置坐标（不知道有没有定位代码，我没找到，我是自己估计的。例如，我的电脑屏幕为 (1920，1080)，我想要单击的地方估计坐标为 (10，500)）

m.move(10, 500)   # 将鼠标移动到位（此步可忽略，直接单击也可）
time.sleep(0.5)   # 暂停 0.5s，方便观察移动结果
m.click(10, 500, 1, 1)   # 表示在 (10, 500) 的地方，单击左键
</code></pre>
<ol start="3">
<li>常用函数</li>
</ol>
<pre><code class="language-python">k.type_string('Hello, World!')	# 模拟键盘输入字符串
k.press_key('H')	# 模拟键盘按 H 键
k.release_key('H')	# 模拟键盘松开 H 键
k.tap_key(&quot;H&quot;)	# 模拟点击 H 键
k.tap_key('H',n=2,interval=5)	# 模拟点击 H 键，2 次，每次间隔 5 秒
k.tap_key(k.function_keys[5])	# 点击功能键 F5
k.tap_key(k.numpad_keys[5],3)	# 点击小键盘 5,3 次
</code></pre>
<ol start="4">
<li>组合键</li>
</ol>
<pre><code class="language-python">k.press_key(k.alt_key)	# 按住 alt 键
k.tap_key(k.tab_key)	# 点击 tab 键
k.release_key(k.alt_key)	# 松开 alt 键
</code></pre>
<ol start="5">
<li>常见的键和键值码</li>
</ol>
<pre><code class="language-python">字母和数字键     数字小键盘的键       功能键         其它键
键   键码      键   键码          键   键码       键         键码
A   65          0   96            F1   112       Backspace  8
B   66          1   97            F2   113       Tab        9
C   67          2   98            F3   114       Clear      12
D   68          3   99            F4   115       Enter      13
E   69          4   100           F5   116       Shift      16
F   70          5   101           F6   117       Control    17
G   71          6   102           F7   118       Alt        18
H   72          7   103           F8   119       Caps Lock  20
I    73         8   104           F9   120       Esc        27
J    74         9   105           F10  121       Spacebar   32
K   75          *   106           F11  122       Page Up    33
L   76          +   107           F12  123       Page Down  34
M   77        Enter 108                          End        35
N   78          -   109                          Home       36
O   79          .   110                          LeftArrow  37
P   80          /   111                          UpArrow    38
Q   81                                           RightArrow 39
R   82                                           DownArrow  40
S   83                                           Insert     45
T   84                                           Delete     46
U   85                                           Help       47
V   86                                           Num Lock   144
W  87
X   88
Y   89
Z   90
0   48
1   49
2   50
3   51
4   52
5   53
6   54
7   55
8   56
9   57
</code></pre>
<h2 id="标准库"><a class="header" href="#标准库">标准库</a></h2>
<h3 id="httpclient"><a class="header" href="#httpclient">http.client</a></h3>
<ol>
<li>demo 实例</li>
</ol>
<pre><code class="language-python">import json

h1 = HTTPConnection('127.0.0.1:7878')
body = json.dumps({&quot;aaa&quot;: 1, &quot;bbb&quot;: 2, &quot;ccc&quot;: &quot;sss&quot;}).encode(&quot;utf-8&quot;)
h1.request(&quot;POST&quot;, &quot;/&quot;, body=body, headers={&quot;Content-Type&quot;: &quot;application/json&quot;})
</code></pre>
<ol start="2">
<li>基本流程</li>
</ol>
<pre><code class="language-php">          --- start ---
                |
                |===== self.__state = _CS_IDLE
                v
HTTPConnection =&gt; _create_connect()
                |
                | socket  // 获取连接
                | _output // 储存请求字符串
                v
    request() -&gt; _send_request(method, url, body, headers)
                |
                |===== self.__state = _CS_REQ_STARTED
                v
    putrequests(method, url)
                |
                | self._output.append(method url http-vsn)
                v
[ putheaders(hdr, value) for hdr, vale in headers ]
                |
                | 形成了不带 body 的部分
                v
    endheaders(body) -&gt; _send_output(body)
                |
                |===== self.__state = _CS_REQ_STARTED
                | self.__state = _CS_REQ_SENT
                | send(msg)
                | send(body) if body exists
                | send(b&quot;0\r\n\r\n&quot;)
                v
            ---end---
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-1"><a class="header" href="#common-1">common</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步运行时"><a class="header" href="#异步运行时">异步运行时</a></h1>
<h2 id="project1"><a class="header" href="#project1">project1</a></h2>
<p>实现了一个最小的 runtime</p>
<h3 id="框架"><a class="header" href="#框架">框架</a></h3>
<ul>
<li>executor(MiniTokio): 保存任务队列，不断尝试 poll 每个 task，如果任务完成就移除队列，如果没有完成就加到队尾
<pre><code class="language-rs">struct MiniTokio {
    tasks: VecDeque&lt;Task&gt;,
}
impl MiniTokio {
    pub fn new() -&gt; Self {
        Self {
            tasks: VecDeque::new(),
        }
    }
    fn run(&amp;mut self) {
        let waker = futures::task::noop_waker();
        let mut cx = Context::from_waker(&amp;waker);
        while let Some(mut task) = self.tasks.pop_front() {
            if task.as_mut().poll(&amp;mut cx).is_pending() {
                println!(&quot;a&quot;);
                self.tasks.push_back(task);
            }
        }
    }
}
</code></pre>
</li>
<li>task: 封装了 future
<pre><code class="language-rs">type Task = Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;;
</code></pre>
</li>
<li>spawner: 作为 runtime 的函数，将 task 添加到队尾
<pre><code class="language-rs">fn spawn&lt;F&gt;(&amp;mut self, f: F)
where
    F: Future&lt;Output = ()&gt; + 'static,
{
    self.tasks.push_back(Box::pin(f));
}
</code></pre>
</li>
</ul>
<h3 id="project2"><a class="header" href="#project2">project2</a></h3>
<p>execotor 本身的 push_back 操作就是 wake 的实现</p>
<p>只要没有 ready 就重新加入队列，这种做法执行失败就立即重会占用大量 cpu 资源，应该等到 ready 是在重新唤醒 (加入队列)</p>
<pre><code class="language-rs">fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
    if (Instant::now() &gt;= self.when) {
        Poll::Ready(&quot;aaa&quot;)
    } else {
        Poll::Pending
    }
}
</code></pre>
<h2 id="project2-1"><a class="header" href="#project2-1">project2</a></h2>
<h3 id="框架-1"><a class="header" href="#框架-1">框架</a></h3>
<ul>
<li>execotor: 只需要一个 receiver，不断尝试接受任务去 poll，结果是什么无所谓
<pre><code class="language-rs">struct MiniTokio {
    sender: Sender&lt;Arc&lt;Task&gt;&gt;,  // 等会在说这个
    receiver: Receiver&lt;Arc&lt;Task&gt;&gt;,
}

impl MiniTokio {
    pub fn new() -&gt; Self {
        let (cx, rx) = crossbeam::channel::unbounded();
        Self {
            sender: cx,
            receiver: rx,
        }
    }

    fn run(&amp;self) {
        while let Ok(task) = self.receiver.recv() {
            let waker = futures::task::waker(task.clone());
            let mut cx = Context::from_waker(&amp;waker);
            let mut future = task.future.lock().expect(&quot;加锁失败&quot;);
            let _ = future.as_mut().poll(&amp;mut cx);
        }
    }
}
</code></pre>
</li>
<li>task: 除了 future 还有一个 sender, task 实现了 Waker，当 task pending 时会按照策略调用 wake 方法，
把自己 send 到 execotor
<pre><code class="language-rs">struct Task {
    future: Mutex&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + Send&gt;&gt;&gt;,
    sender: Sender&lt;Arc&lt;Task&gt;&gt;,
}

impl ArcWake for Task {
    fn wake_by_ref(arc_self: &amp;Arc&lt;Self&gt;) {
        arc_self
            .sender
            .send(arc_self.clone())
            .expect(&quot;send 会 queue 失败了&quot;);
    }
}
</code></pre>
</li>
<li>spawner: 因为 execotor 现在同时保留着 sender 和 receiver，两者都不会被 drop，程序不能正常退出，下一步需要将这两个分离
<pre><code class="language-rs">fn spawn&lt;F&gt;(&amp;self, future: F)
    where
        F: Future&lt;Output = ()&gt; + Send + 'static,
    {
        let task = Task {
            future: Mutex::new(Box::pin(future)),
            sender: self.sender.clone(),
        };
        self.sender
            .send(Arc::new(task))
            .expect(&quot;spawner send new task failed&quot;);
    }
</code></pre>
</li>
</ul>
<h3 id="wake-实现"><a class="header" href="#wake-实现">wake 实现</a></h3>
<pre><code class="language-rs">fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
    if Instant::now() &gt;= self.when {
        Poll::Ready(&quot;aaa&quot;)
    } else {
        // 这里调用 wake 依赖的是 task 实现的 wake 方法

        // 1. 立即 send
        cx.waker().wake_by_ref();

        // 2. 这个是稍微优化过的 wake 策略
        let waker = cx.waker().clone();
        let when = self.when;
        thread::spawn(move || {
            let now = Instant::now();
            if now &lt; when {
                thread::sleep(when - now);
            }
            waker.wake();
        });
        Poll::Pending
    }
}
</code></pre>
<h3 id="不优雅的关闭"><a class="header" href="#不优雅的关闭">不优雅的关闭</a></h3>
<pre><code class="language-rs">fn main() {
    let mut runtime = MiniTokio::new();
    runtime.spawn(async {
        let when = Instant::now() + Duration::from_secs(2);
        let future = Delay::new(when);

        let out = future.await;
        assert_eq!(out, &quot;aaa&quot;);

        println!(&quot;{out}&quot;);
        std::process::exit(0);  // 需要手动退出
    });
    runtime.run();
}
</code></pre>
<h3 id="project3"><a class="header" href="#project3">project3</a></h3>
<ol>
<li>分离 executor(receiver) 和 spawner(sender), 当 receiver 运行结束后 receiver 就销毁</li>
</ol>
<pre><code class="language-rs">struct Executor {
    ready_queue: Receiver&lt;Arc&lt;Task&gt;&gt;,
}

struct Task {
    future: Mutex&lt;Option&lt;BoxFuture&lt;'static, ()&gt;&gt;&gt;,
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}

struct Spawner {
    task_sender: SyncSender&lt;Arc&lt;Task&gt;&gt;,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-实现生命游戏"><a class="header" href="#wasm-实现生命游戏">Wasm 实现生命游戏</a></h1>
<h2 id="hello-wasm"><a class="header" href="#hello-wasm">hello-wasm</a></h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/WebAssembly/Rust_to_wasm">MDN 教程</a></p>
<h3 id="安装准备"><a class="header" href="#安装准备">安装准备</a></h3>
<ul>
<li>安装 Rust</li>
<li>安装 wasm-pack</li>
</ul>
<pre><code>cargo install wasm-pack
</code></pre>
<ul>
<li>安装 node.js 并注册账户</li>
</ul>
<pre><code class="language-powershell">&gt; npm adduser
Username: $username
Password:
Email: (this IS public) $you@example.com
</code></pre>
<h3 id="构建-webassembly-npm-包"><a class="header" href="#构建-webassembly-npm-包">构建 WebAssembly npm 包</a></h3>
<h4 id="新建项目"><a class="header" href="#新建项目">新建项目</a></h4>
<pre><code>cargo new --lib hello-wasm

+-- Cargo.toml
+-- src
    +-- lib.rs
</code></pre>
<h4 id="librs"><a class="header" href="#librs">lib.rs</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    pub fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h4>
<pre><code class="language-toml">[package]
name = &quot;hello-wasm&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
description = &quot;A sample project with wasm-pack&quot;
license = &quot;MIT/Apache-2.0&quot;
repository = &quot;https://github.com/yourgithubusername/hello-wasm&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
wasm-bindgen = &quot;0.2&quot;
</code></pre>
<h4 id="构建发布"><a class="header" href="#构建发布">构建发布</a></h4>
<pre><code class="language-shell"># 构建
wasm-pack build --scope $mynpmusername
# 发布
cd pkg
npm publish --access=public
</code></pre>
<h3 id="在-webpack-项目使用"><a class="header" href="#在-webpack-项目使用">在 webpack 项目使用</a></h3>
<h4 id="目录"><a class="header" href="#目录">目录</a></h4>
<pre><code>+-- site
    +-- package.json
    +-- webpack.config.js
    +-- index.html
</code></pre>
<h4 id="packagejson-1"><a class="header" href="#packagejson-1">package.json</a></h4>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;serve&quot;: &quot;webpack-dev-server&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@mynpmusername/hello-wasm&quot;: &quot;^0.1.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.25.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.2&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.1.10&quot;
  }
}
</code></pre>
<h4 id="webpackconfigjs"><a class="header" href="#webpackconfigjs">webpack.config.js</a></h4>
<pre><code class="language-js">const path = require(&quot;path&quot;);
module.exports = {
  entry: &quot;./index.js&quot;,
  output: {
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;index.js&quot;,
  },
  mode: &quot;development&quot;,
};
</code></pre>
<h4 id="indexhtml"><a class="header" href="#indexhtml">index.html</a></h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;hello-wasm example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="indexjs"><a class="header" href="#indexjs">index.js</a></h4>
<pre><code class="language-js">const js = import(&quot;./node_modules/@yournpmusername/hello-wasm/hello_wasm.js&quot;);
js.then((js) =&gt; {
  js.greet(&quot;WebAssembly&quot;);
});
</code></pre>
<h4 id="启动"><a class="header" href="#启动">启动</a></h4>
<pre><code class="language-shell">$ npm install
$ npm run serve
</code></pre>
<h2 id="康威生命游戏"><a class="header" href="#康威生命游戏">康威生命游戏</a></h2>
<h3 id="内存排布"><a class="header" href="#内存排布">内存排布</a></h3>
<p>js 的<code>Object</code>, <code>Array</code>, <code>DOM Nodes</code>等对象都存储在 GC Heap 上
wasm 的内存是和 js 分离的，线型排布，rust 的数据就存在其中</p>
<h3 id="js-与-rust-通讯"><a class="header" href="#js-与-rust-通讯">js 与 rust 通讯</a></h3>
<p>wasm 目前无法直接访问 js 的 GC Heap(这点可能会改变，wasm 提案正尝试为 wasm 加入高级数据类型),
而 js 可以直接访问 wasm 的内存数据，虽然需要把数据转换为固定大小的 buf array(u8, i32, f64 ...). wasm 函数也只能接受返回标量值。
上面的内容构成了 js 和 wasm 通讯的基本模块</p>
<h3 id="wasm-bindgen"><a class="header" href="#wasm-bindgen">wasm-bindgen</a></h3>
<p>该工具包装了 rust 数据结构，并能够将指针返回给 js，封装了 js 对象，直接调用 js-api</p>
<p>但是依然需要考虑如何设计数据结构以适配 wasm 的需要</p>
<h3 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h3>
<ul>
<li>
<p>最小化 copy 数据，在 js 和 wasm 之间拷贝数据会带来不必要的开销 如果 js 能够使用指针直接操作 wasm 数据，就能大幅减少开销</p>
</li>
<li>
<p>最小化序列化</p>
</li>
</ul>
<p>一些大型的，长期存在的数据结构应该将指针暴露给 js</p>
<h3 id="优化方向"><a class="header" href="#优化方向">优化方向</a></h3>
<ol>
<li>
<p>consle.EndTime 计算函数执行时间</p>
</li>
<li>
<p>结合浏览器性能分析工具，观察函数调用栈的时间占比</p>
</li>
<li>
<p>bench 准备项目</p>
</li>
</ol>
<ul>
<li>切换到<code>nightly</code>版本，项目根目录下增加<code>toolchain</code>文件，写入<code>nightly</code>即可</li>
<li>注释掉所有的<code>#[wasm-bindgen]</code></li>
<li>注释掉所有的<code>web-sys</code>调用</li>
</ul>
<p>开始测试，并将结果导出到 before.txt</p>
<pre><code class="language-shell">cargo bench | tee before.txt
</code></pre>
<p>从 before.txt 中获取运行结果，找到对应的二进制文件，使用 perf 再次运行这个二进制文件</p>
<pre><code>perf record -g target/release/deps/bench-2e4b55af5ebabae8 --bench
</code></pre>
<p>查看结果</p>
<pre><code>perf report
</code></pre>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241137609.png" alt="" />
按下<code>a</code>查看汇编代码的时间统计结果
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241138801.png" alt="" />
竟然相差了十几倍</p>
<pre><code>before: test universe_ticks ... bench:     215,952 ns/iter (+/- 7,814)
after : test universe_ticks ... bench:      18,912 ns/iter (+/- 5,025)
</code></pre>
<p>从 10ms 降低到 3ms
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203241453849.png" alt="" /></p>
<h3 id="-展示"><a class="header" href="#-展示">🎉 展示</a></h3>
<p>康为生命游戏
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203231913525.png" alt="图片" /></p>
<h2 id="-idea"><a class="header" href="#-idea">⭐ idea</a></h2>
<ul>
<li>字符画网页</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-quiz"><a class="header" href="#rust-quiz">Rust Quiz</a></h1>
<h2 id="1-statement-boundry"><a class="header" href="#1-statement-boundry">#1 <code>statement boundry</code></a></h2>
<h3 id="题目"><a class="header" href="#题目">题目</a></h3>
<p>下面的 1 输出是什么？</p>
<pre><code class="language-rs">macro_rules! m {
    ($( $s:stmt )*) =&gt; {
        $(
            { stringify!($s); 1 }
        )&lt;&lt;*
    };
}

fn main() {
    print!(
        &quot;{}{}{}&quot;,
        m! { return || true },
        m! { (return) || true },
        m! { {return} || true },
    );
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示"><a class="header" href="#提示">提示</a></h3>
<p>宏的输出中的表达式与 <code>1 &lt;&lt; (n - 1)</code> 效果相同，其中 n 是宏输入中包含的 Rust 语句的数量。</p>
<h3 id="解答"><a class="header" href="#解答">解答</a></h3>
<p>答案：122</p>
<p>这个问题围绕着 Rust 的语法边界设计。</p>
<blockquote>
<p>This question revolves around where the Rust grammar places statement
boundaries.</p>
</blockquote>
<p>宏的输入规则是 <code>$( $s:stmt )*</code>, 它能够匹配到 0 或多个 Rust 语句。</p>
<p>该规则内部的 <code>$s: stmt</code> 是一个片段分类符，它能够匹配到一个符合 Rust 语法规范的表达式。被匹配到的语句可以在展开后的代码中作为 <code>$s</code> 。</p>
<p>而外部的 <code>$(...)*</code> 部分表示一个重复，它可以重复匹配 0 或多次内容。</p>
<blockquote>
<p>The input rule of the macro m! is $($s:stmt)<em>which matches zero or more Rust
statements. The $(...)</em> part of the rule is a repetition which matches the
contents of the repetition zero or more times, and the $s:stmt is a fragment
specifier that matches a Rust statement (stmt) conforming to the rules of the
Rust grammar. The matched statements are available within the expanded code as
the fragment variable $s.</p>
</blockquote>
<p>语句是函数体中允许的最高级别的语法单位。下面所有的内容都是语句的例子。</p>
<blockquote>
<p>A statement is the top-level unit of syntax permitted within a function body.
All of the following are examples of statements.</p>
</blockquote>
<pre><code class="language-rs">// Items are statements.
struct S { x: u64 }

// Let-bindings are statements.
let mut s = S { x: 1 }

// Expressions are statements.
s.x + 1
</code></pre>
<p>函数体的语法要求某些类型的语句后面有一个分号，但对于宏的语法而言，分号并不是语句的一部分。</p>
<blockquote>
<p>The grammar of function bodies requires that some types of statements are followed by a semicolon, but the semicolon is not part of the statement for the purpose of macro syntax.</p>
</blockquote>
<p><code>m!</code> 将会展开成 0 或多个由 <code>&lt;&lt;</code> 分割的 <code>{ stringify!($s); 1 }</code>。<code>$(...)&lt;&lt;*</code> 部分表示重复语句之间使用 <code>&lt;&lt;</code> 作为分隔符。</p>
<blockquote>
<p>The macro m! expands to zero or more copies of <code>{ stringify!($s); 1 }</code> separated by the <code>&lt;&lt;</code> token. The <code>$(...)&lt;&lt;*</code> part of the rule is a repetition using <code>&lt;&lt;</code> as the separator.</p>
</blockquote>
<p>在宏中使用 <code>&lt;&lt;</code> 作为分隔符非常不常见。最常用的分隔符是逗号，<code>$(...),*</code>，其他的单一符号也是允许的。重要的是，<code>macro_rules!</code> 把所有的 Rust 内置操作符都当成单 token</p>
<blockquote>
<p>Using <code>&lt;&lt;</code> as a separator in a repetition in a macro is highly unusual. The most commmonly used separator is the comma, written as <code>$(...),*</code>, but any other single token is allowed here. Crucially, macro_rules! treats all built-in Rust operators as single tokens, even those that consist of multiple characters like <code>&lt;&lt;</code>.</p>
</blockquote>
<p><code>{ stringify!($s); 1 }</code> 是一个表达式，它的返回值永远是 1。<code>stringify!($s)</code> 被丢弃了，所以它和 <code>{ 1 }</code> 的效果是相同的。这里使用 <code>stringify!($s)</code> 是为了控制重复的次数，规则中定义的标志符</p>
<blockquote>
<p>The <code>{ stringify!($s); 1 }</code> is an expression whose value is always 1. The value of <code>stringify!($s)</code> is discarded, so this is equivalent to the expression <code>{ 1 }</code>. The reason for having <code>stringify!($s)</code> in there is to control the number of times the repetition is repeated, which is determined by which fragment variables are used within the repetition. Writing a repetition without using any fragment variables inside of it would not be legal.</p>
</blockquote>
<p>假设我们调用宏时传入三条语句：</p>
<blockquote>
<p>Suppose we call this macro with three of the statements shown above as input.</p>
</blockquote>
<pre><code class="language-rs">m! {
    struct S { x: u64 }
    let mut s = S { x: 1 }
    s.x + 1
}
</code></pre>
<p>这个宏会被展开为：</p>
<blockquote>
<p>The macro expands to:</p>
</blockquote>
<pre><code class="language-rs">{ stringify!(struct S { x: u64 }); 1 }
    &lt;&lt; { stringify!(let mut s = S { x: 1 }); 1 }
    &lt;&lt; { stringify!(s.x + 1); 1 }
</code></pre>
<p>每个 stringifys 都会被转为字符串字面量：</p>
<blockquote>
<p>Each of the stringifys expands to a string literal:</p>
</blockquote>
<pre><code class="language-rs">{ &quot;struct S { x: u64 }&quot;; 1 }
    &lt;&lt; { &quot;let mut s = S { x: 1 }&quot;; 1 }
    &lt;&lt; { &quot;s.x + 1&quot;; 1 }
</code></pre>
<p>字符串字面量的值没有被使用。所以这个结果等价于 <code>{ 1 } &lt;&lt; { 1 } &lt;&lt; { 1 }</code>，也等价于 <code>1 &lt;&lt; 1 &lt;&lt; 1</code>。<code>&lt;&lt;</code> 操作符就是左移；结果是 4。</p>
<blockquote>
<p>The values of the string literals are not used. In this case the expression is equivalent to <code>{ 1 } &lt;&lt; { 1 } &lt;&lt; { 1 }</code>, which is equivalent to <code>1 &lt;&lt; 1 &lt;&lt; 1</code>. The <code>&lt;&lt;</code> operator is left-associative; the numeric value of this expression is 4.</p>
</blockquote>
<p>总的来说，Rust 语句有多少，1 就重复多少次。所以这个宏就相当于 <code>1 &lt;&lt; (n - 1)</code>。当 n 为 0 时，语句无法展开，会编译失败。</p>
<blockquote>
<p>Altogether, the relevant behavior of this macro is that it evaluates to <code>1 &lt;&lt; 1 &lt;&lt; 1 &lt;&lt; ...</code> where the number of ones is equal to the number of Rust statements in the input of the macro. In closed form, the numeric value is <code>1 &lt;&lt; (n - 1)</code> where n is the number of statements, except in the case that n is zero where the macro expands to nothing and we get a syntax error at the call site.</p>
</blockquote>
<p>剩下的就是判断一下这 3 次调用分别传入了多少个 Rust 语句。</p>
<blockquote>
<p>It remains to determine how many statements are in the three invocations of m! in the quiz code.</p>
</blockquote>
<ol>
<li><code>return || true</code></li>
</ol>
<p>这是一条 return 语句，他返回的 y 是一个闭包 <code>|| true</code>。等价于 <code>(|| true)</code>。所以他会被解析为一条语句，调用 <code>m!</code> 的结果是 1。</p>
<blockquote>
<p>This is a return-expression that would return the closure <code>|| true</code>. It is
equivalent to return <code>(|| true)</code>. It is parsed as a single statement so the m! invocation evaluates to 1</p>
</blockquote>
<ol start="2">
<li><code>(return) || true</code></li>
</ol>
<p>这是一条逻辑或语句。<code>||</code> 是一个二元运算符，左侧是一个 <code>(return)</code> 语句 (或者说 <code>!</code> 类型)，右侧是一个表达式 <code>true</code>。所以 <code>(return) || true</code> 是一个语句，<code>m!</code> 的值仍然为 1。</p>
<blockquote>
<p>This is a logical-OR expression. The <code>||</code> is a binary operator, where the left-hand side is the expression <code>(return)</code> (of diverging type <code>!</code>) and the right-hand side is the expression <code>true</code>. This expression is a single statement so m! again evaluates to 1.</p>
</blockquote>
<ol start="3">
<li><code>{return} || true</code></li>
</ol>
<p>这条是两个语句！一个块表达式 <code>return</code>，后面又跟一个闭包 <code>|| true</code>。</p>
<blockquote>
<p>This one is two statements! A block-statement <code>{return}</code> followed by a closure expression <code>|| true</code>.</p>
</blockquote>
<p>Rust 的语法区分了需要分号的表达式 (作为单个表达式) 和无需分号的一组表达式。看看下面的两个例子：</p>
<blockquote>
<p>The Rust grammar distinguishes between expressions that require a semicolon in order to stand alone as a statement, and expressions that can be statements even without a semicolon. Consider two examples:</p>
</blockquote>
<pre><code class="language-rs">// 结尾不需要分号。
for t in vec {
    /* ... */
}

// 结尾需要分号。
self.skip_whitespace()?;
</code></pre>
<p>不需要分号的表达式都定义在 libsyntex 里。The distinction informs a few different early bail-out cases where the parser decides to finish parsing the current expression.(能力有限，不会翻译)</p>
<blockquote>
<p>The list of expression types that stand alone without a semicolon is defined here in libsyntax. The distinction informs a few different early bail-out cases where the parser decides to finish parsing the current expression.</p>
</blockquote>
<p>块表达式 <code>{ /* ... */ }</code> 终止一个表达式，和本题的情况相同。如果这样做在语法上是合理的，那就意味着解析器在块表达式之后不会立即消耗二元运算符。因此，我们可以这样写。</p>
<blockquote>
<p>Relevant to our case is that block expressions <code>{ /* ... */ }</code> terminate an expression if doing so would be syntactically sensible. The parser does not eagerly consume binary operators after a block expression. Thus one might write:</p>
</blockquote>
<pre><code class="language-rs">fn f() -&gt; &amp;'static &amp;'static bool {
    // 块表达式。
    {
        println!(&quot;What a silly function.&quot;);
    }

    // true 的引用的引用。
    &amp;&amp;true
}
</code></pre>
<p>为了正确解析这种情况（块表达式后面紧跟一个二元运算符），解析器需要在表达式的末尾及时终止。</p>
<blockquote>
<p>In order to parse a block followed by a binary operator, we would need to make it syntactically insensible for the parser to terminate an expression at the close curly brace. This would usually be done by wrapping in parentheses.</p>
</blockquote>
<pre><code class="language-rs">fn f() -&gt; bool {
    ({ true } &amp;&amp; true)
}
</code></pre>
<p>总之，该程序的输出是 112。</p>
<blockquote>
<p>Anyhow, the output of the program is 112.</p>
</blockquote>
<h2 id="2-impl-bitand"><a class="header" href="#2-impl-bitand">#2 <code>impl BitAnd</code></a></h2>
<h3 id="题目-1"><a class="header" href="#题目-1">题目</a></h3>
<pre><code class="language-rs">struct S(i32);

impl std::ops::BitAnd&lt;S&gt; for () {
    type Output = ();

    fn bitand(self, rhs: S) {
        print!(&quot;{}&quot;, rhs.0);
    }
}

fn main() {
    let f = || ( () &amp; S(1) );
    let g = || { () &amp; S(2) };
    let h = || ( {} &amp; S(3) );
    let i = || { {} &amp; S(4) };
    f();
    g();
    h();
    i();
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-1"><a class="header" href="#提示-1">提示</a></h3>
<p>其中一个闭包和另外三个不同。</p>
<h3 id="题解"><a class="header" href="#题解">题解</a></h3>
<p>答案：123</p>
<p>f，g 和 h 都是 <code>impl Fn()</code>。闭包的 body 都会被解析为对上面由 BitAnd Trait 定义的 bitwise-AND 操作符的调用。当闭包被调用时，bitwise-AND 会打印出右侧 S 的内容，闭包则返回 <code>()</code>。</p>
<blockquote>
<p>The closures f, g, and h are all of type impl Fn(). The closure bodies are parsed as an invocation of the user-defined bitwise-AND operator defined above by the BitAnd trait impl. When the closures are invoked, the bitwise-AND implementation prints the content of the S from the right-hand side and evaluates to ().</p>
</blockquote>
<p>闭包 i 则不痛。使用 rustfmt 格式化代码会让他更清晰：</p>
<blockquote>
<p>The closure i is different. Formatting the code with rustfmt makes it clearer how i is parsed.</p>
</blockquote>
<pre><code class="language-rs">let i = || {
    {}
    &amp;S(4)
};
</code></pre>
<p>闭包体由一个空的块状语句 {} 和后面的对 S(4) 的引用组成，而不是一个 bitwise-AND 操作。i 的类型是 <code>impl Fn() -&gt; &amp;'static S</code>。</p>
<blockquote>
<p>The closure body consists of an empty block-statement {} followed by a reference to S(4), not a bitwise-AND. The type of i is impl Fn() -&gt; &amp;'static S.</p>
</blockquote>
<p>f 对这种情况的解析是由 libsyntax 中的代码管理的。</p>
<blockquote>
<p>The parsing of this case is governed by this code in libsyntax.</p>
</blockquote>
<h2 id="3-const-initializer"><a class="header" href="#3-const-initializer">#3 <code>const initializer</code></a></h2>
<h3 id="题目-2"><a class="header" href="#题目-2">题目</a></h3>
<pre><code class="language-rs">struct S {
    x: i32,
}

const S: S = S { x: 2 };

fn main() {
    let v = &amp;mut S;
    v.x += 1;
    S.x += 1;
    print!(&quot;{}{}&quot;, v.x, S.x);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-2"><a class="header" href="#提示-2">提示</a></h3>
<p><code>const</code> 和 不可变的 <code>static</code> 有什么区别？</p>
<h3 id="题解-1"><a class="header" href="#题解-1">题解</a></h3>
<p>答案：32</p>
<p>const 的语义是，任何在表达式位置上以名称提及的 <code>const</code> 都会被 const initializer 的值所替代。上面的代码其实等同于：</p>
<blockquote>
<p>The semantics of const is that any mention of the const by name in expression position is substituted with the value of the const initializer. In this quiz code the behavior is equivalent to:</p>
</blockquote>
<pre><code class="language-rs">struct S {
    x: i32,
}

fn main() {
    let v = &amp;mut S { x: 2 };
    v.x += 1;
    S { x: 2 }.x += 1;
    print!(&quot;{}{}&quot;, v.x, S { x: 2 }.x);
}
</code></pre>
<p>这里我只是简单地把每一个提到 S 的地方都用 <code>const S</code> 的值来代替，即 <code>S { x: 2 }</code>。</p>
<blockquote>
<p>I have simply substituted every mention of S in expresson position with the value of const S which is S { x: 2 }.</p>
</blockquote>
<p>main 的第一行等同于：</p>
<blockquote>
<p>The first line of main is equivalent to:</p>
</blockquote>
<pre><code class="language-rs">let mut _tmp0 = S { x: 2 };
let v = &amp;mut _tmp0;
</code></pre>
<p>main 的第二行改变了 v 指向的 x，在 v 剩余的生命期内，x 仍然可以通过 v 访问，因此打印的第一个字符是 3。</p>
<blockquote>
<p>The second line of main mutates the value pointed to by v. The same value remains accessible through v for the rest of the lifetime of v, which is why the first character printed is 3.</p>
</blockquote>
<p>main 的第三行改变了一个临时变量，该变量在分号结尾就立即超出了作用域。打印的第二个字符来自一个全新的<code>S { x: 2 }</code>，所以第二个打印的是 2。</p>
<blockquote>
<p>The third line of main mutates a temporary that immediately goes out of scope at the semicolon. The second character printed is coming from a brand new S { x: 2 }, so 2 is printed.</p>
</blockquote>
<p>这段代码中还有一个问题，是 Rust 中关于命名空间和名字解析的概念。任何指代类型的名字都在类型命名空间，任何指代值的名字都在值命名空间。</p>
<p>这是两组不同的名字，而语言的结构使我们总是可以知道在哪个命名空间中查找一个名字。</p>
<blockquote>
<p>One additional wrinkle in this code is the concept of namespaces and name resolution in Rust. Any name that refers to a type lives in the type namespace, and any name that refers to a value lives in the value namespace. These are two separate sets of names, and the language is structured such that we can always tell which namespace to look up a name in.</p>
</blockquote>
<p>在代码的上下文中，结构体 S 的名称是类型名称空间的一部分，而常量 S 的名称是值名称空间的一部分。这就是为什么我们可以，在同一时间看到两个相同名称的不同事物。</p>
<blockquote>
<p>In the context of the quiz code, the name of the struct S is part of the type namespace and the name of the const S is part of the value namespace. That is how we can have seemingly two different things with the same name in scope at the same time.</p>
</blockquote>
<h2 id="4-"><a class="header" href="#4-">#4 <code>..</code></a></h2>
<h3 id="题目-3"><a class="header" href="#题目-3">题目</a></h3>
<pre><code class="language-rs">fn main() {
    let (.., x, y) = (0, 1, ..);
    print!(&quot;{}&quot;, b&quot;066&quot;[y][x]);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-3"><a class="header" href="#提示-3">提示</a></h3>
<p><code>..</code> 在表达中和模式匹配中含义不同。</p>
<blockquote>
<p>.. means one thing in an expression and something else in a pattern.</p>
</blockquote>
<h3 id="题解-2"><a class="header" href="#题解-2">题解</a></h3>
<p>答案：54</p>
<p>这个问题展示了 <code>..</code>不同含义</p>
<blockquote>
<p>This question demonstrates two different meanings of ...</p>
</blockquote>
<p>在表达式的一侧 (右侧), <code>..</code> 是构造闰 <code>Range</code> 类型的语法，表达式 <code>(0, 1, ..)</code> 是一个拥有三个元素的元组，其中的第三个拥有 RangeFull 类型。</p>
<blockquote>
<p>In expression position, .. is the syntax for constructing various types of ranges. Here the expression (0, 1, ..) is a tuple with three elements, the third one having type RangeFull.</p>
</blockquote>
<p>在模式的一侧，<code>..</code> 被用来表示任何数量的元素。所以模式 <code>(.., x, y)</code> 会匹配到一个拥有两个或者更多元素的元组，并把倒数第 2 个元素绑定到 x 上，最后一个数绑定到 y 上。</p>
<blockquote>
<p>On the other hand in a pattern, .. is used to mean &quot;any number of elements&quot;. So the pattern (.., x, y) matches a tuple with 2 or more elements, binding the second-last one to x and the last one to y.</p>
</blockquote>
<p>所以在面的第 1 行，x 的值为 1，y 的值为 <code>(..)</code>。因此打印出来的是 <code>b&quot;066[..][1]&quot;</code>。</p>
<blockquote>
<p>Coming out of the first line of main, we have x = 1 and y = (..). Thus the value printed is going to be b&quot;066&quot;[..][1].</p>
</blockquote>
<p><code>b&quot;066&quot;</code> 是一个表达式，他是一个 Byte 形式的字符串字面量，它的类型是 <code>&amp;'static [u8; 3]</code>, 拥有三个 ASCII 字符 <code>b'0'</code>, <code>b'6'</code>, <code>b'6'</code>。</p>
<blockquote>
<p>The expression b&quot;066&quot; is a byte-string literal of type &amp;'static [u8; 3] containing the three ASCII bytes b'0', b'6', b'6'.</p>
</blockquote>
<p>当我们用 RangeFull 对字节串进切片时，我们得到一个长度为 3 的动态大小的切片 [u8]，接下来我们访问切片在 1 处的元素，即类型为 u8 的字节 <code>b'6'</code>。当打印时，我们看到的是 ASCII 数字 6 的十进制表示，也就是数字 54。</p>
<blockquote>
<p>When we slice the byte-string with RangeFull we get a dynamically sized slice [u8] of length 3. Next we access element 1 of the slice, which is the byte b'6' of type u8. When printed, we see the decimal representation of the byte value of the ASCII digit 6, which is the number 54.</p>
</blockquote>
<h2 id="5-t-or-t"><a class="header" href="#5-t-or-t">#5 <code>T or &amp;T</code></a></h2>
<h3 id="题目-4"><a class="header" href="#题目-4">题目</a></h3>
<pre><code class="language-rs">trait Trait {
    fn p(self);
}

impl&lt;T&gt; Trait for fn(T) {
    fn p(self) {
        print!(&quot;1&quot;);
    }
}

impl&lt;T&gt; Trait for fn(&amp;T) {
    fn p(self) {
        print!(&quot;2&quot;);
    }
}

fn f(_: u8) {}
fn g(_: &amp;u8) {}

fn main() {
    let a: fn(_) = f;
    let b: fn(_) = g;
    let c: fn(&amp;_) = g;
    a.p();
    b.p();
    c.p();
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-4"><a class="header" href="#提示-4">提示</a></h3>
<p>如果你熟悉高级生命周期绑定的语法，可以尝试将 impl 签名中的所有类型和 main 中的类型解构为完全显式的形式。</p>
<blockquote>
<p>If you are familiar with higher-rank trait bound syntax, try desugaring all the types in the impl signatures and types in main into their fully explicit form.</p>
</blockquote>
<h3 id="题解-3"><a class="header" href="#题解-3">题解</a></h3>
<p>答案：112</p>
<p>第一个 impl 适用于 <code>fn(T)</code> 类型的函数指针，其中 T 是任何单一的具体类型。第二个 impl 适用于更高等级的 <code>for&lt;'a&gt; fn(&amp;'a T)</code> 类型的函数指针，其中 T 类型的生命周期超过 <code>'a</code>。</p>
<blockquote>
<p>The first impl applies to function pointers of type fn(T) where T is any single concrete type. The second impl applies to function pointers of higher-ranked type for&lt;'a&gt; fn(&amp;'a T) for some concrete type T that outlives 'a.</p>
</blockquote>
<p>在 main 中，编译器会自动使用类型推导，用某种具体的类型来替代所有出现的 <code>_</code>。</p>
<blockquote>
<p>Inside of main, the compiler is going to use type inference to substitute all occurrences of _ in a type by some concrete type.</p>
</blockquote>
<p>对于闭包 a，我们推断 <code>_ = u8</code>，闭包类型为 <code>fn(u8)</code>，接受一个 <code>u8</code> 类型的参数并返回 <code>()</code>。</p>
<blockquote>
<p>For the closure a we infer _ = u8, yielding the closure type fn(u8) taking an argument of type u8 and returning ().</p>
</blockquote>
<p>对于 b，我们推断 <code>_ = &amp;'x u8</code>, 为一些具体的生命周期 <code>'x</code>，最终将被送入借用检查器。b 的类型是 <code>fn(&amp;'x u8)</code>。</p>
<blockquote>
<p>For b we infer _ = &amp;'x u8 for some concrete lifetime 'x that will ultimately feed into the borrow checker. The type of b is fn(&amp;'x u8).</p>
</blockquote>
<p>最后，对于 c，我们推断 <code>_ = u8</code>，产生更高等级的闭包类型 <code>&lt;'a&gt; fn(&amp;'a u8)</code>。</p>
<blockquote>
<p>And finally for c we infer _ = u8, yielding the higher-ranked closure type for&lt;'a&gt; fn(&amp;'a u8).</p>
</blockquote>
<p>以此为框架，可以看出，在 main 结尾出会打印 112。</p>
<blockquote>
<p>Framed in this way, it follows that the trait method calls at the end of main print 112.</p>
</blockquote>
<h2 id="6-size-of-"><a class="header" href="#6-size-of-">#6 <code>size of ()</code></a></h2>
<h3 id="题目-5"><a class="header" href="#题目-5">题目</a></h3>
<pre><code class="language-rs">use std::mem;

fn main() {
    let a;
    let a = a = true;
    print!(&quot;{}&quot;, mem::size_of_val(&amp;a));
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-5"><a class="header" href="#提示-5">提示</a></h3>
<p>有两个名为 a 的变量，它们各自的类型是什么？</p>
<blockquote>
<p>There are two variables named a. What is the type of each one?</p>
</blockquote>
<h3 id="题解-4"><a class="header" href="#题解-4">题解</a></h3>
<p>答案：0</p>
<p>这里有两个名为 a e 的变量，第二个会 &quot;遮蔽&quot; 第一个，这段程序等价于：</p>
<blockquote>
<p>There are two variables named a, one shadowing the other. The program is equivalent to:</p>
</blockquote>
<pre><code class="language-rs">let a;
let b = a = true;
print!(&quot;{}&quot;, mem::size_of_val(&amp;b));
</code></pre>
<p>更进一步，为 b 赋的值是一个表达式 <code>a = true</code>;</p>
<blockquote>
<p>Further, the value being assigned to b is the expression a = true.</p>
</blockquote>
<p>在 Rust 里，赋值表达式的返回值始终是 <code>()</code>。在简化一下代码：</p>
<blockquote>
<p>In Rust, assignment expressions always have the value (). Simplified some more, the quiz code is equivalent to:</p>
</blockquote>
<pre><code class="language-rs">let a = true;
let b = ();
print!(&quot;{}&quot;, mem::size_of_val(&amp;b));
</code></pre>
<p>关于它的行为规范，请参考 size_of_val 的文档，但在这种情况下，它被实例化为 <code>T = ()</code>，我们最终会打印出 <code>size_of::&lt;()&gt;()</code> 的值。</p>
<blockquote>
<p>Refer to the documentation of size_of_val for a specification of its behavior, but in this case it is being instantiated with T = () and we end up printing the value of size_of::&lt;()&gt;().</p>
</blockquote>
<p><code>()</code> 是零大小类型或 ZST 的一个例子，在运行时由零字节的数据表示，所以程序会打印出 0。</p>
<blockquote>
<p>() is one example of a zero-sized type or ZST and is represented by zero bytes of data at runtime, so the program prints 0.</p>
</blockquote>
<h2 id="7-match"><a class="header" href="#7-match">#7 <code>match</code></a></h2>
<h3 id="题目-6"><a class="header" href="#题目-6">题目</a></h3>
<pre><code class="language-rs">#[repr(u8)]
enum Enum {
    First,
    Second,
}

impl Enum {
    fn p(self) {
        match self {
            First =&gt; print!(&quot;1&quot;),
            Second =&gt; print!(&quot;2&quot;),
        }
    }
}

fn main() {
    Enum::p(unsafe {
        std::mem::transmute(1u8)
    });
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-6"><a class="header" href="#提示-6">提示</a></h3>
<p>调用 <code>Enum::p</code> 时传入的参数一定是 <code>Enum::Second</code>。</p>
<blockquote>
<p>The argument of the call to Enum::p is guaranteed to be Enum::Second.</p>
</blockquote>
<h3 id="题解-5"><a class="header" href="#题解-5">题解</a></h3>
<p>答案：1</p>
<p>展开隐藏的条件，这段 Enum 的定义其实等同于：</p>
<blockquote>
<p>Filling in the implicit discriminants, the definition of Enum is equivalent to:</p>
</blockquote>
<pre><code class="language-rs">#[repr(u8)]
enum Enum {
    First = 0u8,
    Second = 1u8,
}
</code></pre>
<p><code>unsafe transmute</code> 只是转移你的注意。<code>#[repr(u8)]</code> 会确保我们的类型和 u8 有相同的内存布局，而 <code>Enum::Second</code> 的判别会确保 <code>Enum::Second</code> 和 1u8 的布局相同。因此这里的 <code>transmute</code> 的定义明确，等价于 <code>Enum::Second</code>。</p>
<blockquote>
<p>The unsafe transmute is a red herring. The attribute #[repr(u8)] guarantees that our type has the same representation as u8, and the discriminant on Enum::Second guarantees that Enum::Second has the same representation as 1u8. The transmute is well-defined and evaluates to Enum::Second.</p>
</blockquote>
<p>如果方法 p 的定时是这样的：</p>
<blockquote>
<p>If the method p had been written as:</p>
</blockquote>
<pre><code class="language-rs">match self {
    Enum::First =&gt; print!(&quot;1&quot;),
    Enum::Second =&gt; print!(&quot;2&quot;),
}
</code></pre>
<p>这个程序会打印 2。</p>
<blockquote>
<p>then this program would print 2.</p>
</blockquote>
<p>但是，模式匹配里的两个分支都是通配符，能够匹配到任何值，并把它绑定到 First 或者 Second 上。模式按顺序匹配，所以这里总是会匹配到 First 分支。</p>
<blockquote>
<p>However, as written, both arms of the match expression are wildcard matches that successfully match any value and bind a variable with the name First or Second. Match arms are applied in order so the wildcard match in the first arm is always the one matched.</p>
</blockquote>
<p>编译器会给我们两条警告。第一个是它描述了匹配的过程。</p>
<blockquote>
<p>The compiler helps us out with not one but two relevant warnings. First it describes exactly how this match is parsed and why that is probably silly.</p>
</blockquote>
<pre><code class="language-rs">warning: unreachable pattern
  --&gt; questions/007.rs:11:13
   |
10 |             First =&gt; print!(&quot;1&quot;),
   |             ----- matches any value
11 |             Second =&gt; print!(&quot;2&quot;),
   |             ^^^^^^ unreachable pattern
</code></pre>
<p>第二个是编译器意识到了程序员可能写错了代码，并给出了可能正确的提示。</p>
<blockquote>
<p>Second, it recognizes what the programmer has done wrong and what they probably meant to write instead.</p>
</blockquote>
<pre><code class="language-rs">warning[E0170]: pattern binding `First` is named the same as one of the variants of the type `Enum`
  --&gt; questions/007.rs:10:13
   |
10 |             First =&gt; print!(&quot;1&quot;),
   |             ^^^^^ help: to match on the variant, qualify the path: `Enum::First`
</code></pre>
<p>在模式中直接写限定路径的方法是把枚举的变体也引入作用域：</p>
<blockquote>
<p>An alternative to writing qualified paths in the pattern is to bring the variants into scope.</p>
</blockquote>
<pre><code class="language-rs">use Enum::*;

match self {
    First =&gt; print!(&quot;1&quot;),
    Second =&gt; print!(&quot;2&quot;),
}
</code></pre>
<p>通过<a href="https://doc.rust-lang.org/std/prelude/index.html">标准库的 prelude</a>，我们可以在模式匹配中直接使用 <code>OK</code> 和 <code>Some</code> (而不是 <code>Result::OK</code> 和 <code>Option::Some</code>)。</p>
<blockquote>
<p>Having variants brought into scope by the standard library prelude is what allows us to write Ok and Some in match arms, rather than the qualified paths Result::Ok and Option::Some.</p>
</blockquote>
<h2 id="8--"><a class="header" href="#8--">#8 <code>= = &gt;</code></a></h2>
<h3 id="题目-7"><a class="header" href="#题目-7">题目</a></h3>
<pre><code class="language-rs">macro_rules! m {
    (==&gt;) =&gt; { print!(&quot;1&quot;); };
    (= = &gt;) =&gt; { print!(&quot;2&quot;); };
    (== &gt;) =&gt; { print!(&quot;3&quot;); };
    (= =&gt;) =&gt; { print!(&quot;4&quot;); };
}

fn main() {
    m!(==&gt;);
    m!(= = &gt;);
    m!(== &gt;);
    m!(= =&gt;);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-7"><a class="header" href="#提示-7">提示</a></h3>
<p>根据 <code>macro_rules!</code> 的规则，<code>==</code> 是一个 token，<code>=&gt;</code> 也是一个 token。</p>
<blockquote>
<p>According to macro_rules!, == is one token and =&gt; is one token.</p>
</blockquote>
<h3 id="题解-6"><a class="header" href="#题解-6">题解</a></h3>
<p>答案：1214</p>
<p>在 <code>macro_rules!</code> 的输入模式中，相邻的标点符号根据它们的用法不同，会被划分为几组。</p>
<blockquote>
<p>Adjacent punctuation characters in the input pattern of a macro_rules! macro are grouped according to how those characters are used by native Rust tokens.</p>
</blockquote>
<p><a href="https://docs.rs/syn/0.15.22/syn/token/index.html#structs">这里</a>列出了 Rust 中的单字符和多字符 token 列表</p>
<blockquote>
<p>This page contains a list of the single-character and multi-character punctuation tokens involved in the Rust grammar.</p>
</blockquote>
<p>列表中的有一个例子，<code>&lt;&lt;=</code> 是一个 token，Rust 语法把它作为左移赋值。因此包含 <code>&lt;&lt;=</code> 的一个 <code>macro_rules!</code> 输入，只有遇到 <code>&lt;&lt;=</code> 且中间没有空格时才会匹配。</p>
<blockquote>
<p>As one example from that list, <code>&lt;&lt;=</code> is a single token because the Rust grammar uses that sequence of characters to mean left shift assignment. Thus a macro_rules! input rule containing <code>&lt;&lt;=</code> would only match if all three characters <code>&lt;&lt;=</code> are written consecutively without spaces in the invocation.</p>
</blockquote>
<p>但是 <code>=&lt;&lt;</code> 在 Rust 语法中不是一个 native token。macro_rules！的解析器会根据贪心将其分解为 Rust 标记。 <code>=&lt;</code> 也不是一个 native token，所以首先我们需要匹配一个 <code>=</code> 本身。然后，<code>&lt;&lt;</code> 是一个 native token。在宏规则中写 <code>=&lt;&lt;</code> 的行为与写 <code>= &lt;&lt;</code> 的行为完全相同。</p>
<blockquote>
<p>But for example <code>=&lt;&lt;</code> is not a native token in the Rust grammar. The parser of macro_rules! will decompose this into Rust tokens according to a greedy process. <code>=&lt;</code> is also not a native token, so first we would need to match a <code>=</code> by itself. Then <code>&lt;&lt;</code> is a native token. Writing <code>=&lt;&lt;</code> in a macro rule behaves exactly the same as writing <code>= &lt;&lt;</code>.</p>
</blockquote>
<p>现在让我们以同样的方式分解代码中的规则。</p>
<blockquote>
<p>Now let's decompose the rules in the quiz code the same way.</p>
</blockquote>
<ul>
<li><code>==&gt;</code> 分解为 <code>== &gt;</code>。</li>
<li><code>= = &gt;</code> 已经被分解了。</li>
<li><code>== &gt;</code> 已经被分解了。</li>
<li><code>= =&gt;</code> 已经被分解了。</li>
</ul>
<p>在我们的宏里，第一条规则加不加空格是一样的。第三条规则是不可达的。</p>
<blockquote>
<p>Our macro is the same as if we had written the first rule with a space. The third rule is unreachable.</p>
</blockquote>
<pre><code class="language-rs">macro_rules! m {
    (== &gt;) =&gt; { print!(&quot;1&quot;); };
    (= = &gt;) =&gt; { print!(&quot;2&quot;); };
    (== &gt;) =&gt; { print!(&quot;3&quot;); };
    (= =&gt;) =&gt; { print!(&quot;4&quot;); };
}
</code></pre>
<p>在 main 中，第一行和第三行都符合第一条宏规则。第二行匹配第二条规则，第四行匹配第四条规则。输出结果是 1214。</p>
<blockquote>
<p>Within main, the first and third lines both match the first macro rule. The second line matches the second rule and the fourth line matches the fourth rule. The output is 1214.</p>
</blockquote>
<p>过程宏使用更灵活、更强大的宏 API，并且总是能够区分相同字符的不同间隔，例如 <code>== &gt;</code> 与 <code>==&gt;</code>。</p>
<blockquote>
<p>Procedural macros use a more flexible and powerful macro API and can always distinguish between different spacings of the same characters, such as == &gt; vs ==&gt;.</p>
</blockquote>
<h2 id="9-tttt"><a class="header" href="#9-tttt">#9 <code>$tt:tt</code></a></h2>
<h3 id="题目-8"><a class="header" href="#题目-8">题目</a></h3>
<pre><code class="language-rs">macro_rules! m {
    (1) =&gt; { print!(&quot;1&quot;) };
    ($tt:tt) =&gt; { print!(&quot;2&quot;) };
}

macro_rules! e {
    ($e:expr) =&gt; { m!($e) };
}

macro_rules! t {
    ($tt:tt) =&gt; { e!($tt); m!($tt); };
}

fn main() {
    t!(1);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-8"><a class="header" href="#提示-8">提示</a></h3>
<p>一旦被匹配为 <code>$:expr</code>，匹配到的表达式就变成了一个不透明的标记树。</p>
<blockquote>
<p>Upon being matched as a $:expr, the matched expression becomes a single opaque token tree.</p>
</blockquote>
<h3 id="题解-7"><a class="header" href="#题解-7">题解</a></h3>
<p>答案：21</p>
<p>这个问题涉及到宏匹配器在匹配宏的元变量时的行为。</p>
<blockquote>
<p>This question involves the behavior of macro matchers as regards matching macro metavariables.</p>
</blockquote>
<p>从代码的最后一行看起，<code>t!(1)</code> 会匹配到 <code>t!</code> 的第一条规则，然后展开为 <code>e!(1); m!(1);</code></p>
<blockquote>
<p>Starting from the bottom of the quiz code, the invocation t!(1) matches the first rule of t! and expands to e!(1); m!(1);.</p>
</blockquote>
<p>调用 <code>e!(1)</code> 会匹配 <code>e!</code> 的第一条规则。作为这个匹配的一部分，表达式 <code>1</code> 会被打包成一个不透明的表达式 token，称为 <code>$e</code>。在接下来的任何时候，任何 <code>macro_rules！</code>宏都不可能查看 <code>$e</code> 的内部，唯一可以知道的是 <code>$e</code> 是某个表达式。</p>
<blockquote>
<p>The invocation e!(1) matches the first rule of e!. As part of this match, the expression 1 is packaged into an opaque expression token called $e. At no subsequent point will it be possible for any macro_rules! macro to look inside of $e. All that can be known is that $e is some expression.</p>
</blockquote>
<p>在任何情况下，<code>e!(1)</code> 都会扩展为 <code>m!($e)</code>，其中 <code>$e</code> 是一个包含 <code>1</code> 的不透明表达式。<code>m!($e)</code> 并不符合 <code>m!</code> 的第一条规则，因为 <code>$e</code> 是不透明的。所以它匹配了 <code>m!</code> 的第二条规则，并打印出 2。</p>
<blockquote>
<p>In any case, e!(1) expands to m!($e) where $e is an opaque expression containing 1. That m!($e) does not match the first rule of m! because $e is opaque. Instead it matches the second rule of m! and prints 2.</p>
</blockquote>
<p>在 <code>e!(1)</code> 之后有一个对 <code>m!(1)</code> 的调用，来自 <code>t!</code> 的展开。这个调用确实符合 <code>m!</code> 的第一条规则，并打印出 1。所以这个程序的输出是 21。</p>
<blockquote>
<p>After e!(1) there is an invocation m!(1) coming from the expansion of t!. That one does match the first rule of m! and prints 1. The output of this program is 21.</p>
</blockquote>
<p>大多数片段分类符都有这种变为不透明 token 的行为，但有些没有。一旦匹配到就变为不透明 token 的片段分类符：</p>
<blockquote>
<p>Most fragment specifiers have this behavior of becoming opaque token boxes, but some do not. Specifiers that are opaque once matched:</p>
</blockquote>
<pre><code class="language-rs">$:block
$:expr
$:item
$:literal
$:meta
$:pat
$:path
$:stmt
$:ty
</code></pre>
<p>剩下的片段分类符匹配成功后不会变为不透明的，可以被后续的规则检查到：</p>
<blockquote>
<p>The rest of the specifiers do not become opaque and can be inspected by subsequent rules:</p>
</blockquote>
<pre><code class="language-rs">$:ident
$:lifetime
$:tt
</code></pre>
<p>比如：</p>
<blockquote>
<p>For example:</p>
</blockquote>
<pre><code class="language-rs">macro_rules! m {
    ('a) =&gt; {};
}

macro_rules! l {
    ($l:lifetime) =&gt; {
        // $l is not opaque.
        m!($l);
    }
}

l!('a);
</code></pre>
<h2 id="10-traitf"><a class="header" href="#10-traitf">#10 <code>Trait::f</code></a></h2>
<h3 id="题目-9"><a class="header" href="#题目-9">题目</a></h3>
<pre><code class="language-rs">trait Trait {
    fn f(&amp;self);
}

impl&lt;'a&gt; dyn Trait + 'a {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for bool {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    Trait::f(&amp;true);
    Trait::f(&amp;true as &amp;dyn Trait);
    &lt;_ as Trait&gt;::f(&amp;true);
    &lt;_ as Trait&gt;::f(&amp;true as &amp;dyn Trait);
    &lt;bool as Trait&gt;::f(&amp;true);
    &lt;dyn Trait as Trait&gt;::f(&amp;true as &amp;dyn Trait);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-9"><a class="header" href="#提示-9">提示</a></h3>
<p>这并不能帮助你解决问题，但可能会让你好受些：作者也被这个问题难住了。</p>
<blockquote>
<p>This won't help you answer the question but may help feel better: the quiz author was also stumped by this one.</p>
</blockquote>
<h3 id="题解-8"><a class="header" href="#题解-8">题解</a></h3>
<p>答案：222222</p>
<p>这道题里有一个 Trait 方法 <code>Trait::f</code>，同时还有特征对象 <code>dyn Trait</code> 的 f 方法。</p>
<blockquote>
<p>This question contains a trait method <code>Trait::f</code> as well as an inherent method f on the trait object type dyn Trait.</p>
</blockquote>
<p>据我所知，鉴于这些名字会相互遮蔽，在 <code>dyn Trait</code> 实现的 <code>f</code> 方法实际上是无法调用的。目前，Rust 中没有任何语法可以在 <code>dyn Trait</code> 上调用它的 <code>f</code>。</p>
<blockquote>
<p>As far as I know, given that these names shadow each other, the inherent method is literally uncallable. There is currently no syntax in Rust for calling the inherent f on dyn Trait.</p>
</blockquote>
<p>如果 trait 方法的名字可以以不同的方式命名，并且只有 <code>dyn Trait</code> 的方法被称为 <code>f</code>，那么 main 的前两行就会成功调用 <code>dyn Trait</code> 的方法。然而，由于写的是被遮蔽的名字，这会导致歧义，最后调用的是 Trait 的方法。</p>
<blockquote>
<p>If the trait method were named something different and only the inherent method were called f, then the first two lines of main would successfully call the inherent method. However, as written with shadowed names, they disambiguate to the trait method.</p>
</blockquote>
<p>还有一种可以尝试的语法：</p>
<blockquote>
<p>One additional syntax to try would be:</p>
</blockquote>
<pre><code class="language-rs">&lt;dyn Trait&gt;::f(&amp;true);
&lt;dyn Trait&gt;::f(&amp;true as &amp;dyn Trait);
</code></pre>
<p>如果特征方法的命名不同，这两个调用都会调用 <code>dyn Trait</code> 的 <code>f</code> 方法。如果 <code>dyn Trait</code> 的方法被命名为不同的东西，这两个方法都会调用 Trait 方法。但是如果 <code>Trait</code> 方法和 <code>dyn Trait</code> 方法都叫作 f，那么编译器会报告一个歧义。</p>
<blockquote>
<p>If the trait method were named something different, both of these would call the inherent method. If the inherent method were named something different, both of these would call the trait method. But if the trait method and the inherent method are both f then the compiler reports an ambiguity.</p>
</blockquote>
<pre><code class="language-rs">error[E0034]: multiple applicable items in scope
  --&gt; questions/010.rs:18:5
   |
18 |     &lt;dyn Trait&gt;::f(&amp;true);
   |     ^^^^^^^^^^^^^^ multiple `f` found
   |
note: candidate #1 is defined in an impl for the type `dyn Trait`
  --&gt; questions/010.rs:6:5
   |
6  |     fn f(&amp;self) {
   |     ^^^^^^^^^^^
note: candidate #2 is defined in the trait `Trait`
  --&gt; questions/010.rs:2:5
   |
2  |     fn f(&amp;self);
   |     ^^^^^^^^^^^^
   = help: to disambiguate the method call, write `Trait::f(...)` instead
</code></pre>
<p>也许有一天，在一个被特征方法所遮蔽的特征对象上调用它的方法可能消除歧义。但是现在，代码只能打印出 222222。</p>
<blockquote>
<p>Maybe some day it will be possible to disambiguate a call to an inherent method on a trait object shadowed by a trait method. For now, the quiz code prints 222222.</p>
</blockquote>
<h2 id="11-early--late-bound"><a class="header" href="#11-early--late-bound">#11 <code>early &amp; late bound</code></a></h2>
<h3 id="题目-10"><a class="header" href="#题目-10">题目</a></h3>
<pre><code class="language-rs">fn f&lt;'a&gt;() {}
fn g&lt;'a: 'a&gt;() {}

fn main() {
    let pf = f::&lt;'static&gt; as fn();
    let pg = g::&lt;'static&gt; as fn();
    print!(&quot;{}&quot;, pf == pg);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-10"><a class="header" href="#提示-10">提示</a></h3>
<p>f 和 g 的写法是不能互换的。</p>
<blockquote>
<p>The way that f and g are written is not interchangeable.</p>
</blockquote>
<h3 id="题解-9"><a class="header" href="#题解-9">题解</a></h3>
<p>答案：编译失败</p>
<p>比较函数指针是一个坏主意。在优化后的构建中，很容易出现无意义的行为。关于这种行为的一个令人瞠目结舌的例子，请看 <a href="https://github.com/rust-lang/rust/issues/54685">rust-lang/rust#54685</a>，其中 x == y 同时为真，又不为真。(译者注：该问题已修复)</p>
<blockquote>
<p>Function pointer comparison is generally a Bad Idea. It is easily possible to get nonsensical behavior in optimized builds. For a jaw-dropping example of such behavior, check out rust-lang/rust#54685 in which x == y is both true and not true at the same time.</p>
</blockquote>
<p>那就是说，这段代码编译失败。下面是编译的输出：</p>
<blockquote>
<p>That said, the quiz code in this question fails to compile. Here is the compiler output:</p>
</blockquote>
<pre><code class="language-rs">error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present
 --&gt; questions/011.rs:5:18
  |
5 |     let pf = f::&lt;'static&gt; as fn();
  |                  ^^^^^^^
  |
note: the late bound lifetime parameter is introduced here
 --&gt; questions/011.rs:1:18
  |
1 | fn f&lt;'a&gt;() {}
  |      ^^
</code></pre>
<p>泛型参数可以是早绑定也可以是晚绑定。目前 (以及可以遇见的未来) 类型参数都是早绑定，但是生命周期参数两者都有可能。</p>
<blockquote>
<p>Generic parameters can be either early bound or late bound. Currently (and for the foreseeable future) type parameters are always early bound, but lifetime parameters can be either early or late bound.</p>
</blockquote>
<p>早绑定是在编译器在单态化过程中决定的。因为类型参数总是早绑定，你不能拥有一个泛型未指定的值。</p>
<blockquote>
<p>Early bound parameters are determined by the compiler during monomorphization. Since type parameters are always early bound, you cannot have a value whose type has an unresolved type parameter. For example:</p>
</blockquote>
<pre><code class="language-rs">fn m&lt;T&gt;() {}

fn main() {
    let m1 = m::&lt;u8&gt;; // ok
    let m2 = m; // error: cannot infer type for `T`
}
</code></pre>
<p>但是，对于生命周期是合法的：</p>
<blockquote>
<p>However, this is often allowed for lifetime parameters:</p>
</blockquote>
<pre><code class="language-rs">fn m&lt;'a&gt;(_: &amp;'a ()) {}

fn main() {
    let m1 = m; // 即使没有提供 'a 也可以
}
</code></pre>
<p>因为 'a 的具体取值取决与它如何被调用，用户可以省略生命周期参数，他会在调用是决定。生命周期甚至可以在每次调用时都不一样。</p>
<blockquote>
<p>Since the actual choice of lifetime 'a depends on how it is called, we are allowed to omit the lifetime parameter and it will be determined at the call site. The lifetime can even be different for each time it gets called.</p>
</blockquote>
<p>鉴于此，我们不能在调用前指定函数上的生命周期。</p>
<blockquote>
<p>For this reason, we cannot specify the lifetime on this function until it is called:</p>
</blockquote>
<pre><code class="language-rs">// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present
let m2 = m::&lt;'static&gt;;
</code></pre>
<p>我们甚至不能让借用检查器提前自动推断：</p>
<blockquote>
<p>We may not even ask the borrow checker to infer it too soon:</p>
</blockquote>
<pre><code class="language-rs">// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present
let m3 = m::&lt;'_&gt;;
</code></pre>
<p>晚绑定参数的概念与 Rust 中的另一个特性 &quot;高阶生命周期&quot; 有些重复。这是一种用于表达特征参数的边界是晚绑定的机制。目前这只限于生命周期参数，但在其他语言（如 Haskell）中也存在同样的想法，用于类型参数，这就是 &quot;高级&quot; 一词的由来。</p>
<blockquote>
<p>The idea of late bound parameters overlaps considerably with a feature of Rust called &quot;higher ranked trait bounds&quot; (HRTB). This is a mechanism for expressing that bounds on a trait's parameters are late bound. Currently this is limited to lifetime parameters, but the same idea exists in other languages (such as Haskell) for type parameters, which is where the term &quot;higher ranked&quot; comes from.</p>
</blockquote>
<p>表达 HRTB 的语法需要使用 for 关键字。为了表达上面 m1 的类型，你可以这么写：</p>
<blockquote>
<p>The syntax to express a HRTB for lifetimes uses the for keyword. To express the type of m1 above, we could have written:</p>
</blockquote>
<pre><code class="language-rs">let m1: impl for&lt;'r&gt; Fn(&amp;'r ()) = m;
</code></pre>
<p>你可以把它看成：&quot;这里有一个生命周期参数，但是目前我们不需要知道它具体是什么&quot;.</p>
<blockquote>
<p>You can think of this as meaning: &quot;There is a lifetime but we don't need to know what it is just yet&quot;.</p>
</blockquote>
<p>晚绑定的生命周期是无限制的；没有明确的语法来表达一个晚绑定的生命周期必须超过其他的生命周期。</p>
<blockquote>
<p>Late bound lifetimes are always unbounded; there is no syntax for expressing a late bound lifetime that must outlive some other lifetime.</p>
</blockquote>
<pre><code class="language-rs">error: lifetime bounds cannot be used in this context
 --&gt; src/main.rs:5:20
  |
5 |     let _: for&lt;'b: 'a&gt; fn(&amp;'b ());
  |                    ^^
</code></pre>
<p>数据类型上的生命周期总是早绑定，除非开发者明确使用 HRBT 的语法。在函数上，生命周期默认是晚绑定，在下列情况下可以是早绑定：</p>
<blockquote>
<p>Lifetimes on data types are always early bound except when the developer has explicitly used the HRTB for syntax. On functions, lifetimes are late bound by default but can be early bound if:</p>
</blockquote>
<ul>
<li>
<p>生命周期在函数签名之外声明，例如，在一个结构体的方法中;或者</p>
<blockquote>
<p>The lifetime is declared outside the function signature, e.g. in an associated method of a struct it could be from the struct itself; or</p>
</blockquote>
</li>
<li>
<p>生命周期参数被其他一些更长的生命周期所约束。正如我们所看到的，这种约束在 HRTB 中是无法表达的，因为 HRTB 会涉及到生命周期的晚绑定。</p>
<blockquote>
<p>The lifetime parameter is bounded below by some other lifetime that it must outlive. As we've seen, this constraint is not expressible in the HRTB that would be involved in late binding the lifetime.</p>
</blockquote>
</li>
</ul>
<p>根据这些规则，签名 <code>fn f&lt;'a&gt;()</code> 有一个晚期绑定的生命周期参数，而签名 <code>fn g&lt;'a: 'a&gt;()</code> 有一个早绑定的生命周期参数 -- 尽管这里的约束是无效的。</p>
<blockquote>
<p>By these rules, the signature fn f&lt;'a&gt;() has a late bound lifetime parameter while the signature fn g&lt;'a: 'a&gt;() has an early bound lifetime parameter — even though the constraint here is ineffectual.</p>
</blockquote>
<p>通常情况下，这些区别是编译器内部的术语，Rust 程序员在日常编写代码时并不需要了解或思考这些术语。只有在少数边缘情况下，类型系统的这个方面在语言中是可以观察到的，比如在这道 Quiz 的代码中。</p>
<blockquote>
<p>Ordinarily these distinctions are compiler-internal terminology that Rust programmers are not intended to know about or think about in everyday code. There are only a few edge cases where this aspect of the type system becomes observable in the surface language, such as in the original quiz code.</p>
</blockquote>
<h2 id="12-let-s--x----s"><a class="header" href="#12-let-s--x----s">#12 <code>let S { x, .. } = S</code></a></h2>
<h3 id="题目-11"><a class="header" href="#题目-11">题目</a></h3>
<pre><code class="language-rs">struct D(u8);

impl Drop for D {
    fn drop(&amp;mut self) {
        print!(&quot;{}&quot;, self.0);
    }
}

struct S {
    d: D,
    x: u8,
}

fn main() {
    let S { x, .. } = S {
        d: D(1),
        x: 2,
    };
    print!(&quot;{}&quot;, x);

    let S { ref x, .. } = S {
        d: D(3),
        x: 4,
    };
    print!(&quot;{}&quot;, x);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-11"><a class="header" href="#提示-11">提示</a></h3>
<p>模式 <code>S { ref x, .. }</code> 从 S 类型的值的所有者那里借用了一个 x 成员，并绑定到了变量 x 上。</p>
<blockquote>
<p>The pattern <code>S { ref x, .. }</code> borrows a binding x from the owner of a value of type S.</p>
</blockquote>
<h3 id="题解-10"><a class="header" href="#题解-10">题解</a></h3>
<p>答案：1243</p>
<p>模式 <code>S { ref x, .. }</code> 从 S 类型的值的所有者那里借用一个绑定的 x。这个问题涉及到 drop 触发的位置。D 在哪里被 drop？</p>
<blockquote>
<p>This question involves drop-placement. Where does D get dropped?</p>
</blockquote>
<p>在第一个 let-binding 中，我们将一个 S 类型的值解构为它的 u8 类型的字段 x 以及代表 &quot;S 的其余部分&quot; 的 <code>..</code>。<code>..</code> 会立即被 drop，因为它不再有所有者。</p>
<blockquote>
<p>In the first let-binding, we destructure a value of type S into its field x of type u8 as well as .. which represents &quot;the rest of S&quot;. The part that is the rest of S is dropped immediately at that point because it no longer has an owner.</p>
</blockquote>
<p>在第二个 let-binding 中，我们从 S 类型的值的所有者那里借用一个字段 x。在字段 x 被借用期间，整个 S 类型的值将保持在作用域内，并在 main 的闭合大括号处退出作用域。</p>
<blockquote>
<p>In the second let-binding, we borrow a field x from the owner of a value of type S. The whole value of type S remains in scope during the time that its field x is borrowed, and goes out of scope at the close curly brace of main.</p>
</blockquote>
<p>最后的输出是 1243。</p>
<blockquote>
<p>The output is 1243.</p>
</blockquote>
<h2 id="13-eq"><a class="header" href="#13-eq">#13 <code>eq</code></a></h2>
<h3 id="题目-12"><a class="header" href="#题目-12">题目</a></h3>
<pre><code class="language-rs">struct S;

fn main() {
    let [x, y] = &amp;mut [S, S];
    let eq = x as *mut S == y as *mut S;
    print!(&quot;{}&quot;, eq as u8);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-12"><a class="header" href="#提示-12">提示</a></h3>
<p>两个可变引用指向同一个内存位置可以吗？会出什么问题呢？</p>
<blockquote>
<p>Is it okay for two mutable references to point to the same memory location? What could go wrong?</p>
</blockquote>
<h3 id="题解-11"><a class="header" href="#题解-11">题解</a></h3>
<p>答案：1</p>
<p>在这段代码中，S 是一个零大小类型。零大小类型是编译时的概念，在编译过程中会消失，在运行时会以零字节表示。</p>
<blockquote>
<p>In this code, S is a zero sized type or ZST. Zero sized types are compile-time concepts that disappear during compilation and have a runtime representation of zero bytes.</p>
</blockquote>
<p>main 的第一行创建了一个类型为 [S; 2] 的本地值。让我们把这个临时值称为 tmp。let-binding 在 tmp 中绑定了两个引用，x 指的是 <code>&amp;mut tmp[0]</code>，y 指的是 <code>&amp;mut tmp[1]</code>。</p>
<blockquote>
<p>The first line of main creates a local value of type [S; 2]. Let's refer to that temporary as tmp. The let-binding binds two references into tmp, x referring to &amp;mut tmp[0] and y referring to &amp;mut tmp[1].</p>
</blockquote>
<p>在 main 的第二行，我们想知道作为指针的 x 和 y 是否有相同的值。</p>
<blockquote>
<p>On the second line of main we want to know whether x and y as pointers have the same value.</p>
</blockquote>
<p>数组类型 <code>[S; 2]</code> 本身就是一个零大小的类型。你可以通过打印 <code>std::mem::size_of::&lt;[S; 2]&gt;()</code> 的值来确认这点。事实上，数组的第一个和第二个元素有相同的内存地址。</p>
<blockquote>
<p>The array type <code>[S; 2]</code> is itself a zero sized type. You can confirm this by printing the value of <code>std::mem::size_of::&lt;[S; 2]&gt;()</code>. Indeed the first and second element of the array have the same memory address.</p>
</blockquote>
<p>通常情况下，对同一内存位置有多个可变引用是不安全的，但是在对零大小类型的可变引用的情况下，解引用是不可行的，所以这种方式没有违反任何内存安全保证。</p>
<blockquote>
<p>Ordinarily having multiple mutable references to the same memory location would not be safe, but in the case of mutable references to zero sized types, dereferencing is a no-op so there is no way to violate any memory safety guarantees this way.</p>
</blockquote>
<h2 id="14-trait-scope"><a class="header" href="#14-trait-scope">#14 <code>trait scope</code></a></h2>
<h3 id="题目-13"><a class="header" href="#题目-13">题目</a></h3>
<pre><code class="language-rs">trait Trait: Sized {
    fn is_reference(self) -&gt; bool;
}

impl&lt;'a, T&gt; Trait for &amp;'a T {
    fn is_reference(self) -&gt; bool {
        true
    }
}

fn main() {
    match 0.is_reference() {
        true =&gt; print!(&quot;1&quot;),
        false =&gt; print!(&quot;0&quot;),
    }

    match '?'.is_reference() {
        true =&gt; print!(&quot;1&quot;),
        false =&gt; {
            impl Trait for char {
                fn is_reference(self) -&gt; bool {
                    false
                }
            }
            print!(&quot;0&quot;)
        }
    }
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-13"><a class="header" href="#提示-13">提示</a></h3>
<p>在这个 <a href="https://stackoverflow.com/a/28552082/6086311">Stack Overflow</a> 的答案中涉及到 trait 方法的自动引用。</p>
<blockquote>
<p>Trait method auto-ref is covered in this Stack Overflow answer.</p>
</blockquote>
<h3 id="题解-12"><a class="header" href="#题解-12">题解</a></h3>
<p>答案：10</p>
<p>程序中所有的 <code>Trait impls</code> 都是在作用域内的，所以在一个代码块内编写的对 char 的 Trait impl 没有任何意义。特别是，这个 impl 在整个程序中都是可见的，而不仅仅是在包含该 impl 的代码块中。</p>
<blockquote>
<p>Trait impls anywhere in a program are always in scope, so there is no significance to the impl Trait for char being written inside of a block of code. In particular, that impl is visible throughout the whole program, not just within the block containing the impl.</p>
</blockquote>
<p>这个问题与 trait 方法自动引用的行为有关，这个问题在 <a href="https://stackoverflow.com/a/28552082/6086311">Stack Overflow</a> 的答案中有所涉及。</p>
<blockquote>
<p>This question relates to the behavior of trait method auto-ref which is covered in this Stack Overflow answer.</p>
</blockquote>
<p>对 <code>0.is_reference()</code> 的调用观察到没有一个我们可以直接调用的为整数类型的 Trait 的实现。所以方法解析自动插入了一个引用，即 <code>(&amp;0).is_reference()</code>。这一次的调用与 <code>&amp;'a, T&gt; Trait</code> 的 <code>impl&lt;'a, T&gt;</code> 匹配，并打印出 1。</p>
<blockquote>
<p>The call to <code>0.is_reference()</code> observes that there is no implementation of Trait for an integer type that we could call directly. Method resolution inserts an auto-ref, effectively evaluating <code>(&amp;0).is_reference()</code>. This time the call matches impl&lt;'a, T&gt; Trait for &amp;'a T and prints 1.</p>
</blockquote>
<p>对 <code>'?'.is_reference()</code> 的调用反而找到了 <code>char</code> 的 <code>implated Trait</code>，打印出 0。</p>
<blockquote>
<p>The call to <code>'?'.is_reference()</code> instead finds impl Trait for char, printing 0.</p>
</blockquote>
<h2 id="15-type-inference"><a class="header" href="#15-type-inference">#15 <code>type inference</code></a></h2>
<h3 id="题目-14"><a class="header" href="#题目-14">题目</a></h3>
<pre><code class="language-rs">trait Trait {
    fn f(&amp;self);
}

impl Trait for u32 {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl&lt;'a&gt; Trait for &amp;'a i32 {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = &amp;0;
    x.f();
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-14"><a class="header" href="#提示-14">提示</a></h3>
<p>类型推断会推断出 x 是什么类型？</p>
<blockquote>
<p>What type would type inference infer for x?</p>
</blockquote>
<h3 id="题解-13"><a class="header" href="#题解-13">题解</a></h3>
<p>答案：1</p>
<p>在类型推断过程中，变量 x 的类型是 <code>&amp;{integer}</code>，是对某个尚未确定的整数类型的引用。</p>
<blockquote>
<p>During type inference the variable x has type &amp;{integer}, a reference to some as yet undetermined integer type.</p>
</blockquote>
<p>如果我们想解决 trait 方法的调用 <code>Trait::f(x)</code>，我们发现它的参数 x 必须是 <code>&amp;Self</code> 类型，即实现了 Trait 的某个 Self 类型。我们发现推断 <code>0: u32</code> 既满足了 u32 是一个整数的约束，也满足了 u32 实现了 Trait，所以这个方法调用最终调用了 <code>&lt;u32 as Trait&gt;::f(x)</code> 并打印出 1。</p>
<blockquote>
<p>If we want to resolve the trait method call <code>Trait::f(x)</code>, we find that its argument x must be of type <code>&amp;Self</code> for some type Self that implements Trait. We find that inferring 0: u32 satisfies both the constraint that u32 is an integer as well as u32 implements Trait, so the method call ends up calling <code>&lt;u32 as Trait&gt;::f(x)</code> and prints 1.</p>
</blockquote>
<p>在这个 <a href="https://stackoverflow.com/a/28552082/6086311">Stack Overflow</a> 的答案中详细介绍了 Trait 方法的解析。</p>
<blockquote>
<p>Trait method resolution is covered in more detail in this <a href="https://stackoverflow.com/a/28552082/6086311">Stack Overflow</a> answer.</p>
</blockquote>
<h2 id="16---i"><a class="header" href="#16---i">#16 <code>--i</code></a></h2>
<h3 id="题目-15"><a class="header" href="#题目-15">题目</a></h3>
<pre><code class="language-rs">fn main() {
    let mut x = 4;
    --x;
    print!(&quot;{}{}&quot;, --x, --x);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-15"><a class="header" href="#提示-15">提示</a></h3>
<p>Rust 所支持的运算符集在 <code>std::ops</code> 中有相关文档。</p>
<blockquote>
<p>The set of operators supported by Rust is documented in <code>std::ops</code>.</p>
</blockquote>
<h3 id="题解-14"><a class="header" href="#题解-14">题解</a></h3>
<p>答案：44</p>
<p>与 C 或 Java 不同，Rust 中没有自增自减运算符。Rust 语言设计的 FAQ（网上已经没有了）曾经涉及过原因。</p>
<blockquote>
<p>Unlike C or Java, there is no unary increment or decrement operator in Rust. The Rust language design FAQ (no longer available online) used to touch on the reason:</p>
</blockquote>
<p>为什么 Rust 没有自增和自减运算符？</p>
<blockquote>
<p>Why doesn't Rust have increment and decrement operators?</p>
</blockquote>
<p>Preincrement 和 Postincrement（以及与之对应的 Decrement），虽然方便，但也相当复杂。它们需要对计算顺序足够了解，并经常导致 C 和 C++ 中一些微妙的错误和未定义的行为。</p>
<blockquote>
<p>Preincrement and postincrement (and the decrement equivalents), while convenient, are also fairly complex. They require knowledge of evaluation order, and often lead to subtle bugs and undefined behavior in C and C++. x = x + 1 or x += 1 is only slightly longer, but unambiguous.</p>
</blockquote>
<p>在没有自减运算符的情况下，<code>--x</code> 被解析为 <code>-(-x)</code>。在 <code>x = 4</code> 的情况下，这将是 <code>-(-4)</code>，也就是 4。该程序等同于：</p>
<blockquote>
<p>In the absense of a decrement operator, --x is parsed as -(-x). In the case of x = 4 this would be -(-4) which is 4. The program is equivalent to:</p>
</blockquote>
<pre><code class="language-rs">fn main() {
    let mut x = 4;
    4;
    print!(&quot;{}{}&quot;, 4, 4);
}
</code></pre>
<h2 id="17--------"><a class="header" href="#17--------">#17 <code>-- - --</code></a></h2>
<h3 id="题目-16"><a class="header" href="#题目-16">题目</a></h3>
<pre><code class="language-rs">fn main() {
    let mut a = 5;
    let mut b = 3;
    print!(&quot;{}&quot;, a-- - --b);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-16"><a class="header" href="#提示-16">提示</a></h3>
<p>Rust 支持的操作符都在 <code>std：：ops</code>。</p>
<blockquote>
<p>The set of operators supported by Rust is documented in <code>std::ops</code>.</p>
</blockquote>
<h3 id="题解-15"><a class="header" href="#题解-15">题解</a></h3>
<p>答案：2</p>
<p>不像 C 或者 Java，Rust 没有自增和自减运算符。Rust 语言设计的 FAQ（网上已经没有了）曾经探讨过这个原因。</p>
<blockquote>
<p>Unlike C or Java, there is no unary increment or decrement operator in Rust. The Rust language design FAQ (no longer available online) used to touch on the reason:</p>
</blockquote>
<p>为什么 Rust 没有自增和自减运算符？</p>
<p>Preincrement (<code>++i</code>) 和 Postincrement (<code>--i</code>)（以及与之对应的 Decrement），虽然方便，但也相当复杂。用户需要知道求值顺序，这经常导致一些 C 和 C++ 中微妙的错误和未定义的行为。</p>
<blockquote>
<p>Why doesn't Rust have increment and decrement operators?
Preincrement and postincrement (and the decrement equivalents), while convenient, are also fairly complex. They require knowledge of evaluation order, and often lead to subtle bugs and undefined behavior in C and C++. x = x + 1 or x += 1 is only slightly longer, but unambiguous.</p>
</blockquote>
<p>在没有自减运算符 (包括 <code>i--</code> 和 <code>--i</code>) 的情况下，<code>a-- --b</code> 会被解析为 <code>a-(-(-(-b))))</code>。在 <code>a=5</code> 和 <code>b=3</code> 的情况下，这个表达式的值是 <code>5-3</code>，也就是 <code>2</code>。</p>
<blockquote>
<p>In the absense of postfix and prefix decrement operators, a-- - --b is parsed as a - (-(-(-(-b)))). In the case of a = 5 and b = 3 the value of this expression is 5 - 3 which is 2.</p>
</blockquote>
<h2 id="18-f-and-f"><a class="header" href="#18-f-and-f">#18 <code>f() and f()</code></a></h2>
<h3 id="题目-17"><a class="header" href="#题目-17">题目</a></h3>
<pre><code class="language-rs">struct S {
    f: fn(),
}

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let print2 = || print!(&quot;2&quot;);
    S { f: print2 }.f();
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-17"><a class="header" href="#提示-17">提示</a></h3>
<p>调用 <code>.f()</code> 可以解析为字段 f 或固有的方法 f，你如何写出对另一个的调用？</p>
<blockquote>
<p>The call .f() resolves to either the field f or the inherent method f. How would you write a call to the other one?</p>
</blockquote>
<h3 id="题解-16"><a class="header" href="#题解-16">题解</a></h3>
<p>答案：1</p>
<p>一个看起来像 <code>.f()</code>的调用总会解析到一个方法，在这里是固有的方法 <code>S::f</code>。如果作用域内没有方法 f，那么即使字段 f 存在并包含一个函数指针，这样的调用也不能编译。</p>
<blockquote>
<p>A call that looks like .f() always resolves to a method, in this case the inherent method <code>S::f</code>. If there were no method f in scope, a call like this would fail to compile even if a field f exists and contains a function pointer.</p>
</blockquote>
<p>为了调用存储在字段 f 中的函数指针，我们需要在字段周围写上圆括号。</p>
<blockquote>
<p>To call the function pointer stored in field f, we would need to write parentheses around the field access:</p>
</blockquote>
<pre><code class="language-rs">fn main() {
    let print2 = || print!(&quot;2&quot;);
    (S { f: print2 }.f)();
}
</code></pre>
<h2 id="19-move-or-drop"><a class="header" href="#19-move-or-drop">#19 <code>move or drop</code></a></h2>
<h3 id="题目-18"><a class="header" href="#题目-18">题目</a></h3>
<pre><code class="language-rs">struct S;

impl Drop for S {
    fn drop(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let s = S;
    let _ = s;
    print!(&quot;2&quot;);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-18"><a class="header" href="#提示-18">提示</a></h3>
<p>s 所有权移动了吗？</p>
<blockquote>
<p>Does s get moved?</p>
</blockquote>
<h3 id="题解-17"><a class="header" href="#题解-17">题解</a></h3>
<p>答案：21</p>
<p>相关的一行是 <code>let _ = s</code>。如果这一行没有移动 s，那么 s 将继续存在，直到大括号结尾，程序将打印 21。但是如果这一行移动了 s，而没有绑定它，那么被移动的 S 类型的值将被立即 drop，程序将打印 12。</p>
<blockquote>
<p>The relevant line is let _ = s. If this line does not move s then s will continue to live until the close curly brace and the program would print 21. But if this line does move s, without binding it, then the moved value of type S would be dropped immediately and the program would print 12.</p>
</blockquote>
<p>事实上，s 并没有被移动，输出结果是 21。</p>
<blockquote>
<p>In fact s does not get moved and the output is 21.</p>
</blockquote>
<h2 id="20-return-and-return"><a class="header" href="#20-return-and-return">#20 <code>return and return</code></a></h2>
<h3 id="题目-19"><a class="header" href="#题目-19">题目</a></h3>
<pre><code class="language-rs">fn return1() {
    if (return { print!(&quot;1&quot;) }) {
    }
}

fn return2() {
    if return { print!(&quot;2&quot;) } {
    }
}

fn break1() {
    loop {
        if (break { print!(&quot;1&quot;) }) {
        }
    }
}

fn break2() {
    loop {
        if break { print!(&quot;2&quot;) } {
        }
    }
}

fn main() {
    return1();
    return2();
    break1();
    break2();
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-19"><a class="header" href="#提示-19">提示</a></h3>
<p>Rust 中涉及 break 的语法与涉及 return 的语法不同。</p>
<blockquote>
<p>The Rust grammar involving break is different from the grammar involving return.</p>
</blockquote>
<h3 id="题解-18"><a class="header" href="#题解-18">题解</a></h3>
<p>答案：121</p>
<p>让我们以此研究这些函数。</p>
<blockquote>
<p>Let's work through the functions one at a time.</p>
</blockquote>
<ul>
<li>
<p><code>fn return1</code></p>
<p>if 语句的，条件。被解析为一个表达式，这个表达式会返回 <code>{ print!(&quot;1&quot;) }</code> 即 ().这个值需要在返回前被计算，所以最终打印 1.</p>
<blockquote>
<p>The condition of the if-statement is parsed as a return-expression that returns the value { print!(&quot;1&quot;) } of type (). The value needs to be evaluated prior to being returned so this function prints 1.</p>
</blockquote>
</li>
<li>
<p><code>fn return2</code></p>
<p>这个函数和 <code>return1</code> 一样。<code>return</code> 关键字会立即消耗掉返回值，即使返回值被大括号包裹．甚至是在 if 语句的条件中，大括号 (例如结构体) 通常也不会被接受。</p>
<blockquote>
<p>This function is parsed the same as return1. The return keyword eagerly consumes a trailing return value, even if the return value begins with a curly brace, and even in the condition of an if-statement where curly braces such as in a struct literal would ordinarly not be accepted. This function prints 2.</p>
</blockquote>
</li>
<li>
<p><code>fn break1</code></p>
<p>if 语句的条件是是个 break-with-value 表达式，它会结束整个循环，并返回 <code>{ print!(&quot;1&quot;) }</code>, 即 ()，和 <code>return1</code> 类似，为了在打破循环时返回值，这个值需要被计算，所以最终打印 1；</p>
<blockquote>
<p>The condition of the if-statement is a break-with-value expression that breaks out of the enclosing loop with the value { print!(&quot;1&quot;) } of type (). Similar to return1, in order to break with this value the value needs to be evaluated and this function prints 1.</p>
</blockquote>
</li>
<li>
<p><code>fn break2</code></p>
<p>这里我们可以看到 break 和 return 语法的区别。不像 return，if 条件里的 break 关键字不会立即解析出后面大括号的值。这段代码会被解析为：</p>
<blockquote>
<p>Here we observe a difference between the grammar of break and the grammar of return. Unlike return, the break keyword in the condition of this if-statement does not eagerly parse a value that begins with a curly brace. This code is parsed as:</p>
</blockquote>
<pre><code class="language-rs">loop {
    if break {
        print!(&quot;2&quot;)
    }
    {}
}
</code></pre>
<p>我们在执行 print 前打破了循环，所以这个函数不会执行 print.</p>
<blockquote>
<p>We break out of the loop before executing the print, so this function does not print anything.</p>
</blockquote>
<p>我相信 return 和 break 不同的原因是，return 在 Rust 1.0 以及之前显然都是支持的，但是 break-with-value 是在 Rust 1.19 才被引入之后。<code>break2</code> 中的代码一直都是合法的 Rust 代码，所以在实现 break-with-value 这个语言特性时也考虑到不能改变它的行为。</p>
<blockquote>
<p>I believe the reason for the difference between return and break is that returning a value was obviously supported at Rust 1.0 and well before, but break-with-value was introduced fairly late, in Rust 1.19. The code in break2 was perfectly legal Rust code prior to Rust 1.19 so we cannot change its behavior when implementing the break-with-value language feature.</p>
</blockquote>
<p>未来的版本有可能对这两种语法进行调整，使之相互一致。</p>
<blockquote>
<p>It is possible that a future Edition would adjust the two grammars to align with each other.</p>
</blockquote>
</li>
</ul>
<p>main 的输出为 121。</p>
<blockquote>
<p>The output from main is 121.</p>
</blockquote>
<h2 id="21-return--break"><a class="header" href="#21-return--break">#21 <code>return &amp; break</code></a></h2>
<h3 id="题目-20"><a class="header" href="#题目-20">题目</a></h3>
<pre><code class="language-rs">trait Trait {
    fn f(&amp;self);
}

impl&lt;F: FnOnce() -&gt; bool&gt; Trait for F {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for () {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let x = || { (return) || true; };
    x().f();

    let x = loop { (break) || true; };
    x.f();

    let x = || { return (|| true); };
    x().f();

    let x = loop { break (|| true); };
    x.f();

    let x = || { return || true; };
    x().f();

    let x = loop { break || true; };
    x.f();
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-20"><a class="header" href="#提示-20">提示</a></h3>
<p>在本题中，break 和 return 关键字的语法是一样的。</p>
<blockquote>
<p>The break and return keywords have the same grammar in this question.</p>
</blockquote>
<h3 id="题解-19"><a class="header" href="#题解-19">题解</a></h3>
<p>答案：221111</p>
<p>我们想知道 <code>return || true;</code> 和 <code>break || true;</code> 的每一个可能的括号是否评估为闭包 <code>|| true</code> 或单位值 ()。</p>
<blockquote>
<p>We want to know whether each possible parenthesization of return || true; and break || true; evaluates to the closure || true or to the unit value ().</p>
</blockquote>
<ul>
<li>
<p><code>let x = || { (return) || true; };</code></p>
<p>在这一行，x 是一个返回 () 的闭包。等价于 <code>let x = || {}</code>.当我们调用 <code>x().f()</code> 时，方法 f 会被解析为 <code>impl Trait for ()</code>, 并打印 2.</p>
<blockquote>
<p>On this line, x is a closure that returns (). It is equivalent to let x = || {}. When we call x().f(), the method f resolves to impl Trait for () which prints 2.</p>
</blockquote>
<p>表达式 <code>(treturn)</code> 的类型是原始的 never 类型，通常写成 <code>！</code>。计算 <code>! || true</code> 是合法的，因为 <code>!</code> 可以转为任何类型，在这里是 <code>bool</code>。表达式 <code>! || true</code> 是一个逻辑或，左侧和右侧都是 <code>bool</code>。</p>
<blockquote>
<p>The type of the expression (return) is the primitive never type, usually written as !. It is legal to compute ! || true because ! can fill in for any type, in this case bool. The expression ! || true is a logical-OR with bool on both the left-hand side and right-hand side.</p>
</blockquote>
<p><code>!</code> 可以转为任何类型的行为允许我们写出如下代码：</p>
<blockquote>
<p>The behavior of ! of filling in for any type is what allows us to write:</p>
</blockquote>
<pre><code class="language-rs">fn f() -&gt; bool {
    unimplemented!()
}
</code></pre>
<p>其中 <code>unimplemented!()</code> 的类型，因为它在没有求值的情况下直接 panic，它的返回值类型也是 <code>！</code>。</p>
<blockquote>
<p>in which the type of unimplemented!(), since it panics without evaluating to any value, is also !.</p>
</blockquote>
</li>
<li>
<p><code>let x = loop { (break) || true; };</code></p>
<p>和 <code>(return)</code> 类似，<code>(break)</code> 的类型也是 <code>!</code>. 这行代码会打破循环，并返回 <code>()</code>, 所以 <code>x</code> 的类型是 <code>()</code>.调用 <code>x.f()</code> 会打印 2.</p>
<blockquote>
<p>Similar to (return), the type of (break) is the never type !. This code breaks out of the loop with the implicit value (), so x is of type (). Calling x.f() will print 2.</p>
</blockquote>
</li>
<li>
<p><code>let x = || { return (|| true); };</code></p>
<p>在这一行，<code>x</code> 是一个闭包，它返回一个返回 true 的闭包。你可以写 <code>x()()</code>，它的值会是 true。</p>
<blockquote>
<p>On this line x is a closure that returns a closure that returns true. You could write x()() and that would be true.</p>
</blockquote>
<p>Quiz 代码调用了 <code>x().f()</code>, 这会解析为 <code>impl&lt;F&gt; Trait for F where F: FnOnce() -&gt; bool</code>. 最终打印 1.</p>
<blockquote>
<p>The quiz code calls <code>x().f()</code> which resolves to <code>impl&lt;F&gt; Trait for F where F: FnOnce() -&gt; bool</code>. That trait impl prints 1.</p>
</blockquote>
</li>
<li>
<p><code>let x = loop { break (|| true); };</code></p>
<p>这是一个包含 <code>break-with-value</code> 表达式的循环。<code>break</code> 的参数变成了循环的返回值。这段代码等同于 <code>let x = || true</code>。</p>
<blockquote>
<p>This is a loop containing a break-with-value expression. The argument of the break becomes the value of the enclosing loop. This code is equivalent to let <code>x = || true</code>.</p>
</blockquote>
<p>当我们调用 <code>x.f()</code> 时，它使用了 FnOnce 的 Trait 实现，打印出 1。</p>
<blockquote>
<p>When we call <code>x.f()</code> it uses the FnOnce impl of Trait which prints 1.</p>
</blockquote>
</li>
<li>
<p><code>let x = || { return || true; };</code></p>
<p>现在我们来到了这个问答问题的核心。<code>return || true</code> 的解析与 <code>(return) || true</code> 相同，还是与 <code>return (|| true)</code> 相同？</p>
<blockquote>
<p>Now we arrive at the meat of this quiz question. Is <code>return || true</code> parsed the same as <code>(return) || true</code> or as <code>return (|| true)</code>?</p>
</blockquote>
<p>结果是后者，所以 x 是一个返回 true 的闭包。<code>x().f()</code> 打印 1。</p>
<blockquote>
<p>It turns out to be the latter, so x is a closure that returns a closure that returns true. <code>x().f()</code> prints 1.</p>
</blockquote>
</li>
<li>
<p><code>let x = loop { break || true; };</code></p>
<p>这个也是类似的问题，这是 <code>(break) || true</code> 还是 <code>break (|| true)</code>？</p>
<blockquote>
<p>Similar question here, is this <code>(break) || true</code> or <code>break (|| true)</code>?</p>
</blockquote>
<p><code>break-with-value</code> 语言功能是在 1.0 之后的两年后 (Rust 1.19) 加入的。在 break-with-value 之前，<code>break || true</code> 是完全合法的 Rust 代码，解析为 <code>(break) || true</code>。</p>
<blockquote>
<p>The break-with-value language feature was added to Rust more than two years after 1.0, in Rust 1.19. Prior to break-with-value, <code>break || true</code> was perfectly legal Rust code that parsed as <code>(break) || true</code>.</p>
</blockquote>
<p>在 Rust 1.19 中，这段代码的行为被语言无意中打破了，现在它被解析为 <code>break (|| true)</code>，打印出来的值是 1。</p>
<blockquote>
<p>In Rust 1.19 the behavior of this code was unintentionally broken by the language such that now it parses as <code>break (|| true)</code> and the printed value is 1.</p>
</blockquote>
<p>如果我们在 Rust 1.19 的开发过程中注意到这种意义上的变化，我们可能会调整解析以保留现有代码的意义。不幸的是，这样做会导致语法在 return 和 break 之间有不同的表现，除了历史的意外，没有任何合理的理由。</p>
<blockquote>
<p>If we had noticed this change in meaning during the development of Rust 1.19, we may have adjusted the parsing to preserve the meaning of existing code. Unfortunately doing so would result in a grammar that behaves differently between return and break for no justifiable reason other than an accident of history.</p>
</blockquote>
<p>或者，我们也有可能认为这是一个永远不会出现在真实代码中的语法边缘案例，用 Crater 来验证这一假设，并有意打破这一行为。</p>
<blockquote>
<p>Or it is possible we would have ruled this an edge case of syntax that would never appear in real code, used Crater to validate that hypothesis, and broken the behavior intentionally.</p>
</blockquote>
</li>
</ul>
<p>main 的完整输出是 221111.</p>
<blockquote>
<p>The total output from main is 221111.</p>
</blockquote>
<h2 id="22---is-a-token"><a class="header" href="#22---is-a-token">#22 <code>- is a token</code></a></h2>
<h3 id="题目-21"><a class="header" href="#题目-21">题目</a></h3>
<pre><code class="language-rs">macro_rules! m {
    ($a:tt) =&gt; { print!(&quot;1&quot;) };
    ($a:tt $b:tt) =&gt; { print!(&quot;2&quot;) };
    ($a:tt $b:tt $c:tt) =&gt; { print!(&quot;3&quot;) };
    ($a:tt $b:tt $c:tt $d:tt) =&gt; { print!(&quot;4&quot;) };
    ($a:tt $b:tt $c:tt $d:tt $e:tt) =&gt; { print!(&quot;5&quot;) };
    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt) =&gt; { print!(&quot;6&quot;) };
    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt $g:tt) =&gt; { print!(&quot;7&quot;) };
}

fn main() {
    m!(-1);
    m!(-1.);
    m!(-1.0);
    m!(-1.0e1);
    m!(-1.0e-1);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-21"><a class="header" href="#提示-21">提示</a></h3>
<p>macro 会计算输入的 &quot;token&quot; 的数量。</p>
<blockquote>
<p>The macro is counting how many &quot;tokens&quot; are in its input.</p>
</blockquote>
<h3 id="题解-20"><a class="header" href="#题解-20">题解</a></h3>
<p>答案：22222</p>
<p>所有的 m！调用都传递了两个标记作为输入：一个减号，然后是一个整数或浮点字样的标记。</p>
<blockquote>
<p>All five invocations of m! pass two tokens as input: a minus sign followed by an integer or floating point literal token.</p>
</blockquote>
<p>浮点字面符号 <code>1.</code>、<code>1.0</code>、<code>1.0e1</code>、<code>1.0e-1</code> 都是单一的原子符号。</p>
<blockquote>
<p>The floating point literals 1., 1.0, 1.0e1, 1.0e-1 are each a single atomic token.</p>
</blockquote>
<p>Rust 编译器内置的解析器总是将负号作为一个单独的标记，与数字进行区分。然而，在过程宏中，用户定义的解析器可以通过向 <code>proc_macro::Literal</code> 的构造器之一传递一个负的整数或负的浮点数来构造一个负数作为单个标记。如果这样的负数最终出现在随后的过程宏调用的输入中，则由编译器决定是重写成一对标记还是将其作为一个标记。</p>
<blockquote>
<p>The parser built into the Rust compiler always parses a negative sign as a separate token from the numeric literal that is being negating. However, it is possible for a user-defined parser within a procedural macro to construct a negative number as a single token by passing a negative integer or negative floating point value to one of the constructors of <code>proc_macro::Literal</code>. If such a negative literal ends up in the input of a subsequent procedural macro invocation, it is up to the compiler whether to rewrite into a pair of tokens or keep them as one.</p>
</blockquote>
<p>编译器的解析器的行为在语言表面也是可以观察到的，不仅仅是在宏中。例如，下面的代码打印出 -81，因为表达式被解析为 <code>-(3i32.pow(4))</code> 而不是 <code>(-3i32).pow(4)</code>。</p>
<blockquote>
<p>The behavior of the compiler's parser is observable in the surface language as well, not only in macros. For example the following code prints -81 because the expression is parsed as -(3i32.pow(4)) rather than (-3i32).pow(4).</p>
</blockquote>
<pre><code class="language-rs">fn main() {
    let n = -3i32.pow(4);
    println!(&quot;{}&quot;, n);
}
</code></pre>
<h2 id="23-method-lookup-order"><a class="header" href="#23-method-lookup-order">#23 <code>method lookup order</code></a></h2>
<h3 id="题目-22"><a class="header" href="#题目-22">题目</a></h3>
<pre><code class="language-rs">trait Trait {
    fn f(&amp;self);
    fn g(&amp;self);
}

struct S;

impl S {
    fn f(&amp;self) {
        print!(&quot;1&quot;);
    }

    fn g(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

impl Trait for S {
    fn f(&amp;self) {
        print!(&quot;2&quot;);
    }

    fn g(&amp;self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    S.f();
    S.g();
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-22"><a class="header" href="#提示-22">提示</a></h3>
<p>我不能帮助你解决这个问题。这是由语言本身做出的一个相当随意的选择。试试所有的可能吧！</p>
<blockquote>
<p>I can't help you with this one. This is a pretty arbitrary choice made by the language. Try all the possibilities!</p>
</blockquote>
<h3 id="题解-21"><a class="header" href="#题解-21">题解</a></h3>
<p>答案：12</p>
<p><code>S.f()</code> 会调用固有方法 f。如果一个固有方法和一个 Trait 方法同名，并且返回值相同，普通的方法调用总是会选择固有方法。调用这必须写 <code>Trait::f(&amp;s)</code> 或者 <code>&lt;S as Trait&gt;::f(&amp;s)</code> 去调用 Trait 方法。 </p>
<blockquote>
<p><code>S.f()</code> calls the inherent method f. If an inherent method and a trait method have the same name and receiver type, plain method call syntax will always prefer the inherent method. The caller would need to write <code>Trait::f(&amp;S)</code> or <code>&lt;S as Trait&gt;::f(&amp;S)</code> in order to call the trait method.</p>
</blockquote>
<p>对于宏的作者来说，意识到这一点很重要。宏生成的代码通常不应该使用普通的方法调用语法来调用用户定义的类型上的特征方法。这些调用可能会被与特质方法同名的固有方法无意中劫持。</p>
<blockquote>
<p>It is important for macro authors to be aware of this. Macro-generated code typically should not use method call syntax to invoke trait methods on types defined by the user. Those calls could get unintentially hijacked by inherent methods having the same name as the trait method.</p>
</blockquote>
<p>另一方面，<code>S.g()</code> 调用特质方法 <code>g</code>。在方法解析过程中，如果 <code>&amp;</code> 和 <code>＆mut</code> 都可以调用，自动引用总是倾向于将某样东西变成 <code>&amp;</code>，而不是将其变成 <code>&amp;mut</code>。</p>
<blockquote>
<p>On the other hand, S.g() calls the trait method g. Auto-ref during method resolution always prefers making something into &amp; over making it into &amp;mut where either one would work.</p>
</blockquote>
<p>请参阅 <a href="https://stackoverflow.com/a/28552082/6086311">Stack Overflow</a> 的答案，了解方法解析过程中自动引用的更详细解释。</p>
<blockquote>
<p>See this Stack Overflow answer for a more detailed explanation of auto-ref during method resolution.</p>
</blockquote>
<h2 id="24-hygiene"><a class="header" href="#24-hygiene">#24 <code>Hygiene</code></a></h2>
<h3 id="题目-23"><a class="header" href="#题目-23">题目</a></h3>
<pre><code class="language-rs">fn main() {
    let x: u8 = 1;
    const K: u8 = 2;

    macro_rules! m {
        () =&gt; {
            print!(&quot;{}{}&quot;, x, K);
        };
    }

    {
        let x: u8 = 3;
        const K: u8 = 4;

        m!();
    }
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-23"><a class="header" href="#提示-23">提示</a></h3>
<p>宏的卫生性只是用于局部变量。</p>
<blockquote>
<p>Hygiene in macro_rules! only applies to local variables.</p>
</blockquote>
<h3 id="题解-22"><a class="header" href="#题解-22">题解</a></h3>
<p>答案：14</p>
<p>这个程序打印出 14，因为宏的 &quot;卫生性&quot;(Hygiene) 只适用于局部变量。</p>
<blockquote>
<p>This program prints 14 because hygiene in macro_rules! only applies to local variables.</p>
</blockquote>
<p>你可以把 Hygiene 想象成：给每次提到的局部变量的名字分配一种颜色，允许在范围内有多个可区分的局部变量同时具有相同的名字。</p>
<blockquote>
<p>You can imagine hygiene as a way of assigning a color to each mention of the name of a local variable, allowing for there to be multiple distinguishable local variables in scope simultaneously with the same name.</p>
</blockquote>
<p>在 main 的顶端，假设我们认为局部变量 x 的名字是紫色的 x，常量 K 的名字只是普通的 K，因为常量被认为是项 (Item) 而不是局部变量（你可以把项放在函数体之外；但是不能把局部变量放在函数体之外）。</p>
<blockquote>
<p>At the top of main, suppose we consider the name of the local variable x to be a purple x. The name of the constant K is just plain K, as constants are considered items rather than local variables (you can place items outside of a function body; you cannot place local variables outside of a function body).</p>
</blockquote>
<pre><code>let   x: u8 = 1; // x 为紫色
const K: u8 = 2; // K 为无色
</code></pre>
<p>我们继续往下看，在 macro m! 的声明中，有两个被用到的标识符。因为作用域内有一个变量 x，所以在 m! 内使用的标识符 x 的颜色与局部变量 x 相同。在作用域内没有局部变量 K，所以在宏的声明中的 K 被分配了一些新的颜色，例如橙色。</p>
<blockquote>
<p>Continuing down the body of main, within the declaration of the macro m! there are identifiers x and K being used. Since there is a local variable x in scope, the use of the identifier x within the macro body picks up the same color as the local variable x. There is no local variable K in scope so the K within the declaration of the macro is assigned some new color, say orange.</p>
</blockquote>
<pre><code>macro_rules! m {
    () =&gt; {
        print!(&quot;{}{}&quot;, x, K); // x 为紫色，K 为橙色
    };
}
</code></pre>
<p>接下来我们进入一个新的作用域（用大括号划定），包含另一个 x 和 K。每一个新的局部变量总是会引入一个新的颜色，所以我们把这个 x 叫做蓝色。const 依然不是一个局部变量，所以没有给 K 分配颜色。</p>
<blockquote>
<p>Next we enter a new scope (delimited by curly braces) containing another x and K. Every new local variable always introduces a new color so let's call this x blue. The const again is not a local variable so no color is assigned to K.</p>
</blockquote>
<pre><code>{
    let   x: u8 = 3; // x 为蓝色
    const K: u8 = 4; // K 为无色

    m!();
}
</code></pre>
<p>当 <code>m!()</code> 展开时，展开的代码包含一个紫色的 x 和一个橙色的 K。紫色的 x 可以和蓝色的 x 区分开来，所以紫色的 x 的值被打印出来，是 1。至于 K，一个不卫生的（未着色的）K 被允许像任何颜色一样。第二个 K 会遮蔽第一个 K。当 m! 寻找一个橙色的 K 时，会识别到第二个 K，第二个 K 的值被打印出来，即 4。</p>
<blockquote>
<p>When m!() expands, the expanded code refers to a purple x and an orange K. The purple x is distinguishable from the blue x -- the value of the purple x is printed which is 1. As for the K, an unhygienic (uncolored) K is allowed to act like any color. The second K is shadowing the first one. It gets picked up when looking for an orange K and its value is printed, which is 4.</p>
</blockquote>
<p>所以输出是 14。</p>
<blockquote>
<p>So the output of the quiz code is 14.</p>
</blockquote>
<h2 id="25-drop"><a class="header" href="#25-drop">#25 <code>drop</code></a></h2>
<h3 id="题目-24"><a class="header" href="#题目-24">题目</a></h3>
<pre><code class="language-rs">use std::fmt::{self, Display};

struct S;

impl Display for S {
    fn fmt(&amp;self, formatter: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        formatter.write_str(&quot;1&quot;)
    }
}

impl Drop for S {
    fn drop(&amp;mut self) {
        print!(&quot;2&quot;);
    }
}

fn f() -&gt; S {
    S
}

fn main() {
    let S = f(); 
    print!(&quot;{}&quot;, S);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-24"><a class="header" href="#提示-24">提示</a></h3>
<p>弄清楚哪些值被哪些变量所拥有。当一个值不再有所有者时，它就被 drop 了。</p>
<blockquote>
<p>Figure out what values are owned by which variables where. A value is dropped when it no longer has an owner.</p>
</blockquote>
<h3 id="题解-23"><a class="header" href="#题解-23">题解</a></h3>
<p>答案：212</p>
<p>程序打印 212。</p>
<blockquote>
<p>This program prints 212.</p>
</blockquote>
<p>在函数 f 内，没有 S 会被 drop。f 函数内产生一个 S，然后把它的所有权返回给 f 的调用者；调用者会决定什么时候 drop 掉他拿到的 S。</p>
<blockquote>
<p>No value of type S gets dropped within the body of function f. The function f conjures an S and returns ownership of it to the caller of f; the caller determines when to drop the S of which it received ownership.</p>
</blockquote>
<p>在 main 的第一行，我们调用了 f(),但是并没有把它绑定到某一个变量上。所以 f() 返回的 S 会被立即 drop，打印了 2。<code>let S = f()</code> 中的 S 是一个单元结构体的模式匹配 (不是一个变量)，它能够通过解构匹配到 S 结构体里的字段，但是这里并没有将匹配到的字段绑定到某一变量。</p>
<blockquote>
<p>On the first line of main, we call f() and perform an infallible match that binds no new variables. As no variables are declared on this line, there is no variable that could be the owner of the S returned by f() so that S is dropped at that point, printing 2. The S in let S = f() is a unit struct pattern (not a variable name) that matches a value of type S via destructuring but does not bind the value to any variable.</p>
</blockquote>
<p>main 的第二行产生一个新的 S，并打印，最后在分号处 drop 它。</p>
<blockquote>
<p>The second line of main conjures a new S, prints it, and drops it at the semicolon.</p>
</blockquote>
<h2 id="26-lazy-map"><a class="header" href="#26-lazy-map">#26 <code>lazy map</code></a></h2>
<h3 id="题目-25"><a class="header" href="#题目-25">题目</a></h3>
<pre><code class="language-rs">fn main() {
    let input = vec![1, 2, 3];

    let parity = input
        .iter()
        .map(|x| {
            print!(&quot;{}&quot;, x);
            x % 2
        });

    for p in parity {
        print!(&quot;{}&quot;, p);
    }
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-25"><a class="header" href="#提示-25">提示</a></h3>
<p>请查阅 <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">Iterator</a> Trait 的文档</p>
<blockquote>
<p>Refer to the documentation of the Iterator trait.</p>
</blockquote>
<h3 id="题解-24"><a class="header" href="#题解-24">题解</a></h3>
<p>答案：112031</p>
<p>正如 <code>Iterator::map</code> 方法的文档中所描述的，map 操作是惰性执行的。作为参数提供给 map 的闭包只有在值从结果迭代器中被消耗时才会被调用。闭包并不会立即应用于整个输入流。</p>
<blockquote>
<p>As described in the documentation of the Iterator::map method, the map operation is performed lazily. The closure provided as an argument to map is only invoked as values are consumed from the resulting iterator. The closure is not applied eagerly to the entire input stream up front.</p>
</blockquote>
<p>在这段代码中，for 循环是驱动迭代的因素。对于从奇偶性迭代器中消耗的每个元素，我们的闭包都需要被执行一次。因此，输出将在由闭包打印的数字和由循环体打印的数字之间交替进行。</p>
<blockquote>
<p>In this code, the for loop is what drives the iteration. For each element consumed from the parity iterator, our closure needs to be evaluated one time. Thus the output will alternate between numbers printed by the closure and numbers printed by the loop body.</p>
</blockquote>
<h2 id="27-dyn-trait"><a class="header" href="#27-dyn-trait">#27 <code>dyn Trait</code></a></h2>
<h3 id="题目-26"><a class="header" href="#题目-26">题目</a></h3>
<pre><code class="language-rs">trait Base {
    fn method(&amp;self) {
        print!(&quot;1&quot;);
    }
}

trait Derived: Base {
    fn method(&amp;self) {
        print!(&quot;2&quot;);
    }
}

struct BothTraits;
impl Base for BothTraits {}
impl Derived for BothTraits {}

fn dynamic_dispatch(x: &amp;dyn Base) {
    x.method();
}

fn static_dispatch&lt;T: Base&gt;(x: T) {
    x.method();
}

fn main() {
    dynamic_dispatch(&amp;BothTraits);
    static_dispatch(BothTraits);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-26"><a class="header" href="#提示-26">提示</a></h3>
<p><code>Base::method</code> 和 <code>Derived::method</code> 碰巧有相同的名字，但是是毫不相关的两个方法。不会互相覆盖。</p>
<blockquote>
<p>Base::method and <code>Derived::method</code> happen to have the same name but are otherwise unrelated methods. One does not override the other.</p>
</blockquote>
<h3 id="题解-25"><a class="header" href="#题解-25">题解</a></h3>
<p>答案：11</p>
<p>这两个 Trait，<code>Base</code> 和 <code>Derived</code> 各自定义了一个名为 method 的 Trait 方法。这两个方法只是碰巧拥有相同的名称，但在其他方面并不相关，如下文所解释。</p>
<blockquote>
<p>The two traits Base and Derived each define a trait method called method. These methods happen to have the same name but are otherwise unrelated methods as explained below.</p>
</blockquote>
<p>两个 Trait 都为 method 提供了一个默认的实现。如果某个具体实现没有定义方法，那么默认的实现在概念上会被复制到具体的实现中。</p>
<p>默认实现在概念上被复制到每个没有明确定义相同方法的 trait impl 中。例如，在这种情况下，BothTraits 的 impl Base 没有提供自己的 Base::method 的实现，这意味着 BothTraits 的 Base 的实现将使用该 trait 定义的默认行为，即 print!</p>
<blockquote>
<p>Both traits provide a default implementation of their trait method. Default implementations are conceptually copied into each trait impl that does not explicitly define the same method. In this case for example impl Base for BothTraits does not provide its own implementation of <code>Base::method</code>, which means the implementation of Base for BothTraits will use the default behavior defined by the trait i.e. print!(&quot;1&quot;).</p>
</blockquote>
<p>此外，Derived 将 Base 作为一个 supertrait，这意味着每个实现 Derived 的类型也都需要实现 Base。这两个 trait 方法尽管名字相同，但却没有关系 -- 因此任何实现 Derived 的类型都会有 Derived::method 和 Base::method 的实现，而且这两个方法可以自由地有不同的行为。Supertraits 不是继承！Supertraits 是一种特征约束，如果要实现 Derived，那么 Base 也必须被实现。</p>
<blockquote>
<p>Additionally, Derived has Base as a supertrait which means that every type that implements Derived is also required to implement Base. The two trait methods are unrelated despite having the same name -- thus any type that implements Derived will have an implementation of Derived::method as well as an implementation of <code>Base::method</code> and the two are free to have different behavior. Supertraits are not inheritance! Supertraits are a constraint that if some trait is implemented, some other trait must also be implemented.</p>
</blockquote>
<p>让我们看一下从 main 调用的两个方法的具体过程。</p>
<blockquote>
<p>Let's consider what happens in each of the two methods called from main.</p>
</blockquote>
<ul>
<li>
<p><code>dynamic_dispatch(&amp;BothTraits)</code></p>
<p>参数 x 是一个对特征对象 <code>dyn Base</code> 的引用。特征对象是由编译器生成的一个 &quot;小垫片&quot;，它具有和 Trait 相同的名称 (如下所示)，可以通过将所有特质方法的调用，转发到原始类型的特质方法。转发是通过读取特征对象里包含的函数指针表来完成的。</p>
<blockquote>
<p>The argument x is a reference to the trait object type dyn Base. A trait object is a little shim generated by the compiler that implements the trait with the same name by forwarding all trait method calls to trait methods of whatever type the trait object was created from. The forwarding is done by reading from a table of function pointers contained within the trait object.</p>
</blockquote>
<pre><code class="language-rs">// Generated by the compiler.
//
// This is an implementation of the trait `Base` for the
// trait object type `dyn Base`, which you can think of as
// a struct containing function pointers.
impl Base for (dyn Base) {
    fn method(&amp;self) {
        /*
        Some automatically generated implementation detail
        that ends up calling the right type's impl of the
        trait method Base::method.
        */
    }
}
</code></pre>
<p>在 quiz 代码里，<code>x.method()</code> 实际上是调用由编译器自动生成的方法，它的名字是 <code>&lt;dyn Base as Base&gt;::method</code>。由于 x 是通过将 <code>BothTraits</code> 转换为 <code>dyn Base</code> 得到的，自动生成的实现将转发到 <code>&lt;BothTraits as Base&gt;::method</code>，最后打印出 1。</p>
<blockquote>
<p>In the quiz code, <code>x.method()</code> is a call to this automatically generated method whose fully qualified name is <code>&lt;dyn Base as Base&gt;::method</code>. Since x was obtained by converting a BothTraits to dyn Base, the automatically generated implementation detail will wind up forwarding to <code>&lt;BothTraits as Base&gt;::method</code> which prints 1.</p>
</blockquote>
<p>希望从这一切可以看出，这里没有任何东西与 <code>BothTraits</code> 定义的 <code>Derived::method</code> 有关。特别要注意的是，<code>x.method()</code> 不可能是对 <code>Derived::method</code> 的调用，因为 x 是 <code>dyn Base</code> 类型，而 <code>dyn Base</code> 并没有 <code>Derived</code> 的实现。</p>
<blockquote>
<p>Hopefully it's clear from all of this that nothing here has anything to do with the unrelated trait method Derived::method defined by BothTraits. Especially notice that <code>x.method()</code> cannot be a call to Derived::method because x is of type dyn Base and there is no implementation of Derived for dyn Base.</p>
</blockquote>
</li>
<li>
<p>static_dispatch(BothTraits)</p>
<p>在编译时我们知道 <code>x.method()</code> 是对 <code>&lt;T as Base&gt;::method</code> 的调用。Rust 中对泛型函数的类型推断是独立于泛型函数的任何具体实例而发生的，也就是说，在我们知道 T 可能是什么之前，只知道它实现了 Base 这一事实。因此，具体类型 T 上的任何固有方法或任何其他特征方法都不可能影响 <code>x.method()</code> 的调用。在决定 T 的时候，已经确定 <code>x.method()</code> 会调用 <code>&lt;T as Base&gt;::method</code>。</p>
<blockquote>
<p>At compile time we know that <code>x.method()</code> is a call to <code>&lt;T as Base&gt;::method</code>. Type inference within generic functions in Rust happens independently of any concrete instantiation of the generic function i.e. before we know what T may be, other than the fact that it implements Base. Thus no inherent method on the concrete type T or any other trait method may affect what method <code>x.method()</code> is calling. By the time that T is decided, it has already been determined that <code>x.method()</code> is calling <code>&lt;T as Base&gt;::method</code>.</p>
</blockquote>
<p>泛型函数在实例化时，T 等于 BothTraits，所以这将会调用 <code>&lt;BothTraits as Base&gt;::method</code>，打印出 1。</p>
<blockquote>
<p>The generic function is instantiated with T equal to BothTraits so this is going to call <code>&lt;BothTraits as Base&gt;::method</code> which prints 1.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>If you are familiar with C++, the behavior of this code in Rust is different from the behavior of superficially analogous C++ code. In C++ the output would be 22 as seen in the following implementation. This highlights the difference between Rust's traits and supertraits vs C++'s inheritance.</p>
</blockquote>
<p>如果你熟悉 C++，这段代码在 Rust 中的行为与表面上类似的 C++代码的行为是不同的。在 <code>C++</code> 中，输出将是 22，正如在下面的实现中看到的那样。这突出了 Rust 的 traits 和 supertraits 与 C++ 的继承之间的区别。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

struct Base {
    virtual void method() const {
        std::cout &lt;&lt; &quot;1&quot;;
    }
};

struct Derived: Base {
    void method() const {
        std::cout &lt;&lt; &quot;2&quot;;
    }
};

void dynamic_dispatch(const Base &amp;x) {
    x.method();
}

template &lt;typename T&gt;
void static_dispatch(const T x) {
    x.method();
}

int main() {
    dynamic_dispatch(Derived{});
    static_dispatch(Derived{});
}
</code></pre>
<h2 id="28-_guard--_"><a class="header" href="#28-_guard--_">#28 <code>_guard &amp; _</code></a></h2>
<h3 id="题目-27"><a class="header" href="#题目-27">题目</a></h3>
<pre><code class="language-rs">struct Guard;

impl Drop for Guard {
    fn drop(&amp;mut self) {
        print!(&quot;1&quot;);
    }
}

fn main() {
    let _guard = Guard;
    print!(&quot;3&quot;);
    let _ = Guard;
    print!(&quot;2&quot;);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-27"><a class="header" href="#提示-27">提示</a></h3>
<p>当一个值不再有所有者时，它就被 drop 了。</p>
<blockquote>
<p>A value is dropped when it no longer has an owner.</p>
</blockquote>
<h3 id="题解-26"><a class="header" href="#题解-26">题解</a></h3>
<p>答案：3121</p>
<p>该程序打印出 3121。也就是说，<code>let _guard = Guard</code> 的 <code>Drop</code> 在 main 的末尾运行，但是 <code>let _ = Guard</code> 的 <code>Drop</code> 却立即运行。</p>
<blockquote>
<p>The program prints 3121. That is, the Drop impl for let _guard = Guard runs at the end of main but the Drop impl for let _ = Guard runs right away.</p>
</blockquote>
<p>一般来说，当一个值不再有所有者时，它就会被放弃。变量 <code>_guard</code> 拥有 Guard 类型的第一个值，并且在 main 结束前一直处于作用域中。<code>_</code> 不是一个变量，而是一个通配符模式，它没有绑定任何东西；因为这一行没有绑定任何变量，所以没有变量成为 Guard 类型的第二个值的所有者，该值在同一行被丢弃。</p>
<blockquote>
<p>In general, a value is dropped when it no longer has an owner. The variable _guard owns the first value of type Guard and remains in scope until the end of main. The _ is not a variable but a wildcard pattern that binds nothing; since no variables are bound on this line, there is no variable to be the owner of the second value of type Guard and that value is dropped on the same line.</p>
</blockquote>
<p>下划线模式与带下划线的变量之间的区别在某些情况下很重要，特别是当在 unsafe 代码中使用锁时，</p>
<blockquote>
<p>This distinction between the underscore pattern vs variables with a leading underscore is incredibly important to remember when working with lock guards in unsafe code.</p>
</blockquote>
<pre><code class="language-rs">use std::sync::Mutex;

static MUTEX: Mutex&lt;()&gt; = Mutex::new(());

/// MUTEX must be held when accessing this value.
static mut VALUE: usize = 0;

fn main() {
    let _guard = MUTEX.lock().unwrap();
    unsafe {
        VALUE += 1;
    }
}
</code></pre>
<p>如果这段代码使用 <code>let _ = MUTEX.lock().unwrap()</code>，则会立即释放互斥锁，无法对 <code>VALUE</code> 的访问进行限制。</p>
<blockquote>
<p>If this code were to use <code>let _ = MUTEX.lock().unwrap()</code> then the mutex guard would be dropped immediately, releasing the mutex and failing to guard the access of VALUE.</p>
</blockquote>
<h2 id="29-t--t"><a class="header" href="#29-t--t">#29 <code>(T) &amp; (T,)</code></a></h2>
<h3 id="题目-28"><a class="header" href="#题目-28">题目</a></h3>
<pre><code class="language-rs">trait Trait {
    fn p(&amp;self);
}

impl Trait for (u32) {
    fn p(&amp;self) { print!(&quot;1&quot;); }
}

impl Trait for (i32,) {
    fn p(&amp;self) { print!(&quot;2&quot;); }
}

impl Trait for (u32, u32) {
    fn p(&amp;self) { print!(&quot;3&quot;); }
}

impl Trait for (i32, i32,) {
    fn p(&amp;self) { print!(&quot;4&quot;); }
}

fn main() {
    (0).p();
    (0,).p();
    (0, 0).p();
    (0, 0,).p();
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-28"><a class="header" href="#提示-28">提示</a></h3>
<p>括号内的值与只有一个元素的元组的类型不一样。</p>
<blockquote>
<p>A value in parentheses does not have the same type as a 1-tuple.</p>
</blockquote>
<h3 id="题解-27"><a class="header" href="#题解-27">题解</a></h3>
<p>答案：1244</p>
<p>在单元素元组的情况下，尾部的逗号是必须的，因为它可以将其与与 <code>(0)</code> 区分开来 (<code>(0)</code> 和 <code>0</code> 相同)。然而，对于更大的元组，它是完全可选的：<code>(i32)</code> 与 <code>(i32,)</code> 是不同的类型，但是 <code>(i32, i32)</code> 和 <code>(i32, i32, )</code> 是相同的。</p>
<blockquote>
<p>The trailing comma is required in the case of a 1-tuple, (0,), because it disambiguates it from (0) which is identical to 0. However, for larger tuples, it is entirely optional: (i32) is a distinct type from (i32,), but (i32, i32) and (i32, i32,) are the same.</p>
</blockquote>
<p>一个整形 0 可以被推断为任何整数类型，但如果没有足够的类型信息，则默认推断为 i32。<code>(0)</code> 被推断为 <code>u32</code>，<code>(0,)</code> 被推断为 <code>(i32,)</code>，因为它们分别具有唯一的 Trait 实现。</p>
<blockquote>
<p>An integral literal 0 can be inferred to be any integer type, but defaults to i32 if insufficient type information is available. (0) is inferred to be a u32 and (0,) is inferred to be a (i32,) because those are respectively the only integral and 1-tuple types with an implementation for Trait.</p>
</blockquote>
<p>由于 <code>(0, 0)</code> 和 <code>(0, 0,)</code> 具有相同的类型，它们的 <code>p</code> 方法的输出也是相同的，但是 Rust 需要在 Trait 的两种可能的实现中进行选择，即 <code>(u32, u32)</code> 和 <code>(i32, i32)</code>。由于 <code>i32</code> 是默认的整形类型，所以在这两种情况下都会选择 <code>(i32, i32)</code>。</p>
<blockquote>
<p>Since (0, 0) and (0, 0,) have the same type, the output of their p methods must be the same, but Rust needs to somehow choose between the two possible implementations of Trait, namely (u32, u32) and (i32, i32). Since i32 is the default integral type, (i32, i32) is chosen in both cases.</p>
</blockquote>
<h2 id="30-clone"><a class="header" href="#30-clone">#30 <code>clone</code></a></h2>
<h3 id="题目-29"><a class="header" href="#题目-29">题目</a></h3>
<pre><code class="language-rs">use std::rc::Rc;

struct A;

fn p&lt;X&gt;(x: X) {
    match std::mem::size_of::&lt;X&gt;() {
        0 =&gt; print!(&quot;0&quot;),
        _ =&gt; print!(&quot;1&quot;),
    }
}

fn main() {
    let a = &amp;A;
    p(a);
    p(a.clone());
    
    let b = &amp;();
    p(b);
    p(b.clone());
    
    let c = Rc::new(());
    p(Rc::clone(&amp;c));
    p(c.clone());
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-29"><a class="header" href="#提示-29">提示</a></h3>
<p>不可变的指针 <code>&amp;T</code> 和 <code>Rc&lt;T&gt;</code> 实现了 <code>Clone</code>，即使 <code>T</code> 并没有实现。</p>
<blockquote>
<p>Immutable pointers <code>&amp;T</code> and <code>Rc&lt;T&gt;</code> implement Clone even if T doesn't.</p>
</blockquote>
<h3 id="题解-28"><a class="header" href="#题解-28">题解</a></h3>
<p>答案：111011</p>
<p>这里出现的两个非引用类型，<code>()</code> 和 <code>A</code> 都是零大小类型 (ZST)。如果你向函数 <code>p&lt;X&gt;</code> 传一个 <code>X = ()</code> 或者 <code>X = A</code>，那么会打印 0。如果传的是 <code>X = ＆()</code> 或者 <code>X = &amp;A</code>，无论指针有多大，总会打印 1。</p>
<blockquote>
<p>Both of our non-reference types, <code>()</code> and <code>A</code>, are zero-sized types (ZST). The function <code>p&lt;X&gt;</code> will print 0 if it is passed a value of type <code>X = ()</code> or <code>X = A</code>, and it will print 1 if passed a reference <code>X = &amp;()</code> or <code>X = &amp;A</code> regardless of exactly how big pointers happen to be.</p>
</blockquote>
<p><code>p(a)</code> 用 <code>X = &amp;A</code> 调用 p，因为参数 a 是 <code>&amp;A</code> 类型的；打印出 1。</p>
<blockquote>
<p>p(a) invokes p with X = &amp;A because the argument a is of type <code>&amp;A</code>; this prints 1.</p>
</blockquote>
<p>在下一行 <code>p(a.clone())</code>，如果 A 实现了 Clone，那么 <code>a.clone()</code> 会调用对应的实现。但是它没有，编译器发现 <code>&amp;T</code> 实现了 Clone，所以这里会调用 <code>&amp;A</code> 实现的 Clone，它会通过简单地重复引用，将一个 <code>&amp;&amp;A</code> 转为 <code>&amp;A</code>。对 p 的调用中，<code>X = &amp;A</code>，也会打印 1。在实践中，当包含引用的结构想要派生出 Clone 时，Clone 对引用的影响是非常有用的，但正如这里所看到的，它有时会意外地启动。</p>
<blockquote>
<p>On the next line, if A implemented Clone then a.clone() would be a call to that impl. But since it doesn't, the compiler finds another applicable impl which is the implementation of Clone for references &amp;T -- so concretely the clone call is calling the impl of Clone for &amp;A which turns a &amp;&amp;A into a &amp;A by simply duplicating the reference. We get another call to p with X = &amp;A printing 1. The impl of Clone for references is useful in practice when a struct containing a reference wants to derive Clone, but as seen here it can sometimes kick in unexpectedly.</p>
</blockquote>
<p>类型 <code>()</code> 确实实现了 Clone，所以 <code>b.clone()</code> 调用了该实现，产生了 <code>()</code>。对 <code>&amp;()</code>的 Clone 实现也适用于 A 的情况，但是编译器更喜欢调用 trait impl for ()，将 <code>&amp;()</code> 转换为 <code>()</code> ，而不是 trait impl for &amp;()，将 <code>&amp;&amp;()</code> 转换为 <code>&amp;()</code>，因为前者对 trait solver 插入的隐式引用或取消引用的要求更少。在对 <code>b.clone()</code> 的调用中，<code>b</code> 的类型是 <code>&amp;()</code>，与 <code>impl Clone for ()</code> 的参数完全匹配，而为了拿到 <code>&amp;&amp;()</code> 作为参数传递给 <code>impl Clone for &amp;()</code>，特征求解器还需要插入额外的隐式引用层 -- 有效地计算 <code>(&amp;b).clone()</code>。</p>
<blockquote>
<p>The type () does implement Clone so b.clone() invokes that impl and produces (). The implementation of Clone for &amp;() would also be applicable as happened in the case of A, but the compiler prefers calling the trait impl for () which converts &amp;() to () over the trait impl for &amp;() which converts &amp;&amp;() to &amp;() because the former is the one that requires fewer implicit references or dereferences inserted by the trait solver. In the call to b.clone(), b is of type &amp;() which exactly matches the argument of the impl Clone for (), while in order to obtain a &amp;&amp;() to pass as argument to the impl Clone for &amp;() the trait solver would need to insert an additional layer of referencing implicitly -- effectively computing (&amp;b).clone().</p>
</blockquote>
<p>我们在调用 <code>p(b)</code> 时实际传入的 <code>X = ＆()</code>，调用 <code>p(b.clone())</code> 时则是 <code>X = ()</code>。</p>
<blockquote>
<p>What we get is p(b) calling p with X = &amp;() and p(b.clone()) calling p with X = (). Together these print 10.</p>
</blockquote>
<p>最后是 Rc，两次对 b 的调用都是 <code>X = Rc&lt;()&gt;</code>，大小不为零。使用 <code>Rc::clone(&amp;c)</code> 而不是 <code>c.clone()</code> 来克隆一个 Rc 被认为是习惯性的，因为 <code>Rc::clone()</code> 使人明显感觉到这是一个引用计数的增加，而不是克隆底层数据，但最终两者指的是同一个函数。要在 Rc 内部调用一个值的克隆，你需要先对它解引用：<code>(*c).clone()</code>。</p>
<blockquote>
<p>Finally in the Rc case, both calls to p are with <code>X = Rc&lt;()&gt;</code> which is non-zero sized. It is considered idiomatic to clone a Rc using <code>Rc::clone(&amp;c)</code> instead of <code>c.clone()</code> because it makes it apparent that this is a reference count bump rather than cloning underlying data, but ultimately both refer to the same function. To call the clone method of a value inside a Rc, you would need to dereference it first: <code>(*c).clone()</code>.</p>
</blockquote>
<h2 id="31-method-lookup-order"><a class="header" href="#31-method-lookup-order">#31 <code>method lookup order</code></a></h2>
<h3 id="题目-30"><a class="header" href="#题目-30">题目</a></h3>
<pre><code class="language-rs">trait Or {
    fn f(self);
}

struct T;

impl Or for &amp;T {
    fn f(self) {
        print!(&quot;1&quot;);
    }
}

impl Or for &amp;&amp;&amp;&amp;T {
    fn f(self) {
        print!(&quot;2&quot;);
    }
}

fn main() {
    let t = T;
    let wt = &amp;T;
    let wwt = &amp;&amp;T;
    let wwwt = &amp;&amp;&amp;T;
    let wwwwt = &amp;&amp;&amp;&amp;T;
    let wwwwwt = &amp;&amp;&amp;&amp;&amp;T;
    t.f();
    wt.f();
    wwt.f();
    wwwt.f();
    wwwwt.f();
    wwwwwt.f();
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-30"><a class="header" href="#提示-30">提示</a></h3>
<p>在方法查找过程中，Rust 会自动解引用，并以明确的顺序借用接收器，直到找到第一个有合适签名的函数。这个顺序是什么呢？</p>
<blockquote>
<p>During a method lookup, Rust automatically derefences and borrows the receiver in a well-defined order until it finds the first function with a suitable signature. What is that order?</p>
</blockquote>
<h3 id="题解-29"><a class="header" href="#题解-29">题解</a></h3>
<p>答案：111222</p>
<p>这篇 <a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html">引用</a> 描述了 Rust 的方法查找顺序。相关的段落如下： </p>
<p>获得 [候选接收方类型] 的方法是：反复解引用接受者表达式的类型，将遇到的每个类型添加到列表中，最后尝试在最后进行非大小胁迫，如果成功，则添加结果类型。然后，对于每个候选的T，将 <code>&amp;T</code> 和 <code>&amp;mut T</code> 添加到紧跟 <code>T</code> 的列表中。</p>
<blockquote>
<p>The <a href="https://doc.rust-lang.org/reference/expressions/method-call-expr.html">Reference</a> describes Rust's method lookup order. The relevant paragraph is:</p>
</blockquote>
<blockquote>
<p>Obtain [the candidate receiver type] by repeatedly dereferencing the receiver expression's type, adding each type encountered to the list, then finally attempting an unsized coercion at the end, and adding the result type if that is successful. Then, for each candidate T, add &amp;T and &amp;mut T to the list immediately after T.</p>
</blockquote>
<p>把这些规则添加到所给的例子里：</p>
<blockquote>
<p>Applying these rules to the given examples, we have:</p>
</blockquote>
<ul>
<li>
<p><code>t.f()</code>: 我们试图找到一个定义在类型 <code>T</code> 上的函数 f，但是没有。接下来，我们搜索类型 <code>&amp;T</code>，并找到 <code>Or</code> 特征的第一个实现，然后我们就完成了。在调用时，找到的调用会打印出 1。</p>
<blockquote>
<p>t.f(): We try to find a function f defined on the type T, but there is none. Next, we search the type &amp;T, and find the first implemenation of the Or trait, and we are done. Upon invocation, the resolved call prints 1.</p>
</blockquote>
</li>
<li>
<p><code>wt.f()</code>: 我们搜索一个定义在 <code>&amp;T</code> 上的函数 f，立刻就成功了。调用后，该函数打印出 1。</p>
<blockquote>
<p>We search for a function f defined on &amp;T, which immediately succeeds. Upon invocation, the function prints 1.</p>
</blockquote>
</li>
<li>
<p><code>wwt.f()</code>: 搜索顺序是 <code>&amp;&amp;T -&gt; &amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;T -&gt; &amp;T</code>，结果打印 1。</p>
<blockquote>
<p>The search order is <code>&amp;&amp;T -&gt; &amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;T -&gt; &amp;T</code>, and we're done. Upon invocation, the function prints 1.</p>
</blockquote>
</li>
<li>
<p><code>wwwt.f()</code>: <code>&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code> 这个打印 2。</p>
<blockquote>
<p><code>&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code>. This prints 2.</p>
</blockquote>
</li>
<li>
<p><code>wwwwt.f()</code>: <code>&amp;&amp;&amp;&amp;T</code> 这个打印 2。 </p>
<blockquote>
<p><code>&amp;&amp;&amp;&amp;T</code>. This prints 2.</p>
</blockquote>
</li>
<li>
<p><code>wwwwwt.f()</code>: <code>&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code> 这个打印 2。</p>
<blockquote>
<p><code>&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;&amp;&amp;T -&gt; &amp;mut &amp;&amp;&amp;&amp;&amp;T -&gt; &amp;&amp;&amp;&amp;T</code>. This prints 2.</p>
</blockquote>
</li>
</ul>
<h2 id="32-march-arm--if-guard"><a class="header" href="#32-march-arm--if-guard">#32 <code>march arm &amp; if guard</code></a></h2>
<h3 id="题目-31"><a class="header" href="#题目-31">题目</a></h3>
<pre><code class="language-rs">fn check(x: i32) -&gt; bool {
    print!(&quot;{}&quot;, x);
    false
}

fn main() {
    match (1, 2) {
        (x, _) | (_, x) if check(x) =&gt; {
            print!(&quot;3&quot;)
        }
        _ =&gt; print!(&quot;4&quot;),
    }
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-31"><a class="header" href="#提示-31">提示</a></h3>
<p>无论哪种方式，在不同的情况下都会令人困惑；没有一个明确的正确行为，提示可以帮助识别。猜测两者都是。</p>
<blockquote>
<p>Either way would be confusing in different situations; there isn't a clear right behavior that a hint could help identify. Guess both. :/</p>
</blockquote>
<h3 id="题解-30"><a class="header" href="#题解-30">题解</a></h3>
<p>答案：124</p>
<p>这个问题覆盖了 match 分支和 guards 的行为。</p>
<blockquote>
<p>This question covers two behaviors of match arms and guards.</p>
</blockquote>
<p>首先，包含 <code>|</code> 的匹配臂上的 if guard 是适用于匹配臂中的所有备选方案，还是只适用于它相邻的方案。在测验代码中，<code>check(x)</code> 是同时对 <code>(x, _)</code> 和 <code>(_, x)</code> 执行，还是只覆盖了 <code>(_, x)</code>？我们希望只有在前者的情况下，1 才会被打印出来。事实上，1 确实被打印出来了。一个匹配臂最多只能有一个 if guard，而且这个 guard 适用于匹配臂中所有的由 <code>|</code> 分隔的备选方案。</p>
<blockquote>
<p>First, whether an if guard on a match-arm containing <code>|</code> applies to all alternatives in the match-arm or just to the one it is adjacent to. In the quiz code, does <code>check(x)</code> execute at all for <code>(x, _)</code> or does it only cover the <code>(_, x)</code> case? We would expect 1 would get printed if and only if the former is the case. In fact 1 does get printed. A match-arm gets to have at most one if guard and that guard applies to all the <code>|</code>-separated alternatives in the arm.</p>
</blockquote>
<p>其次，这个问题还包括匹配臂的一种 &quot;回溯&quot; 行为。当 <code>check(x)</code> 在 <code>(x, _)</code> 上返回 false 时，整个匹配臂是在这里匹配失败，还是 Rust 继续前进到 <code>(_, x)</code> 并第二次执行 guard？我们期望当且仅当后一种情况出现时 2 会被打印出来。事实上，2 确实被打印出来了；if guard 被运行了多次，在匹配臂中的每一个 <code>|</code> 分隔的选项中都有一次。</p>
<blockquote>
<p>But second, this question also covers a kind of &quot;backtracking&quot; behavior of match-arms. After <code>check(x)</code> returns false on <code>(x, _)</code>, does the whole match-arm fail to match at that point or does Rust move on to <code>(_, x)</code> and execute the guard a second time? We would expect 2 to be printed if and only if the latter is the case. In fact 2 does get printed; the guard is being run multiple times, once per <code>|</code>-separated alternative in the match-arm.</p>
</blockquote>
<h2 id="33-ranges-method"><a class="header" href="#33-ranges-method">#33 <code>Range's method</code></a></h2>
<h3 id="题目-32"><a class="header" href="#题目-32">题目</a></h3>
<pre><code class="language-rs">use std::ops::RangeFull;

trait Trait {
    fn method(&amp;self) -&gt; fn();
}

impl Trait for RangeFull {
    fn method(&amp;self) -&gt; fn() {
        print!(&quot;1&quot;);
        || print!(&quot;3&quot;)
    }
}

impl&lt;F: FnOnce() -&gt; T, T&gt; Trait for F {
    fn method(&amp;self) -&gt; fn() {
        print!(&quot;2&quot;);
        || print!(&quot;4&quot;)
    }
}

fn main() {
    (|| .. .method())();
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-32"><a class="header" href="#提示-32">提示</a></h3>
<p><code>||</code> 是一个闭包。<code>..</code> 是 range 的语法，通常会在切片中看到，例如 <code>&amp;s[1..4]</code> 或者 <code>&amp;s[..s.len() - 1]</code>。</p>
<blockquote>
<p><code>||</code> is a closure introducer. <code>..</code> is range syntax, normally seen in slicing operations like <code>&amp;s[1..4]</code> or <code>&amp;s[..s.len() - 1]</code>.</p>
</blockquote>
<h3 id="题解-31"><a class="header" href="#题解-31">题解</a></h3>
<p>答案：24</p>
<p>两个合理的可能是 1 或 24，取决于如何区分 <code>|| .. .method()</code> 的优先级。</p>
<blockquote>
<p>The two rational possibilities are 1 or 24, depending on how the precedence of <code>|| .. .method()</code> is disambiguated.</p>
</blockquote>
<p>如 <code>|| ((..).method())</code>，这是一个闭包，其主体调用了我们对 <code>RangeFull</code> 的实现的 Trait 方法。在这种情况下，main 会打印 1。它不会打印 13，因为从 <code>(..).method()</code> 返回的 <code>fn()</code> 从未被 main 调用。</p>
<blockquote>
<p>As <code>|| ((..).method())</code>, which is a closure whose body invokes our impl of Trait on <code>RangeFull</code>. In this case main would print 1. It would not print 13 because the <code>fn()</code> returned from <code>(..).method()</code> is never invoked by main.</p>
</blockquote>
<p>如 <code>(|| ..).method()</code>，它是我们对 <code>FnOnce()-&gt;T</code> 实现的 Trait 的调用，其中 <code>T</code> 被推断为 <code>RangeFull</code>。在这种情况下，main 会打印 24。</p>
<blockquote>
<p>As <code>(|| ..).method()</code>, which is an invocation of our impl of Trait on <code>FnOnce() -&gt; T</code> where T is inferred to be <code>RangeFull</code>. In this case main would print 24.</p>
</blockquote>
<p>后者才是正确的答案。</p>
<blockquote>
<p>The latter of those is the correct answer.</p>
</blockquote>
<p>我们可以通过显式的括号来实现前者的行为，如上文中所示。</p>
<blockquote>
<p>We can achieve the former behavior by explicitly parenthesizing as shown in the bullet above.</p>
</blockquote>
<p>只有部分括号如 <code>|| (.. .method())</code> 是不够的。这会导致一个解析错误。</p>
<blockquote>
<p>Partially parenthesizing as <code>|| (.. .method())</code> is not sufficient. This results in a parse error.</p>
</blockquote>
<pre><code class="language-rs">error: expected one of `)` or `,`, found `.`
  --&gt; src/main.rs:22:13
   |
22 |     (|| (.. .method()))();
   |            -^ expected one of `)` or `,`
   |            |
   |            help: missing `,`
</code></pre>
<p>正确处理像 <code>|| .. .method()</code> 这样相当模糊的表达式对 Rust tooling 来说是一个挑战，从 Rustfmt (<a href="https://github.com/rust-lang/rustfmt/issues/4808">rust-lang/rustfmt#4808</a>) 和 Syn (<a href="https://github.com/dtolnay/syn/issues/1019">dtolnay/syn#1019</a>) 的相关错误中可以看出。</p>
<blockquote>
<p>Correctly handling a quite ambiguous expression like || .. .method() is a challenge for tooling, as seen by the associated bugs in Rustfmt (<a href="https://github.com/rust-lang/rustfmt/issues/4808">rust-lang/rustfmt#4808</a>) and Syn (<a href="https://github.com/dtolnay/syn/issues/1019">dtolnay/syn#1019</a>).</p>
</blockquote>
<h2 id="34-size-of-fn"><a class="header" href="#34-size-of-fn">#34 <code>size of fn</code></a></h2>
<h3 id="题目-33"><a class="header" href="#题目-33">题目</a></h3>
<pre><code class="language-rs">fn d&lt;T&gt;(_f: T) {
    match std::mem::size_of::&lt;T&gt;() {
        0 =&gt; print!(&quot;0&quot;),
        1 =&gt; print!(&quot;1&quot;),
        _ =&gt; print!(&quot;2&quot;),
    }
}

fn a&lt;T&gt;(f: fn(T)) {
    d(f);
}

fn main() {
    a(a::&lt;u8&gt;);
    d(a::&lt;u8&gt;);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-33"><a class="header" href="#提示-33">提示</a></h3>
<p>用任何其他整数类型代替 u8，答案都是一样的。</p>
<blockquote>
<p>The answer would be the same with any other integer type in place of u8.</p>
</blockquote>
<h3 id="题解-32"><a class="header" href="#题解-32">题解</a></h3>
<p>答案：20</p>
<p>表达式 <code>a::&lt;u8&gt;</code> 的类型是一个零大小类型（ZST）。</p>
<blockquote>
<p>The expression <code>a::&lt;u8&gt;</code>'s type is a zero-sized type (ZST).</p>
</blockquote>
<p>Rust 围绕函数类型的作出的选择和具体实现与几乎所有其他语言都不同，但它是 Rust 许多零开销抽象的重要促成因素。在 Rust 中，每个函数（或泛型函数的每个不同实例）都有自己的独特类型。特别是，即使是具有相同函数签名的两个函数也会有不同的类型。</p>
<blockquote>
<p>Rust's implementation choices around function types are different from nearly all other languages, but are an important enabler of many of Rust's zero-overhead abstractions. In Rust, every function (or every distinct instantiation of a generic function) has its own unique type. In particular, even two functions with the same function signature would have different types.</p>
</blockquote>
<p>每个函数都有一个独特的类型，这种特性允许类型本身携带将被调用的函数的信息，不需要任何运行时状态，如指针。</p>
<blockquote>
<p>Having a unique type for each function allows the type itself to carry the information of what function will be called, not needing any runtime state such as a pointer.</p>
</blockquote>
<p>为了理解这种优化方法的优势，考虑 <code>Iterator::map</code> 和两个调用 <code>iter.map(f)</code> 和 <code>iter.map(g)</code>，其中 <code>f</code> 和 <code>g</code> 是具有相同签名的不同函数。因为 <code>f</code> 和 <code>g</code> 有不同的类型，这两个 map 调用会产生两个不同的泛型函数的单态实例，其中一个静态地调用 <code>f</code>，另一个静态地调用 <code>g</code>，就像你直接为每个函数写了一个特殊的 map 实现，而没有 map 提供的抽象。因此，泛型 map 是一个零成本的抽象。传统上，在其他语言如 C++ 或 Go 中，f 和 g 会被作为一个函数指针传递给 map，并且只有一个 map 的实例，包含一个执行函数调用的动态分发，这通常会比静态调用函数更慢。这种性能缺陷使得这些语言中的 map 不是一个零成本的抽象。</p>
<blockquote>
<p>To understand the optimization advantages of this approach, consider <code>Iterator::map</code> and the two calls <code>iter.map(f)</code> and iter.map(g) where f and g are different functions with the same signature. Because f and g have distinct types, the two map calls would produce two different monomorphic instantiations of the generic map function, one of which statically calls f and the other statically calls g, as if you had directly written a special-purpose map implementation specific to each function without the abstraction provided by map. The generic map is thus a zero-overhead abstraction. Traditionally in other languages such as C++ or Go, in this situation f and g would be passed to map as a function pointer and there would be just one instantiation of map, containing a dynamic dispatch to execute the function call, which is usually going to be slower than statically calling the right function. This performance penalty makes map in those languages not a zero-overhead abstraction.</p>
</blockquote>
<p>目前在 Rust 中，没有语法来表达特定的函数类型，所以它们总是作为一个通用的类型参数与 <code>FnOnce</code>、<code>Fn</code> 或 <code>FnMut</code> 绑定传递。在错误信息中，你可能会看到函数类型以 <code>fn(T) -&gt; U {fn_name}</code> 的形式出现，但你不能在代码中使用这种语法。</p>
<blockquote>
<p>Currently in Rust there is no syntax to express the type of a specific function, so they are always passed as a generic type parameter with a FnOnce, Fn or FnMut bound. In error messages you might see function types appear in the form fn(T) -&gt; U {fn_name}, but you can't use this syntax in code.</p>
</blockquote>
<p>另一方面，一个函数指针，<code>fn(T) -&gt; U</code>，在运行时是指针大小。函数类型可以被胁迫为函数指针，这一点在你需要将 &quot;选择调用那个函数&quot; 推迟到运行时很有用。</p>
<blockquote>
<p>On the other hand, a function pointer, fn(T) -&gt; U, is pointer-sized at runtime. Function types can be coerced into function pointers, which can be useful in case you need to defer the choice of function to call until runtime.</p>
</blockquote>
<p>在测验代码中，main 中的第一个调用在调用 d 之前将 <code>a::&lt;u8&gt;</code> 从一个函数胁迫为一个函数指针<code>(fn(fn(u8)) {a::&lt;u8&gt;}</code> 到 <code>fn(fn(u8)))</code>，因此在一个具有 64 位函数指针的系统中，它的大小为 8。main 中的第二个调用不涉及函数指针；d 被直接调用，T 是 <code>a::&lt;u8&gt;</code> 的不可表达的类型，它的大小为零。</p>
<blockquote>
<p>In the quiz code, the first call in main coerces <code>a::&lt;u8&gt;</code> from a function to a function pointer <code>(fn(fn(u8)) {a::&lt;u8&gt;}</code> to <code>fn(fn(u8)))</code> prior to calling d, so its size would be 8 on a system with 64-bit function pointers. The second call in main does not involve function pointers; d is directly called with T being the inexpressible type of <code>a::&lt;u8&gt;</code>, which is zero-sized.</p>
</blockquote>
<h2 id="35-hygiene-2"><a class="header" href="#35-hygiene-2">#35 <code>Hygiene 2</code></a></h2>
<h3 id="题目-34"><a class="header" href="#题目-34">题目</a></h3>
<pre><code class="language-rs">macro_rules! x {
    ($n:expr) =&gt; {
        let a = X($n);
    };
}

struct X(u64);

impl Drop for X {
    fn drop(&amp;mut self) {
        print!(&quot;{}&quot;, self.0);
    }
}

fn main() {
    let a = X(1);
    x!(2);
    print!(&quot;{}&quot;, a.0);
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-34"><a class="header" href="#提示-34">提示</a></h3>
<p>有一些程序，cargo expand 产生的展开后的代码可以编译，但其行为与原始代性码的原始宏卫生不同。</p>
<blockquote>
<p>There are some programs for which cargo expand produces expanded code that compiles, but behaves differently than the original code with the original macro hygiene.</p>
</blockquote>
<h3 id="题解-33"><a class="header" href="#题解-33">题解</a></h3>
<p>答案：121</p>
<p>根据你对 macro 展开的假设，本题有两条看似合理的错误答案：</p>
<blockquote>
<p>There are two reasonable paths to an incorrect answer on this question, based on your assumptions around how this macro gets expanded:</p>
</blockquote>
<pre><code class="language-rs">1. let a = X(2);
2. { let a = X(2); }
</code></pre>
<p>如果第一种展开方式是正确的，这个宏会引入一个新的绑定，a，它将遮蔽 main 中已经直接分配的 a。因此，main 中的 print 语句将首先执行，打印 2，然后变量将按引入的顺序倒序 drop，先打印 2，再打印 1，最后输出 221。</p>
<blockquote>
<p>If the first expansion were right, the macro would introduce a new binding, a, which shadows the a already directly assigned in main. So the print statement in main would execute first, printing 2, then the variables would drop in reverse order of introduction, printing 2 then 1, with a final output of 221.</p>
</blockquote>
<p>如果第二种展开方式是正确的，这个宏会在一个嵌套的作用域中引入 a，只在这个作用域中遮蔽已经存在的 a，而不是在它之外。由于新的 a 的作用域在打印语句之前就结束了，所以当它超出作用域时，它的 Drop impl 将是第一个执行的打印，打印 2。接下来，main 中的打印将打印 1，也就是第一个 a 的值，最后，当这个值在 main 结束时，再打印 1，最终输出 211。</p>
<blockquote>
<p>If the second expansion were right, the macro would introduce a in a nested scope, shadowing the already existing a only inside of that scope and not beyond it. Since the new a's scope ends before the print statement, its Drop impl when going out of scope would be the first print to execute, printing 2. Next the print in main would print 1 which is the value of the first a, and finally 1 again when that value drops at the end of main, with final output 211.</p>
</blockquote>
<p>如果你读过关于宏卫生性的文章，那么你可能已经猜到它的实现方式与第二个选项类似。重要的是，宏的内部结构不会与调用地点范围内的变量发生冲突，而且 Rust 宏在防止意外的名称冲突方面做得很好。然而，这并不是卫生性的实现方式；在宏扩展周围引入人为的作用域会使它们的作用更加有限，而且不会解决很多其他的卫生性问题。</p>
<blockquote>
<p>If you've read about macro hygiene then you might have guessed it would be implemented something like this second option. It's important that internals of a macro don't interfere coincidentally with variables in scope at the call site, and Rust macros mostly do a good job of preventing unintended name collisions. However, this is not how hygiene is implemented; introducing artificial scopes around macro expansions would make them more limited in their usefulness, and wouldn't solve a lot of other hygiene problems.</p>
</blockquote>
<p>你可以把 lazily calcalute 想象成给每个提到的局部变量的名字分配一个颜色，允许在作用域内有多个可区分的局部变量同时拥有相同的文本名称。</p>
<blockquote>
<p>You can instead imagine hygiene as a way of assigning a color to each mention of the name of a local variable, allowing for there to be multiple distinguishable local variables in scope simultaneously with the same textual name.</p>
</blockquote>
<pre><code class="language-rs">fn main() {
    let a = X(1);
    let a = X(2);
    print!(&quot;{}&quot;, a.0);
}
</code></pre>
<p>所以打印出来的是 main 的标识符 a 的值，也就是 1，然后两个值按照引入的相反顺序丢掉，先打印 2 再打印 1，程序的输出是 121。</p>
<blockquote>
<p>So what's printed is the value of main's identifier a which is 1, then the two values are dropped in reverse order of introduction printing 2 then 1, and the output of the program is 121.</p>
</blockquote>
<h2 id="36-move--fn"><a class="header" href="#36-move--fn">＃36 <code>move &amp; Fn</code></a></h2>
<h3 id="题目-35"><a class="header" href="#题目-35">题目</a></h3>
<pre><code class="language-rs">fn call(mut f: impl FnMut() + Copy) {
    f();
}

fn g(mut f: impl FnMut() + Copy) {
    f();
    call(f);
    f();
    call(f);
}

fn main() {
    let mut i = 0i32;
    g(move || {
        i += 1;
        print!(&quot;{}&quot;, i);
    });
}
</code></pre>
<ol>
<li>未定义的行为</li>
<li>编译失败</li>
<li>程序确定会输出：[ ]</li>
</ol>
<h3 id="提示-35"><a class="header" href="#提示-35">提示</a></h3>
<p>变量 <code>i</code> 被编译器生成的闭包对象所捕获。</p>
<blockquote>
<p>The variable <code>i</code> is captured by value in the compiler-generated closure object.</p>
</blockquote>
<h3 id="题解-34"><a class="header" href="#题解-34">题解</a></h3>
<p>答案：1223</p>
<p>传入 g 的对象是一个 <code>FnMut</code> 闭包，它捕获了一个整数。实际上，它是一个不可命名的结构体，包含一个类型为 i32 的字段，并有一个函数调用操作符，该操作符接收 <code>&amp;mut self</code>。</p>
<blockquote>
<p>The object passed into g is a FnMut closure which captures an integer by value. Effectively it's an unnameable struct containing a single field whose type is i32, with a function call operator that takes &amp;mut self:</p>
</blockquote>
<pre><code class="language-rs">#[derive(Copy, Clone)]
pub struct UnnameableClosure {
    i: i32,
}

impl UnnameableClosure {
    pub fn unnameable_call_operator(&amp;mut self) {
        self.i += 1;
        print!(&quot;{}&quot;, self.i);
    }
}

let mut i = 0i32;
g(UnnameableClosure { i });
</code></pre>
<p>g 里面的 4 个调用的行为如下。</p>
<blockquote>
<p>The behavior of the 4 calls inside g is as follows:</p>
</blockquote>
<ul>
<li>
<p><code>f()</code> 运行闭包，其通过值捕获的 <code>i</code> 的值变为 1。</p>
<blockquote>
<p>f() runs the closure and its by-value captured value of i becomes 1.</p>
</blockquote>
</li>
<li>
<p><code>call(f)</code> 制造一个 <code>f</code> 的副本，作为 call 的参数。这个副本被执行，它的 <code>i</code> 变成了 2，但是原始闭包仍然保持着它捕获的 <code>i</code> 的值为 1。<code>f</code> 的副本在调用主体的末尾超出了作用域被 drop。</p>
<blockquote>
<p>call(f) makes a copy of f to become the argument of call. The copy gets executed and its i becomes 2, but the original closure still holds a value of 1 for its captured i. The copy of the closure gets dropped as it goes out of scope at the end of the body of call.</p>
</blockquote>
</li>
<li>
<p><code>f()</code> 第二次运行原始闭包，其 i 变为 2。</p>
<blockquote>
<p>f() runs the original closure a second time and its i becomes 2.</p>
</blockquote>
</li>
<li>
<p><code>call(f)</code> 第二次复制 f 并执行副本，它的 i 变成了 3。</p>
<blockquote>
<p>call(f) copies f a second time and executes the copy, its i becomes 3.</p>
</blockquote>
</li>
</ul>
<p>从 Rust 1.26 开始，如果闭包的所有捕获都实现了 Clone，则闭包自动实现了 Clone；如果所有捕获都实现了 Copy，则闭包自动实现了 Copy。</p>
<blockquote>
<p>Since Rust 1.26, closures automatically implement Clone if all their captures implement Clone, and Copy if all the captures implement Copy.</p>
</blockquote>
<p>如果 quiz 代码中省略了 move 关键字，编译器生成的闭包将通过可变引用而不是通过值捕获 i。</p>
<blockquote>
<p>If the move keyword were omitted from the quiz code, the compiler-generated closure would capture i by mutable reference instead of by value:</p>
</blockquote>
<pre><code class="language-rs">pub struct UnnameableClosure&lt;'a&gt; {
    i: &amp;'a mut i32,
}
</code></pre>
<p>并且不再有 Copy impl，因为将一个可变引用复制成多个副本是不正确的（aliasing xor mutation；这是借用检查器的重点）。</p>
<blockquote>
<p>and there would no longer be a Copy impl, because it's incorrect to duplicate a mutable reference into multiple copies (aliasing xor mutation; this is the point of the borrow checker).</p>
</blockquote>
<p>对于 Rust 的初学者来说，一个经常出现的困惑是 move, non-move 闭包与 Fn、FnMut 和 FnOnce 闭包之间的关系。这是两个几乎完全不同的东西。正如上面的 <code>UnnameableClosure</code> 伪代码所示，move 与 non-move 是指编译器生成的闭包结构的字段是否与原始被捕获变量的类型相同，或者是对原始捕获变量类型的引用（例如，<code>i32</code> 与 <code>&amp;mut i32</code>）。相比之下，<code>Fn</code> vs <code>FnMut</code> vs <code>FnOnce</code> 是关于编译器生成的闭包结构的调用方法是否有一个接收器，该接收器是 <code>&amp;self</code> vs <code>&amp;mut self</code> vs <code>self</code>。</p>
<blockquote>
<p>One recurring source of confusion for Rust beginners is the relationship between move and non-move closures vs Fn and FnMut and FnOnce closures. These are two nearly-orthogonal things. As illustrated in the UnnameableClosure pseudocode above, move vs non-move is about whether the fields of the compiler-generated closure struct have the same type as the original captured variable's type, vs are references to the original captured variable's type (i32 vs &amp;mut i32, for example). In contrast, Fn vs FnMut vs FnOnce is about whether the call method of the compiler-generated closure struct has a receiver which is &amp;self vs &amp;mut self vs self.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>sidebar_position: 1
sidebar_label: Rust 语言
sidebar_class_name: green</h2>
<h1 id="rust-语言"><a class="header" href="#rust-语言">Rust 语言</a></h1>
<h2 id="1-生命周期"><a class="header" href="#1-生命周期">1. 生命周期</a></h2>
<h3 id="自动处理生命周期"><a class="header" href="#自动处理生命周期">自动处理生命周期</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Only one reference in input, so the output must be derived from that input
fn foo(&amp;A) -&gt; &amp;B; // sugar for:
fn foo&lt;'a&gt;(&amp;'a A) -&gt; &amp;'a B;

// Many inputs, assume they're all independent
fn foo(&amp;A, &amp;B, &amp;C); // sugar for:
fn foo&lt;'a, 'b, 'c&gt;(&amp;'a A, &amp;'b B, &amp;'c C);

// Methods, assume all output lifetimes are derived from `self`
fn foo(&amp;self, &amp;B, &amp;C) -&gt; &amp;D; // sugar for:
fn foo&lt;'a, 'b, 'c&gt;(&amp;'a self, &amp;'b B, &amp;'c C) -&gt; &amp;'a D;
<span class="boring">}
</span></code></pre></pre>
<h2 id="2-智能指针"><a class="header" href="#2-智能指针">2. 智能指针</a></h2>
<h3 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h3>
<p>实现了 Deref Trait 和 Drop Trait 的就是智能指针</p>
<ol>
<li>Deref Trait: 具有指针语义</li>
<li>Drop Trait：拥有内存自动管理的机制</li>
</ol>
<p>看一眼 Box 的实现</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
impl&lt;T: ?Sized, A: Allocator&gt; Deref for Box&lt;T, A&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;**self
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="简单实现"><a class="header" href="#简单实现">简单实现</a></h3>
<p>我们实现一个智能指针（只实现了 Deref Trait）</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::ops::Deref;

pub struct MySmartPointer&lt;T&gt; (T);

impl&lt;T&gt; MySmartPointer&lt;T&gt; {
    pub fn new(t: T) -&gt; Self {
        MySmartPointer(t)
    }
}

impl&lt;T&gt; Deref for MySmartPointer&lt;T&gt; {
    type Target = T;
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
// 调用*x 其实就是调用 *x.deref()
let x = 5;
let a = MySmartPointer::new(x);
let b = Box::new(x);
assert_eq!(x, *a.deref());
assert_eq!(x, *a);
assert_eq!(x, *b.deref());
assert_eq!(x, *b);
print!(&quot;{}&quot;, a.to_string())
<span class="boring">}
</span></code></pre></pre>
<h3 id="自动解引用的时机"><a class="header" href="#自动解引用的时机">自动解引用的时机</a></h3>
<ul>
<li>
<p>遇到*运算符自动接引用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>assert_eq!(x, *a.deref());
assert_eq!(x, *a);
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>遇到 . 运算符接引用调用方法</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print!(&quot;{}&quot;, a.to_string())
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p>参数传递自动解引用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;aaaa&quot;);
fn take_str(s: &amp;str) {
    print!(&quot;{}&quot;, s);
}
take_str(&amp;s);

#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
impl ops::Deref for String {
    type Target = str;

    #[inline]
    fn deref(&amp;self) -&gt; &amp;str {
        unsafe { str::from_utf8_unchecked(&amp;self.vec) }
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h3 id="自动管理内存"><a class="header" href="#自动管理内存">自动管理内存</a></h3>
<p>自动化管理内存 (drop，作用域外自动释放内存)</p>
<h2 id="2-atomic-在-rust-中的实践"><a class="header" href="#2-atomic-在-rust-中的实践">2. Atomic 在 rust 中的实践</a></h2>
<p><a href="https://www.youtube.com/watch?v=rMGWeSjctlY">Crust of Rust: Atomics and Memory Ordering</a></p>
<h3 id="使用-atomic-实现简单的-mutex"><a class="header" href="#使用-atomic-实现简单的-mutex">使用 Atomic 实现简单的 Mutex</a></h3>
<pre><pre class="playground"><code class="language-rust">use std::{sync::atomic::{AtomicBool, Ordering, AtomicUsize}, thread::{self, spawn}, cell::UnsafeCell};

const UNLOCKED: bool = true;
const LOCKED: bool = false;

struct Mutex&lt;T&gt; {
    locked: AtomicBool,
    v: UnsafeCell&lt;T&gt;
}

unsafe impl&lt;T&gt; Sync for Mutex&lt;T&gt; where T: Send {}

impl&lt;T&gt; Mutex&lt;T&gt; {

    pub fn new(v: T) -&gt; Self {
        Self {
            locked: AtomicBool::new(UNLOCKED),
            v: UnsafeCell::new(v)
        }
    }

    /// 暴露一个可变引用出去
    ///
    /// 当线程 A 和线程 B 同时执行时，A，B 可能同时拿到🔓，并同时上锁，这两个线程并没有`看到`对方页拿到了锁
    /// 所以就出先了，线程 A 和 B 同时从寄存器拿到值 1，改为了 2，然后复制到寄存器内，后修改的会覆盖前一次修改
    /// 为了解决上述问题，下面是一些解决方法
    ///
    /// 方案 1，使用`compare_exchange`合并加锁上锁过程
    /// while self.locked.compare_exchange(UNLOCKED, LOCKED, Ordering::Relaxed, Ordering::Relaxed).is_err() {}
    ///
    /// #1 compare_exchange 是低效的，如果是多核都在同时争夺锁，8 个核中有一个和先拿到了锁
    /// 那么剩下的 7 个核依然会互相竞争，这个变量的内存就会在多个核中不断拷贝
    /// #2 相比于 mutex，mutex 拿不到锁就会阻塞线程，而 compare_exchange 拿不到就会返回一个 Err
    /// #3 rust 中还提供了 compare_and_exchange_weak，最大的区别是
    ///     compare_and_exchange 只允许在判断 Current v alue 和传入的值不一样时返回 Err
    ///     compare_and_exchange_weak 即使在一样的时候也可能会返回 Err，这种细小的差别能够用于某些场景，让性能更好
    ///     原因是由于在不同平台上的实现不同
    ///         x86: compare_and_swap
    ///         ARM: LDREX STREX
    ///     在 x86 上 weak 与普通的相同，
    ///     在 ARM 上：
    ///         compare_and_exchange: impl using a loop of LDREX and STREX
    ///         compare_and_exchange_weak: LDREX and STREX with no loop, it may be fake
    pub fn with_lock&lt;R&gt;(&amp;self, f: impl FnOnce(&amp;mut T) -&gt; R) -&gt; R {
        // 拿🔓 上🔓
        // while self.locked.load(Ordering::Relaxed) != UNLOCKED {}
        // self.locked.store(LOCKED, Ordering::Relaxed);

        // 方案 1
        // while self.locked.compare_exchange(UNLOCKED, LOCKED, Ordering::Relaxed, Ordering::Relaxed).is_err() {}

        // 方案 2 在 arm 下有更好的性能
        while self.locked.compare_exchange_weak(UNLOCKED, LOCKED, Ordering::Relaxed, Ordering::Relaxed).is_err() {
            // 假如现在 current value 就是 UNLOCKED 状态，已经修改为 LOCKED 状态，那么就已经拿到了所有权
            // 加入现在还没有修改完成，current value 依然是 UNLOCKED 状态，当前线程就会卡住，直到有别的线程成功拿到了所有权
            while self.locked.load(Ordering::Relaxed) == LOCKED {
                thread::yield_now();
            }
            thread::yield_now();
        }

        // 暴露数据
        let ret = f(unsafe { &amp;mut *self.v.get() });
        // 解🔓
        self.locked.store(UNLOCKED, Ordering::Relaxed);
        ret
    }
}

fn main() {
    let l: &amp;'static _ = Box::leak(Box::new(Mutex::new(0)));

    let handles: Vec&lt;_&gt; = (0..1000).map(|_| {
        thread::spawn(move || {
            for _ in 0..1000 {
                l.with_lock(|v| {
                    *v += 1;
                })
            }
        })
    }).collect();

    for handle in handles {
        handle.join().unwrap();
    }

    // 这里依然会报错
    assert_eq!(l.with_lock(|v| *v), 1000 * 1000);

}
</code></pre></pre>
<h3 id="acquire-与-release"><a class="header" href="#acquire-与-release">Acquire 与 Release</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 但是即使用了上面的东西也有可能会出问题，虽然在 X86 64 位系统上没有出现问题，这是因为他不支持！，他只支持 Seq 的，不过还是要说明问题
/// 因为下面对变量 v 的修改和上锁释放锁的过程毫不相关，
/// 所以下一行可能被重新排列在加锁之前，或者解锁之后，这两种都是不允许的，但是 cpu 和编译器就可能这样做
///
/// 对此需要使用 Acquire 和 Release
pub fn with_lock2&lt;R&gt;(&amp;self, f: impl FnOnce(&amp;mut T) -&gt; R) -&gt; R {
    // 任何之后的读写操作不会被重排到 Acquire 之前
    // 别的线程中的写操作，对于这里的 Acquire 都是可见的
    while self.locked.compare_exchange_weak(UNLOCKED, LOCKED, Ordering::Acquire, Ordering::Relaxed).is_err() {
        while self.locked.load(Ordering::Relaxed) == LOCKED {
            thread::yield_now();
        }
        thread::yield_now();
    }
    let ret = f(unsafe { &amp;mut *self.v.get() });

    // 任何之前的读写操作不会被重排到 Release 之后
    // 这个线程里的所有写操作对别的线程中的 Acquire 都是可见的
    self.locked.store(UNLOCKED, Ordering::Release);
    ret
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="必需用-seq-的场景"><a class="header" href="#必需用-seq-的场景">必需用 Seq 的场景</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn seq_test() {
    // fetch_add always succeed

    let x: &amp;'static _ = Box::leak(Box::new(AtomicBool::new(false)));
    let y: &amp;'static _ = Box::leak(Box::new(AtomicBool::new(false)));
    let z: &amp;'static _ = Box::leak(Box::new(AtomicUsize::new(0)));
    let tx = thread::spawn(move || {
        x.store(true, Ordering::Release);                  // ！！！
    });
    let ty = thread::spawn(move || {
        y.store(true, Ordering::Release);
    });
    let t1 = spawn(move || {
        while !x.load(Ordering::Acquire) {}
        if y.load(Ordering::Acquire) {
            z.fetch_add(1, Ordering::Release);
        }
    });
    let t2 = spawn(move || {
        while !y.load(Ordering::Acquire) {}                    // 这行和下面一行可能重排 (或者说不是重排，单纯时可见性的问题，下面的 x 就是看到了 x 是 false)
        if x.load(Ordering::Acquire) {                         // ！！！x 为 false，当 x 被修改为 true 后，也不会发生改变
            z.fetch_add(1, Ordering::Release);
        }
    });
    println!(&quot;{}&quot;, z.load(Ordering::SeqCst));

    // What are the possibles for z?
    // - is 0 possibly ?
    //   经过判断，至少有下面的条件
    //     t1 must run after tx
    //     t2 must run after ty
    //   几种排列组合应该是 1 或 2，没有 0
    //   但是 0 还是可能的，
    //           t2    t1,t2
    //   MO(x)  false  true
    //           t1    t1,t2
    //   MO(y)  false  true
    // - is 1 possibly ?
    //   Yes: tx -&gt; t1 -&gt; ty -&gt; t2
    // - is 2 possibly ?
    //   Yes: tx -&gt; ty -&gt; t1 -&gt; t2

}
<span class="boring">}
</span></code></pre></pre>
<h2 id="3-常用-trait"><a class="header" href="#3-常用-trait">3. 常用 Trait</a></h2>
<h3 id="31-read"><a class="header" href="#31-read">3.1 Read</a></h3>
<p>Read Trait 的功能是：从数据源拉取 (Pull) 一定数据到指定的缓冲区，返回读取的字节数。</p>
<p><strong>关于阻塞：</strong> read 函数不保证 Read 是否会处于阻塞状态，如果一个 read 过程阻塞了而且等待失败，那他就会返回一个 [<code>Err</code>] 标记。</p>
<p><strong>关于返回值：</strong> 如果<code>read()</code>返回的是 [<code>OK(n)</code>] , 它的实现就必须保证<code>0 &lt;- n &lt; buf.len()</code>。
如果<code>n == 0</code>，那可能有两种情况：</p>
<ol>
<li>reader 已经到达了<code>the end of file</code>，而且这个<code>file</code>可能不会在产生新数据。注意，这里只是 likely，比如：在 linux
系统中，read 可能对一个 [<code>TcpStream</code>] 调用了<code>recv</code>系统调用，0 代表这个连接已经被成功关闭，如果是对 [<code>File</code>] ,
那就可能意味着确实读取到了文件的末尾，但是如果有更多的数据被追加 (append) 到文件末尾，那么未来的 read 操作依然能够正常返回被追加的数据</li>
<li>缓冲区 (buffer) 大小确实就是 0</li>
</ol>
<p><code>n</code> 只要小于缓冲区的长度一般就不是个错误，即使文件还没有被读取完，这种情况可能会发生在，当前只有一部分数据是可用的，或者是 read 操作被一个信号打断了</p>
<p><strong>关于安全性：</strong></p>
<ul>
<li>
<p>因为实现这个 Trait 是安全的，调用者不能用 <code>n &lt; buf.len()</code> 去确保安全，使用 unsafe 是更要小心确保诸如越界问题是否会发生。</p>
</li>
<li>
<p>read 不保证 buf 里的数据是对的，所以不推荐读取缓冲区里的数据，只推荐向缓冲区里写入数据</p>
</li>
<li>
<p>相应的，调用者不能有任何假设，这个 buf 会被 read 怎么使用，read 函数也可能会从中读取内容。所以我们需要保证在调用 read 前，这个 buf
已经被初始化过了，调用没有被初始化的 buf 是不安全的，可能会导致未定义的行为</p>
</li>
</ul>
<p>*<strong>关于错误：</strong> 如果遇到了 Error，那就必须保证没有读取过任何字节，如果遇到了<code>ErrorKind::Interrupted</code>，而且不能作别的事时，
读取过程就必须被回滚</p>
<p>下面是一个来自 doc 的例子</p>
<pre><pre class="playground"><code class="language-rust">use std::io;
use std::io::prelude::*;
use std::fs::File;
fn main() -&gt; io::Result&lt;()&gt; {
    let mut f = File::open(&quot;foo.txt&quot;)?;
    let mut buffer = [0; 10];
    // read up to 10 bytes
    let n = f.read(&amp;mut buffer[..])?;
    println!(&quot;The bytes: {:?}&quot;, &amp;buffer[..n]);
    Ok(())
}
</code></pre></pre>
<h3 id="32-write"><a class="header" href="#32-write">3.2 Write</a></h3>
<p>Write 的基本功能就是向 writer 中写入一段 buf，返回写入的字节数 <strong>关于阻塞：</strong> write 会尝试向 writer 中写入整个 buf
里的内容，但是写入可能不成功，或者写入时产生了一个错误，调用一次 write 意味着最多一次尝试写入 write 函数同样不保证 Write
是否处于阻塞状态以等待数据被写入，如果一次写入阻塞了，他可能会返回一个 [<code>Err</code>]。</p>
<p><strong>关于返回值：</strong> 如果<code>write()</code>返回的是 [<code>OK(n)</code>] , 它的实现就必须保证<code>0 &lt;- n &lt; buf.len()</code>。
如果<code>n == 0</code>，那可能有两种情况：</p>
<ol>
<li>被写入的东西已经不会接受新数据了，之后也不一定会</li>
<li>缓冲区 (buffer) 大小确实就是 0</li>
</ol>
<p><code>n</code> 只要小于缓冲区的长度一般就不是个错误，即使文件还没有被读取完，这种情况可能会发生在，当前只有一部分数据是可用的，或者是 read 操作被一个信号打断了</p>
<p>*<strong>关于错误：</strong> 如果遇到了 Error，那就必须保证没有任何字节被成功写入 返回值小于 buf 的长度不被当成是错误
如果遇到了<code>ErrorKind::Interrupted</code>，而且不能作别的事时，写入过程就必须被回滚</p>
<p>同样是官方的 demo</p>
<pre><pre class="playground"><code class="language-rust">use std::io::prelude::*;
use std::fs::File;
fn main() -&gt; std::io::Result&lt;()&gt; {
    let mut buffer = File::create(&quot;foo.txt&quot;)?;
    // Writes some prefix of the byte string, not necessarily all of it.
    buffer.write(b&quot;some bytes&quot;)?;
    Ok(())
}
</code></pre></pre>
<h3 id="33-seek--bufreader--bufwriter"><a class="header" href="#33-seek--bufreader--bufwriter">3.3 Seek &amp; BufReader &amp; BufWriter</a></h3>
<p>[<code>Read</code>] 和 [<code>Write</code>] 是最重要的两个 Trait，除此之外还有两个重要的 Trait[<code>Seek</code>] 和 [<code>BufRead</code>],
这两个都建立在 reader 只上，用来控制 read 的过程。</p>
<p>[<code>Seek</code>] 让你控制下一个字节将要读取的来自哪里</p>
<pre><pre class="playground"><code class="language-rust">use std::io;
use std::io::prelude::*;
use std::io::SeekFrom;
use std::fs::File;
fn main() -&gt; io::Result&lt;()&gt; {
    let mut f = File::open(&quot;foo.txt&quot;)?;
    let mut buffer = [0; 10];
    // skip to the last 10 bytes of the file
    f.seek(SeekFrom::End(-10))?;
    // read up to 10 bytes
    let n = f.read(&amp;mut buffer)?;
    println!(&quot;The bytes: {:?}&quot;, &amp;buffer[..n]);
    Ok(())
}
</code></pre></pre>
<p>基于 byte 的接口性能不佳，所以提供了很多基于 buffer 的接口 [<code>BufRead</code>] 就提供了更多 Read 相关的 API</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = File::open(&quot;foo.txt&quot;)?;
let mut reader = BufReader::new(f);
let mut buffer = String::new();
// read a line into buffer
reader.read_line(&amp;mut buffer)?;
<span class="boring">}
</span></code></pre></pre>
<p>[<code>BufWriter</code>] 没有提供更多写入的方法，他只是缓冲了每次调用</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = File::create(&quot;foo.txt&quot;)?;
{
    let mut writer = BufWriter::new(f);

    // write a byte to the buffer
    writer.write(&amp;[42])?;

} // the buffer is flushed once writer goes out of scope
<span class="boring">}
</span></code></pre></pre>
<h2 id="4-其他"><a class="header" href="#4-其他">4. 其他</a></h2>
<h3 id="2-rc--arc"><a class="header" href="#2-rc--arc">2. Rc &amp; Arc</a></h3>
<h4 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h4>
<blockquote>
<p>The key to our design is the RefCell type. The heart of RefCell is a pair of
methods:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn borrow(&amp;self) -&gt; Ref&lt;'_, T&gt;;
fn borrow_mut(&amp;self) -&gt; RefMut&lt;'_, T&gt;;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Introducing inherited mutability roots to shared types Shared smart pointer
types, including Rc and Arc, provide containers that can be cloned and shared
between multiple parties. Because the contained values may be
multiply-aliased, they can only be borrowed as shared references, not mutable
references. Without cells it would be impossible to mutate data inside of
shared boxes at all!</p>
</blockquote>
<blockquote>
<p>It's very common then to put a RefCell inside shared pointer types to
reintroduce mutability:</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use std::cell::RefCell;
use std::rc::Rc;
fn main() {
    let shared_map: Rc&lt;RefCell&lt;_&gt;&gt; = Rc::new(RefCell::new(HashMap::new()));
    shared_map.borrow_mut().insert(&quot;africa&quot;, 92388);
    shared_map.borrow_mut().insert(&quot;kyoto&quot;, 11837);
    shared_map.borrow_mut().insert(&quot;piccadilly&quot;, 11826);
    shared_map.borrow_mut().insert(&quot;marbles&quot;, 38);
}
</code></pre></pre>
<blockquote>
<p>Note that this example uses Rc and not Arc. RefCells are for single-threaded
scenarios. Consider using Mutex if you need shared mutability in a
multi-threaded situation</p>
</blockquote>
<h4 id="try_unwrap"><a class="header" href="#try_unwrap">try_unwrap()</a></h4>
<blockquote>
<p>Get T from Rc&lt;T&gt; try to use <code>try_unwrap()</code>, which moves out the contents
of an Rc if its refcount is 1 ::: warning unwrap on Result requires that you
can debug-print the error case. RefCell only implements Debug if T does. Node
doesn't implement Debug. try:
Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem :::</p>
</blockquote>
<h3 id="4-cell--refcell"><a class="header" href="#4-cell--refcell">4. Cell &amp; RefCell</a></h3>
<blockquote>
<p>Shareable mutable containers.</p>
<p>Values of the Cell and RefCell types may be mutated through shared references
(i.e. the common &amp;T type), whereas most Rust types can only be mutated through
unique (&amp;mut T) references. We say that Cell and RefCell provide 'interior
mutability', in contrast with typical Rust types that exhibit 'inherited
mutability'.</p>
<p>Cell types come in two flavors: Cell and RefCell. Cell provides get and set
methods that change the interior value with a single method call. Cell though
is only compatible with types that implement Copy. For other types, one must
use the RefCell type, acquiring a write lock before mutating.</p>
<p>RefCell uses Rust's lifetimes to implement 'dynamic borrowing', a process
whereby one can claim temporary, exclusive, mutable access to the inner value.
Borrows for RefCells are tracked 'at runtime', unlike Rust's native reference
types which are entirely tracked statically, at compile time. Because RefCell
borrows are dynamic it is possible to attempt to borrow a value that is
already mutably borrowed; when this happens it results in thread panic.</p>
</blockquote>
<h3 id="5-ref--refmut"><a class="header" href="#5-ref--refmut">5. Ref &amp; RefMut</a></h3>
<h4 id="refmap"><a class="header" href="#refmap">Ref::map()</a></h4>
<ol>
<li>example1</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>map(Ref&lt; T&gt;, f: F) -&gt; Ref&lt;U&gt;
// Get Ref&lt;T&gt; from Ref&lt;Node&lt;T&gt;&gt;
// my example
pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
    self.head.as_ref().map(|node| {
        Ref::map(node.borrow(), |node| &amp;node.elem)
    })
}
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>example2</li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Makes a new Ref for a component of the borrowed data.

// The RefCell is already immutably borrowed, so this cannot fail.

// This is an associated function that needs to be used as Ref::map(...). A method would interfere with methods of the same name on the contents of a RefCell used through Deref.

use std::cell::{RefCell, Ref};

let c = RefCell::new((5, 'b'));
let b1: Ref&lt;(u32, char)&gt; = c.borrow();
let b2: Ref&lt;u32&gt; = Ref::map(b1, |t| &amp;t.0);
assert_eq!(*b2, 5)
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-print-宏"><a class="header" href="#rust-print-宏">Rust print! 宏</a></h1>
<pre><code class="language-rs">print!(&quot;{}&quot;, &amp;a)
</code></pre>
<h2 id="1-print-宏"><a class="header" href="#1-print-宏">1. <code>print!</code> 宏</a></h2>
<p><code>print!</code> 宏会调用 <code>format_args!</code> 将<code>&quot;{}&quot;, &amp;a</code>转换为一个 <code>Arguments</code> 结构体，接着作为参数传入 <code>_print</code>
函数</p>
<pre><code class="language-rs">macro_rules! print {
    ($($arg:tt)*) =&gt; {
        $crate::io::_print($crate::format_args!($($arg)*))
    };
}
</code></pre>
<h2 id="2-format_args"><a class="header" href="#2-format_args">2. <code>format_args!</code></a></h2>
<p><code>format_args!</code> 的实现需要编译器介入 (这里有懂的大佬可以帮忙解答)</p>
<pre><code class="language-rs">macro_rules! format_args {
    ($fmt:expr) =&gt; {{ /* compiler built-in */ }};
    ($fmt:expr, $($args:tt)*) =&gt; {{ /* compiler built-in */ }};
}

use std::fmt;
let s = fmt::format(format_args!(&quot;hello {}&quot;, &quot;world&quot;)); assert_eq!(s,
format!(&quot;hello {}&quot;, &quot;world&quot;));
</code></pre>
<p>Arguements 结构体签名如下：</p>
<pre><code class="language-rs">pub struct Arguments&lt;'a&gt; {
    // 字符串
    pieces: &amp;'a [&amp;'static str],

    // 参数列表
    // `ArgumentV1` 结构体包含参数的值，以及它对应的格式化方式（通过 {} {:p} 指定）
    args: &amp;'a [ArgumentV1&lt;'a&gt;],

    // 具体的格式化信息。
    // Arguement 结构体中保存了 对应的参数在 args 中的索引
    // 还有额外的格式化信息，比如参数位置，宽度，填充字符等
    fmt: Option&lt;&amp;'a [rt::v1::Argument]&gt;,
}
</code></pre>
<p>以下面的代码为例：</p>
<pre><code class="language-rs">fn main() {
    let a = 1;
    print!(&quot;hello{}aa{0}too{:p}ohmygod{:p}&quot;, a, &amp;a, &amp;a);
}
</code></pre>
<ul>
<li>字符串片段有 4 个，所以 pieces 的值为 [&quot;hello&quot;, &quot;aa&quot;, &quot;too&quot;, &quot;ohmygod&quot;]</li>
<li>如果有两个连续的 <code>{}</code>, 它们中间相当于被插入了一个空字符串。</li>
<li>参数只有三个，所以 <code>arg</code> 只有三个元素。</li>
<li>由于后两个都是使用 <code>{:p}</code> 打印地址，所以 <code>args[1]</code> 和 <code>args[2]</code> 的 <code>formatter</code> 的值相同</li>
<li>有四个位置需要填充参数，所以 fmt 有 4 个元素。</li>
</ul>
<p>生成的 Arguements 结构体如图所示：</p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202205221334215.jpg" alt="" /></p>
<p>下面是 cargo expand 展开后的结果：</p>
<pre><code class="language-rs">#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::fmt::Display;
fn main() {
    let a = 1;
    ::std::io::_print(::core::fmt::Arguments::new_v1_formatted(
        &amp;[&quot;hello&quot;, &quot;aa&quot;, &quot;too&quot;, &quot;ohmygod&quot;],
        &amp;[
            ::core::fmt::ArgumentV1::new_display(&amp;a),
            ::core::fmt::ArgumentV1::new_pointer(&amp;&amp;a),
            ::core::fmt::ArgumentV1::new_pointer(&amp;&amp;a),
        ],
        &amp;[
            ::core::fmt::rt::v1::Argument {
                position: 0usize,
                format: ::core::fmt::rt::v1::FormatSpec {
                    fill: ' ',
                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                    flags: 0u32,
                    precision: ::core::fmt::rt::v1::Count::Implied,
                    width: ::core::fmt::rt::v1::Count::Implied,
                },
            },
            ::core::fmt::rt::v1::Argument {
                position: 0usize,
                format: ::core::fmt::rt::v1::FormatSpec {
                    fill: ' ',
                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                    flags: 0u32,
                    precision: ::core::fmt::rt::v1::Count::Implied,
                    width: ::core::fmt::rt::v1::Count::Implied,
                },
            },
            ::core::fmt::rt::v1::Argument {
                position: 1usize,
                format: ::core::fmt::rt::v1::FormatSpec {
                    fill: ' ',
                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                    flags: 0u32,
                    precision: ::core::fmt::rt::v1::Count::Implied,
                    width: ::core::fmt::rt::v1::Count::Implied,
                },
            },
            ::core::fmt::rt::v1::Argument {
                position: 2usize,
                format: ::core::fmt::rt::v1::FormatSpec {
                    fill: ' ',
                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                    flags: 0u32,
                    precision: ::core::fmt::rt::v1::Count::Implied,
                    width: ::core::fmt::rt::v1::Count::Implied,
                },
            },
        ],
        unsafe { ::core::fmt::UnsafeArg::new() },
    ));
    ::std::io::_print(::core::fmt::Arguments::new_v1(
        &amp;[&quot;&quot;],
        &amp;[::core::fmt::ArgumentV1::new_display(&amp;&amp;a)],
    ));
}
</code></pre>
<h2 id="3-_print"><a class="header" href="#3-_print">3. _print()</a></h2>
<p>只是简单的调用了 <code>print_to</code>, 指定了输出到 <code>stdout</code></p>
<pre><code class="language-rs">pub fn _print(args: fmt::Arguments&lt;'_&gt;) {
    print_to(args, stdout, &quot;stdout&quot;);
}
</code></pre>
<p>print_to 函数具体内容如下，主要就是调用了缓冲区的 <code>write_fmt</code> 方法</p>
<pre><code class="language-rs">fn print_to&lt;T&gt;(args: fmt::Arguments&lt;'_&gt;, global_s: fn() -&gt; T, label: &amp;str)
where
    T: Write,
{
    // 尝试拿到输出的缓冲区 w
    if OUTPUT_CAPTURE_USED.load(Ordering::Relaxed) &amp;&amp; OUTPUT_CAPTURE.try_with(|s| {
            s.take().map(|w| { // w: Arc&lt;Mutex&lt;Vec&lt;u8&gt;&gt;&gt;
                // 调用 write_fmt 方法
                let _ = w.lock().unwrap_or_else(|e| e.into_inner()).write_fmt(args);
                s.set(Some(w));
            })
        }) == Ok(Some(()))
    {
        // Successfully wrote to capture buffer.
        return;
    }
    //
    if let Err(e) = global_s().write_fmt(args) {
        panic!(&quot;failed printing to {label}: {e}&quot;);
    }
}
</code></pre>
<h2 id="4-wwrite_fmtargs"><a class="header" href="#4-wwrite_fmtargs">4. <code>w.write_fmt(args)</code></a></h2>
<pre><code class="language-rs">fn write_fmt(&amp;mut self, fmt: fmt::Arguments&lt;'_&gt;) -&gt; Result&lt;()&gt; {
    // 创建一个 Adapter 将 fmt 转化为一个 impl Write，顺便储存错误信息
    struct Adapter&lt;'a, T: ?Sized + 'a&gt; {
        inner: &amp;'a mut T,
        error: Result&lt;()&gt;,
    }

    // 这个 write_str 实际上就是调用了 Vec&lt;u8&gt; 的 write_all() 方法
    impl&lt;T: Write + ?Sized&gt; fmt::Write for Adapter&lt;'_, T&gt; {
        fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result {
            match self.inner.write_all(s.as_bytes()) {
                ...
            }
        }
    }

    let mut output = Adapter { inner: self, error: Ok(()) };
    match fmt::write(&amp;mut output, fmt) {
        Ok(()) =&gt; Ok(()),
        ...
    }
}
</code></pre>
<h2 id="5最后是-fmtwritemut-output-fmt"><a class="header" href="#5最后是-fmtwritemut-output-fmt">5.最后是 fmt::write(&amp;mut output, fmt)</a></h2>
<pre><code class="language-rs">pub fn write(output: &amp;mut dyn Write, args: Arguments&lt;'_&gt;) -&gt; Result {
    let mut formatter = Formatter::new(output);
    let mut idx = 0;
    match args.fmt {
        None =&gt; {
            // 如果没有格式化方法，我们就使用默认的格式化方法。
            // 遍历所有`参数`，每次先输出一个字符串，再使用格式化方法输出一个参数
            for (i, arg) in args.args.iter().enumerate() {
                // 安全性：args.args 和 args.pieces 来自同一个结构体，这里的 get_unchecked 是安全的
                let piece = unsafe { args.pieces.get_unchecked(i) };
                if !piece.is_empty() {
                    // 这里的 formatter 就是之前的 Adapter,
                    // write_str 就是调用 Vec&lt;u8&gt; 对应的实现
                    formatter.buf.write_str(*piece)?;
                }
                (arg.formatter)(arg.value, &amp;mut formatter)?;
                idx += 1;
            }
        }
        Some(fmt) =&gt; {
            // 每个格式化方法都有一个对应的参数。每次输出参数前，都输出一个字符串片段
            // 注意：这里是对 fmt 进行遍历，因为参数数量和需要填充数量不是一一对应
            for (i, arg) in fmt.iter().enumerate() {
                ...同上
                // 这里的 run 还是会调用
                // (arg.formatter)(arg.value, &amp;mut formatter)?;
                // 只不过会为 formatter 添加一些额外信息
                unsafe { run(&amp;mut formatter, arg, args.args) }?;
                idx += 1;
            }
        }
    }

    // 打印末尾多余的字符串
    if let Some(piece) = args.pieces.get(idx) {
        formatter.buf.write_str(*piece)?;
    }

    Ok(())
}
</code></pre>
<p>至此，一个 <code>print!</code> 的大体流程就结束了</p>
<h2 id="6-为什么-print-a-无法打印出地址"><a class="header" href="#6-为什么-print-a-无法打印出地址">6. 为什么 <code>print!(&quot;{}&quot;, &amp;a)</code> 无法打印出地址</a></h2>
<p>通过上面的讲解，打印的关键就在于下面这行代码：</p>
<pre><code class="language-rs">// arg：ArgumentV1
(arg.formatter)(arg.value, &amp;mut formatter)?
</code></pre>
<p><code>formatter</code> 实际上是一个函数指针：</p>
<pre><code class="language-rs">// This struct represents the generic &quot;argument&quot; which is taken by the Xprintf family of functions. It contains a function to format the given value.
// At compile time it is ensured that the function and the value have the correct types, and then this struct is used to canonicalize arguments to one type.

// 该结构表示 Xprintf 系列函数采用的通用“参数”。它包含一个格式化给定值的函数。
// 在编译时，确保函数和值具有正确的类型，然后使用此结构将参数规范化为一种类型。

pub struct ArgumentV1&lt;'a&gt; {
    value: &amp;'a Opaque,
    formatter: fn(&amp;Opaque, &amp;mut Formatter&lt;'_&gt;) -&gt; Result,
}
// NB. Argument is essentially an optimized partially applied formatting function,
// equivalent to `exists T.(&amp;T, fn(&amp;T, &amp;mut Formatter&lt;'_&gt;) -&gt; Result`.
extern &quot;C&quot; {
    type Opaque;
}

pub struct Formatter&lt;'a&gt; {
    flags: u32,
    fill: char,
    align: rt::v1::Alignment,
    width: Option&lt;usize&gt;,
    precision: Option&lt;usize&gt;,

    buf: &amp;'a mut (dyn Write + 'a),
}
</code></pre>
<p>下面是 stackoverflow 上的解答</p>
<p><code>print!</code>, <code>println!</code>, <code>eprint!</code>, <code>eprintln!</code>, <code>write!</code>, <code>writeln!</code> and <code>format!</code>
这些宏会隐式的拿走参数的引用</p>
<pre><code class="language-rs">fn main() {
    let x = 5;
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>在 nightly 的编译器上使用 <code>rustc -Z unstable-options --pretty</code> 展开上面的代码：</p>
<blockquote>
<p>或者是 <code>cargo expand</code></p>
</blockquote>
<pre><code class="language-rs">#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
fn main() {
    let x = 5;
    {
        ::std::io::_print(::core::fmt::Arguments::new_v1(
            &amp;[&quot;&quot;, &quot;\n&quot;],
            &amp;match (&amp;x,) {
                (arg0,) =&gt; [::core::fmt::ArgumentV1::new(
                    arg0,
                    ::core::fmt::Display::fmt,
                )],
            },
        ));
    };
}
</code></pre>
<p>整理之后就是：</p>
<pre><code class="language-rs">use std::{fmt, io};

fn main() {
    let x = 5;
    io::_print(fmt::Arguments::new_v1(
        &amp;[&quot;&quot;, &quot;\n&quot;],
        &amp;[fmt::ArgumentV1::new(&amp;x, fmt::Display::fmt)],
        //                     ^^
    ));
}
</code></pre>
<p>注意 <code>&amp;x</code>.</p>
<p>如果你写的是 <code>println!(&quot;{}&quot;, &amp;x)</code>，Rust 编译器依然能够帮你处理这两层引用;</p>
<p>因为 Rust 为 &amp;T(T: Display) 也实现了 Display</p>
<pre><code class="language-rs">// 有点像智能指针的 Deref
impl&lt;'a, T&gt; Display for &amp;'a T where T: Display + ?Sized
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内网穿透工具"><a class="header" href="#内网穿透工具">内网穿透工具</a></h1>
<p><a href="https://github.com/trdthg/net-piercer">net-piercer(github)</a></p>
<p>设计架构图</p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202203262224928.svg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="channel-源码剖析"><a class="header" href="#channel-源码剖析">Channel 源码剖析</a></h1>
<h2 id="标准库-channel"><a class="header" href="#标准库-channel">标准库 channel</a></h2>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202205181708400.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="too-many-lists"><a class="header" href="#too-many-lists">Too-Many-Lists</a></h1>
<h2 id="1-a-bad-stack"><a class="header" href="#1-a-bad-stack">1. A Bad Stack</a></h2>
<h3 id="引例"><a class="header" href="#引例">引例</a></h3>
<ul>
<li>用这种方式会有标签带来的额外开销，属于函数式编程语言的默认方法</li>
<li>所以用下面的 C-like 结构体形式占用空间更小，</li>
<li>而且单个节点能承载更多内容</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum List&lt;T&gt; {
    Empty,
    Elem(T, Box&lt;List&lt;T&gt;&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="完整案例"><a class="header" href="#完整案例">完整案例</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2.1. Layout
pub struct List {
    head: Link,
}
enum Link {
    Empty,
    More(Box&lt;Node&gt;),
}
struct Node {
    elem: i32,
    next: Link,
}
use std::mem;
impl List {
    // 2.2. New
    pub fn new() -&gt; Self {
        List {
            head: Link::Empty,
        }
    }
    // 2.4. Push
    pub fn push(&amp;mut self, elem: i32) {
        let new_node = Box::new(Node {
            elem,
            next: mem::replace(&amp;mut self.head, Link::Empty),
        });
        self.head = Link::More(new_node)
    }
    // 2.5. Pop
    // 相比于上一个更常用而且更简洁的写法
    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match mem::replace(&amp;mut self.head, Link::Empty) {
            Link::Empty =&gt; None,
            Link::More(node) =&gt; {
                self.head = node.next;
                Some(node.elem)
            }
        }
    }
}

// 2.6. Testing
#[cfg(test)]
mod test {
    #[test]
    fn basics() {
        // TODO
        use super::-;
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), Some(4));

        // check exhaustion
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), None);

        // Check drop
        list.push(1);
        list.push(2);
        list.push(3);

    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="drop-的手动编写"><a class="header" href="#drop-的手动编写">Drop 的手动编写</a></h3>
<p>尝试根据尾递归写出 drop 函数，失败</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 2.7. Drop
impl Drop for List {
    fn drop(&amp;mut self) {
        self.head.drop();
    }
}
impl Drop for Link {
    fn drop(&amp;mut self) {
        match self {
            Link::Empty =&gt; {},
            Link::More(ref mut boxed_node) =&gt; {
                boxed_node.drop();
            }
        }
    }
}
impl Drop for Box&lt;Node&gt; {
    fn drop(&amp;mut self) {
        self.ptr.drop();   // uh oh, not tail recursive!
        deallocate(self.ptr);
    }
}
impl Drop for Node {
    fn drop(&amp;mut self) {
        self.next.drop();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>::: danger &gt;We can't drop the contents of the Box after deallocating, so there's
no way to drop in a tail-recursive manner! &gt;Instead we're going to have to
manually write an iterative drop for List that hoists nodes out of their boxes.
::: So, the next is the real way to write drop ourselfs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for List {
    fn drop(&amp;mut self) {
        println!(&quot;开始 drop&quot;);
        let mut cur_link = mem::replace(&amp;mut self.head, Link::Empty);
        while let Link::More(mut boxed_node) = cur_link {
            println!(&quot;{}&quot;, boxed_node.elem);
            cur_link = mem::replace(&amp;mut boxed_node.next, Link::Empty);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="unimplemented"><a class="header" href="#unimplemented">unimplemented!</a></h3>
<p>::: warning</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 返回 unimplemented!()
impl List {
    pub fn pop(&amp;mut self) -&gt; Option&lt;i32&gt; {
        match &amp;self.head {
            Link::Empty =&gt; {
                // TODO
            },
            Link::More(node) =&gt; {
                // TODO
            }
        }
        unimplemented!()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>:::</p>
<h2 id="2-an-ok-singly-linked-stack"><a class="header" href="#2-an-ok-singly-linked-stack">2. An Ok Singly-Linked Stack</a></h2>
<h3 id="优化目标"><a class="header" href="#优化目标">优化目标</a></h3>
<ol>
<li>3.1: Option 简化语法</li>
</ol>
<ul>
<li>use Option to replace our own Enum</li>
<li>use Option.take() to replace mem::replace(&amp;self, None)</li>
<li>use option.take().map(|elem {}|) to replace match option { None =&gt; None,
Some(x) =&gt; Some(y) }</li>
</ul>
<ol start="2">
<li>3.2 Generic 通用性</li>
</ol>
<ul>
<li>just use T to replace i32</li>
</ul>
<ol start="3">
<li>3.3 Peek(偷看) 实现 peek</li>
</ol>
<ul>
<li></li>
<li>注意 3 者的区别</li>
<li>self.head.take() -&gt; self -&gt; Option(T)</li>
<li>self.head.as_ref() -&gt; &amp;self -&gt; Option(&amp;T)</li>
<li>self.head.as_mut() -&gt; &amp;mut self -&gt; Option(&amp;mut T)</li>
</ul>
<ol start="4">
<li>3.4 - 3.6 三种迭代器</li>
</ol>
<ul>
<li>IntoIter - T</li>
<li>IterMut - &amp;mut T</li>
<li>Iter - &amp;T</li>
</ul>
<blockquote>
<p>map(): Maps an Option&lt;T&gt; to Option&lt;U&gt; by applying a function to a
contained value. as_ref()-&gt;&amp;self: Converts from &amp;Option&lt;T&gt; to
Option&lt;&amp;T&gt;. as_mut()-&gt;&amp;mut self: Converts from &amp;mut Option&lt;T&gt; to
Option&lt;&amp;mut T&gt;. take()-&gt;&amp;mut self: Takes the value out of the option,
leaving a [None] in its place</p>
</blockquote>
<h3 id="option--generic"><a class="header" href="#option--generic">Option &amp; Generic</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::mem;

#[derive(Debug)]
pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

#[derive(Debug)]
struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    // 2.2. New
    pub fn new() -&gt; Self {
        List { head: None }
    }
    // 2.4. Push
    pub fn push(&amp;mut self, elem: T) {
        let new_node = Box::new(Node {
            elem,
            // next: mem::replace(&amp;mut self.head, None),
            next: self.head.take(),
        });
        self.head = Some(new_node);
    }
    // 2.5. Pop
    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|node| {
            self.head = node.next;
            node.elem  //  node.elem not need to be wrapped by Some()
        })
    }

}
<span class="boring">}
</span></code></pre></pre>
<h3 id="peek"><a class="header" href="#peek">Peek</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; List&lt;T&gt; {
    /-
    impl&lt;T&gt; Option&lt;T&gt; {
        pub fn as_ref(&amp;self) -&gt; Option&lt;&amp;T&gt;;
    }
    -/

    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {

        // Converts from &amp;Option&lt;T&gt; to Option&lt;&amp;T&gt;.

        // self             -&gt; &amp;List
        // self.head        -&gt; &amp;Option&lt; Box&lt;Node&lt;T&gt;&gt;&gt;
        // self.head.as_ref -&gt;  Option&lt;&amp;Box&lt;Node&lt;T&gt;&gt;&gt;
        // map(node)        -&gt;         &amp;Box&lt;Node&lt;T&gt;&gt;
        // node.elem        -&gt;                   T
        // &amp;node.elem       -&gt;         &amp;         T
        // map-&gt;&amp;node.elem  -&gt;  Option&lt;&amp;         T  &gt;
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }
    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        // Converts from &amp;mut Option&lt;T&gt; to Option&lt;&amp;mut T&gt;.

        // self             -&gt; &amp;mut List
        // self.head        -&gt; &amp;mut Option&lt;     Box&lt;Node&lt;T&gt;&gt;&gt;
        // self.head.as_mut -&gt;      Option&lt;&amp;mut Box&lt;Node&lt;T&gt;&gt;&gt;
        // map(node)        -&gt;             &amp;mut Box&lt;Node&lt;T&gt;&gt;
        // node.elem        -&gt;                           T
        // &amp;mut node.elem   -&gt;             &amp;mut          T
        // map-&gt;&amp;node.elem  -&gt;      Option&lt;&amp;mut          T  &gt;
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }
    pub fn peek_(&amp;mut self) -&gt; Option&lt;T&gt; {
        // warning(not sure): mut_only_in_this_fu_but_only_read_after_read
        // Takes the value out of the option, leaving a [None] in its place

        // self             -&gt; &amp;mut List
        // self.head        -&gt; &amp;mut Option&lt;     Box&lt;Node&lt;T&gt;&gt;&gt;
        // self.head.take   -&gt;      Option&lt;&amp;mut Box&lt;Node&lt;T&gt;&gt;&gt;

        // self.head        -&gt; &amp;mut Option&lt;None&gt;
        // temp             -&gt; &amp;mut Option&lt;     Box&lt;Node&lt;T&gt;&gt;&gt;

        // map(node)        -&gt;                  Box&lt;Node&lt;T&gt;&gt;
        // node.elem        -&gt;                           T
        // map-&gt;node.elem   -&gt;      Option&lt;              T  &gt;
        self.head.take().map(|node| {
            node.elem
        })
    }

}

#[test]
fn peek() {
    let mut list = List::new();
    assert_eq!(list.peek(), None);
    assert_eq!(list.peek_mut(), None);
    list.push(1); list.push(2); list.push(3);

    assert_eq!(list.peek(), Some(&amp;3));
    assert_eq!(list.peek_mut(), Some(&amp;mut 3));
    // match list.peek_mut() {
    //     Some(k) =&gt; {-k = 30},
    //     None =&gt; {}
    // }
    list.peek_mut().map(|val| {
        -val = 30;
    });
    assert_eq!(list.peek_mut(), Some(&amp;mut 30));
    if let Some(val) = list.peek_mut() {
        println!(&quot;{}&quot;, val);
        -val = 10;
    }
    assert_eq!(list.peek_mut(), Some(&amp;mut 10));
    assert_eq!(list.pop(), Some(10));
    assert_eq!(list.peek(), Some(&amp;2));
    if let Some(val) = list.peek_() {
        println!(&quot;{}&quot;, val);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="intoiter"><a class="header" href="#intoiter">IntoIter</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 3.4 IntoIter------------------------------------------------------------------------------

pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}

#[test]
fn into_iter_test() {
    let mut list = List::new();
    list.push(1);
    list.push(2);
    list.push(3);
    let mut iter = list.into_iter();
    assert_eq!(iter.next(), Some(3));
    assert_eq!(iter.next(), Some(2));
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="iter"><a class="header" href="#iter">Iter</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 3.5 Iter------------------------------------------------------------------------------
pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;
}

impl&lt;T&gt; List&lt;T&gt; {
    // 1. initial
    // pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
    // 2. apply lifetime elision
    // pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
    // 3. Or, if you're not comfortable &quot;hiding&quot; that a struct contains a lifetime, you can use the Rust 2018 &quot;explicitly elided lifetime&quot; syntax, '_:
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {

        // self             -&gt; &amp;List                    | self                -&gt; &amp;List
        // self.head        -&gt; &amp;Option&lt; Box&lt;Node&lt;T&gt;&gt;&gt;   | self.head           -&gt; &amp;Option&lt; Box&lt;Node&lt;T&gt;&gt;&gt;
        // self.head.as_ref -&gt;  Option&lt;&amp;Box&lt;Node&lt;T&gt;&gt;&gt;   | self.head.as_deref  -&gt; &amp;Option&lt;     Node&lt;T&gt; &gt;
        // map(node)        -&gt;         &amp;Box&lt;Node&lt;T&gt;&gt;    |
        // -node            -&gt;          Box&lt;Node&lt;T&gt;&gt;    |
        // --node           -&gt;              Node&lt;T&gt;     |
        // &amp;--node          -&gt;             &amp;Node&lt;T&gt;     |
        // map-&gt;node        -&gt;  Option&lt;    &amp;Node&lt;T&gt; &gt;   |

        // can be replaced by the next line
        Iter { next: self.head.as_ref().map(|node| { &amp;--node }) }

        // Iter { next: self.head.as_deref() }

        // node: expected struct `second::Node`, found struct `std::boxed::Box`
        // -node: expected `&amp;second::Node&lt;T&gt;`, found struct `std::boxed::Box`
        // --node: expected `&amp;second::Node&lt;T&gt;`, found struct `second::Node`
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {

        // self                  -&gt; &amp;mut Iter                           | self                   -&gt; &amp;mut Iter
        // self.next             -&gt; &amp;mut Option&lt;         &amp;Node&lt;T&gt; &gt;     | self.next              -&gt; &amp;mut Option&lt;         &amp;Node&lt;T&gt;&gt;
        // map(node)             -&gt; &amp;mut                 &amp;Node&lt;T&gt;       | map(node)              -&gt; &amp;mut                 &amp;Node&lt;T&gt;
        //     node.next         -&gt; &amp;mut Option&lt;         &amp;Node&lt;T&gt; &gt;     |     node.next          -&gt; &amp;mut Option&lt;     Box&lt; Node&lt;T&gt;&gt;&gt;
        //     node.next.as_ref  -&gt;      Option&lt;&amp;mut Box&lt; Node&lt;T&gt;&gt;&gt;     |     node.next.as_deref -&gt; &amp;mut Option&lt;          Node&lt;T&gt; &gt;
        //     map(inner_node)   -&gt;             &amp;mut Box&lt; Node&lt;T&gt;&gt;      |
        //     -inner_node       -&gt;                  Box&lt; Node&lt;T&gt;&gt;      |
        //     --inner_node      -&gt;                       Node&lt;T&gt;       |
        //     &amp;--inner_node     -&gt;                      &amp;Node&lt;T&gt;       |
        //     map(inner_node)   -&gt;      Option&lt;         &amp;Node&lt;T&gt; &gt;     |
        // self.next             -&gt; &amp;mut Option&lt;         &amp;Node&lt;T&gt;&gt;      | self.next              -&gt; &amp;mut Option&lt;&amp; Node&lt;T&gt;&gt;
        // node.elem             -&gt; &amp;mut                       T        |
        // &amp;node.elem            -&gt; &amp;mut                      &amp;T        |
        // map-&gt;&amp;node.elem       -&gt; &amp;mut Option&lt;              &amp;T &gt;      |

        self.next.map(|node| {
            self.next = (-node).next.as_ref().map(|node| &amp;--node);
            // self.next = node.next.as_deref();
            // self.next = node.next.as_ref().map::&lt;&amp;Node&lt;T&gt;, _&gt;(|node| &amp;node);
            // node.next = Some(Box::new(Node{elem: 1, next: None}));
            &amp;node.elem
        })
    }
}

#[test]
fn iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&amp;3));
    assert_eq!(iter.next(), Some(&amp;2));
    assert_eq!(iter.next(), Some(&amp;1));
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="3-a-persistent-stack"><a class="header" href="#3-a-persistent-stack">3. A Persistent Stack</a></h2>
<h3 id="实现目标"><a class="header" href="#实现目标">实现目标</a></h3>
<pre><code>list1 = A -&gt; B -&gt; C -&gt; D
list2 = tail(list1) = B -&gt; C -&gt; D
list3 = push(list2, X) = X -&gt; B -&gt; C -&gt; D

list1 -&gt; A ---+
              |
              v
list2 ------&gt; B -&gt; C -&gt; D
              ^
              |
list3 -&gt; X ---+
</code></pre>
<h3 id="basic"><a class="header" href="#basic">Basic</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
// basic -------------------------------------------------------------------
pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;
}

type Link&lt;T&gt; = Option&lt;Rc&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; List&lt;T&gt; {
        List { head: None }
    }
    pub fn prepend(&amp;self, elem: T) -&gt; List&lt;T&gt; {
        List { head: Some(Rc::new(Node { elem, next: self.head.clone() })) }
    }
    pub fn tail(&amp;self) -&gt; List&lt;T&gt; {
        List { head: self.head.as_ref().and_then(|node| node.next.clone()) }
    }
    pub fn head(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| &amp;node.elem)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="iter-1"><a class="header" href="#iter-1">Iter</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Iter ------------------------------------------------------------------
pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;
}
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt; {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &amp;--node);
            &amp;node.elem
        })
    }
}
impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.as_ref().map(|node| &amp;--node) }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="drop-1"><a class="header" href="#drop-1">Drop</a></h3>
<p>多了判断 ref count 的过程</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// drop ------------------------------------------------------------
impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        let mut head = self.head.take();
        while let Some(node) = head {
            if let Ok(mut node) = Rc::try_unwrap(node) {
                head = node.next.take();
            } else {
                break
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="test-1"><a class="header" href="#test-1">Test</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(Test)]
mod test {
    use super::List;
    #[test]
    fn basics_test() {
        let list = List::new();
        list.prepend(1).prepend(2).prepend(3);

        assert_eq!(list.head(), Some(&amp;3));
        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;2));
        let list = list.tail();
        assert_eq!(list.head(), Some(&amp;1));
        let list = list.tail();
        assert_eq!(list.head(), None);
        let list = list.tail();
        assert_eq!(list.head(), None);
    }
    #[test]
    fn iter_test() {
        let list = List::new().prepend(1).prepend(2).prepend(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;1));
    }

}
<span class="boring">}
</span></code></pre></pre>
<h2 id="4-a-bad-safe-deque"><a class="header" href="#4-a-bad-safe-deque">4. A Bad Safe Deque</a></h2>
<p>加入了 Rc 和 RefCell</p>
<h3 id="layout"><a class="header" href="#layout">Layout</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>se std::rc::Rc;
use std::cell::{ Ref, RefMut, RefCell };

pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: Link&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
    prev: Link&lt;T&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="basic-1"><a class="header" href="#basic-1">Basic</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; List&lt;T&gt; {
        List { head: None, tail: None }
    }
    // 5.2 Building 下`
    pub fn push_front(&amp;mut self, elem: T) {
        let new_head = Node::new(elem);
        match self.head.take() {
            Some(old_head) =&gt; {
                old_head.borrow_mut().prev = Some(new_head.clone());
                new_head.borrow_mut().next = Some(old_head);
                self.head = Some(new_head);
            },
            None =&gt; {
                self.head = Some(new_head.clone());
                self.tail = Some(new_head);
            }
        }
    }
    // 5.3 Breaking
    pub fn pop_front(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|old_head| {
            // 临时借用 old_head，并 take 了 next 的 ownership
            match old_head.borrow_mut().next.take() {
                Some(new_head) =&gt; {
                    new_head.borrow_mut().prev = None;
                    self.head = Some(new_head);
                }
                None =&gt; {
                    self.tail.take();
                }
            }
            Rc::try_unwrap(old_head).ok().unwrap().into_inner().elem
        })
    }
    // 5.4 Peeking
    // pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
    //     self.head.as_ref().map(|node| {
    //         // Rc::try_unwrap(node).ok().unwrap().into_inner().elem
    //         // &amp;node.borrow().elem
    //     })
    // }
    pub fn peek_front(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
        self.head.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }
    pub fn peek_front_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
        self.head.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
        })
    }
    // Back ---------------------------------------------------------
    pub fn push_back(&amp;mut self, elem: T) {
        let new_tail = Node::new(elem);
        match self.tail.take() {
            Some(old_tail) =&gt; {
                old_tail.borrow_mut().next = Some(new_tail.clone());
                new_tail.borrow_mut().prev = Some(old_tail.clone());
                self.tail = Some(new_tail);
            }
            None =&gt; {
                self.head = Some(new_tail.clone());
                self.tail = Some(new_tail);
            }
        }
    }
    pub fn pop_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.tail.take().map(|old_tail| {
            match old_tail.borrow_mut().prev.take() {
                Some(new_tail) =&gt; {
                    new_tail.borrow_mut().next.take();
                    self.tail = Some(new_tail);
                }
                None =&gt; {
                    self.head = None;
                }
            }
            Rc::try_unwrap(old_tail).ok().unwrap().into_inner().elem
        })
    }
    pub fn peek_back(&amp;self) -&gt; Option&lt;Ref&lt;T&gt;&gt; {
        self.tail.as_ref().map(|node| {
            Ref::map(node.borrow(), |node| &amp;node.elem)
        })
    }
    pub fn peek_back_mut(&amp;mut self) -&gt; Option&lt;RefMut&lt;T&gt;&gt; {
        self.tail.as_ref().map(|node| {
            RefMut::map(node.borrow_mut(), |node| &amp;mut node.elem)
        })
    }
}

impl&lt;T&gt; Node&lt;T&gt; {
    pub fn new(elem: T) -&gt; Rc&lt;RefCell&lt;Node&lt;T&gt;&gt;&gt; {
        Rc::new(RefCell::new(Node {
            elem,
            next:None,
            prev: None,
        }))
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="drop-2"><a class="header" href="#drop-2">Drop</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Drop for List&lt;T&gt; {
    fn drop(&amp;mut self) {
        while self.pop_front().is_some() {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="iterator"><a class="header" href="#iterator">Iterator</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 另一个方向直接实现 DoubleEndedIterator Trait 就行
// IntoIter
pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
}

// natural
impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_front()
    }
}
// reverse
impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {
    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.0.pop_back()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="iterdanger"><a class="header" href="#iterdanger">Iter(danger)</a></h3>
<p>:::warning</p>
<p>无法实现而且根本看不懂，一头雾水</p>
<p>:::</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Iter
pub struct Iter&lt;'a, T&gt;(Option&lt;Ref&lt;'a, Node&lt;T&gt;&gt;&gt;);

impl&lt;T&gt; List&lt;T&gt; {
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter(self.head.as_ref().map(|head| {head.borrow()}))
        // 若为 Ref&lt;T&gt;
        // Iter(self.head.as_ref().map(|head| {Ref::map(head.borrow(), |head| &amp;head.elem)}))
    }
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = Ref&lt;'a, T&gt;;
    fn next(&amp;mut self) -&gt; Option&lt;Ref&lt;'a, T&gt;&gt; {
        self.0.take().map(|node_ref| {
            // self.0 = node_ref.next.as_ref().map(|head| {head.borrow()});
            // // node_ref 在闭包内被借用
            // Ref::map(node_ref, |node| &amp;node.elem)
            // // node_ref 在闭包外再次被借用
            let (next, elem) = Ref::map_split(node_ref, |node| {
                (&amp;node.next, &amp;node.elem)
            });
            self.0 = next.as_ref().map(|head| head.borrow());
            elem
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="5-an-unsafe-queue"><a class="header" href="#5-an-unsafe-queue">5. An Unsafe Queue</a></h2>
<h3 id="51-safe-rust"><a class="header" href="#51-safe-rust">5.1 Safe Rust</a></h3>
<p>Well, pushing is actually fine.</p>
<h4 id="push"><a class="header" href="#push">push</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An Unsafe Queue

/-
input list:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, None)

flipped push X:
[Some(ptr)] -&gt; (A, Some(ptr)) -&gt; (B, Some(ptr)) -&gt; (X, None)

-/

// Layout
pub struct List&lt;'a, T&gt; {
    head: Link&lt;T&gt;,
    tail: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

// Basic
impl&lt;'a, T&gt; List&lt;'a, T&gt; {
    pub fn new() -&gt; List&lt;'a, T&gt; {
        List { head: None, tail: None }
    }

    pub fn push(&amp;'a mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        match self.tail.take() {
            Some(old_tail) =&gt; {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                self.tail = old_tail.next.as_deref_mut()
            }
            None =&gt; {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.tail = self.head.as_deref_mut()
            }
        };
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>However pop is another story. If they're popping elements outside of our
range, it should still be fine. We can't see those nodes so nothing will
happen. However if they try to pop off the node we're pointing at...
&gt;everything will blow up! In particular when they go to unwrap the result of
the try_unwrap, it will actually fail, and the whole program will panic.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
    self.head.take().map(|head| {
        let head = -head;
        self.head = head.next;
        if self.head.is_none() {
            self.tail = None;
        }
        head.elem
    })
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="52-unsafe-rust"><a class="header" href="#52-unsafe-rust">5.2 Unsafe Rust</a></h3>
<h4 id="layout-1"><a class="header" href="#layout-1">Layout</a></h4>
<pre><code class="language-rus">// Layout
pub struct List&lt;T&gt; {
    head: Link&lt;T&gt;,
    tail: -mut Node&lt;T&gt;,
}

type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

struct Node&lt;T&gt; {
    elem: T,
    next: Link&lt;T&gt;,
}

use std::ptr;
impl&lt;T&gt; List&lt;T&gt; {
    pub fn new() -&gt; Self {
        List { head: None, tail:  ptr::null_mut()}
    }
    pub fn push(&amp;mut self, elem: T) {
        let mut new_tail = Box::new(Node {
            elem,
            next: None,
        });

        let raw_tail: -mut _ = &amp;mut -new_tail;
        if !self.tail.is_null() {
            unsafe {
                (-self.tail).next = Some(new_tail);
            }
        } else {
            self.head = Some(new_tail);
        }
        self.tail = raw_tail;
    }
    pub fn pop(&amp;mut self) -&gt; Option&lt;T&gt; {
        self.head.take().map(|head| {
            let head = -head;
            self.head = head.next;
            if self.head.is_none() {
                self.tail = ptr::null_mut()
            };
            head.elem
        })
    }
}
</code></pre>
<h4 id="extras"><a class="header" href="#extras">Extras</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IntoIter&lt;T&gt;(List&lt;T&gt;);

pub struct Iter&lt;'a, T&gt; {
    next: Option&lt;&amp;'a Node&lt;T&gt;&gt;
}

pub struct IterMut&lt;'a, T&gt; {
    next: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;
}

impl&lt;T&gt; List&lt;T&gt; {
    pub fn peek(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        self.head.as_ref().map(|node| {
            &amp;node.elem
        })
    }
    pub fn peek_mut(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        self.head.as_mut().map(|node| {
            &amp;mut node.elem
        })
    }
    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {
        IntoIter(self)
    }
    pub fn iter(&amp;self) -&gt; Iter&lt;T&gt; {
        Iter { next: self.head.as_deref() }
    }
    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {
        IterMut { next: self.head.as_deref_mut() }
    }
}

impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {
    type Item = T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.0.pop()
    }
}
impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &amp;node.elem
        })
    }
}
impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {
    type Item = &amp;'a mut T;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.next.take().map(|node| {
            self.next = node.next.as_deref_mut();
            &amp;mut node.elem
        })
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="test-2"><a class="header" href="#test-2">test</a></h4>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);
    }
    #[test]
    fn into_iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.into_iter();
        assert_eq!(iter.next(), Some(1));
        assert_eq!(iter.next(), Some(2));
        assert_eq!(iter.next(), Some(3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter();
        assert_eq!(iter.next(), Some(&amp;1));
        assert_eq!(iter.next(), Some(&amp;2));
        assert_eq!(iter.next(), Some(&amp;3));
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn iter_mut() {
        let mut list = List::new();
        list.push(1); list.push(2); list.push(3);

        let mut iter = list.iter_mut();
        assert_eq!(iter.next(), Some(&amp;mut 1));
        assert_eq!(iter.next(), Some(&amp;mut 2));
        assert_eq!(iter.next(), Some(&amp;mut 3));
        assert_eq!(iter.next(), None);
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-1"><a class="header" href="#rust-1">rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="riscv-1"><a class="header" href="#riscv-1">riscv</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="riscv-2"><a class="header" href="#riscv-2">riscv</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="远程-usb"><a class="header" href="#远程-usb">远程 USB</a></h1>
<p>https://unix.stackexchange.com/questions/201757/how-can-i-set-up-a-usb-proxy-for-dev-ttyusb0-over-the-network
https://cygwin.com/cygwin-ug-net/using-specialnames.html#pathnames-posixdevices</p>
<h2 id="socat"><a class="header" href="#socat">socat</a></h2>
<ul>
<li>linux
<ul>
<li>socat</li>
</ul>
</li>
<li>windows
<ul>
<li>com2tcp</li>
<li>socat-windows</li>
</ul>
</li>
</ul>
<pre><code class="language-make">get-remote-usb:
        ssh nixos &quot;socat PTY,raw,echo=0,link=/home/trdthg/tmp/dev/ttyVUSB0 tcp:47.94.225.51:50100&quot;
set-remote-usb:
        socat.exe /dev/ttyS11,raw,echo=0 tcp-listen:50100,reuseaddr
set-remote-usb2:
        com2tcp.bat --baud 460800 COM12 50100
set-frp:
        frpc -c C:/Users/trdth/github/frp/frpc.ini
</code></pre>
<h2 id="usbip"><a class="header" href="#usbip">usbip</a></h2>
<ul>
<li>
<p>linux: just install</p>
</li>
<li>
<p>windows: usbip-win https://github.com/cezanne/usbip-win
https://usbip.sourceforge.net/</p>
</li>
<li>
<p>https://www.linux-magazine.com/Issues/2018/208/Tutorial-USB-IP</p>
</li>
<li>
<p>https://pluhuxc.github.io/2018/11/01/usbip.html</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="资源整理"><a class="header" href="#资源整理">资源整理</a></h1>
<ul>
<li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">Leaf——美团点评分布式 ID 生成系统</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-发行版配置"><a class="header" href="#linux-发行版配置">Linux 发行版配置</a></h1>
<h2 id="nixos"><a class="header" href="#nixos">nixos</a></h2>
<h3 id="安装注意"><a class="header" href="#安装注意">安装注意</a></h3>
<p>在执行最后的 <code>nixos-install</code> 之前记得打开网络设置，不然就要重装</p>
<h3 id="网络设置"><a class="header" href="#网络设置">网络设置</a></h3>
<pre><code class="language-sh">systemctl start wpa_supplicant

wpa_cli
add_network
set_network 0 ssid | psk | key_mgmt

WPA-PSK

list_network
enable_network 0
</code></pre>
<p>关闭设备（wifi）被禁用</p>
<pre><code class="language-sh">rfkill list
rfkill unblock all
</code></pre>
<h3 id="亮度设置"><a class="header" href="#亮度设置">亮度设置</a></h3>
<pre><code class="language-sh">programs.light.enable = true;
</code></pre>
<pre><code class="language-sh">light -U 30 # darker.
light -A 30 # brighter.
</code></pre>
<h3 id="音量调节"><a class="header" href="#音量调节">音量调节</a></h3>
<pre><code class="language-sh">
alsamixer

amixer set Master mute
amixer set Master unmute
amixer set Master 10%
amixer set Master 20%
</code></pre>
<h2 id="i3wm"><a class="header" href="#i3wm">i3wm</a></h2>
<h3 id="多屏幕"><a class="header" href="#多屏幕">多屏幕</a></h3>
<pre><code class="language-sh">xrandr
xrandr --output DP-1 --auto --right-of eDP-1
</code></pre>
<h2 id="manjaro"><a class="header" href="#manjaro">manjaro</a></h2>
<h3 id="cpu-调频"><a class="header" href="#cpu-调频">cpu 调频</a></h3>
<ol>
<li>查看当前所有 CPU 的信息：</li>
</ol>
<pre><code class="language-shell">cpupower -c all frequency-info
</code></pre>
<ol start="2">
<li>设置所有 CPU 为性能模式：</li>
</ol>
<pre><code class="language-shell">cpupower -c all frequency-set -g performance
</code></pre>
<ul>
<li>
<p>performance: 固定最高运行频率上，不动态调节。</p>
</li>
<li>
<p>powersave: 固定工作在其支持的最低运行频率上</p>
</li>
<li>
<p>ondemand: 按需快速动态调整 CPU 频率，一有 cpu 计算量的任务，就会立即达到最大频率运行，等执行完毕就立即回到最低频率；</p>
</li>
<li>
<p>conservative:
与 ondemand 不同，平滑地调整 CPU 频率，频率的升降是渐变式的，会自动在频率上下限调整，和 ondemand 的区别在于它会按需分配频率，而不是一味追求最高频率；</p>
</li>
</ul>
<h3 id="自动挂载"><a class="header" href="#自动挂载">自动挂载</a></h3>
<pre><code class="language-shell"># 100mb 虚拟硬盘
mount tmpfs in /home/trdthg/tmp/
tmpfs /home/trdthg/tmp tmpfs size=96m 0 0

# 1.查看电脑中所有硬盘的分区情况。
# 命令如下：
# sudo fdisk -l
# 2.结果如下
# /dev/nvme0n1p3    567296  210282495 209715200   100G Microsoft 基本数据
# /dev/nvme0n1p4 210282496  872337407 662054912 315.7G Microsoft 基本数据

#auto mount windows fs
/dev/nvme0n1p3 /mnt/C ntfs nls=utf8,umask=000   0   0
/dev/nvme0n1p4 /mnt/D ntfs nls=utf8,umask=000   0   0

# 注： 末尾的 2 行是添加的内容。其中/dev/nvme0n1p3 一行代表 C 盘分区将自动挂载到/mnt/C 目录下，文件系统为 NTFS（如果步骤 1 中查看分 区的文件系统为 FAT32 时，此处请写 vfat），字符编码为 utf8。umask 表示文件目录的权限，此参数以及之后的 2 个参数都为 0 即可。以下几行以 此类推。此处可以选择性的添加需要自动挂载的分区，不想挂载的分区不用书写。
</code></pre>
<h3 id="openssh-serversshd-启动"><a class="header" href="#openssh-serversshd-启动">openssh-server(sshd) 启动</a></h3>
<h3 id="openssh"><a class="header" href="#openssh">OpenSSH</a></h3>
<p>OpenSSH 可以支撑 Manjaro 成为 SSH Server，以便其他主机可以通过 SSH 连接到 Manjaro。</p>
<pre><code class="language-shell"># 安装 OpenSSH
sudo pacman -S openssh
# 开机自启 sshd 服务
sudo systemctl enable sshd
# 启动 sshd 服务
sudo systemctl start sshd
# 重启 sshd 服务
sudo systemctl restart sshd
</code></pre>
<h2 id="gamepad"><a class="header" href="#gamepad">gamepad</a></h2>
<p>驱动下载：xboxdrv</p>
<p>蓝牙：</p>
<pre><code class="language-txt">bluetoothctl pair &lt;mac_addr&gt;
bluetoothctl connect &lt;mac_addr&gt;
bluetoothctl remove &lt;mac_addr&gt;
bluetoothctl trust &lt;mac_addr&gt;
</code></pre>
<p><a href="https://zhongguo.eskere.club/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8bluetoothctl%E5%9C%A8linux%E4%B8%8A%E7%AE%A1%E7%90%86%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87/2021-05-16/">如何使用 bluetoothctl 在 Linux 上管理蓝牙设备</a></p>
<p>测试：</p>
<p><a href="https://www.shumeijiang.com/2021/08/04/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%92%8C%E6%89%8B%E6%9F%84-%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5.html">树莓派和手柄 - 蓝牙连接</a></p>
<p>资料：</p>
<p><a href="https://www.makeuseof.com/tag/get-game-controllers-running-linux/">How to Set Up and Use Game Controllers on Linux</a>
<a href="https://wiki.archlinux.org/title/Gamepad">Arch-Wiki Gamepad</a>
<a href="https://help.wooting.io/en/article/guide-configuring-xinput-support-for-linux-69m32u/">Guide – Configuring XInput support for Linux</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库存储引擎"><a class="header" href="#数据库存储引擎">数据库存储引擎</a></h1>
<h2 id="bitcast"><a class="header" href="#bitcast">Bitcast</a></h2>
<ul>
<li>日志型</li>
<li>基于 hash 表</li>
</ul>
<ol>
<li>只支持追加
Bitcast 仅支持追加操作（Append-only），即所有的写操作只追加而不修改老的数据。</li>
<li>多版本文件
<ul>
<li>每个文件有一定的大小限制，当文件增加到相应的大小时，就会产生一个新的文件，老的文件只读不写。</li>
<li>在任意时刻，只有一个文件是可写的，用于数据追加，称为活跃数据文件（active data file）。而其他已经达到大小限制的文件，称为老数据文件（older data file）。</li>
</ul>
</li>
<li>日志文件
<ul>
<li>Bitcast 数据文件中的数据是一条一条的 &quot;操作&quot;, 所有的操作都会序列化到日志文件里 (包括删除).</li>
<li>写入时首先将 Key-Value 记录追加到活跃数据文件的末尾，接着更新内存哈希表，因此，每个写操作总共需要进行一次顺序的磁盘写入和一次内存操作。</li>
</ul>
</li>
<li>日志压缩
<ul>
<li>Bitcask 需要定期执行合并（Compaction）操作以实现垃圾回收。</li>
<li>合并操作，即将所有老数据文件中的数据扫描一遍并生成新的数据文件，同一个 key 的多个操作以只保留最新一个的原则进行删除，每次合并后，新生成的数据文件就不再有冗余数据了。</li>
</ul>
</li>
<li>hash 索引
<ul>
<li>哈希索引存储在内存中，如果不做额外的工作，服务器断电重启重建哈希表需要扫描一遍数据文件</li>
<li>如果数据文件很大，这是一个非常耗时的过程。可以通过索引文件（hint file）来提高重建哈希表的速度。</li>
</ul>
</li>
</ol>
<h2 id="lsm"><a class="header" href="#lsm">LSM</a></h2>
<h3 id="核心思想"><a class="header" href="#核心思想">核心思想</a></h3>
<p><strong>放弃部分读能力，换取写入的最大化能力</strong></p>
<p>先可以将更新的数据驻留在内存中，等到积累足够多之后，再使用归并排序的方式将内存内的数据合并追加到磁盘中。</p>
<p>LSM-tree 的主要思想是划分不同等级的树。</p>
<ul>
<li>以两级树为例，可以想象一份索引数据由两棵树组成，一棵树存在于内存，一棵树存在于磁盘。</li>
<li>内存中的树可以不一定是 B 树，可以是其他的树，例如 AVL 树。因为数据大小是不同的，没必要牺牲 CPU 来达到最小的树高度，而存在于磁盘的树则是一棵 B 树。</li>
</ul>
<h3 id="写入过程"><a class="header" href="#写入过程">写入过程</a></h3>
<ul>
<li>
<p>在 LSM 树中，写入数据时首先会插入到内存的树中。</p>
</li>
<li>
<p>当内存中的树的数据超过一定阈值时，会进行合并操作。合并操作会顺序遍历内存中的树的叶子节点，并与磁盘中的树的叶子节点进行合并</p>
<ul>
<li>当被合并的数据量达到磁盘的存储页的大小时，会将数据持久化到磁盘，同时更新父亲节点对叶子节点的指针。</li>
</ul>
</li>
<li>
<p>LSM 树可以划分成很多层级的树</p>
<ul>
<li>第 0 层存储在内存，第 1 到 k 层存储在磁盘，每层的数据都是有序的。</li>
<li>数据首先会插入到第 0 层，然后后台逐层合并。</li>
<li>每一层的数据超过一定阈值时，往下一层合并。</li>
<li>读取叶由于不知道数据在哪一层上，可能需要遍历所有的层。</li>
</ul>
</li>
</ul>
<h3 id="level-db"><a class="header" href="#level-db">Level DB</a></h3>
<p>LevelDB 存储引擎主要包括：</p>
<ul>
<li>内存中的 MemTable 和不可变 MemTable（也称为 Frozen MemTable）</li>
<li>磁盘上的几种主要文件：
<ul>
<li>当前（Current）文件</li>
<li>清单（Manifest）文件</li>
<li>操作日志（Commit Log，也称为提交日志）文件</li>
<li>SSTable 文件</li>
</ul>
</li>
</ul>
<p>写入过程：</p>
<ul>
<li>当应用写入一条记录时，LevelDB 会首先将修改操作写入到操作日志文件，成功后再将修改操作应用到 MemTable，这样就完成了写入操作。</li>
<li>当 MemTable 占用的内存达到一个上限值后，需要将内存的数据转储到外存文件中。</li>
<li>LevelDB 会将原先的 MemTable 冻结成为不可变 MemTable，并生成一个新 MemTable。新到来的数据被记入新的操作日志文件和新生成的 MemTable 中。</li>
<li>不可变 MemTable 的内容是不可更改的，只能读取不能写入或者删除。LevelDB 后台线程会将不可变 MemTable 的数据排序后转储到磁盘，形成一个新的 SSTable 文件，这个操作称为 Compaction。</li>
<li>SSTable 文件是内存中的数据不断进行 Compaction 操作后形成的，且 SSTable 的所有文件是一种层级结构，第 0 层为 Level 0，第 1 层为 Level 1，以此类推。</li>
</ul>
<blockquote>
<p>SSTable: SSTable 是一个键是有序的，存储字符串形式键值对的文件。它是一个内部包含了任意长度、排好序的键值对集合的文件。SSTable 文件由两部分数据组成：索引和键值对数据。所有的 key 和 value 都是紧凑地存放在一起的，如果要读取某个键对应的值，需要通过索引中的 key:offset 来定位。SSTable 在序列化成文件之后，是不可变的，因为此时的 SSTable，就类似于一个数组一样，如果插入或者删除，需要移动一大片数据，开销比较大。</p>
</blockquote>
<p>加快访问效率：</p>
<ul>
<li>LSM 树写入效率很高，但读取可能需要访问较多的磁盘文件，效率较低。为了加快读取效率，工程实现上一般使用 Bloom Filter 来加快读取效率。它使用很小的存储空间换来较大的读取效率提升。</li>
</ul>
<p>Bloom Filter 是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。</p>
<ul>
<li>Bloom Filter 的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter 不适合那些“零错误”的应用场合。</li>
<li>而在能容忍低错误率的应用场合下，Bloom Filter 通过极少的错误换取了存储空间的极大节省。</li>
</ul>
<blockquote>
<p>初始状态时，Bloom Filter 是一个包含 m 位的位数组，每一位都置为 0。为了表达 S={x1, x2,…,xn}这样一个 n 个元素的集合，Bloom Filter 使用 k 个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到{1,…,m}的范围中。对任意一个元素 x，第 i 个哈希函数映射的位置 hi(x) 就会被置为 1（1≤i≤k）。注意，如果一个位置多次被置为 1，那么只有第一次会起作用，后面几次将没有任何效果。在判断 y 是否属于这个集合时，我们对 y 应用 k 次哈希函数，如果所有 hi(y) 的位置都是 1（1≤i≤k），那么我们就认为 y 是集合中的元素，否则就认为 y 不是集合中的元素。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网站更新日志"><a class="header" href="#网站更新日志">网站更新日志</a></h1>
<h2 id="v4-mdbook"><a class="header" href="#v4-mdbook">v4 mdbook</a></h2>
<p>2023.4.24 Docusaurus 懒得折腾了，mdbook 比较熟，还能通过模板引用代码文件，就用它了。</p>
<h2 id="v3-docusaurus"><a class="header" href="#v3-docusaurus">v3 Docusaurus</a></h2>
<p>2022.10.21 从 vuepress2 迁移到 Docusaurus</p>
<h2 id="v2-vuepress2"><a class="header" href="#v2-vuepress2">v2 vuepress2</a></h2>
<p>迁移到 vite 后的构建速度是真滴快！</p>
<h2 id="v1-vuepress1"><a class="header" href="#v1-vuepress1">v1 vuepress1</a></h2>
<p>基于 typora 处理图片</p>
<pre><code class="language-sh"># rm -rf docs/.vuepress/dist
cd vuePressBlog
# 生成静态文件
pnpm run build

# 图片源修改
rm docs/.vuepress/public/assets/img/*
cp /home/trthg/.config/Typora/typora-user-images/* docs/.vuepress/public/assets/img/

# md 引用图片路径修改
sed -i &quot;s/\/home\/trthg\/.config\/Typora\/typora-user-images/\/assets\/img/g&quot; `grep -rl &quot;/assets/img&quot; ./`

# # /* 会忽略。开头的文件   /. 不会
rm -r ../assets
rm -r ../java
rm -r ../other
rm -r ../js
rm -r ../python
rm -r ../rust
rm -r ../ioclub
rm -r ../magic
rm ../*.html
# rm ../*.png
# rm ../*.jpg

mv docs/.vuepress/dist/* ../

curDate=$(date &quot;+%Y-%m-%d&quot;)
curTime=$(date &quot;+%H:%M:%S&quot;)
# # git init
cd ..
git add .
git commit -s -m &quot;commit: $curDate $curTime&quot;
git push -u origin main
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ioclub"><a class="header" href="#ioclub">ioclub</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b-树以及在数据库中的应用"><a class="header" href="#b-树以及在数据库中的应用">B+ 树以及在数据库中的应用</a></h1>
<ul>
<li><a href="other/ioclub/share_1.html#b%E6%A0%91%E4%BB%A5%E5%8F%8A%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">B+ 树以及在数据库中的应用</a>
<ul>
<li><a href="other/ioclub/share_1.html#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93">什么是数据库</a>
<ul>
<li><a href="other/ioclub/share_1.html#%E6%8A%80%E6%9C%AF%E5%88%9D%E8%A1%B7">技术初衷</a></li>
<li><a href="other/ioclub/share_1.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a></li>
<li><a href="other/ioclub/share_1.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%86%E7%B1%BB">数据库的分类</a>
<ul>
<li><a href="other/ioclub/share_1.html#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93">关系数据库</a></li>
<li><a href="other/ioclub/share_1.html#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93nosql">非关系型数据库（NoSQL）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="other/ioclub/share_1.html#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93">如何实现一个数据库？</a>
<ul>
<li><a href="other/ioclub/share_1.html#%E4%BD%BF%E7%94%A8%E5%8D%95%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%9A%84%E7%BC%BA%E7%82%B9">使用单文件存储的缺点</a></li>
<li><a href="other/ioclub/share_1.html#%E7%9B%AE%E6%A0%87">目标</a></li>
</ul>
</li>
<li><a href="other/ioclub/share_1.html#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF">实现思路</a>
<ul>
<li><a href="other/ioclub/share_1.html#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8">使用数组存储</a></li>
<li><a href="other/ioclub/share_1.html#%E4%BD%BF%E7%94%A8%E6%A0%91%E5%AD%98%E5%82%A8">使用树存储</a>
<ul>
<li><a href="other/ioclub/share_1.html#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></li>
<li><a href="other/ioclub/share_1.html#%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%80%97%E6%97%B6%E5%9C%A8%E5%93%AA%E9%87%8C">查询的耗时在哪里</a></li>
<li><a href="other/ioclub/share_1.html#%E5%A4%9A%E5%8F%89%E6%A0%91">多叉树</a>
<ul>
<li><a href="other/ioclub/share_1.html#b%E6%A0%91">B 树</a></li>
<li><a href="other/ioclub/share_1.html#b%E6%A0%91-1">B+ 树</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="什么是数据库"><a class="header" href="#什么是数据库">什么是数据库</a></h2>
<p><strong>数据库</strong>，又称为数据管理系统，简而言之可视为<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9B%BB%E5%AD%90%E5%8C%96&amp;action=edit&amp;redlink=1">电子化</a>的<a href="https://zh.wikipedia.org/wiki/%E6%A1%A3%E6%A1%88%E6%9F%9C">文件柜</a>——存储电子<a href="https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88">文件</a>的处所，用户可以对<a href="https://zh.wikipedia.org/wiki/%E6%AA%94%E6%A1%88">文件</a>中的资料运行新增、截取、更新、删除等操作 [<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93#cite_note-1">1]</a>。</p>
<h3 id="技术初衷"><a class="header" href="#技术初衷">技术初衷</a></h3>
<p>在<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>出现之后，随着<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>应用范围的扩大、需要处理的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE">数据</a>迅速膨胀。最初，数据与<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F">程序</a>一样，以简单的文件作为主要存储形式。以这种方式组织的数据在逻辑上更简单，但<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7">可扩展性</a>差，访问这种数据的程序需要了解数据的具体组织格式。当系统数据量大或者用户访问量大时，应用程序还需要解决数据的完整性、一致性以及安全性等一系列的问题。因此，必须开发出一种<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">系统软件</a>，它应该能够像操作系统屏蔽了硬件访问复杂性那样，屏蔽数据访问的复杂性。由此产生了数据管理系统，即数据库。</p>
<h3 id="数据库管理系统"><a class="header" href="#数据库管理系统">数据库管理系统</a></h3>
<p>主条目：<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库管理系统</a>（英语：Database Management
System，简称<a href="https://zh.wikipedia.org/wiki/DBMS">DBMS</a>）是为管理<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%BA%AB">数据库</a>而设计的电脑<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94">软件</a>系统，一般具有存储、截取、安全保障、备份等基础功能。数据库管理系统可以依据它所支持的<a href="https://zh.wikipedia.org/w/index.php?title=%E8%B3%87%E6%96%99%E5%BA%AB%E6%A8%A1%E5%9E%8B&amp;action=edit&amp;redlink=1">数据库模型</a>来作分类，例如<a href="https://zh.wikipedia.org/wiki/%E9%97%9C%E8%81%AF%E6%A8%A1%E5%9E%8B">关系式</a>、<a href="https://zh.wikipedia.org/wiki/XML">XML</a>；或依据所支持的电脑类型来作分类，例如服务器聚类、移动电话；或依据所用查询语言来作分类，例如<a href="https://zh.wikipedia.org/wiki/SQL">SQL</a>、<a href="https://zh.wikipedia.org/w/index.php?title=XQuery&amp;action=edit&amp;redlink=1">XQuery</a>；或依据性能冲量重点来作分类，例如最大规模、最高运行速度；亦或其他的分类方式。不论使用哪种分类方式，一些 DBMS 能够跨类别，例如，同时支持多种查询语言。</p>
<h3 id="数据库的分类"><a class="header" href="#数据库的分类">数据库的分类</a></h3>
<h4 id="关系数据库"><a class="header" href="#关系数据库">关系数据库</a></h4>
<ul>
<li>
<p><a href="https://www.mysql.com/cn/">MySQL</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/PostgreSQL">PostgreSQL</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/Microsoft_Access">Microsoft Access</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/Microsoft_SQL_Server">Microsoft SQL Server</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93">Oracle 数据库</a></p>
<p>类似于 excel 表格，所有数据以表格的形式按行或按列存储</p>
</li>
</ul>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021248061.png" alt="" /></p>
<h4 id="非关系型数据库a-hrefhttpszhwikipediaorgwikinosqlnosqla"><a class="header" href="#非关系型数据库a-hrefhttpszhwikipediaorgwikinosqlnosqla">非关系型数据库（<a href="https://zh.wikipedia.org/wiki/NoSQL">NoSQL</a>）</a></h4>
<ul>
<li>
<p><a href="https://zh.wikipedia.org/wiki/MongoDB">MongoDB</a></p>
</li>
<li>
<p><a href="https://zh.wikipedia.org/wiki/Redis">Redis</a></p>
</li>
</ul>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021249305.png" alt="" /></p>
<h2 id="如何实现一个数据库"><a class="header" href="#如何实现一个数据库">如何实现一个数据库？</a></h2>
<h3 id="使用单文件存储的缺点"><a class="header" href="#使用单文件存储的缺点">使用单文件存储的缺点</a></h3>
<ol>
<li>单个文件存储数据效率低，读取速度慢</li>
<li>如果文件过大 (几个 G), 就不能直接把整个文件读入内存再进行操作 , 即使能够读入内存，那也是完全没有必要的，我们需要的数据可能只有一行，
想要找到这一行就把所有数据全部读取是很浪费的</li>
<li>如果对文件的修改速度过快，可能会导致文件'损坏'</li>
</ol>
<h3 id="目标"><a class="header" href="#目标">目标</a></h3>
<ol>
<li>加速文件读取速度</li>
<li>能够实现分快读取</li>
<li>能够在修改文件时，保证数据的完整性 (先不提)</li>
</ol>
<h2 id="实现思路"><a class="header" href="#实现思路">实现思路</a></h2>
<h3 id="使用数组存储"><a class="header" href="#使用数组存储">使用数组存储</a></h3>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021249677.png" alt="" />
<strong>优点</strong></p>
<ol>
<li>存储在内存中，数据量少的时候尚且可以，</li>
<li>可以通过索引 (下标) 访问数据元素，速度最快</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>
<p>当每个元素变大时，这种方式就会占用较大的内存</p>
<p>(依次为 学号，姓名，成绩，按照学号排序)</p>
</li>
</ol>
<p><strong>优化</strong></p>
<p>结合之前二分的方法，我们尝试将数组中学号最小，最大，和位于中间的元素提取出来</p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021250084.png" alt="" />
当我们需要查询学号为 3 的学生时，我们只需要先读取上一层的 3 个元素，在 知道 1 &lt; 3 &lt; 5 后就只需要在数组索引从 1 到 5 中查询学号为 3 的元素了</p>
<p><strong>更大更多</strong></p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021252950.png" alt="" />
这是一种实现思路，不过不是我们讲的重点，只是为了拓展一下大家的事业</p>
<p>(这个东西叫跳表，可以实现对链表的二分，感兴趣的自己可以去查，我没亲手实现过)</p>
<p><strong>结果</strong></p>
<p>实现了查询速度的优化，但是如果每个节点都单独分一个文件，硬盘对于存储大量小文件是低效的 (这里不展开讲), 不适和在硬盘中存储</p>
<h3 id="使用树存储"><a class="header" href="#使用树存储">使用树存储</a></h3>
<h4 id="二叉树"><a class="header" href="#二叉树">二叉树</a></h4>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021252234.png" alt="" />
树的任意节点的左子树的节点对应的值都比右子树的值小，
二叉查找树相比于其他数据结构的优势在于查找、插入的<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a>较低。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">集合</a>、<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E9%9B%86">多重集</a>、<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">关联数组</a>等。</p>
<p>我们分析一下对于使用二叉树进行查询需要的次数</p>
<pre><code class="language-python"># 1. '**'在 python 中表示次方，print(3**2)
# 2. 数字中间的下划线会被忽视，作用只是为了看数字时更方便

2**27 = 134_000_000
2**26 = 67_000_000
2**25 = 34_000_000
2**24 = 17_000_000
</code></pre>
<p>从 1 亿数据中查询最大只需要 27 次，效果非常好，但是这还远远不够</p>
<p>让我们继续分析</p>
<h4 id="查询的耗时在哪里"><a class="header" href="#查询的耗时在哪里">查询的耗时在哪里</a></h4>
<p>对于二叉树</p>
<pre><code> 从磁盘中读取一个节点
   |
 得到节点内存储的学号
   |
 比较该节点的学号和我们需要查询的学号
   |
找到左子树或右子树在硬盘中的位置
   |
  进行下一次
</code></pre>
<p>我们这里先讨论机械硬盘的条件下</p>
<p>下面就是一张机械硬盘的图片，最重要的就是磁头和磁盘两个结构，每次硬盘把文件读取到内存中，都需要先把磁头旋转到对应的位置，才能开始读取存储在文件中的数据</p>
<p><img src="https://bkimg.cdn.bcebos.com/pic/32fa828ba61ea8d3c3793017940a304e251f584d?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" alt="???" /></p>
<p>因为从硬盘读取数据的速度远远低于比较节点的速度，所以我们可以尽量降低二叉树的深度 (即降低检索数据的次数),</p>
<h4 id="多叉树"><a class="header" href="#多叉树">多叉树</a></h4>
<h5 id="b-树"><a class="header" href="#b-树">B 树</a></h5>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021253576.png" alt="" /></p>
<p>假如我们一个节点可以存储更多分支，我们就能用更少的次数查到相应的数据节点，这本身是一种很好的结构，已经能够解决一些问题，
PostgreSql 就提供了 B 树作为存储结构</p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021254278.png" alt="" />
现在每个节点存储了多个元素数据，每个元素中都包含了一个学生的信息，</p>
<p>每次查询时，如果学号匹配我们就直接返回结果，如果不匹配，就继续深入下一层</p>
<p><strong>缺点</strong></p>
<p>但是在真实环境下，一个节点不可能只有一个序号，我们现在把图扩充下</p>
<p>存储的信息越多，单个元素就越大，我们能读取到内存中的元素个数就会变少，树的分叉就不会太多为了让分叉足够多，我们引入 B+ 树</p>
<h5 id="b-树-1"><a class="header" href="#b-树-1">B+ 树</a></h5>
<p>为了能够让一个节点存储更多的元素，我们决定抛弃节点中存储的无用的信息，之保留学号这一项数据，然后之在叶子节点 (就是最后一层的节点) 存储完整的节点
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021254900.png" alt="" /></p>
<p>现在我们得到最好的结构了，我们可以一次加载一个节点，每个节点可能有几百几千个学号，假如有 100 个分支，两层数据就能够存储 100 * 100 =
10_000 个数据，在 10000 个人中只用两次就能查到我们需要的数据，想对于二叉树 2**13 = 8192 需要大概 13 次，我们现在磁盘只需要旋转 2 +
1 次就能读到数据，这是一个飞跃。</p>
<p><strong>小问题</strong></p>
<p>学号为 10, 20, 30 的学生的数据去哪了？没了？
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021254452.png" alt="" /></p>
<p>比如我们现在需要查询学号为 10 的学生的数据，我们在在查询第一层时已经找到了 10，但是依然不能停，需要继续想下查找，知道找到最后一层节点为止</p>
<p><strong>小拓展</strong></p>
<p>把最后一层的数据串起来，我们就能实现区间查询，比如查询学好为 12 到 22 的所有学生的数据</p>
<p><img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021255491.png" alt="" /></p>
<p><strong>一个 demo</strong>
<img src="https://trdthg-img-for-md-1306147581.cos.ap-beijing.myqcloud.com/img/202202021255706.png" alt="" /></p>
<p><strong>快要忘记的固态硬盘</strong></p>
<p>如果你用的是固态硬盘，那么 B+ 树......卒</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ioclub-1"><a class="header" href="#ioclub-1">ioclub</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2021-后端"><a class="header" href="#2021-后端">2021-后端</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backend_1"><a class="header" href="#backend_1">backend_1</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backend_2"><a class="header" href="#backend_2">backend_2</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backend_3"><a class="header" href="#backend_3">backend_3</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backend_4"><a class="header" href="#backend_4">backend_4</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2021-后端-1"><a class="header" href="#2021-后端-1">2021-后端</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backend_1-1"><a class="header" href="#backend_1-1">backend_1</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backend_2-1"><a class="header" href="#backend_2-1">backend_2</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backend_3-1"><a class="header" href="#backend_3-1">backend_3</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backend_4-1"><a class="header" href="#backend_4-1">backend_4</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2021-后端-2"><a class="header" href="#2021-后端-2">2021-后端</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算机组成原理"><a class="header" href="#计算机组成原理">计算机组成原理</a></h1>
<h2 id="41-存储器概述"><a class="header" href="#41-存储器概述">4.1 存储器概述</a></h2>
<h3 id="分类"><a class="header" href="#分类">分类</a></h3>
<p>按存储介质：</p>
<ul>
<li>
<p>1 半导体存储器：TTL, MOS (容易丢失，断电就没)</p>
</li>
<li>
<p>2.1 磁表面存储器：(塑料或金属基片涂磁层并磁化) 磁头 磁载体 (盘片)</p>
</li>
<li>
<p>2.2 磁芯存储器：硬磁材料 环形元件</p>
</li>
<li>
<p>3 光盘存储器：激光 磁光材料</p>
</li>
</ul>
<p>按存储方式：</p>
<ol>
<li>
<p>存取时间与地址无关 (随机访问)</p>
<ul>
<li>随机存储器 (RAM random-access memory) 在程序执行过程中可读可写</li>
<li>只读存储器 (ROM read-only memory) 在程序执行过程中只读</li>
</ul>
</li>
<li>
<p>存取时间与地址有关 (串行访问)</p>
<ul>
<li>顺序存储存储器 磁带</li>
<li>直接存储存储器 硬盘 (定位 磁头一栋，停在指定的柱面上，读写头移动到柱面下，等待磁盘指定的区域旋转过来)</li>
</ul>
</li>
</ol>
<p>按在计算机中的作用：</p>
<ol>
<li>主存储器
<ul>
<li>RAM
<ul>
<li>静态 RAM cache</li>
<li>动态 RAM 内存条</li>
</ul>
</li>
<li>ROM
<ul>
<li>MROM 出厂厂家写入</li>
<li>PROM 一次可编程</li>
<li>EPROM 可擦鞋，可编程 ROM, 擦写复杂</li>
<li>EEPROM 更容易擦写</li>
</ul>
</li>
</ul>
</li>
<li>Flash Memory 大硬盘缓冲</li>
<li>高速缓冲存储器 (Cache)</li>
<li>辅助存储器 磁盘 磁带 光盘</li>
</ol>
<h3 id="层次结构"><a class="header" href="#层次结构">层次结构</a></h3>
<ol>
<li>存储器的三个主要特性的关系</li>
</ol>
<p>速度 价格 容量</p>
<p>寄存器 &gt; 缓存 &gt; 主存 &gt; 硬盘 &gt; 光盘 &gt; 磁带</p>
<ol start="2">
<li>存储层次</li>
</ol>
<ul>
<li>cache &lt;=&gt; 主存
<ul>
<li>解决 CPU 和主存速度差异过大</li>
</ul>
</li>
<li>主存 &lt;=&gt; 辅存
<ul>
<li>解决容量问题</li>
<li>虚拟地址空间</li>
</ul>
</li>
</ul>
<pre><code>   +-----------------------------+
   |                             |
+--+--+      +-------+        +--+--+        +-----+
|     |------|       |--------|     |--------|     |
| CPU |      | cache |        | 主存 |       | 辅存 |
|     |------|       |--------|     |--------|     |
+--+--+      +-------+        +--+--+        +-----+
   |                             |
   +-----------------------------+
</code></pre>
<h2 id="42-主存储器"><a class="header" href="#42-主存储器">4.2 主存储器</a></h2>
<h3 id="概述-5"><a class="header" href="#概述-5">概述</a></h3>
<ol>
<li>主存储器基本组成</li>
</ol>
<pre><code>+-------+     +---------+       +-----+
|       |&lt;---&gt;|         |&lt;-----&gt;|     |  数据总线
| 存储体 |     | 读写电路 |       | MDR | &lt;========&gt;
|       |&lt;---&gt;|         |&lt;-----&gt;|     |
+-------+     +---------+       +-----+
  ￪   ￪          ￪   ￪
+-------+     +---------+
| 驱动器 |     | 控制电路 |
+-------+     +---------+
  ￪   ￪          ￪   ￪
+-------+       读   写
| 译码器 |
+-------+
  ￪   ￪
+-------+
|  MAR  |
+-------+
    ￪
    | 地址总线
    |
</code></pre>
<p>MAR 中保存了由 01 代码构成的地址 译码器将 01 代码译码之后会对应存储体的存储单元
接着选中的存储单元的开关打开，存储体中的数据会送到数据线上，或者数据线上的数据会保存到存储单元里</p>
<ol start="2">
<li>主存和 CPU 的联系</li>
</ol>
<pre><code>+------------+
|            |
| +-------+  | 数据总线   +-------+
| |  MAR  |&lt;=|==========&gt;|       |
| +-------+  |           |       |
|            |     读    |       |
|            |----------&gt;|       |
|     CPU    |     写    |  主存  |
|            |----------&gt;|       |
|            |           |       |
| +-------+  | 地址总线   |       |
| |  MAR  |==|==========&gt;|       |
| +-------+  |           +-------+
|            |
+------------+
</code></pre>
<ul>
<li>存储器和主存需要数据交换，所以数据总线是双向的</li>
<li>读和写都是站在 CPU 角度来说的，CPU 需要发出读或者写信号</li>
</ul>
<ol start="3">
<li>主存中存储单元地址的分配</li>
</ol>
<pre><code>字地址      字节地址         字地址      字节地址
  0    +--+--+--+--+         0    +--+--+--+--+
  4    |1 |2 |3 |4 |         4    |4 |3 |2 |1 |
  8    |5 |6 |7 |8 |         8    |8 |7 |6 |5 |
       +--+--+--+--+              +--+--+--+--+
       小端对齐                       大端对齐
</code></pre>
<p>举例：将 16 进制数 0X12345678H 存储</p>
<pre><code>字地址      字节地址        字地址      字节地址
  0    +--+--+--+--+       0    +--+--+--+--+
  4    |12|34|56|78|       4    |78|56|34|12|
       +--+--+--+--+            +--+--+--+--+
</code></pre>
<ol start="4">
<li>存储器的技术指标</li>
</ol>
<ul>
<li>存储容量：主存存储二进制代码的总位数</li>
<li>存储速度
<ul>
<li>存取时间：存储器的访问时间，读出时间，写入时间</li>
<li>存取周期：连续两次独立的存储器操作 (读或写) 所需要的最小间隔时间</li>
</ul>
</li>
<li>存储器的带宽</li>
</ul>
<h3 id="半导体芯片概述"><a class="header" href="#半导体芯片概述">半导体芯片概述</a></h3>
<h4 id="1-基本结构"><a class="header" href="#1-基本结构">1. 基本结构</a></h4>
<pre><code>         +-------------------------+
         | +----+   +----+  +----+ |
  地址线  | | 译 |   | 存 |   | 读 | |  数据线
  =====&gt; | | 码 |   | 储 |   | 写 | | &lt;=====&gt;
         | | 驱 |   | 矩 |   | 电 | |
         | | 动 |   | 阵 |   | 路 | |
         | +----+   +----+  +----+ |
片选线---&gt;|                         | &lt;--- 读/写控制线
         +-------------------------+
</code></pre>
<ul>
<li>
<p>地址线：单向，由外部输入，能够表示有多少个存储单元</p>
</li>
<li>
<p>数据线：双向，读出和写入的数据都通过数据线传输，表示存储单元有多少信息</p>
</li>
<li>
<p>片选线：内存条上有很多芯片，需要由它确定。(CS/CE)</p>
<p>一个存储单元的容量是 1b，需要 8 个存储单元组成一组才能表示 1 字节，很多组就构成了一个大存储器，片选线能够指定组</p>
</li>
<li>
<p>读/写控制线：读写的控制信号 (例如 WE 低电平写，高电平读，OE 允许读，WE 允许写)</p>
</li>
</ul>
<p>芯片容量 = 2 ^ 地址线条数 × 2 ^ 数据线条数</p>
<h4 id="2-译码器"><a class="header" href="#2-译码器">2. 译码器</a></h4>
<p>将输入地址映射到对应的线路，找到对应的存储单元</p>
<ul>
<li>线选法：每个地址都对应一根线，线太多不现实</li>
<li>重合法：地址信号分为两部分，可以等分也可以不等分，按照矩阵的 x y 选择</li>
</ul>
<h4 id="3-随机存取存储器-ram"><a class="header" href="#3-随机存取存储器-ram">3. 随机存取存储器 (RAM)</a></h4>
<ol>
<li>静态 RAM(SRAM)</li>
</ol>
<p>行选，列选同时打开，完成读写操作</p>
<ol start="2">
<li>动态 RAM(DRAM)</li>
</ol>
<p>假如数据保存的是 0</p>
<ul>
<li>预充电：读数据线为高电平 1</li>
<li>读选择线有效，这是读出的数据为 1，需要取反的到真实数据</li>
</ul>
<p>假如数据保存的是 1</p>
<ul>
<li>数据是高电平，t1 也导通，接地，</li>
<li>数据电容放电会变为 0，读数据线也会变为低电平
<blockquote>
<p>注意：读数据线不能一直充电</p>
</blockquote>
</li>
<li>这是读选择线会读到 0, 取反得到真实数据</li>
<li><strong>注意</strong>: 因为数据改变了，需要重新写入原始数据。写入时就通过写选择线写入，写选择线会控制一整行</li>
</ul>
<ol start="3">
<li>动态 RAM 时序</li>
</ol>
<p>行列地址分开传送</p>
<ul>
<li>引脚数量更少，速度相对会慢</li>
<li>静态 RAM 也可以实现，但是它速度更快，价格更高，不能舍弃性能</li>
</ul>
<h4 id="4-只读存储器"><a class="header" href="#4-只读存储器">4. 只读存储器</a></h4>
<ol>
<li>掩膜 ROM(MROM)</li>
</ol>
<ul>
<li>
<p>出厂时写入，不能修改</p>
</li>
<li>
<p>可以保存常用的函数等</p>
</li>
<li>
<p>行列选择线交叉处有 MOS 管为 1</p>
</li>
<li>
<p>行列选择线交叉处无 MOS 管为 0</p>
</li>
</ul>
<ol start="2">
<li>PROM (一次性编程)</li>
</ol>
<p>融丝</p>
<ol start="3">
<li>EPROM(多次性编程)</li>
</ol>
<p>必须整块擦出</p>
<ol start="4">
<li>EPPRAM</li>
</ol>
<ul>
<li>电可擦写</li>
<li>局部擦写</li>
<li>全部擦写</li>
</ul>
<ol start="5">
<li>Flash Memory(闪速型存储器)</li>
</ol>
<h4 id="5-存储器和-cpu-的连接"><a class="header" href="#5-存储器和-cpu-的连接">5. 存储器和 CPU 的连接</a></h4>
<p>存储器容量的拓展</p>
<ol>
<li>位拓展（增加存储字长）</li>
</ol>
<p>用 16K × 4 位 的存储芯片组成 1K × 8 位的存储器</p>
<ul>
<li>
<p>准备两个芯片（以 2114 为例）</p>
</li>
<li>
<p>1K 对应 10 根地址线，分别连接到两个芯片上</p>
</li>
<li>
<p>每一个芯片输出 4 位数据，把它们分别接到 8 根地址线上</p>
</li>
<li>
<p>片选线会同时选中两个芯片，他们会同时工作</p>
</li>
</ul>
<ol start="2">
<li>字拓展（增加存储器器的容量）</li>
</ol>
<p>用 1K × 8 位的存储芯片组成 2K × 8 位的存储器</p>
<p>2K 对应 11 根地址线</p>
<p>使用最高位作为芯片选择的信号</p>
<ol start="3">
<li>字位拓展</li>
</ol>
<p>用 1K × 4 位的存储芯片组成 4K × 8 位</p>
<p>先用两个 1K × 4 的组成 1 个 1K × 8 的</p>
<pre><code>4K 对应 12 根地址线
4K A11 A10 A9 ... A1 A0

1K         A9 ... A1 A0
</code></pre>
<p>可以用最高 2 位选择 4 个芯片，两位译码出 4 根线，决定是哪一个芯片</p>
<p>存储器与 CPU 的连接</p>
<ol>
<li>
<p>地址线的连接</p>
</li>
<li>
<p>数据线的连接</p>
</li>
<li>
<p>读/写命令线的连接</p>
</li>
<li>
<p>片选线的连接</p>
</li>
<li>
<p>合理选择存储芯片</p>
</li>
<li>
<p>其他，时序，负载</p>
</li>
</ol>
<h4 id="6-存储器的校验"><a class="header" href="#6-存储器的校验">6. 存储器的校验</a></h4>
<ol>
<li>奇偶校验</li>
</ol>
<p>计算一组存储单元中 1 的个数，如果 1 的个数是偶数，校验码就为 0, 1 的个数是奇数，校验码变为 1</p>
<p>假如纠错码发生翻转呢？并无影响</p>
<p>缺点：</p>
<ul>
<li>只能知道出错，但不知到出错的位置</li>
<li>如果有偶数位发生翻转，无法检查到出错</li>
</ul>
<ol start="2">
<li>汉明码</li>
</ol>
<p>将数据分组，并利用二分法反复确认对比错误，能够发现两个数据翻转，无法解决 3 个数据翻转</p>
<p>由于汉明码的性质，纠错码出现在 2^n 位上。数据块越大，纠错吗的相对占比就越少</p>
<ol start="3">
<li>LDPC</li>
</ol>
<h4 id="7-提高访存速度"><a class="header" href="#7-提高访存速度">7. 提高访存速度</a></h4>
<ul>
<li>采用高速器件</li>
<li>采用层次结构 Cache-主存</li>
<li>调整主存结构</li>
</ul>
<ol>
<li>单体多字结构</li>
</ol>
<p>每次向数据中取出多个记录</p>
<p>带宽可能提高 4 倍</p>
<ol start="2">
<li>多体并行系统</li>
</ol>
<ul>
<li>
<p>高位交叉，顺序编址</p>
<p>不同存储体之间可以并行，但是 CPU 只会频繁访问某一个存储体</p>
</li>
<li>
<p>低位交叉，各个存储体轮流编址</p>
<p>需要满足一定条件，在存取周期内</p>
</li>
</ul>
<h2 id="43-高速缓冲存储器"><a class="header" href="#43-高速缓冲存储器">4.3 高速缓冲存储器</a></h2>
<h3 id="1"><a class="header" href="#1">1.</a></h3>
<h3 id="2cache-和-主存的映射"><a class="header" href="#2cache-和-主存的映射">2.Cache 和 主存的映射</a></h3>
<ol>
<li>直接映射</li>
</ol>
<p>特点：</p>
<ul>
<li>每个缓存块 i 和若干个主存块对应</li>
<li>每个主存块 j 只能和 1 干个缓存块对应</li>
</ul>
<p>过程：</p>
<ul>
<li>将主存储器的每个单元按照所在地址取模（Cache 大小）分组</li>
<li>根据地址就能直接找到地址在 Cache 中的位置，</li>
<li>接着在经过比较器比较组号是否对应判断是否命中</li>
</ul>
<p>优点：速度快</p>
<ul>
<li>只需要一个额外的标记，组号</li>
<li>CPU 三级缓存，适合做为一级缓存，追求极致速度</li>
</ul>
<p>缺点：利用率不高，</p>
<ul>
<li>假如 Cache 不满，1 号已经被占用，其他组 1 号的存储记录也不能利用到空的 Cache 资源</li>
</ul>
<ol start="2">
<li>全相连映射</li>
</ol>
<p>特点：</p>
<ul>
<li>
<p>主存的任一块可以映射到 Cache 的任一块</p>
</li>
<li>
<p>主存储器依然需要分组</p>
</li>
<li>
<p>Cache 需要除了组号，还要标记第几位</p>
</li>
<li>
<p>在比较时需要同时比较组号，位号</p>
</li>
</ul>
<p>优点：</p>
<ul>
<li>利用率高</li>
<li>适合做为 CPU 后几级缓存</li>
</ul>
<ol start="3">
<li>组相连映射</li>
</ol>
<p>前两种方法的折中</p>
<p>让每个主存块可以和 n 个 缓存块对应，它可以选择这 n 个中的任意一个</p>
<h3 id="3替换算法"><a class="header" href="#3替换算法">3.替换算法</a></h3>
<ol>
<li>先进先出（FIFO）</li>
</ol>
<p>没有体现程序的局部型原理</p>
<ol start="2">
<li>最近最少使用算法（LRU）</li>
</ol>
<p>很好体现程序的局部型原理</p>
<p>实现复杂：（滑动窗口 + 次数）？</p>
<p>最近最旧使用简单替代？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="计算机网络"><a class="header" href="#计算机网络">计算机网络</a></h1>
<h2 id="1-概述"><a class="header" href="#1-概述">1. 概述</a></h2>
<h2 id="2-应用层"><a class="header" href="#2-应用层">2. 应用层</a></h2>
<h3 id="电路交换-circuit-switching"><a class="header" href="#电路交换-circuit-switching">电路交换 circuit-switching</a></h3>
<p>频分，时分</p>
<p>建立连接 - 数据传输 - 释放资源</p>
<h3 id="分组-包-交换-package-switching"><a class="header" href="#分组-包-交换-package-switching">分组 (包) 交换 package-switching</a></h3>
<p>为每一个连接只分配一小块资源，同时服务多个 (用户) 连接</p>
<p>端到端</p>
<ul>
<li>
<p>所有数据包都是利用的完整的带宽，带宽不用分片</p>
</li>
<li>
<p>限制在交换机转发的能力</p>
</li>
<li>
<p>不需要预留资源</p>
</li>
<li>
<p>不需要提前和转发设备沟通，</p>
</li>
<li>
<p>需要存储转发</p>
</li>
<li>
<p>超过转发能力会有排队延迟，甚至产生丢包</p>
<ul>
<li>电路交换会限制发送速率，不会在中间产生不可用</li>
</ul>
</li>
</ul>
<h2 id="3-传输层"><a class="header" href="#3-传输层">3. 传输层</a></h2>
<h3 id="1-传输层服务"><a class="header" href="#1-传输层服务">1. 传输层服务</a></h3>
<ol>
<li>
<p>传输层和网络层的区别</p>
<ul>
<li>网络层：主机间的逻辑通信</li>
<li>传输层：进程间的逻辑通信</li>
</ul>
<p>传输层的服务 = 传输层的协议 + 网络层的服务</p>
<p>不同主机进程间数据传输 = 传输层的协议 + 进程所在主机间数据传输</p>
<p>发送端：</p>
<ul>
<li>接收应用层的消息</li>
<li>设置报文头部字段的值</li>
<li>创建报文段</li>
<li>把报文端传递给对应 IP</li>
</ul>
<p>接收端：</p>
<ul>
<li>从某 IP 接收 报文段</li>
<li>检查 header 的值</li>
<li>解析应用层消息</li>
<li>通过 socket 把数据多路分解到应用</li>
</ul>
</li>
<li>
<p>两个传输层协议</p>
<p>TCP(Transmission Control Protocol):</p>
<ul>
<li>可靠传输 (reliable, in-order delivery)</li>
<li>拥塞控制 (congestion control)</li>
<li>流量控制 (flow control)：确保发送端不会发送过多数据导致接收端 buffer 溢出而丢包的机制</li>
<li>面向建立</li>
</ul>
<p>UDP(User Datagram Protocol):</p>
<ul>
<li>不可靠传输 (unreliable, unordered delivery)</li>
<li>尽力而为 (no-frills extension of &quot;best-effort&quot; IP)</li>
</ul>
</li>
</ol>
<h3 id="2-多路复用--多路分解"><a class="header" href="#2-多路复用--多路分解">2. 多路复用 / 多路分解</a></h3>
<blockquote>
<p><em>Multiplexing/demultiplexing</em></p>
</blockquote>
<ul>
<li>创建 socket 时需要指定本机端口号</li>
<li>连接 UDP 时需要指定目的主机的 IP 和 端口号</li>
<li>当接收端接收到 UDP 报文后会检查目的端口，然口投递到对应的进程</li>
</ul>
<p>TCP 面向连接，TCP socket 定义了一个四元组</p>
<p>总结</p>
<ul>
<li>UDP 多路分解只使用端口号</li>
<li>TCP 多路分解使用 源和目地的 IP 和 端口</li>
<li>多路复用和多路分解发生在所有层</li>
</ul>
<h3 id="3-无连接传输-udp"><a class="header" href="#3-无连接传输-udp">3. 无连接传输 UDP</a></h3>
<h4 id="udp-特点"><a class="header" href="#udp-特点">UDP 特点</a></h4>
<ol>
<li>
<p>UDP 是一种尽力而为的协议</p>
<ul>
<li>UDP 报文段可能会丢失</li>
<li>也可能会乱序</li>
</ul>
</li>
<li>
<p>无连接</p>
<ul>
<li>UDP 发送端和接收端不需要握手</li>
<li>每一个 UDP 数据段都是独立的，上下可能没有关系</li>
<li>只有 checkout 用于错误检验</li>
</ul>
</li>
</ol>
<h4 id="为什么需要-udp"><a class="header" href="#为什么需要-udp">为什么需要 UDP？</a></h4>
<ol>
<li>无连接简历（可能会增加延迟）</li>
<li>简单，发送端和接收端不需要保存连接状态</li>
<li>没有拥塞控制，UDP 会尽可能快的送达</li>
</ol>
<p>应用场景：</p>
<p>流媒体 app</p>
<ul>
<li>低延迟</li>
<li>速度敏感</li>
</ul>
<p>如何在 UDP 上个构建可靠传输：在应用层上构建可靠性</p>
<h4 id="udp-报文段格式"><a class="header" href="#udp-报文段格式">UDP 报文段格式</a></h4>
<pre><code class="language-txt">+---------+---------+
| 源端口   | 目的端口 |
+---------+---------+
| 长度     | 校验和   |
+---------+---------+
| 应用数据（消息）     |
|                   |
+-------------------+
</code></pre>
<ul>
<li>长度：UDP 报文段的长度（包含 header）</li>
<li>数据：上层协议数据，例如 DNS，SNMP</li>
<li>checksum：错误检测（数学手段的冗余）</li>
</ul>
<h4 id="checksum-计算方法"><a class="header" href="#checksum-计算方法">checksum 计算方法</a></h4>
<p>将所有数据求和</p>
<ul>
<li>假如发送 5 bit 数据 (7, 11, 12, 0, 6), 实际会发送 (7, 11, 12, 0, 6, 36)</li>
<li>接收方重新计算数字之和，并与收到的比较</li>
<li>发送方法送的是实际数据的反码 (-36), 被称为 checkout</li>
</ul>
<p>问题</p>
<p>如何用 4 bit 表示 36 和 -36？</p>
<p>答：1s 补运算</p>
<ul>
<li><code>36 = 0001 0100</code></li>
<li><code>0100 + 0100 = 0110 = 6</code></li>
<li><code>+6 = 0100 -6 = 1001 取反得到 -6</code></li>
<li><code>-36 可以用 1001(9) 表示</code></li>
</ul>
<pre><code class="language-txt"> 1110 0110 0110 0110
 1101 0101 0101 0101

11011 1011 1011 1011
 1011 1011 1011 1100
</code></pre>
<h3 id="4-可靠传输"><a class="header" href="#4-可靠传输">4. 可靠传输</a></h3>
<h4 id="rdt"><a class="header" href="#rdt">rdt</a></h4>
<p>Rdt1.0:</p>
<ol>
<li>下层的 channel 是可靠的
<ul>
<li>不会发生比特翻转</li>
<li>不会丢包</li>
</ul>
</li>
<li>为 sender，receiver 设置不同的 FSM
<ul>
<li>sender 和 receiver 分别从下层的 channel 发送和接收数据</li>
</ul>
</li>
</ol>
<p>Rdt2.0:</p>
<ul>
<li>发送端发送数据</li>
<li>接收端接收数据，如果接收到的数据正确，返回 ACK，如果数据错误，返回 NAK。</li>
<li>发送端根据收到的是 ACK 还是 NAK，选择重传</li>
</ul>
<p>问题：</p>
<ol>
<li>出现比特翻转
<ul>
<li>使用 checksum 检测错误</li>
<li>ack/nak 确认</li>
<li>重传</li>
</ul>
</li>
<li>如何从错误恢复：
<ul>
<li>自动请求重传</li>
</ul>
</li>
<li>新的状态机
<ul>
<li>sender 使用 udt_send 发送数据，发送完毕后等待接收 ACK。</li>
<li>如果接收到了 ACK，就是成功。</li>
<li>如果接收到了 NAK，就会重传。</li>
</ul>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果接收方成功接收，但是返回失败，会导致消息不一致</li>
</ol>
<p>rdt2.1:</p>
<p>解决同步问题 和 ACK/NAK 出错：</p>
<ul>
<li>发送端发送的数据除了数据和 checksum 之外还有一个序列号</li>
<li>在接收端返回 ACK 或 NAK 是，还会返回序列号</li>
<li>发送端直到收到正确的序列化才会转换到下一个状态</li>
<li>是需要 0 和 1 两个状态其实就够了，区分新包和旧包</li>
</ul>
<p>rdt2.2:</p>
<p>去掉 NAK，都用 ACK 表示：</p>
<ul>
<li>发送方发送 ACK</li>
<li>接收方接收到数据，如果正确，返回原本的 ACK，如果错误，返回其他数据表示错误。</li>
<li>发送方检查 ACK，如果 ACK 相同，则切换到下一个状态</li>
</ul>
<p>rdt3.0:</p>
<ol>
<li>可能发送丢包
<ul>
<li>发送端等待一段时间，可能是数据丢了 或者 ACK 丢了，无法区分，统一重传</li>
<li>等待多久，准本计数器，等待超时</li>
</ul>
</li>
</ol>
<h4 id="pipelined-protocols-流水线"><a class="header" href="#pipelined-protocols-流水线">Pipelined protocols (流水线)</a></h4>
<p>提高效率，在发送端收到确认后可以发送更多数据</p>
<p>每次发送多份数据，当份数提高到一定程度，利用率就到 100%, 无法继续提高效率</p>
<ol>
<li>
<p>go-Back-N</p>
<p>滑动窗口，重传很多</p>
<p>积累确认机制</p>
<ul>
<li>
<p>发送方发送 5 个数据包</p>
</li>
<li>
<p>假如第 3 个丢失，接收方会返回错误的序号</p>
</li>
<li>
<p>发送端从这里重新发送</p>
</li>
<li>
<p>在接收方</p>
</li>
<li>
<p>如果到达分组是按序到达，那么发送 ACK，发送方正常移动窗口</p>
</li>
<li>
<p>如果不是按序到达，那么接收方丢弃所有失序分组；丢弃一个正确接收的失序分组可能会导致更多的重传</p>
</li>
<li>
<p>如果某个确认丢失，后续的确认（只有发送端正确接收到了数据才可能会有后续的确认）也能使发送端正常移动窗口</p>
</li>
</ul>
</li>
<li>
<p>selective repeat(选择重传)</p>
<ul>
<li>接收方因为有 buffer，所以不用按序接收分组，失序的分组会被缓存</li>
<li>发送方的 buffer，每个数据包都有各自的计数器，不用重传多的数据包</li>
</ul>
<p>为了防止误判数据包</p>
<p>ACK 编号数量至少要 = 发送窗口 + 接收窗口</p>
</li>
</ol>
<h3 id="tcp"><a class="header" href="#tcp">TCP</a></h3>
<p><img src="draft/./computer_network/tcp_segment_format.jpg" alt="TCP" /></p>
<ul>
<li>源端口和目的端口字段：各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</li>
<li>序号字段：占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li>
<li>确认号字段：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li>
<li>数据偏移（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。</li>
<li>保留字段：占 6 位，保留为今后使用，但目前应置为 0。</li>
<li>紧急 URG：当 URG  1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送 (相当于高优先级的数据)。</li>
<li>确认 ACK：只有当 ACK  1 时确认号字段才有效。当 ACK  0 时，确认号无效。</li>
<li>推送 PSH (PuSH)：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li>
<li>复位 RST (ReSeT) ：当 RST  1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li>
<li>同步 SYN：同步 SYN = 1 表示这是一个连接请求或连接接受报文。</li>
<li>终止 FIN (FINis) ：用来释放一个连接。FIN  1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li>
<li>窗口字段：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</li>
<li>检验和：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li>
<li>紧急指针字段：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</li>
<li>选项字段：长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。</li>
</ul>
<p>TCP seq 序列号</p>
<h4 id="tcp-feature"><a class="header" href="#tcp-feature">TCP Feature</a></h4>
<ul>
<li>Point to Point (单播，单发送者，单接收者)</li>
<li>reliable, in-order byte stream</li>
<li>pipelined（拥塞控制，流量控制）</li>
<li>send &amp; receive buffers</li>
<li>full deplex data(全双工，双向数据传输，MSS(最大报文长度))</li>
<li>connection-orinted(握手，初始化 sender 和 receiver 的状态)</li>
<li>flow controlled(发送端不能超过接收端的处理能力)</li>
</ul>
<h3 id="flow-control"><a class="header" href="#flow-control">Flow Control</a></h3>
<p>为什么需要流量控制？</p>
<ul>
<li>发送者接收者的速率不一定匹配，如果发的快，可能产生消息堆积</li>
</ul>
<p>如何解决？</p>
<ul>
<li>接收端需要通知发送端自己的缓冲区大小，让它不要发送太多。对应的就是 TCP 协议中规定的 Receive Window (接收窗口) 字段</li>
</ul>
<blockquote>
<p>注意滑动窗口 (发送窗口)，接收窗口，以及之后的拥塞窗口的区别</p>
</blockquote>
<h3 id="congestion-control"><a class="header" href="#congestion-control">Congestion Control</a></h3>
<h4 id="拥塞"><a class="header" href="#拥塞">拥塞</a></h4>
<ul>
<li>太多发送源发送了太多的数据，超过了网络的承载能力</li>
<li>对资源需求的总和 &gt; 可用资源</li>
<li>与流量控制不同</li>
<li>表现
<ul>
<li>丢包</li>
<li>高延迟</li>
</ul>
</li>
<li>top-10 question!</li>
</ul>
<h4 id="解决方法-1"><a class="header" href="#解决方法-1">解决方法</a></h4>
<ol>
<li>
<p>端到端</p>
<ul>
<li>没有来自网络的明确反馈</li>
<li>端系统通过丢包和延迟推测出可能通过拥塞</li>
<li>TCP 采用这种方法</li>
</ul>
</li>
<li>
<p>网络层辅助</p>
<ul>
<li>路由主动反馈给端系统
<ul>
<li>由 1 个 bit 指出网络存在拥塞 (SNA, DECbit, TCP/IP ECN, ATM)</li>
<li>发送端需要以一个固定的速率发送数据</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="draft/./computer_network/congestion_ctl.png" alt="congestion_ctl" /></p>
<h4 id="三大问题"><a class="header" href="#三大问题">三大问题</a></h4>
<ol>
<li>
<p>如何限制发送速度？</p>
<ul>
<li>
<p>Last Byte Sent(上一个发送的字节) - Last Byte Acked(最后确认的字节) &lt; CongWin(拥塞窗口)</p>
</li>
<li>
<p>rate(发送速率) = CongWIn / RTT B/s</p>
</li>
</ul>
</li>
<li>
<p>如何检测到拥塞？
loss event = timeout or 3 duplicate acks</p>
</li>
<li>
<p>应该发送多快？</p>
<ul>
<li>
<p>AIMD</p>
<ul>
<li>加法增加，乘法减小 (additive increase, multiplicative decrease)</li>
<li>增加有一个单位（1 字节，1k），一般以 MSS 数量为单位</li>
<li>图像表现为锯齿状</li>
</ul>
</li>
<li>
<p>slow start</p>
<ul>
<li>连接开始时，CongWin 为 1MSS，
<ul>
<li>每次接收到 ACK，CongWin 就会乘 2</li>
<li>慢启动其实并不慢，增加的速度很快</li>
</ul>
</li>
<li>速度增加有一定得阈值，当超过阈值后，到达新阶段，一般称为 &quot;拥塞避免&quot;，每次只会增加 1 个 MSS。</li>
</ul>
</li>
<li>
<p>conservative after timeout events</p>
<ul>
<li>发生丢包后
<ul>
<li>窗口掉回 1 MSS</li>
<li>线性增加</li>
</ul>
</li>
<li>收到 3 个重复的 ACK
<ul>
<li>窗口砍半</li>
<li>线性增加</li>
<li>快速重传</li>
</ul>
</li>
<li>新的阈值都为上次阈值的一半</li>
</ul>
<blockquote>
<p>丢包相对于 3 个重复的 ACK 更严重</p>
</blockquote>
</li>
<li>
<p>TCP CUBIC</p>
<ul>
<li>窗口减半后，增加的速度改为 <code>x^3</code> 的曲线</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="tcp-公平性"><a class="header" href="#tcp-公平性">TCP 公平性</a></h3>
<p>AIMD 具有较好的公平性，使得不同连接占有的带宽相等</p>
<blockquote>
<p>如果 TCP 和 UDP 同时竞争会怎样？TCP 会主动降低速度，UDP 则不管
想要可靠传输，不想要拥塞控制怎么办？在 UDP 的基础上自行实现可靠传输 (QUIC 就是这么干)</p>
</blockquote>
<h2 id="4-网络层"><a class="header" href="#4-网络层">4. 网络层</a></h2>
<h3 id="简介-1"><a class="header" href="#简介-1">简介</a></h3>
<ul>
<li>提供主机间的数据传输</li>
<li>发送端将段 (segments) 封装为数据报，接收端把 segments 发送到传输层</li>
<li>网络层协议在各个主机和路由间</li>
<li>router 会确认经过他的所有 IP 数据报的 header 字段</li>
</ul>
<h3 id="转发--路由"><a class="header" href="#转发--路由">转发 &amp; 路由</a></h3>
<p>路由：决定从发送源发送的 packets 到目的地的路径</p>
<ul>
<li>路由选择算法</li>
</ul>
<p>转发：把 packets 从路由的输入转发到合适的输出</p>
<ul>
<li>如何通过某一个交换机</li>
</ul>
<h3 id="数据平面控制平面"><a class="header" href="#数据平面控制平面">数据平面，控制平面</a></h3>
<ol>
<li>
<p>数据平面</p>
<ul>
<li>局部的</li>
</ul>
</li>
<li>
<p>控制平面</p>
<ul>
<li>全局的</li>
<li>Per-router control plane
<ul>
<li>每一个路由设备单独实现路由算法</li>
</ul>
</li>
<li>Software-Defined Networking(SDN) control plane
<ul>
<li>由一个集中式的计算机计算路由并向下发送了路由表</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="是否建立连接"><a class="header" href="#是否建立连接">是否建立连接</a></h3>
<ul>
<li>三种重要的网络架构
<ul>
<li>ATM, frame relay, X.25</li>
</ul>
</li>
<li>在数据报流动前，两个主机以及它们之间的路由会建立虚拟连接</li>
<li>网络层和传输层连接的区别
<ul>
<li>网络层：两个主机之间 (也可能包含之间的交换机)</li>
<li>传输层：两个进程之间</li>
</ul>
</li>
</ul>
<h3 id="虚电路--数据报"><a class="header" href="#虚电路--数据报">虚电路 &amp; 数据报</a></h3>
<ul>
<li>
<p>虚电路</p>
<ul>
<li>有连接</li>
</ul>
</li>
<li>
<p>数据报</p>
<ul>
<li>无连接</li>
</ul>
</li>
</ul>
<blockquote>
<p>网络层应该是面向连接的还是无连接的？
在计算机通信中，可靠交付应该由谁来负责？是网络还是端系统？</p>
</blockquote>
<p>转发表的建立</p>
<p>对于虚电路，转发表会在建立连接时产生</p>
<h3 id="ip-地址"><a class="header" href="#ip-地址">IP 地址</a></h3>
<blockquote>
<p><em>addressing, forwarding, routing</em></p>
</blockquote>
<ul>
<li>地址块如何设计</li>
<li>对存储和转发的影响</li>
</ul>
<h4 id="ip-地址的编址方法"><a class="header" href="#ip-地址的编址方法">IP 地址的编址方法</a></h4>
<p>分类的 IP 地址</p>
<ul>
<li>每一类地址都由两个固定长度的字段组成
<ul>
<li>网络号 net-id: 标志主机（或路由器）连接到的网络</li>
<li>主机号 host-id：标志该主机或路由器</li>
</ul>
</li>
<li>两级的 IP 地址可以记为：<code>IP 地址 ::= { &lt;网络号&gt;, &lt;主机号&gt;}</code></li>
</ul>
<blockquote>
<p><code>::=</code> 表示 &quot;定义为&quot;</p>
</blockquote>
<table><thead><tr><th>网络类别</th><th>首部</th><th>地址范围</th></tr></thead><tbody>
<tr><td>A 类</td><td>0</td><td>1.0.0.0 - 127.255.255.255</td></tr>
<tr><td>B 类</td><td>10</td><td>128.0.0.0 - 191.255.255.255</td></tr>
<tr><td>C 类</td><td>110</td><td>192.0.0.0 - 223.255.255.255</td></tr>
<tr><td>D 类</td><td>1110</td><td>224.0.0.0 - 239.255.255.255</td></tr>
<tr><td>E 类</td><td>1111</td><td></td></tr>
</tbody></table>
<p>| 类别 | 最大网络数 | 第一个可用的网络号 | 最后一个可用的网络号 | 每个网络中的最大主技术 |
| A |  126(2^7 - 2)     | 1       | 126         | 16,777,214 |
| B | 16383(2^14 - 1)   | 128.1   | 191.255     | 65,534 |
| C | 2097151(2^21 - 1) | 192.0.1 | 223.255.255 | 254 |</p>
<ul>
<li>
<p>私有地址</p>
<ul>
<li>A: 10.0.0.0 - 10.255.255.255(10.0.0.0/8 prefix)</li>
<li>B: 172.16.0.0 - 172.31.255.255(172.16.0.0/12 prefix)</li>
<li>C: 192.168.0.0 - 192.168.255.255(192.168.0.0/16 prefix)</li>
</ul>
</li>
<li>
<p>127.0.0.1: loopback</p>
</li>
<li>
<p>255.255.255.255:</p>
</li>
<li>
<p>0.0.0.0:</p>
</li>
</ul>
<p>子网的划分</p>
<p>CIDR 方案</p>
<ul>
<li>无分类的编制方法</li>
</ul>
<h4 id="ip-地址的一些重要特点"><a class="header" href="#ip-地址的一些重要特点">IP 地址的一些重要特点</a></h4>
<ul>
<li>IP 地址是 &quot;分等级&quot; 的地质结构
<ul>
<li>方便了 IP 管理：IP 管理机构分配 IP 时只分配网络号，剩下的交由单位自行管理</li>
<li>减小了路由表的大小：路由器仅根据网络号来转发路由（不用考虑目的主机号），减少了路由表项数，减小了存储空间。</li>
</ul>
</li>
<li>实际上 IP 地址标志一个主机和一条链路的接口
<ul>
<li>当一个主机同时连接到两个网络上时，它必须同时有两个 IP 地址，并且 net-id 必须不同（称为多归属主机）</li>
<li>一个路由器至少要连接到两个网络，才能将 IP 数据报总一个网络转发到另一个网络。因此路由器至少有两个不同的 IP 地址</li>
</ul>
</li>
<li>用转发器或者网桥连接起来的若干局域网仍属以一个网络，这些局域网有相同的 net-id</li>
</ul>
<h4 id="分类-ip-地址的路由转发"><a class="header" href="#分类-ip-地址的路由转发">分类 IP 地址的路由转发</a></h4>
<ul>
<li>direct delivery 直接投递/交付</li>
<li>indirect delivery 间接投递/交付</li>
<li>Route based，基于路径（构建转发表困难，维护难度大）</li>
<li>Next hop based，基于下一跳（类似于 &quot;路牌&quot;）</li>
</ul>
<ol>
<li>
<p>如果多个源 IP 有相同的下一跳，他们的目的地址可以合并</p>
</li>
<li>
<p>Default routing（缺省（默认）路由）</p>
</li>
</ol>
<h4 id="划分子网和构造超网"><a class="header" href="#划分子网和构造超网">划分子网和构造超网</a></h4>
<ol>
<li>
<p>从两极 IP 到 三级 IP 地址
原因：</p>
<ul>
<li>IP 地址利用率低</li>
<li>为每一个物理网络分配一个网络号会使路由表变大，降低性能</li>
<li>两极 IP 地址不够灵活</li>
</ul>
</li>
<li>
<p>子网掩码</p>
</li>
</ol>
<p>子网掩码前一部分为 1，后一部分全为 0，将子网掩码与 IP 地址进行 &quot;与&quot; 运算，就能找到 IP 地址的子网部分。</p>
<p>可以用来区分 net-id 和 host-id 或者 subnet-id 和 host-id</p>
<p>不同的子网掩码可以得到相同的网络地址，但是不同的掩码的效果是不同的。如果使用，路由器给出目的的网络地址外，还必须同时给出该网络的子网掩码。</p>
<p>若一个路由器连接在两个子网上，他就有两个网络地址和子网掩码</p>
<h4 id="无分类编址-cidr"><a class="header" href="#无分类编址-cidr">无分类编址 CIDR</a></h4>
<ol>
<li>
<p>CIDR 特点</p>
<ul>
<li>消除了 A，B，C 类地址，以及划分子网的概念</li>
<li>使用各种长度的 &quot;网络前缀&quot; 代替分类地址中的网络号和子网号。</li>
<li>从三级编制（取消子网掩码）变回二级编制</li>
</ul>
</li>
<li>
<p>无分类的两级编址</p>
<ul>
<li>IP 记法：<code>IP 地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}</code></li>
<li>CIDR 还是用斜线记法：在 IP 地址面加一个 <code>/</code>，后面跟上网络前缀所占的位数。（对应子网掩码中 1 的个数）</li>
<li>举例：128.14.32.0/20 <code>min: 128.14.32.0, max: 128.14.47.255</code></li>
<li>全 0 和全 1 一般不使用</li>
</ul>
</li>
<li>
<p>可变掩码长度向右移能划分为小块，向左移合并为大块</p>
</li>
<li>
<p>路由聚合减少了路由表的表项</p>
</li>
</ol>
<h3 id="ip-配置"><a class="header" href="#ip-配置">IP 配置</a></h3>
<ul>
<li>
<p>系统管理员将 IP 硬编码到文件中
UNIX: /etc/rc.config</p>
</li>
<li>
<p>DHCP: Dynamic Host Configuration Protocal:</p>
<p>从服务器动态获取 IP</p>
</li>
</ul>
<p>目的：允许主机加入网络后，从网络服务器，动态获取自己的 IP 地址。</p>
<ul>
<li>支持重置，复用，手机用户</li>
</ul>
<h3 id="dhcp"><a class="header" href="#dhcp">DHCP</a></h3>
<p>Overview</p>
<ul>
<li>主机广播 &quot;DHCP discover&quot; 消息</li>
<li>DHCP 服务器回复 &quot;DHCP offer&quot; 消息</li>
<li>主机请求 IP 地址：&quot;DHCP request&quot; 消息</li>
<li>DHCP 服务器发送地址：&quot;DHCP ack&quot; 消息</li>
</ul>
<h3 id="nat-网络地址转换"><a class="header" href="#nat-网络地址转换">NAT 网络地址转换</a></h3>
<h4 id="动机"><a class="header" href="#动机">动机</a></h4>
<p>对外部世界而言，本地网络只使用一个 IP 地址</p>
<ul>
<li>不需要 ISP 提供一系列地址，所有设别共用一个 IP 地址。</li>
<li>无需通知外部实际就可以更换本地网络的设备 IP.</li>
<li>可以在不改变本地设备 IP 情况下更换 ISP.</li>
<li>内网对外不设备不可见。</li>
</ul>
<h4 id="实现-1"><a class="header" href="#实现-1">实现</a></h4>
<p>NAT 路由必须</p>
<ul>
<li>
<p>将每个向外发送数据报的源 IP 地址，端口替换为 NAT 的 IP 地址，新端口</p>
<p>. .远程客户/服务器将使用 NAT 的 IP 地址，新端口作为目标地址进行响应。</p>
</li>
<li>
<p>在 NAT 转换表中记录每一个源 IP 地址，端口到 NAT IP 地址，新端口的映射</p>
</li>
<li>
<p>传入的数据报，将 NAT IP 地址和端口替换为 NAT 表中相应的源 IP 地址，端口。</p>
</li>
</ul>
<h4 id="nat-的缺点"><a class="header" href="#nat-的缺点">NAT 的缺点</a></h4>
<ul>
<li>16 位端口号：60000 同时连接到同一个地址</li>
<li>NAT 有争议
<ul>
<li>routers should only process up to layer 3</li>
<li>violates end-to-end argument(违背 e2e 原则)</li>
<li>NAT possibility must be taken into account by app designers, eg, P2P applications</li>
<li>address shortage should instead be solved by IPv6</li>
</ul>
</li>
</ul>
<h4 id="nat-的问题"><a class="header" href="#nat-的问题">NAT 的问题</a></h4>
<p>外部的客户端如何访问内网地址？</p>
<ul>
<li>
<ol>
<li>静态配置端口转发</li>
</ol>
</li>
<li>
<ol start="2">
<li>Universal Plug and Play (UPnP) Internet Gateway Device (IGD) Protocol.</li>
</ol>
<ul>
<li>learn public IP address (138.76.29.7)</li>
<li>enumerate existing port mappings</li>
<li>add/remove port mappings (with lease times)</li>
</ul>
<blockquote>
<p>自动配置静态端口映射</p>
</blockquote>
</li>
<li>
<ol start="3">
<li>中继 (Skype 使用)</li>
</ol>
<ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="ip-数据报格式"><a class="header" href="#ip-数据报格式">IP 数据报格式</a></h3>
<p>首部 (20 字节固定 + 变长) + 数据</p>
<ul>
<li>版本——占 4 位，指 IP 协议的版本，目前的 IP 协议版本号为 4 (即 IPv4)</li>
<li>首部长度——占 4 位，可表示的最大数值是 15 个单位 (一个单位为 4 字节) 因此 IP 的首部长度的最大值是 60 字节。</li>
<li>区分服务——占 8 位，用来获得更好的服务在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段</li>
<li>总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。</li>
<li>标识 (identification) 占 16 位，它是一个计数器，用来产生数据报的标识。</li>
<li>标志 (flag) 占 3 位，目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。
<ul>
<li>MF = 1 表示后面“还有分片”。</li>
<li>MF = 0 表示最后一个分片。</li>
<li>标志字段中间的一位是 DF (Don't Fragment) 。只有当 DF = 0 时才允许分片。</li>
</ul>
</li>
<li>片偏移 (12 位) 指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。</li>
<li>生存时间 (8 位) 记为 TTL (Time To Live) 数据报在网络中可通过的路由器数的最大值。</li>
<li>协议 (8 位) 字段指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程</li>
<li>首部检验和 (16 位) 字段只检验数据报的首部不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。</li>
<li>源地址和目的地址都各占 4 字节</li>
</ul>
<h3 id="路由"><a class="header" href="#路由">路由</a></h3>
<h4 id="路由算法"><a class="header" href="#路由算法">路由算法</a></h4>
<ul>
<li>
<p>全局的</p>
<ul>
<li>链路状态 (link state) 算法</li>
<li>所有路由器都有完整的拓扑结构和链路成本信息</li>
</ul>
</li>
<li>
<p>分布式的</p>
<ul>
<li>路径向量 (distance vector) 算法</li>
<li>路由器知道有物理连接的邻居，与邻居的链接成本</li>
<li>迭代计算的过程，与邻居交换信息</li>
</ul>
</li>
<li>
<p>静态</p>
<ul>
<li>路径更新缓慢</li>
</ul>
</li>
<li>
<p>动态</p>
<ul>
<li>路径更新更快</li>
<li>定期更新</li>
<li>应对链路变化的成本</li>
</ul>
</li>
</ul>
<h4 id="dijkstra-算法"><a class="header" href="#dijkstra-算法">Dijkstra 算法</a></h4>
<p>算法复杂性：N 个节点</p>
<ul>
<li>每次迭代：需要检查所有的节点，w，不在 N 中的节点 n(n+1)/2 的比较。O(n2)</li>
<li>可能有更有效的实现。O(nlogn)</li>
</ul>
<p>有可能出现震荡：例如，链路成本=承载流量的数量</p>
<h4 id="distance-vector-算法"><a class="header" href="#distance-vector-算法">Distance Vector 算法</a></h4>
<p><code>d(x, y) = min { c(x, v) + d(v, y) }</code></p>
<h4 id="对比-1"><a class="header" href="#对比-1">对比</a></h4>
<p>link state(LS):</p>
<ul>
<li>把距离向量告诉所有人</li>
</ul>
<p>distance vector(DV):</p>
<ul>
<li>把距离向量只告诉邻居</li>
</ul>
<p>实际上都有缺点：</p>
<ul>
<li>这两个算法都只适合规模较小的网络</li>
<li>路由器不一定能执行统一的路由算法</li>
</ul>
<h3 id="分层路由"><a class="header" href="#分层路由">分层路由</a></h3>
<p>引入 AS 自治系统，使用内部外部两套路由算法</p>
<ul>
<li>AS 以内：使用 intra-AS 路由算法</li>
<li>AS 之间：inter-AS 算法</li>
</ul>
<h4 id="intra-as-路由"><a class="header" href="#intra-as-路由">Intra-AS 路由</a></h4>
<p>也称为 (Interior Gateway Protocols) IGP 内部网关协议</p>
<ul>
<li>
<p>RIP</p>
<ul>
<li>distance vector</li>
<li>最远经过 15 个路由器</li>
<li>每 20 秒交换一次路由</li>
<li>适用于小型网络</li>
</ul>
</li>
<li>
<p>OSPF</p>
<ul>
<li>Dij</li>
<li>OSPF 是分层的，具有可扩展性</li>
<li>通告放在 UDP 里</li>
</ul>
</li>
<li>
<p>IGRP</p>
</li>
</ul>
<h4 id="inter-as-路由"><a class="header" href="#inter-as-路由">Inter-AS 路由</a></h4>
<p>(Border Gateway Protocol) BGP 边缘网关协议</p>
<p>通告是路径向量 (Path Vector)，从 AS-a 到 AS-b 的路径向</p>
<p>基于策略路由，方便管理，不是为了找到最优路由</p>
<p>通告放在 TCP 里</p>
<h2 id="链路层"><a class="header" href="#链路层">链路层</a></h2>
<p>链路的类型</p>
<ul>
<li>点对点</li>
<li>广播或共享式链路</li>
<li>交换式</li>
</ul>
<p>问题：</p>
<ol>
<li>
<p>帧</p>
<ul>
<li>把上层的数据组装成帧</li>
</ul>
<p>解决透明传输</p>
<ul>
<li>比特填充</li>
<li>字节</li>
</ul>
</li>
<li>
<p>检错</p>
<p>奇偶校验</p>
<p>CRC: 循环冗余校验</p>
</li>
<li>
<p>可靠传输</p>
</li>
<li>
<p>广播的特有问题</p>
<ul>
<li>多路控制</li>
<li>地址区分</li>
</ul>
</li>
</ol>
<h3 id="多路访问协议-multi-access-protocol"><a class="header" href="#多路访问协议-multi-access-protocol">多路访问协议 (multi access protocol)</a></h3>
<p>接收端同时接受两个以上信号时会发生冲突，多路访问需要解决这个问题</p>
<p>多路访问特点：</p>
<p>解决方法：</p>
<ul>
<li>信道划分 (Channel Partitioning)
<ul>
<li>时分：可能会产生浪费</li>
<li>频分：不够灵活</li>
<li>码分 (CDMA):</li>
</ul>
</li>
<li>随机访问 (Random Access)
<ul>
<li>可能产生冲突</li>
<li>需要从冲突中恢复</li>
</ul>
</li>
<li>轮转 (&quot;Taking turn&quot;)
<ul>
<li>节点多的时候轮转时间会变长</li>
</ul>
</li>
</ul>
<h4 id="随机访问"><a class="header" href="#随机访问">随机访问</a></h4>
<p>如何检错，如何恢复？</p>
<ol>
<li>
<p>ALOHA:</p>
<ul>
<li>有数据就发，有冲突就停止</li>
<li>最大利用率 37%</li>
</ul>
</li>
<li>
<p>Pure ALOHA:</p>
<ul>
<li>最大利用率 18%</li>
</ul>
</li>
<li>
<p>CSMA (载波监听，多点接入):</p>
<ul>
<li>先去监听是否有其他人发数据，没有了再发</li>
</ul>
</li>
<li>
<p>CSMA/CD (Collision detection)</p>
<ul>
<li>带有冲突检测，一边发一边检测</li>
</ul>
</li>
</ol>
<h4 id="轮流访问"><a class="header" href="#轮流访问">轮流访问</a></h4>
<ul>
<li>
<p>轮询 (Polling)</p>
</li>
<li>
<p>令牌传递 (Token passing)</p>
</li>
</ul>
<h3 id="mac-地址"><a class="header" href="#mac-地址">MAC 地址</a></h3>
<p>一般直接写入网卡</p>
<ul>
<li>48 bit</li>
</ul>
<p>广播地址：<code>FF-FF-FF-FF-FF-FF</code></p>
<h3 id="arp-address-resolution-protocol"><a class="header" href="#arp-address-resolution-protocol">ARP (address resolution protocol)</a></h3>
<p>ARP 地址解析协议</p>
<p>通过 ARP 表将 ip 解析为 MAC 地址</p>
<table><thead><tr><th>IP addr</th><th>MAC addr</th><th>TTL</th></tr></thead><tbody>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<p>如何构建 ARP 表？</p>
<ol>
<li>
<p>广播：A 通过广播发送 ARP 请求</p>
</li>
<li>
<p>响应：B 响应时是单播，返回自己的 MAC 地址</p>
</li>
<li>
<p>保存：A 将收到的数据放入自己的 ARP 表</p>
</li>
</ol>
<p>路由器不会改变源 IP 和目的 IP, 目的 MAC 地址则会一直改变</p>
<ol>
<li>发送方是主机，要把 IP 数据报发送到本网络上的另一个 主机。这时用 ARP 找到目的主机的硬件地址。</li>
<li>发送方是主机，要把 IP 数据报发送到另一个网络上的一 个主机。这时用 ARP 找到本网络上的一个路由器的硬件 地址。剩下的工作由这个路由器来完成。</li>
<li>发送方是路由器，要把 IP 数据报转发到本网络上的一个 主机。这时用 ARP 找到目的主机的硬件地址。</li>
<li>发送方是路由器，要把 IP 数据报转发到另一个网络上的 一个主机。这时用 ARP 找到本网络上另一个路由器的硬 件地址。剩下的工作由这个路由器来完成。</li>
</ol>
<h3 id="repeaters-中继器"><a class="header" href="#repeaters-中继器">Repeaters (中继器)</a></h3>
<h3 id="hubs集线器"><a class="header" href="#hubs集线器">Hubs(集线器)</a></h3>
<ul>
<li>和中继器是同一类设备，只不过端口数量更多</li>
<li>集线器会将从一个链路传来的数据转发到所有其他链路</li>
<li>所有连接的链路都会发生冲突</li>
<li>用集线器组成的更大局域网都在一个碰撞域里，所以总吞吐量并未提高</li>
</ul>
<h3 id="bridge网桥"><a class="header" href="#bridge网桥">Bridge(网桥)</a></h3>
<h3 id="switch交换机"><a class="header" href="#switch交换机">Switch(交换机)</a></h3>
<ul>
<li>多端口的网桥</li>
<li>智能化转发，自动学习</li>
</ul>
<p>交换机可以分割冲突域</p>
<p>Switch Table (交换表)</p>
<p>| MAC address of host | interface to reach MAC | time stamp |</p>
<ul>
<li>交换机一定不能成环，否则会产生广播风暴</li>
</ul>
<table><thead><tr><th></th><th>集线器</th><th>交换机</th><th>路由器</th></tr></thead><tbody>
<tr><td>分割冲突域</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>分割广播域</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>即插即用</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>最有路径</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>直通转发</td><td>1</td><td>1</td><td>0</td></tr>
</tbody></table>
<h3 id="vlan"><a class="header" href="#vlan">VLAN</a></h3>
<ul>
<li>虚拟局域网</li>
<li>可以跨交换机</li>
<li>跨 VLAN 的流量都需要经过路由器转发</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lets-dev-a-package-manager"><a class="header" href="#lets-dev-a-package-manager">Let's Dev: A Package Manager</a></h1>
<p>大家好！今天，我们要写一个新的包管理器，甚至比 Yarn 还要好！好吧，也许不是，但至少我们会玩得开心，了解包管理器的工作原理，并思考 Yarn
的下一步可能会发生什么。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分布式系统"><a class="header" href="#分布式系统">分布式系统</a></h1>
<h2 id="优势"><a class="header" href="#优势">优势</a></h2>
<ul>
<li>
<p>通过并行计算增加容量 (parallelism)</p>
</li>
<li>
<p>通过复制容忍故障 (fault tolerance)</p>
</li>
<li>
<p>匹配物理设备的分布 (physical)</p>
</li>
<li>
<p>通过隔离来实现安全 (security / isolated)</p>
<ul>
<li>将安全的和不安全的计算放在不同机器上运行</li>
<li>系统间通过网络进行交互</li>
</ul>
</li>
</ul>
<h2 id="挑战"><a class="header" href="#挑战">挑战</a></h2>
<ul>
<li>
<p>分布式系统有许多部分组成，这些部分是同时运行的，会遇到各种并发编程和复杂交互带来的问题。因此需要某些机制在时间上进行控制（比如超时机制，熔断机制）。</p>
</li>
<li>
<p>多台计算机加网络会使故障原因也更加复杂</p>
</li>
<li>
<p>性能，n 台计算机并不能达到 n 倍的性能</p>
</li>
</ul>
<h2 id="主题"><a class="header" href="#主题">主题</a></h2>
<ol>
<li>
<p>一致性</p>
<p>通用的基础设施需要有明确的行为。例如，&quot;Get(k) 获取最近一次 Put(k,v) 的值&quot;。</p>
<p>实现良好的行为是很难的！ &quot;复制&quot; 的服务器很难保持一致。</p>
</li>
<li>
<p>性能</p>
<p>目标：可扩展的吞吐量</p>
<p>Nx 个服务器，通过并行的 CPU、磁盘、网络实现 Nx 个总吞吐量。随着 N 的增长，扩展会变得更加困难，负载不平衡。有些事情不会随着 N 的增加而加快，例如初始化、交互。</p>
</li>
<li>
<p>权衡</p>
<p>容错性、一致性和性能是敌人。实现容错性和一致性需要通信</p>
<ul>
<li>
<p>发送数据到备份</p>
</li>
<li>
<p>检查数据是否是最新的。</p>
</li>
<li>
<p>通信通常很慢，而且不可扩展</p>
</li>
<li>
<p>许多设计只提供弱的一致性，以获得速度。</p>
<ul>
<li>例如，Get() 并不*产生最新的 Put()! 对于应用程序的程序员来说，这是很痛苦的，但可能是一个很好的权衡。</li>
</ul>
</li>
</ul>
<p>我们会在一致性/性能中看到许多设计点。</p>
</li>
<li>
<p>实现</p>
<p>RPC、线程、并发控制。</p>
</li>
</ol>
<h2 id="lab"><a class="header" href="#lab">Lab</a></h2>
<ul>
<li>
<p>Map-Reduce</p>
</li>
<li>
<p>Raft 解决容错性</p>
</li>
<li>
<p>使用 Raft 构建 K/V server，它可以被复制</p>
</li>
<li>
<p>Sharded K/V server 将有可复制能力的主备 K/V server 克隆到多个组中，并将之前的数据分割存储到这些组中，提高运行速度（每个组只存储自己对应的数据，组合起来就是一整份数据）。同时还要实现在不同的服务期间移动数据，保证不会丢失（数据分片到各个组中，各组的服务器内也会有主从复制）。</p>
</li>
</ul>
<h2 id="map-reduce"><a class="header" href="#map-reduce">Map-Reduce</a></h2>
<p>以一个 word-count 为例，如果集群要对上万的文件进行计算，GFS 会先寻找到文件的所在位置，然后直接在本机的 map-reduce 程序中运行，从而节约了大量的网络传输。</p>
<blockquote>
<p>将按行存储转换为按列存储的过程，在论文中成为 shuffle</p>
</blockquote>
<h3 id="概述-6"><a class="header" href="#概述-6">概述</a></h3>
<p>背景：在多 TB 级数据集上进行多小时的计算，例如，建立搜索索引，或排序，或分析网络的结构，只有在有 1000 台计算机的情况下才实用。</p>
<p>但是应用不是由分布式系统专家编写的，它的总体目标是让非专业的程序员也能轻松使用，对于程序员来说，他只需要定义 Map 和 Reduce 函数 (通常是相当简单的同步代码). MR 管理并隐藏了分布式的所有细节！</p>
<p>一个 MapReduce 作业的抽象视图</p>
<pre><code>输入 1 -&gt; Map -&gt; a,1 b,1
输入 2 -&gt; Map -&gt; b,1
输入 3 -&gt; Map -&gt; a,1 c,1
| | |
| | -&gt; Reduce -&gt; c,1
| -----&gt; Reduce -&gt; b,2
---------&gt; Reduce -&gt; a,2
</code></pre>
<ul>
<li>
<ol>
<li>输入文件（已经）被分成 M 个文件</li>
</ol>
</li>
<li>
<ol start="2">
<li>MR 对每个输入文件调用 Map()，产生一组 k2, v2 的 &quot;中间&quot; 数据，每个 Map() 调用都是一个 &quot;任务&quot;</li>
</ol>
</li>
<li>
<ol start="3">
<li>当地图被 Reduce 时。MR 会收集给定 k2 的所有中间 v2。并将每个键和值传递给一个 Reduce 调用</li>
</ol>
</li>
<li>
<ol start="4">
<li>最终输出是来自 Reduce() 的&lt;k2,v3&gt;对的集合。</li>
</ol>
</li>
</ul>
<p>以 wordcount 为例：</p>
<ul>
<li>Map(k, v) 将 v 分割成单词</li>
<li>对于每个词 w, emit(w, &quot;1&quot;)</li>
<li>Reduce(k, v_set)</li>
<li>emit(len(v_set))</li>
</ul>
<h3 id="mapreduce-系统的优缺点"><a class="header" href="#mapreduce-系统的优缺点">MapReduce 系统的优缺点</a></h3>
<ol>
<li>
<p>MapReduce 的扩展性很好。</p>
<p>N 个 worker 计算机（可能）让你获得 Nx 的吞吐量。Maps() 和 Reduce() 可以并行运行，因为它们不相互影响。因此，更多的计算机可以带来更多的吞吐量！</p>
</li>
<li>
<p>MapReduce 隐藏了很多细节。</p>
<ul>
<li>发送应用代码到服务器</li>
<li>跟踪哪些任务已经完成</li>
<li>将中间数据从 Maps &quot;洗&quot; 到 Reduce 中去</li>
<li>平衡服务器上的负载</li>
<li>从故障中恢复。</li>
</ul>
</li>
<li>
<p>MapReduce 限制了应用程序可以做的事。</p>
<ul>
<li>没有互动或状态 (除了通过中间输出)</li>
<li>没有迭代</li>
<li>没有实时或流式处理</li>
</ul>
</li>
<li>
<p>MapReduce 输入和输出都存储在 GFS 集群文件系统上</p>
<ul>
<li>MR 需要巨大的并行输入和输出的吞吐量。</li>
<li>GFS 将文件分割到许多服务器上，以 64MB 为一个块。
<ul>
<li>Map 并行读取</li>
<li>Reduce 并行写入</li>
</ul>
</li>
<li>GFS 还将每个文件复制到 2 或 3 个服务器上</li>
</ul>
</li>
</ol>
<h3 id="mr-的工作细节"><a class="header" href="#mr-的工作细节">MR 的工作细节</a></h3>
<ol>
<li>
<p>MapReduce 需要一个协调器，将任务分配给 worker 并纪录进度。</p>
<p>协调器将 Map 任务分配给 worker，直到所有的 Map 完成。</p>
<ul>
<li>Map 将输出（或者说中间数据）写到本地磁盘上</li>
<li>Map 通过哈希将输出分割到每个 Reduce 任务的一个文件中。</li>
</ul>
<p>在所有 Map 完成后，协调器将 Reduce 任务分配给 worker</p>
<ul>
<li>每个 Reduce 任务从（所有）Map worker 那里获取其中间输出。</li>
<li>每个 Reduce 任务在 GFS 上写入一个单独的输出文件</li>
</ul>
</li>
<li>
<p>什么可能会限制性能？</p>
<p>CPU、内存、磁盘、网络？在 2004 年，论文作者受到了网络容量的限制。</p>
<p>MR 在网络上发送什么？</p>
<ul>
<li>Map 从 GFS 读取输入。</li>
<li>Reduces 读取 Map 的中间输出。通常和输入一样大，例如用于排序。</li>
<li>Reduces 写输出文件到 GFS。</li>
</ul>
<p>在 MR 的 shuffle 过程中，一半的流量要经过根交换机。</p>
<p>论文的根交换机速度为 100 ~ 200 Gb/s，总共有 1800 台机器，所以每台机器可以分得 55 Gb/s。相比于磁盘或 RAM 的速度小得多。</p>
</li>
<li>
<p>MR 如何尽量减少网络的使用？</p>
<ul>
<li>
<p>协调器试图在存储其输入的 GFS 服务器上原地运行每个 Map 任务。所有的计算机都会同时运行 GFS 和 MR worker, 所以 Map 的输入都会通过 GFS 在本地磁盘读取，而不是网络。</p>
</li>
<li>
<p>中间数据被分割为许多文件，每个文件都存储了许多 key. 文件数量比 key 要少得多，大文件传输的效率要更高</p>
</li>
</ul>
</li>
<li>
<p>MR 如何处理负载均衡？</p>
<p>如果 N-1 个服务器必须等待 1 个慢速服务器完成，则是浪费和缓慢的。但有些任务可能确实比其他任务花的时间更长。</p>
<p>解决方法：比 worker 数量多得多的任务</p>
<ul>
<li>协调器将新的任务分配给完成先前任务的 worker。</li>
<li>因此，没有一个任务大到可以支配完成时间（希望如此）。</li>
<li>因此，快的服务器会比慢的服务器做更多的任务，完成的时间也差不多。</li>
</ul>
</li>
<li>
<p>MR 的容错性如何？</p>
<p>如果一个 worker 在 MP 任务中崩溃了怎么办？
MR 会对程序员隐藏故障。</p>
<p>MR 不必从头开始重新运行整个工作，它只重新运行失败的 Map 和 Reduce。假设 MR 将一个 Map 运行了两次，一个 Reduce 看到了第一次运行的输出。另一个 Reduce 看到了第二次运行的输出？</p>
<p>正确性要求重新执行时产生完全相同的输出。所以 Map 和 Reduce 必须是纯确定性的函数。它们只允许看它们的参数/输入。没有状态，没有文件 I/O，没有交互，没有外部通信。</p>
<p>如果你想允许 non-functional 的 Map 或 Reduce 呢？worker 失败将重新执行整个工作。或者是回滚到某个全局检查点。</p>
</li>
<li>
<p>崩溃恢复的细节</p>
<ul>
<li>
<p>一个 Map worker 崩溃了。</p>
<ul>
<li>协调器注意到 worker 不再响应 ping</li>
<li>协调器知道哪些 Map 任务在该 worker 上运行
<ul>
<li>这些任务的中间输出现在已经丢失，必须重新运行</li>
<li>协调器通知其他 worker 运行这些任务</li>
</ul>
</li>
<li>如果所有的 Reduce 任务都获取了中间数据，可以不重新运行。</li>
</ul>
</li>
<li>
<p>一个 Reduce worker 崩溃了。</p>
<ul>
<li>完成的任务是好的 -- 已经存储在 GFS 中，并且保存有副本。</li>
<li>协调器在其他 worker 上重新启动未完成的任务。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>其他故障/问题。</p>
<ul>
<li>
<p>如果协调者给两个 worker 分配了相同的 Map 任务怎么办？</p>
<p>= 也许协调器错误地认为一个 worker 死了。它将只告诉 Reduce worer 其中一个。</p>
</li>
<li>
<p>如果协调者给了两个 worker 同样的 Reduce() 任务怎么办？</p>
<ul>
<li>他们都会试图在 GFS 上写下同一个输出文件！</li>
<li>GFS 的原子重命名可以防止混合；一个完整的文件将是可见的。</li>
</ul>
</li>
<li>
<p>如果一个 worker 非常慢 --&quot;散兵游勇&quot;，怎么办？</p>
<ul>
<li>也许是硬件它弱。</li>
<li>协调器启动最后几个任务的第二个副本。</li>
</ul>
</li>
<li>
<p>如果一个 worker 由于硬件或软件损坏而计算出不正确的输出，怎么办？</p>
<ul>
<li>太糟糕了！MR 假设 &quot;故障停止&quot; 的 CPU 和软件。</li>
</ul>
</li>
<li>
<p>如果协调器崩溃了怎么办？</p>
</li>
</ul>
</li>
<li>
<p>目前的状况？</p>
<ul>
<li>影响力巨大（Hadoop, Spark, &amp;c）。</li>
<li>可能谷歌已经不使用了。
<ul>
<li>被Flume/FlumeJava取代（见Chambers等人的论文）。</li>
<li>GFS 被 Colossus（没有好的描述）和 BigTable 取代。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>结论</p>
<p>MapReduce 使大集群计算流行起来。</p>
<ul>
<li>不是最有效或最灵活的。</li>
<li>扩展性好。</li>
<li>易于编程</li>
</ul>
<p>这些在实践中是很好的权衡。现在已经有了一些更高级的继承者。</p>
</li>
</ol>
<h3 id="论文细节"><a class="header" href="#论文细节">论文细节</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2022-秋冬季开源操作系统训练营"><a class="header" href="#2022-秋冬季开源操作系统训练营">2022 秋冬季开源操作系统训练营</a></h1>
<h2 id="11-月"><a class="header" href="#11-月">11 月</a></h2>
<h3 id="116---11-26"><a class="header" href="#116---11-26">11.6 - 11-26</a></h3>
<p>RISC-V 手册读完，顺便跟着米老师的课有巩固了一下，感觉比看书理解了更多。</p>
<blockquote>
<p>折腾了新系统，作业，考试，幸亏早看了十几天。刚好赶上了进度。</p>
</blockquote>
<h3 id="116"><a class="header" href="#116">11.6</a></h3>
<p>RISC-V 手册前半部分</p>
<h3 id="112---115"><a class="header" href="#112---115">11.2 - 11.5</a></h3>
<p>RISC-V 黑皮书第二章完成</p>
<h3 id="1028---111"><a class="header" href="#1028---111">10.28 - 11.1</a></h3>
<p>读 RISC-V 手册前两章。计组 2.7, 2.8 晕。</p>
<p>看了关于链接脚本的视频 (没记笔记), 感觉要在看一遍。</p>
<h3 id="1026---1027"><a class="header" href="#1026---1027">10.26 - 10.27</a></h3>
<p>Rust Quiz 完成。</p>
<h3 id="1025"><a class="header" href="#1025">10.25</a></h3>
<p>Rust Quiz 第 20 题。</p>
<p>黑皮书 2.0 - 2.6</p>
<h3 id="1024"><a class="header" href="#1024">10.24</a></h3>
<p>Rust Quiz 第 19 题。</p>
<h3 id="1023"><a class="header" href="#1023">10.23</a></h3>
<p>看了计算机组成与设计：硬件软件接口 RISC-V 版 (黑皮书) 第一章</p>
<p>Rust Quiz 第 10 题。</p>
<h3 id="1022"><a class="header" href="#1022">10.22</a></h3>
<p>今天发现 classroom 的 rust 环境没了，zsh 的 history 也没有保存。不过提交的代码没丢。再次安装环境。</p>
<p>rustlings 做完了，姑且算是个有 Rust 基础的人（笑）。发现 macro 部分不是很熟。</p>
<p>开启 Rust Quiz，今天做了/翻译到第 6 道题，题目很细。</p>
<blockquote>
<p>顺便翻一下，为 RustCN 作贡献？</p>
</blockquote>
<h3 id="1021"><a class="header" href="#1021">10.21</a></h3>
<p>今天开始学习，配置并熟悉了 github classroom 的环境，真不错。</p>
<p>rrustlings 做了二十几个题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编译原理"><a class="header" href="#编译原理">编译原理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="垃圾软件"><a class="header" href="#垃圾软件">垃圾软件</a></h1>
<ul>
<li>数据库连接工具</li>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8">git-credential-helper</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="链接脚本"><a class="header" href="#链接脚本">链接脚本</a></h1>
<h2 id="划分内存"><a class="header" href="#划分内存">划分内存</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库设计"><a class="header" href="#数据库设计">数据库设计</a></h1>
<h2 id="聚合函数"><a class="header" href="#聚合函数">聚合函数</a></h2>
<p>状态</p>
<p>key 优化</p>
<p>开放寻址（没有链表，内存连续，cache 优化，指针跳转少，向量化优化），拉链（key 冲突）</p>
<p>string 短不如不存引用 string 长就不方便</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="draft"><a class="header" href="#draft">draft</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computer_network"><a class="header" href="#computer_network">computer_network</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computer_network-1"><a class="header" href="#computer_network-1">computer_network</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
