<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Blog | Trdthg&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://trdthg.github.io//blog"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="Blog | Trdthg&#x27;s blog"><meta data-rh="true" name="description" content="Blog"><meta data-rh="true" property="og:description" content="Blog"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="icon" href="/img/logo_png.png"><link data-rh="true" rel="canonical" href="https://trdthg.github.io//blog"><link data-rh="true" rel="alternate" href="https://trdthg.github.io//blog" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://trdthg.github.io//blog" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Trdthg&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Trdthg&#39;s blog Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4TM86KZ83J"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-4TM86KZ83J",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.6b28552f.css">
<link rel="preload" href="/assets/js/runtime~main.dd3dbc08.js" as="script">
<link rel="preload" href="/assets/js/main.916d2c7b.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo_png.png" alt="Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo_png.png" alt="Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Trdthg</b></a><a class="navbar__item navbar__link" href="/docs/intro">文档</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/trdthg" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">全部博文</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/01/03/[译] Rust冒险: 滥用 Serde">[译] Rust冒险: 滥用 Serde</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/01/02/[译] 未初始化内存: unsafe Rust太难了">[译] 未初始化内存: unsafe Rust太难了</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/01/01/[译] 拓展 Rust 中的 Map">[译] 拓展 Rust 中的 Map</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/i3wm">Linux 发行版配置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/lsm">数据库存储引擎</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/resources">资源整理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/site_update_log">网站更新日志</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/DistributedSystem">分布式系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/[译] pkg_mng">Let&#x27;s Dev: A Package Manager</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/ld">链接脚本</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/oscamp2022">2022 秋冬季开源操作系统训练营</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/riscv">RISC-V</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/test">垃圾软件</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/数据库设计">数据库设计</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/组成原理">计算机组成原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/计算机网络">计算机网络</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/05/04/[译] 可视化 Rust 各数据类型的内存布局">[译] 可视化 Rust 各数据类型的内存布局</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/30/[译] 什么时候不应该使用 Rust ？">[译] 什么时候不应该使用 Rust ？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/20/[译] 使用 Tokio 处理 CPU 密集型任务">[译] 使用 Tokio 处理 CPU 密集型任务</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/13/[译] tail_latency">对重请求 - 应对尾部延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/11/[译] 异步 Rust：协作与抢占式调度">[译] 异步 Rust：协作与抢占式调度</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/README">Rust 六边形架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 1 域">[译] Rust 六边形架构/Rust 六边形架构 1 域</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 2 内存存储库">[译] Rust 六边形架构/Rust 六边形架构 2 内存存储库</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 3 HTTP API">[译] Rust 六边形架构/Rust 六边形架构 3 HTTP API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 4 重构">[译] Rust 六边形架构/Rust 六边形架构 4 重构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 5 其他用例">[译] Rust 六边形架构/Rust 六边形架构 5 其他用例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 6 CLI">[译] Rust 六边形架构/Rust 六边形架构 6 CLI</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 7 长期存储库">[译] Rust 六边形架构/Rust 六边形架构 7 长期存储库</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/01/[译] search_engine">查询引擎：推送与拉取</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/2023/01/03/[译] Rust冒险: 滥用 Serde">[译] Rust冒险: 滥用 Serde</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-01-03T00:00:00.000Z" itemprop="datePublished">2023年1月3日</time> · <!-- -->阅读需 16 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote><p>原文链接：<a href="https://lucumr.pocoo.org/2021/11/14/abusing-serde/" target="_blank" rel="noopener noreferrer">https://lucumr.pocoo.org/2021/11/14/abusing-serde/</a></p><p><strong>翻译：<a href="https://github.com/trdthg" target="_blank" rel="noopener noreferrer">trdthg</a></strong></p><p>选题：<a href="https://github.com/trdthg" target="_blank" rel="noopener noreferrer">trdthg</a></p><p>本文由 <a href="https://Rustt.org" target="_blank" rel="noopener noreferrer">Rustt</a> 翻译，<a href="https://studyrust.org" target="_blank" rel="noopener noreferrer">StudyRust</a> 荣誉推出</p></blockquote><h1>Rust 冒险：滥用 Serde</h1><p>当你让一个 Rust 程序员指出自己最喜欢的东西时，他们会很快的指出 serde 是一个让工作愉快好帮手。serde 是一个 Rust
的序列化和反序列化框架。它的格式相对独立，可以让你处理 JSON，YAML 以及一系列不同的格式。</p><p>除了上面的之外，还有很多东西可以用 serve 完成。我认为有一些用例相当有趣，值得分享。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="滥用序列化">滥用序列化<a class="hash-link" href="#滥用序列化" title="标题的直接链接">​</a></h2><p><em>Abusing Serialization</em></p><p>其中一个有趣的用例是用 serde 作为某种形式的反射框架，将结构体暴露给其他的不能原生支持 Rust
结构体的环境。在这些情况下，作为一个开发者，你序列化了一个可以被序列化的对象，接着立即以某种稍微不同的格式再次反序列化它。相比于反序列化，我们也可以自定义一个序列化器用来
&#x27;捕获&#x27; 序列化的调用。这是在 IPC，模板引擎上下文、格式转换中常用的模式。</p><p>这在实践中大概是什么样呢？让我们从用户的角度看一下我写的 <a href="https://github.com/mitsuhiko/minijinja" target="_blank" rel="noopener noreferrer">MiniJinja</a>
模板引擎。MiniJinja 使用 serde 作为核心数据模型，将结构化的数据传递给模板，以便它们可以在运行时进行评估。下面是一些给开发者的示例代码：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Serialize, Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    name: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut env = Environment::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    env.add_template(&quot;hello.txt&quot;, &quot;Hello {{ user.name }}!&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let template = env.get_template(&quot;hello.txt&quot;).unwrap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let user = User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        name: &quot;John&quot;.into(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{}&quot;, template.render(context!(user)).unwrap());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如你所见，我们定义了一个叫 User 的结构体，可以使用默认的 Serialize 实现将它序列化。这个对象接着被传递到
<code>context!()</code>。<code>context!()</code> 所做的就是创建了一个 map，然后将一个键设为
user，接着设置为该变量的值。这样做的目的是允许模板引擎访问到 user 的 &#x27;属性&#x27;，例如 name。Rust
不是动态语言，这意味着通常在运行时做这样的事情是不可能的。但是由于 serde 为 User 实现了
Seralize，我们可以这样做。具体的实现大致如下（伪代码）：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Serialize for User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn serialize(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        where S: Serializer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let s = serializer.serialize_struct(&quot;User&quot;, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s.serialize_field(&quot;name&quot;, &amp;self.name)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        s.end()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>正常情况下，serializer 是一个类似于 JSON 序列化器的东西，它可以将结构体写入到一个字符串或者是文件，在这个过程中把它编码为 JSON。但是
serde 提供的接口并不要求用户必须这样。实际上，MiniJinja 直接将结构体编码为一个内存中的结构，模板引擎可以解析它。</p><p>这种模式并不新颖，serde 本身其实也有使用。当你使用 serde 的 flatter 功能时，serde 会启用一个内部缓冲模式，数据会被存储在一个内部的
Context 类型中，Context 类型可以表示 serde 数据模型的全部内容。然后这个 context 可以被传递给另一个序列化器中。</p><p>我不仅在 MiniJinja，同时也在 <a href="https://insta.rs/" target="_blank" rel="noopener noreferrer">insta</a>
（一个快照测试工具）使用到这种模式。为了避免由于非确定性数据导致的测试快照的不稳定性，我首先将其序列化为一种内部的格式，接着在该格式上进行一个再加工，最后再将其序列化为最终的格式（例如
YAML）。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="tls-恶作剧">TLS 恶作剧<a class="hash-link" href="#tls-恶作剧" title="标题的直接链接">​</a></h2><p><em>TLS Shenanigans</em></p><blockquote><p>TLS：Thread Local Storage，Shenanigans：恶作剧</p></blockquote><p>然而，MiniJinja 在此处使用 serde 的有趣之处在于，它允许在序列化和序列化器之间传递不兼容的数据。如前所述，serde
有一个特定的数据模型，不符合该数据模型的东西都会遇到这个问题。例如，serde 可以编码的最大整型是
i128。如果你需要一个任意精度的整型，那就不走运了。但是还是有办法的，你可以使用
<a href="https://en.wikipedia.org/wiki/In-band_signaling" target="_blank" rel="noopener noreferrer">带内信令（in-band signalling）</a>传递额外数据。例如，serde
JSON 序列化器能够表示任意精度整型，因为它在单值对象中保留了一个特殊的键，并用它去指示 JSON 序列化 /
反序列化器组合，决定这个任意精度的整型是否要被序列化。它看起来像这样：</p><div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token property" style="color:#36acaa">&quot;$serde_json::private::Number&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;value&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>但是你应该能发现，如果一个人给出了这样的 JSON 文档，serde JSON 会把它当作任意精度的整形去解析，这意味着 &#x27;value&#x27; 部分本身也需要于
serde 兼容。对于任意精度的整型，这没有问题，因为它可以用字符串表示。但是假如你想在序列化和反序列化中传递的东西根本不能序列化呢？</p><p>这时，巧妙地利用 <strong>thread local</strong> 就是一种变通方法。</p><p>在 MiniJinja 中，运行时值的内部表示是一个叫做 <code>Value</code>
的结构体。正如你所期望的，它可以容纳整型，浮点数，字符串，列表，对象等等。然而，他也可以容纳一些 serde
完全无法解析的类型。特别是它可以保存一种特殊类型的字符串，称为 <code>&#x27;safe&#x27; string</code>, 它是一个存储了安全的 HTML
代码的字符串，不需要转义，也不需要所谓的 &#x27;动态值&#x27;。后者特别有趣，因为它不能被序列化。</p><p>什么是动态值？它实际上是具有状态的对象的句柄，应该直接传递给模板。这里的一个例子是 MiniJinja 中的 loop 变量：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;ul&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{% for item in seq %}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;li&gt;{{ loop.index }}: {{ item }}&lt;/li&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{% endfor %}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/ul&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>MiniJinja（类似于 Jinja2）提供了一个特殊的 loop 变量可以访问循环的状态。例如，你可以通过 <code>loop.index</code>
来获取当前循环的迭代次数。在 MiniJinja 的工作原理中，&#x27;循环控制器&#x27; 本身会被直接传递给模板，并且把值本身当作引用计数存进去。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pub struct LoopState {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    len: AtomicUsize,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    idx: AtomicUsize,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let controller = Rc::new(LoopState {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    idx: AtomicUsize::new(!0usize),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    len: AtomicUsize::new(len),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当循环迭代时，控制器上的索引会 +1。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">controller.idx.fetch_add(1, Ordering::Relaxed);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>控制器本身会被直接添加到上下文中：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let template_side_controller = Value::from_object(controller);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>为了达到这个目的，控制器需要实现 MiniJinja 内部的 <code>Object</code> 特征，下面是一个最小实现：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Object for LoopState {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn attributes(&amp;self) -&gt; &amp;[&amp;str] {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &amp;[&quot;index&quot;, &quot;length&quot;][..]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn get_attr(&amp;self, name: &amp;str) -&gt; Option&lt;Value&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let idx = self.idx.load(Ordering::Relaxed) as u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let len = self.len.load(Ordering::Relaxed) as u64;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match name {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;index&quot; =&gt; Some(Value::from(idx + 1)),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;length&quot; =&gt; Some(Value::from(len)),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _ =&gt; None,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在模板引擎那一边，系统知道当 <code>index</code> 属性被使用时，需要调用 <code>get_attr()</code> 方法。</p><p>到目前为止我们所说的都是理论，serde 究竟是如何做的呢？当 <code>Value::from_object</code> 调用时，传入的值会被 <code>move</code> 到 value
对象里。这样做不需要特殊处理，特别是由于已经使用了引用计数。但是现在的问题是，对于像 <code>LoopState</code> 这样本身没有实现 <code>Serialize</code>
的东西，它的值是如何被序列化的？答案是线程本地存储（thread local storage）和一个合作的（co-operating）序列化和反序列化器。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="越过边界的-state">越过边界的 State<a class="hash-link" href="#越过边界的-state" title="标题的直接链接">​</a></h2><p><em>Out of Bound State</em></p><p>隐藏在 MiniJinja 的 Value 实现有这样一段代码：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const VALUE_HANDLE_MARKER: &amp;str = &quot;\x01__minijinja_ValueHandle&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">thread_local! {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     static INTERNAL_SERIALIZATION: AtomicBool = AtomicBool::new(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     static LAST_VALUE_HANDLE: AtomicUsize = AtomicUsize::new(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     static VALUE_HANDLES: RefCell&lt;BTreeMap&lt;usize, Value&gt;&gt; = RefCell::new(BTreeMap::new());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn in_internal_serialization() -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    INTERNAL_SERIALIZATION.with(|flag| flag.load(atomic::Ordering::Relaxed))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它们的用处是，Value
自身能够感知到什么时候使用内部序列化的特殊形式。这种内部序列化是一种特殊形式的序列化，我们明确知道我们的序列化数据的接收者是一个可以理解该数据的反序列化器。我们没有直接对数据进行序列化，而是将其存入到
TLS 中，然后把数据的句柄序列化到 serde 序列化器中。反序列化器会先反序列化句柄，接着再从 TLS 中提取值。</p><p>因此，我们的循环控制器序列化的实现大致如下：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl Serialize for Value {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        S: Serializer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // enable round tripping of values</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if in_internal_serialization() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            use serde::ser::SerializeStruct;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let handle = LAST_VALUE_HANDLE.with(|x| x.fetch_add(1, atomic::Ordering::Relaxed));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            VALUE_HANDLES.with(|handles| handles.borrow_mut().insert(handle, self.clone()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let mut s = serializer.serialize_struct(VALUE_HANDLE_MARKER, 1)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            s.serialize_field(&quot;handle&quot;, &amp;handle)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return s.end();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ... here follows implementation for serializing to JSON etc.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果它被序列化为 JSON，我们大致能看到这样的东西：</p><div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> </span><span class="token property" style="color:#36acaa">&quot;\u0001__minijinja_ValueHandle&quot;</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而真正的循环控制器将被存储在 <code>VALUE_HANDLES</code> 中句柄为 1 处。现在我们如何从里面的到数值呢？在 MiniJinja
中，反序列化其实从未发生，只有序列化。而且序列化也只是将内存中的对象组装起来。因此，我们只需要让序列化器理解带内信令如何处理，并以此找到带外的值。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl ser::SerializeStruct for SerializeStruct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Ok = Value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    type Error = Error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn serialize_field&lt;T: ?Sized&gt;(&amp;mut self, key: &amp;&#x27;static str, value: &amp;T) -&gt; Result&lt;(), Error&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        T: Serialize,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let value = value.serialize(ValueSerializer)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.fields.insert(key, value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ok(())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn end(self) -&gt; Result&lt;Value, Error&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        match self.name {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            VALUE_HANDLE_MARKER =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                let handle_id = self.fields[&quot;handle&quot;].as_usize();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Ok(VALUE_HANDLES.with(|handles| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    let mut handles = handles.borrow_mut();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    handles</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .remove(&amp;handle_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        .expect(&quot;value handle not in registry&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            _ =&gt; /* regular struct code */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="ser-to-de">Ser-to-De<a class="hash-link" href="#ser-to-de" title="标题的直接链接">​</a></h2><p>上面的例子是你可以滥用的一种方式，但是同样的模式在真实的序列化和反序列化中也可以用到。在 MiniJinja
中，我可以不使用序列化，因为我有效地利用了序列化代码，从一种内存格式转换到另一种内存格式。如果你想在进程间传递数据，情况就会变得棘手一些，实际的序列化就是必要的。例如，你想建立一个
IPC
系统，在进程之间交换数据，这里的挑战是，出于性能的考虑，对于比较大的内存段，你必须使用共享内存，或者是以文件描述符的形式传递打开的文件（因为这些文件有可能是
socket）。在我的实验性 <a href="https://github.com/mitsuhiko/unix-ipc" target="_blank" rel="noopener noreferrer">unix-ipc</a> crate
中，我就是这样做的。</p><p>我在这里建立了一个二级缓冲区，它可以放置文件描述符。同样，这里必须使用 TLS。</p><p>API 大致如下：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pub fn serialize&lt;S: Serialize&gt;(s: S) -&gt; io::Result&lt;(Vec&lt;u8&gt;, Vec&lt;RawFd&gt;)&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut fds = Vec::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut out = Vec::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enter_ipc_mode(|| bincode::serialize_into(&amp;mut out, &amp;s), &amp;mut fds)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map_err(bincode_to_io_error)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Ok((out, fds))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从用户的角度来看，这些都是透明的。当一个 Serailize 实现遇到了一个文件对象时，它可以检查是否应该使用 IPC 的序列化，如果是，它可以把 FD
存起来，<code>enter_ipc_mode</code> 基本上将 fds 绑定到了一个线程局部变量里，接着调用 <code>register_fd</code>
注册它。例如，下面展示了内部句柄的序列化方式：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;F: IntoRawFd&gt; Serialize for Handle&lt;F&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        S: ser::Serializer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if is_ipc_mode() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // effectively a weird version of `into_raw_fd` that does</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // consume</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let fd = self.extract_raw_fd();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let idx = register_fd(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            idx.serialize(serializer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Err(ser::Error::custom(&quot;can only serialize in ipc mode&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>然后是反序列化：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;&#x27;de, F: FromRawFd + IntoRawFd&gt; Deserialize&lt;&#x27;de&gt; for Handle&lt;F&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn deserialize&lt;D&gt;(deserializer: D) -&gt; Result&lt;Handle&lt;F&gt;, D::Error&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        D: de::Deserializer&lt;&#x27;de&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if is_ipc_mode() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let idx = u32::deserialize(deserializer)?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            let fd = lookup_fd(idx).ok_or_else(|| de::Error::custom(&quot;fd not found in mapping&quot;))?;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            unsafe { Ok(Handle(Mutex::new(Some(FromRawFd::from_raw_fd(fd))))) }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Err(de::Error::custom(&quot;can only deserialize in ipc mode&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从用户的角度来看，他只需要通过 IPC channel 传递一个 <code>Handle::new(my_file)</code> 就能实现。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="serde-的现状">Serde 的现状<a class="hash-link" href="#serde-的现状" title="标题的直接链接">​</a></h2><p><em>State of Serde</em></p><p>不幸的是，上面所有的东西都依赖线程本地变量和对内信令。整体上都不是很好，如果有一天出了 serde 2.0，我希望有更好的方法实现上面的内容。</p><p>实际上，现在的 serde 仍然有不少问题和上述的 Hack 行为相关。</p><ul><li><a href="https://github.com/serde-rs/serde/issues/1463" target="_blank" rel="noopener noreferrer">serde requires in-band signalling</a></li><li><a href="https://github.com/serde-rs/serde/issues/1183" target="_blank" rel="noopener noreferrer">Internal buffering disrupts format-specific deserialization features</a></li><li><a href="https://github.com/serde-rs/json/issues/721" target="_blank" rel="noopener noreferrer">serde_json&#x27;s arbitrary precision feature incompatible with flatten</a></li></ul><p>说到这里，在我们需要重写 serde 之前，肯定还有进一步可以被滥用的地方。但是现在是时候应该慢慢考虑 serve
未来版本的设想了它应该对数据模型的支持更友好，可以用更少的 Hack 来脱离规定框架。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/2023/01/02/[译] 未初始化内存: unsafe Rust太难了">[译] 未初始化内存: unsafe Rust太难了</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-01-02T00:00:00.000Z" itemprop="datePublished">2023年1月2日</time> · <!-- -->阅读需 13 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote><p>原文链接：<a href="https://lucumr.pocoo.org/2022/1/30/unsafe-rust/" target="_blank" rel="noopener noreferrer">https://lucumr.pocoo.org/2022/1/30/unsafe-rust/</a></p><p><strong>翻译：<a href="https://github.com/trdthg" target="_blank" rel="noopener noreferrer">trdthg</a></strong></p><p>选题：<a href="https://github.com/trdthg" target="_blank" rel="noopener noreferrer">trdthg</a></p><p>本文由 <a href="https://Rustt.org" target="_blank" rel="noopener noreferrer">Rustt</a> 翻译，<a href="https://studyrust.org" target="_blank" rel="noopener noreferrer">StudyRust</a> 荣誉推出</p></blockquote><h1>未初始化内存：unsafe Rust 太难了</h1><p>Rust
在很多意义上不仅仅是一个现代的系统编程语言，也是一个实用的语言。它承诺了自己的安全性，并且提供了一个完整的框架，使得创建安全的抽象成为可能，同时运行时开销很小甚至为
0。你可以使用 unsafe 来明确的脱离安全的 Rust。</p><p>如果你之前看过这篇文章，你会惊讶的发现，它和之前的版本大不相同。这篇文章的作者是被 unsafe
的规则所困惑的受害者。我在文章中增加了一个例子，用来更好的展示其中的陷阱。我之前在 Twitter 上说过，编写 unsafe Rust 比 C / C++
更困难，所以我想为我的观点作出一些解释。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="从-c-到-rust">从 C 到 Rust<a class="hash-link" href="#从-c-到-rust" title="标题的直接链接">​</a></h2><p>我们从下面的例子开始：我们有一个待初始化的结构体。比较有趣的字段是
<code>name</code>。它是一个指针，指向一个已经分配好的字符串。除此之外，分配到哪里对我们并不重要，因此我们可以将这个结构体自身分配在栈上。我们的想法是，当这个结构体被初始化之后，它就可以被安全的传递和打印。</p><div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">include</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property string" style="color:#e3116c">&lt;stdio.h&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">include</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property string" style="color:#e3116c">&lt;stdlib.h&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">include</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property string" style="color:#e3116c">&lt;stdbool.h&gt;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">role</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">char</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">name</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">bool</span><span class="token plain"> disabled</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> flag</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">main</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">struct</span><span class="token plain"> </span><span class="token class-name">role</span><span class="token plain"> r</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    r</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">name </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">strdup</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;basic&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    r</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">flag </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    r</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">disabled </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token boolean" style="color:#36acaa">false</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">printf</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&quot;%s (%d, %s)\n&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> r</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">name</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> r</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">flag</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> r</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">disabled </span><span class="token operator" style="color:#393A34">?</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;true&quot;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;false&quot;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">free</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">r</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">name</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>接下来我们用 Rust 去实现上面的代码。现在我们并不需要过多的关注 Rust
文档，只需要专注于一对一翻译即可。在你阅读下面的代码之前还有一点要注意：我们正在有意的创建一个对 Rust 程序员更熟悉的对象，并且可以被看作公共
API。所以我们在这里直接使用 String，而不是 C 语言的字符串。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::mem;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Role {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    name: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    disabled: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flag: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let role = unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut role: Role = mem::zeroed();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        role.name = &quot;basic&quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        role.flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        role.disabled = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        role</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{} ({}, {})&quot;, role.name, role.flag, role.disabled);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>看到这里，立即就有人想问，这里为什么需要
unsafe？当然了，你的确不需要。但是这段代码使用了一个函数：<code>std::mem::zeroed</code>。如果你尝试在最近的 Rust
编译器运行，应该会的得到这个错误：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">thread &#x27;main&#x27; panicked at &#x27;attempted to zero-initialize type `Role`,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  which is invalid&#x27;, src/main.rs:11:30</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>老版本的编译器能够正常运行，但是那其实也是错误的。怎么解决呢？编译器又一次告诉我们解决之法：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">warning: the type `Role` does not permit zero-initialization</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; src/main.rs:11:30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 | let mut role: Role = mem::zeroed();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |                      ^^^^^^^^^^^^^</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |                      |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |                      this code causes undefined behavior when executed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |                      help: use `MaybeUninit&lt;T&gt;` instead, and only call</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |                         `assume_init` after initialization is done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>为什么 <code>Role</code> 类型不支持使用 0 初始化呢？我们需要改动那些代码？我们能不能不初始化？</p><p>有人可能会想，使用 <code>#[repr(C)]</code> 强制结构体使用 C 语言的内存布局，但是这不能解决问题。正如编译器给出的建议，我们需要
<code>MaybeUninit</code>。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::mem::MaybeUninit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Role {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    name: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    disabled: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flag: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let role = unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut uninit = MaybeUninit::&lt;Role&gt;::zeroed();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let role = uninit.as_mut_ptr();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (*role).name = &quot;basic&quot;.to_string();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (*role).flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (*role).disabled = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        uninit.assume_init()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{} ({}, {})&quot;, role.name, role.flag, role.disabled);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>将 <code>zeroed</code> 换为 <code>MaybeUninit::zeroed</code> 之后，一切都变了。现在我们不能直接使用结构体，而是要操作一个裸指针。由于裸指针没有实现
<code>deref</code>，并且 Rust 中没有 <code>-&gt;</code> 操作符，我们需要手动解引用，并用这种笨拙的语法分配每一个字段。</p><p>首先：这样做可行吗？答案是肯定的。但是它正确吗？不正确。</p><p>答案在于，任何像可变引用（&amp;mut）或者是栈上的值本身这样的构造，在 unsafe 代码之外仍然需要一直处于有效的状态。<code>zeroed</code> 返回一个值为 0
的结构，我们不能保证它可以有效的表示结构体或者任何其中的字段。在我们的例子中，我们的字符串在所有内容被清零的情况下是有效的，但是这并不能保证，而且是未定义行为。</p><p>需要注意的一点是，一个可变引用永远不能指向一个无效的对象，所以在对象的所有字段都被初始化之前，下面的操作是错误的：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let role = &amp;mut *uninit.as_mut_ptr()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>所以，让我们把 <code>zeroed</code> 改为 <code>uninit</code>。如果我们再次运行，程序就会崩溃。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// let mut uninit = MaybeUninit::&lt;Role&gt;::uninit();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">free(): invalid pointer</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>为什么会崩溃呢？答案是，通过给 name 赋值一个新的字符串，我们也 drop 了之前的旧字符串。我们之前只是碰巧没有遇到这种情况，因为 Drop
碰巧能够处理一个被清零的字符串。但现在，我们深入了未定义行为。我们如何解决这个问题呢？我们需要以某种方式直接将字符串写到那里的指针。</p><p>我们首先要接受 MaybeUninit 是必要的，现在我们要处理这里的裸指针。这有些麻烦，但是看起来不是特别难。现在我们有两个新问题：我们知道 <code>&amp;mut X</code>
是不允许的，但是 <code>*mut X</code> 是允许的。我们如何在不使用 <code>&amp;mut X</code> 的情况下得到一个 <code>*mut X</code>? 讽刺的是，在 Rust 1.51
之前，再不打破任何规则之前，这是不可能的，但是现在，你可以使用 <code>addr_of_mut!</code> 宏。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let name_ptr = std::ptr::addr_of_mut!((*role).name);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>太棒了，现在我们拿到了 name 的指针，如何写入呢？我们可以使用 <code>write</code> 方法。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">addr_of_mut!((*role).name).write(&quot;basic&quot;.to_string());</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>现在完成了吗？还记得我们是如何使用普通结构体的吗？如果阅读一下文档，你就会发现，结构体的内存布局没有任何保证。事实表明，<a href="https://github.com/rust-lang/reference/issues/1151" target="_blank" rel="noopener noreferrer">尽管目前的文档是这样说的</a>，但是我们可以依靠字段的对齐性。如果我们处理的是
<code>#[repr(packed)]</code>，我们就必须使用 <code>write_unaligned</code> 方法来代替。如果 Rust
选择的结构体的一个成员是不对齐的，这是合法的。</p><p>最终的代码：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::mem::MaybeUninit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::ptr::addr_of_mut;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct Role {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    name: String,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    disabled: bool,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flag: u32,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let role = unsafe {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let mut uninit = MaybeUninit::&lt;Role&gt;::uninit();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        let role = uninit.as_mut_ptr();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        addr_of_mut!((*role).name).write(&quot;basic&quot;.to_string());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (*role).flag = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        (*role).disabled = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        uninit.assume_init()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;{} ({}, {})&quot;, role.name, role.flag, role.disabled);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="什么时候用-addr_of_mut">什么时候用 <code>addr_of_mut!</code><a class="hash-link" href="#什么时候用-addr_of_mut" title="标题的直接链接">​</a></h2><p>一般有两种情况：未初始化的内存，未对齐的引用。Rust
不允许用户创建一个未对齐的引用（即时只是暂时的），同时也不允许创建一个对未初始化内存的引用。那么，这些引用是什么时候被创建的呢？</p><p>对于下面的代码：<code>(*flag).flag = 1</code>，根据 Rust 的规则，如果一个类型没有实现 Drop，这是可以的。如果该类型实现了
Drop，这行代码会产生很多问题：当 <code>Drop::drop</code> 被调用时，并且调用在未初始化的内存上，这时我们就需要
<code>addr_of_mut!</code>。这就是为什么我们可以直接为 flag 字段赋值，但是我们却需要通过 <code>addr_of_mut!</code> 来获取 name
字段，因为它是一个字符串。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="maybeuninit">MaybeUninit<a class="hash-link" href="#maybeuninit" title="标题的直接链接">​</a></h2><p>对安全的理解随着时间的推移而不断改变。曾经，<code>mem::uninitialized</code> 被认为是一个健全的 API，但是在后来，<code>MaybeUninit</code>
被引入去解决发现的缺点。但是，由于部分初始化的类型的存在，MaybeUninit 在实践中并不理想。虽然由于 <code>#[repr(transparent)]</code>，
MaybeUninit 和 T 是内存兼容的，但是在嵌套使用时的效果并不佳。</p><p>有时你需要结构体的某个字段上有一个 MaybeUninit，但是只后你又希望这个抽象不存在，这种情况并不罕见。实际上，在实践中使用 MaybeUninit
是一个充满挑战的体验，但是这篇文章并没有体现出来。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="我的-unsafe-代码正确吗">我的 unsafe 代码正确吗？<a class="hash-link" href="#我的-unsafe-代码正确吗" title="标题的直接链接">​</a></h2><p>在 2022 年，我承认，我不再对编写 Rust 代码感到自信。unsafe 的规则可能可能都是如此复杂，但是从我多年来阅读过的 unsafe 代码来说，大多数
unsafe 代码都不太关心这些规则，并且无视了它们。<code>addr_of_mut!</code>直到 1.53 才被添加到语言中是有原因的。即使到了今天，文档中都说它
Rust 结构体 repr 的对齐方式没有任何保证。</p><p>在过去的几年里，似乎发生了这样的事情：Rust 开发者在实践中编写 unsafe
越来越困难，现在的规则是如此复杂，以至于对一个随意的程序员来说非常难以理解，围绕他的文档也很容易被曲解。我在这篇文章的<a href="https://github.com/mitsuhiko/lucumr/blob/48440d3cf151f0d774bc9ad62f903034ca2b30ff/2022/1/30/unsafe-rust.rst" target="_blank" rel="noopener noreferrer">上一个版本</a>中认为
<code>addr_of_mut!</code> 的一些使用是必要的，但实际上并非如此。在有人指出这个错误之前，文章已经得到了大量关注。</p><p>这些规则使得 Rust 最好的功能之一越来越难以接近，同时也越来越难以理解。要求存在 MaybeUninit，而不仅仅是过去的
mem::uninitialized API 是显而易见的，但是却展示了语言规则是多么的复杂。</p><p>我不认为这是好的。事实上，我认为这根本不是一个好的趋势，好像越来越少的人了解 unsafe Rust。与 C 的互操作性是让 Rust
伟大的一个原因，但是我们现在正在创建巨大的屏障，这是不可取的。更重要的是：编译器在指出我的错误时没有什么帮助。</p><p>让 unsafe 变得更符合人体工程学是一个困难的问题，但是它值得被解决。因为有一点很明确：人们不会很快停止编写 unsafe 代码。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/2023/01/01/[译] 拓展 Rust 中的 Map">[译] 拓展 Rust 中的 Map</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2023-01-01T00:00:00.000Z" itemprop="datePublished">2023年1月1日</time> · <!-- -->阅读需 13 分钟</div></header><div class="markdown" itemprop="articleBody"><blockquote><p>原文链接：<a href="https://lucumr.pocoo.org/2022/1/6/rust-extension-map/" target="_blank" rel="noopener noreferrer">https://lucumr.pocoo.org/2022/1/6/rust-extension-map/</a></p><p><strong>翻译：<a href="https://github.com/trdthg" target="_blank" rel="noopener noreferrer">trdthg</a></strong></p><p>选题：<a href="https://github.com/trdthg" target="_blank" rel="noopener noreferrer">trdthg</a></p><p>本文由 <a href="https://Rustt.org" target="_blank" rel="noopener noreferrer">Rustt</a> 翻译，<a href="https://studyrust.org" target="_blank" rel="noopener noreferrer">StudyRust</a> 荣誉推出</p></blockquote><h1>拓展 Rust 中的 Map</h1><p>在 Rust 中，如果你想为用户提供一个灵活的 API，一般可以引入泛型参数。以一个 web
框架为例，它可能需要一个程序类型，并且需要传递给很多函数。这个程序类型需要能够以配置的形式被参数化。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="引入-any-特征">引入 Any 特征<a class="hash-link" href="#引入-any-特征" title="标题的直接链接">​</a></h2><p>一个解决方法是使用 <code>Any</code> 特征。它需要一个 <code>&#x27;static</code> 的生命周期，当你之后使用它时，还需要用 <code>Box</code>
进行装箱。比如我们可能对它进行向下转型，即转换为原始的类型。这意味着你可以在某个地方（比如我们的 App）中存储和获取任意类型。</p><p>我们期望的 API 大致如下：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let app = App::new();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// place in extension map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.extensions().insert(Config { ... });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.extensions().insert(Database { ... });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// retrieve from extension map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let config = app.extensions().get::&lt;Config&gt;();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们的 app 需要容纳其他拓展的类型，以便之后使用。</p><p>现在，让我们试试最简单的实现方式：准备一个 <code>Extensions</code> 对象，让它实现插入和获取的方法。如果一个拓展还不存在，我们就自动插入一个默认的（需要实现
<code>Default</code> 特征）。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::collections::HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::any::{Any, TypeId};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Default)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Extensions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map: HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Extensions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn insert&lt;T: &#x27;static&gt;(&amp;mut self, value: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.map.insert(TypeId::of::&lt;T&gt;(), Box::new(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn get&lt;T: &#x27;static&gt;(&amp;self) -&gt; &amp;T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.map.get(&amp;TypeId::of::&lt;T&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .and_then(|b| b.downcast_ref())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn get_mut&lt;T: Default + &#x27;static&gt;(&amp;mut self) -&gt; &amp;mut T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.ensure::&lt;T&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.map.get_mut(&amp;TypeId::of::&lt;T&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .and_then(|b| b.downcast_mut())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn ensure&lt;T: Default + &#x27;static&gt;(&amp;mut self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.map.get(&amp;TypeId::of::&lt;T&gt;()).is_none() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.insert(T::default());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上面的代码非常直接，但是存在两个问题：首先，只有 <code>get_mut</code> 能够调用 <code>ensure</code> 去插入默认值，如果有人直接调用 <code>get</code> 就会导致
panic。第二个问题是，借用检查器会让之后的编写非常困难。上面的 map 对于解决经典的问题（例如 app）是很有用的，你只需要配置一次，自那之后 map
就像是被冻结了一样，因为有太多的引用在飞来分飞去，以至于没有人能够得到 <code>&amp;mut</code> 的引用。</p><p>how does it work？</p><p>上面的代码是如何做到的呢，Rust 中的每一种类型都会有一个 type ID，你可以使用 <code>TypeId::of::&lt;T&gt;()</code>
获取。他是唯一的，你可以用它进行比较，或者是作为 map 的键来使用。每种类型只允许有一个值。接着我们把 T 作为 <code>dyn Any</code> 存储在 map
里，<code>Any</code> 特征允许我们使用 <code>downcast_ref</code> 和 <code>downcast_mut</code> 方法拿到原始类型。由于我们使用了 ensure
方法确保这里的类型存在，因此可以安全的 unwrap。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="内部可变性">内部可变性<a class="hash-link" href="#内部可变性" title="标题的直接链接">​</a></h2><p>让我们看一个 web 框架或者是模板引擎的常见案例。以
<a href="https://github.com/mitsuhiko/minijinja" target="_blank" rel="noopener noreferrer">MiniJinja</a>（模板引擎）为例，它里面有一个 State
对象，每次模板初始化时都会创建一次，State 没有实现 Send 和 Sync，MiniJinja 在评估时需要 State。如果你想让用户能够放入自定义的
State 呢？在这种情况下，我们可以通过在内部使用 <code>RefCell</code> 来调整上面的类型。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::collections::HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::any::{Any, TypeId};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::cell::{Ref, RefCell, RefMut};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Default)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Extensions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map: RefCell&lt;HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Extensions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn insert&lt;T: &#x27;static&gt;(&amp;self, value: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.map.borrow_mut().insert(TypeId::of::&lt;T&gt;(), Box::new(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn get&lt;T: Default + &#x27;static&gt;(&amp;self) -&gt; Ref&lt;&#x27;_, T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.ensure::&lt;T&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ref::map(self.map.borrow(), |m| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            m.get(&amp;TypeId::of::&lt;T&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .and_then(|b| b.downcast_ref())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn get_mut&lt;T: Default + &#x27;static&gt;(&amp;self) -&gt; RefMut&lt;&#x27;_, T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.ensure::&lt;T&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RefMut::map(self.map.borrow_mut(), |m| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            m.get_mut(&amp;TypeId::of::&lt;T&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .and_then(|b| b.downcast_mut())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn ensure&lt;T: Default + &#x27;static&gt;(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.map.borrow().get(&amp;TypeId::of::&lt;T&gt;()).is_none() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.insert(T::default());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从用户的角度来看，几乎没有变化。主要的区别是你不需要一个可变引用就能调用 <code>get_mut</code>，这一壮举是由 <code>RefCell</code> 实现的，Refcell
能够将检查移动到运行时。当一个 <code>RefMut</code> 被给出时，如果已经存在任何的可变或不可变引用，就会发生
panic。对于这里的用户来说，这并不是一个很大的问题，因为我们可以很容易地确保只有一个可变的引用在使用。特别棒的是，Ref 和 RefMut
类型提供了一个静态的 map 方法，让你可以轻松派生出另一个 Ref 或 RefMut，并保持原来的引用，但对值进行转换。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="同步支持">同步支持<a class="hash-link" href="#同步支持" title="标题的直接链接">​</a></h2><p>如果我们想要用 Send 和 Sync 来实现和上面相同的效果呢？我们需要一个锁。可惜的是标准库提供的 Mutex 和 RwLock 不能让你在拿到锁的同时
map，你可以使用 <code>parking_lot</code> 替代，它实现了必要的一些方法。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use parking_lot::{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MappedRwLockReadGuard,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MappedRwLockWriteGuard,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RwLock,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RwLockReadGuard,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RwLockWriteGuard,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::any::{Any, TypeId};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::collections::HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Default)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Extensions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map: RwLock&lt;HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Extensions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn insert&lt;T: Send + Sync + &#x27;static&gt;(&amp;self, value: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.map.write().insert(TypeId::of::&lt;T&gt;(), Box::new(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn get&lt;T: Send + Sync + Default + &#x27;static&gt;(&amp;self) -&gt; MappedRwLockReadGuard&lt;&#x27;_, T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.ensure::&lt;T&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RwLockReadGuard::map(self.map.read(), |m| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            m.get(&amp;TypeId::of::&lt;T&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .and_then(|b| b.downcast_ref())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn get_mut&lt;T: Send + Sync + Default + &#x27;static&gt;(&amp;self) -&gt; MappedRwLockWriteGuard&lt;&#x27;_, T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.ensure::&lt;T&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RwLockWriteGuard::map(self.map.write(), |m| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            m.get_mut(&amp;TypeId::of::&lt;T&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .and_then(|b| b.downcast_mut())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn ensure&lt;T: Default + Send + Sync + &#x27;static&gt;(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.map.read().get(&amp;TypeId::of::&lt;T&gt;()).is_none() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.insert(T::default());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意：由于 Any 并没有实现 Debug，所以我们很难为我们的 map 实现 Debug 特征，一些简单的改变并不能解决目前的问题。下半部分我们将介绍
<code>as-any</code> 模式</p><p>我们面临的挑战是，在 Rust 里，你不能使用 <code>Box&lt;Any + Debug&gt;</code>，然而还是有一些方法解决这个问题。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="为-map-实现-debug">为 map 实现 Debug<a class="hash-link" href="#为-map-实现-debug" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="简化问题">简化问题<a class="hash-link" href="#简化问题" title="标题的直接链接">​</a></h3><p>我们的目标是对 <code>Box&lt;dyn Any&gt;</code> 做一个包装，并让 Wrapper 实现 Debug。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct AnyBox(Box&lt;dyn Any + Debug&gt;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果你尝试编译，编译器应该会很不高兴的抛出错误：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error[E0225]: only auto traits can be used as additional traits in a trait object</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> --&gt; src/main.rs:9:29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">9 | struct AnyBox(Box&lt;dyn Any + Debug&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |                       ---   ^^^^^ additional non-auto trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |                       |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |                       first non-auto trait</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  = help: consider creating a new trait with all of these as supertraits and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    using that trait here instead: `trait NewTrait: Any + Debug {}`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="超级特征">超级特征<a class="hash-link" href="#超级特征" title="标题的直接链接">​</a></h3><p>幸运的是，编译器再次为我们指明了解决之道，我们需要创建一个父特征，并利用特征约束。同时，我们为所有实现了 Any 和 Debug
的类型实现我们的超级特征。就像下面这样：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct AnyBox(Box&lt;dyn DebugAny&gt;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait DebugAny: Any + Debug {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: Any + Debug + &#x27;static&gt; DebugAny for T {}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>你可以想这样构建一个 Box，但是真正不能通过编译的是向下转型</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let any_box = AnyBox(Box::new(42i32));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dbg!(any_box.0.downcast_ref::&lt;i32&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>编译器会告诉我们，AnyBox 中的值并没有 <code>downcast_ref</code> 方法</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">error[E0599]: no method named `downcast_ref` found for struct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  `Box&lt;(dyn DebugAny + &#x27;static)&gt;` in the current scope</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --&gt; src/main.rs:15:20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 |     dbg!(any_box.0.downcast_ref::&lt;i32&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   |                    ^^^^^^^^^^^^ method not found in `Box&lt;(dyn DebugAny + &#x27;static)&gt;`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>原因是 <code>Box&lt;dyn DebugAny&gt;</code> 并不是 <code>Box&lt;dyn Any&gt;</code>，因此我们不能那里得到 Any
特征拥有的方法。那么我们如何解决这个问题呢？最简单的方法是 <strong>&quot;as any&quot;</strong> 模式，我们在我们的 DebugAny
特征上实现一个方法，将其向上转换为一个 Any。看起来像这样：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">trait DebugAny: Any + Debug {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any(&amp;self) -&gt; &amp;dyn Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: Any + Debug + &#x27;static&gt; DebugAny for T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any(&amp;self) -&gt; &amp;dyn Any { self }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any { self }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>现在虽然我们依然不能在 DebugAny 上调用 <code>downcast_ref</code>，但是我们可以拿走它的值，并调用 <code>as_any</code> 得到一个
<code>&amp;dyn Any</code>：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let any_box = AnyBox(Box::new(42i32));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dbg!(any_box.0.as_any().downcast_ref::&lt;i32&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dbg!(&amp;any_box);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>但是当我们运行后，却得到了一个 None。发生什么事了？？？</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[src/main.rs:23] any_box.0.as_any().downcast_ref::&lt;i32&gt;() = None</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个谜题的答案与方法解析的工作方式和空白实现有关。当我们在 <code>Box&lt;dyn DebugAny&gt;</code> 上调用 <code>as_any</code> 时，Box
并没有发生自动解引用，事实上调用的是 <code>Box&lt;dyn DebugAny&gt;</code> 的 as_any，因为 Box 现在也实现了我们的
DebugAny。那么，我们如何穿过这个 Box 呢？通过手动解引用。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let any_box = AnyBox(Box::new(42i32));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dbg!((*any_box.0).as_any().downcast_ref::&lt;i32&gt;());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dbg!(&amp;any_box);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这样就是我们预期的值了</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[src/main.rs:23] (*any_box.0).as_any().downcast_ref::&lt;i32&gt;() = Some(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    42,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[src/main.rs:24] &amp;any_box = AnyBox(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    42,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="可调试的-extension-map">可调试的 Extension Map<a class="hash-link" href="#可调试的-extension-map" title="标题的直接链接">​</a></h2><p>有了上面的经验，我们现在可以拿出之前的非同步 map，稍加改造就能为其实现 Debug。</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::any::{Any, TypeId};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::cell::{Ref, RefCell, RefMut};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::collections::HashMap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::fmt::Debug;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">trait DebugAny: Any + Debug {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any(&amp;self) -&gt; &amp;dyn Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl&lt;T: Any + Debug + &#x27;static&gt; DebugAny for T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any(&amp;self) -&gt; &amp;dyn Any { self }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any { self }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[derive(Default, Debug)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct Extensions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map: RefCell&lt;HashMap&lt;TypeId, Box&lt;dyn DebugAny&gt;&gt;&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Extensions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn insert&lt;T: Debug + &#x27;static&gt;(&amp;self, value: T) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .borrow_mut()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            .insert(TypeId::of::&lt;T&gt;(), Box::new(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn get&lt;T: Default + Debug + &#x27;static&gt;(&amp;self) -&gt; Ref&lt;&#x27;_, T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.ensure::&lt;T&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Ref::map(self.map.borrow(), |m| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            m.get(&amp;TypeId::of::&lt;T&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .and_then(|b| (**b).as_any().downcast_ref())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn get_mut&lt;T: Default + Debug + &#x27;static&gt;(&amp;self) -&gt; RefMut&lt;&#x27;_, T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.ensure::&lt;T&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        RefMut::map(self.map.borrow_mut(), |m| {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            m.get_mut(&amp;TypeId::of::&lt;T&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .and_then(|b| (**b).as_any_mut().downcast_mut())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .unwrap()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn ensure&lt;T: Default + Debug + &#x27;static&gt;(&amp;self) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if self.map.borrow().get(&amp;TypeId::of::&lt;T&gt;()).is_none() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            self.insert(T::default());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>向 map 里面添加点东西，打印一下：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[src/main.rs:63] &amp;extensions = Extensions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map: RefCell {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TypeId {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                t: 13431306602944299956,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }: 42,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这个例子中，我在 map 中放置了一个 32 位的整数 42，它打印出了作为键的 TypeId，和作为值的 42。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="保留类型名称">保留类型名称<a class="hash-link" href="#保留类型名称" title="标题的直接链接">​</a></h2><p>如果你想保留原来的类型名称，而不仅仅是类型的 ID，我们可以使用一个自定义的类型作为 map 的键。通过对 TypeId 和 TypeName
做一次简单的包装就能轻松实现：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">use std::any::{TypeId, type_name};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::hash::{Hash, Hasher};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">use std::fmt::{self, Debug};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pub struct TypeKey(TypeId, &amp;&#x27;static str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl TypeKey {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pub fn of&lt;T: &#x27;static&gt;() -&gt; TypeKey {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        TypeKey(TypeId::of::&lt;T&gt;(), type_name::&lt;T&gt;())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Hash for TypeKey {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.0.hash(state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl PartialEq for TypeKey {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn eq(&amp;self, other: &amp;Self) -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self.0 == other.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Eq for TypeKey {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">impl Debug for TypeKey {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        write!(f, &quot;{}&quot;, self.1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>接着用它替换掉原来的键，调试一下：</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[src/main.rs:90] &amp;extensions = Extensions {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map: RefCell {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        value: {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            i32: 42,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            alloc::vec::Vec&lt;i32&gt;: [</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                3,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意，我在 map 中额外插入了一个 <code>Vec&lt;i32&gt;</code>，以获得更明显的输出。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/i3wm">Linux 发行版配置</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-10T10:40:08.000Z" itemprop="datePublished">2022年11月10日</time> · <!-- -->阅读需 3 分钟</div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="i3wm">i3wm<a class="hash-link" href="#i3wm" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="多屏幕">多屏幕<a class="hash-link" href="#多屏幕" title="标题的直接链接">​</a></h3><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">xrandr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xrandr --output DP-1 --auto --right-of eDP-1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="manjaro">manjaro<a class="hash-link" href="#manjaro" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="cpu-调频">cpu 调频<a class="hash-link" href="#cpu-调频" title="标题的直接链接">​</a></h3><ol><li>查看当前所有 CPU 的信息：</li></ol><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cpupower -c all frequency-info</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="2"><li>设置所有 CPU 为性能模式：</li></ol><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cpupower -c all frequency-set -g performance</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><p>performance: 固定最高运行频率上，不动态调节。</p></li><li><p>powersave: 固定工作在其支持的最低运行频率上</p></li><li><p>ondemand: 按需快速动态调整 CPU 频率，一有 cpu 计算量的任务，就会立即达到最大频率运行，等执行完毕就立即回到最低频率；</p></li><li><p>conservative:
与 ondemand 不同，平滑地调整 CPU 频率，频率的升降是渐变式的，会自动在频率上下限调整，和 ondemand 的区别在于它会按需分配频率，而不是一味追求最高频率；</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="自动挂载">自动挂载<a class="hash-link" href="#自动挂载" title="标题的直接链接">​</a></h3><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># 100mb 虚拟硬盘</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">mount</span><span class="token plain"> tmpfs </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> /home/trdthg/tmp/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tmpfs /home/trdthg/tmp tmpfs </span><span class="token assign-left variable" style="color:#36acaa">size</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">96m </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 1.查看电脑中所有硬盘的分区情况。</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 命令如下：</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># sudo fdisk -l</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 2.结果如下</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># /dev/nvme0n1p3    567296  210282495 209715200   100G Microsoft 基本数据</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># /dev/nvme0n1p4 210282496  872337407 662054912 315.7G Microsoft 基本数据</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#auto mount windows fs</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/nvme0n1p3 /mnt/C ntfs </span><span class="token assign-left variable" style="color:#36acaa">nls</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">utf8,umask</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">000   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/dev/nvme0n1p4 /mnt/D ntfs </span><span class="token assign-left variable" style="color:#36acaa">nls</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">utf8,umask</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">000   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain">   </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 注： 末尾的 2 行是添加的内容。其中/dev/nvme0n1p3 一行代表 C 盘分区将自动挂载到/mnt/C 目录下，文件系统为 NTFS（如果步骤 1 中查看分 区的文件系统为 FAT32 时，此处请写 vfat），字符编码为 utf8。umask 表示文件目录的权限，此参数以及之后的 2 个参数都为 0 即可。以下几行以 此类推。此处可以选择性的添加需要自动挂载的分区，不想挂载的分区不用书写。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="openssh-serversshd-启动">openssh-server(sshd) 启动<a class="hash-link" href="#openssh-serversshd-启动" title="标题的直接链接">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="openssh">OpenSSH<a class="hash-link" href="#openssh" title="标题的直接链接">​</a></h3><p>OpenSSH 可以支撑 Manjaro 成为 SSH Server，以便其他主机可以通过 SSH 连接到 Manjaro。</p><div class="language-shell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-shell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># 安装 OpenSSH</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">sudo</span><span class="token plain"> pacman -S openssh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 开机自启 sshd 服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">sudo</span><span class="token plain"> systemctl </span><span class="token builtin class-name">enable</span><span class="token plain"> sshd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 启动 sshd 服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">sudo</span><span class="token plain"> systemctl start sshd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 重启 sshd 服务</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">sudo</span><span class="token plain"> systemctl restart sshd</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="gamepad">gamepad<a class="hash-link" href="#gamepad" title="标题的直接链接">​</a></h2><p>驱动下载：xboxdrv</p><p>蓝牙：</p><div class="language-txt codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-txt codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">bluetoothctl pair &lt;mac_addr&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bluetoothctl connect &lt;mac_addr&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bluetoothctl remove &lt;mac_addr&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bluetoothctl trust &lt;mac_addr&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><a href="https://zhongguo.eskere.club/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8bluetoothctl%E5%9C%A8linux%E4%B8%8A%E7%AE%A1%E7%90%86%E8%93%9D%E7%89%99%E8%AE%BE%E5%A4%87/2021-05-16/" target="_blank" rel="noopener noreferrer">如何使用 bluetoothctl 在 Linux 上管理蓝牙设备</a></p><p>测试：</p><p><a href="https://www.shumeijiang.com/2021/08/04/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%92%8C%E6%89%8B%E6%9F%84-%E8%93%9D%E7%89%99%E8%BF%9E%E6%8E%A5.html" target="_blank" rel="noopener noreferrer">树莓派和手柄 - 蓝牙连接</a></p><p>资料：</p><p><a href="https://www.makeuseof.com/tag/get-game-controllers-running-linux/" target="_blank" rel="noopener noreferrer">How to Set Up and Use Game Controllers on Linux</a>
<a href="https://wiki.archlinux.org/title/Gamepad" target="_blank" rel="noopener noreferrer">Arch-Wiki Gamepad</a>
<a href="https://help.wooting.io/en/article/guide-configuring-xinput-support-for-linux-69m32u/" target="_blank" rel="noopener noreferrer">Guide – Configuring XInput support for Linux</a></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/lsm">数据库存储引擎</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-10T10:40:08.000Z" itemprop="datePublished">2022年11月10日</time> · <!-- -->阅读需 9 分钟</div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="bitcast">Bitcast<a class="hash-link" href="#bitcast" title="标题的直接链接">​</a></h2><ul><li>日志型</li><li>基于 hash 表</li></ul><ol><li>只支持追加
Bitcast 仅支持追加操作（Append-only），即所有的写操作只追加而不修改老的数据。</li><li>多版本文件<ul><li>每个文件有一定的大小限制，当文件增加到相应的大小时，就会产生一个新的文件，老的文件只读不写。</li><li>在任意时刻，只有一个文件是可写的，用于数据追加，称为活跃数据文件（active data file）。而其他已经达到大小限制的文件，称为老数据文件（older data file）。</li></ul></li><li>日志文件<ul><li>Bitcast 数据文件中的数据是一条一条的 &quot;操作&quot;, 所有的操作都会序列化到日志文件里 (包括删除).</li><li>写入时首先将 Key-Value 记录追加到活跃数据文件的末尾，接着更新内存哈希表，因此，每个写操作总共需要进行一次顺序的磁盘写入和一次内存操作。</li></ul></li><li>日志压缩<ul><li>Bitcask 需要定期执行合并（Compaction）操作以实现垃圾回收。</li><li>合并操作，即将所有老数据文件中的数据扫描一遍并生成新的数据文件，同一个 key 的多个操作以只保留最新一个的原则进行删除，每次合并后，新生成的数据文件就不再有冗余数据了。</li></ul></li><li>hash 索引<ul><li>哈希索引存储在内存中，如果不做额外的工作，服务器断电重启重建哈希表需要扫描一遍数据文件</li><li>如果数据文件很大，这是一个非常耗时的过程。可以通过索引文件（hint file）来提高重建哈希表的速度。</li></ul></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="lsm">LSM<a class="hash-link" href="#lsm" title="标题的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="核心思想">核心思想<a class="hash-link" href="#核心思想" title="标题的直接链接">​</a></h3><p><strong>放弃部分读能力，换取写入的最大化能力</strong></p><p>先可以将更新的数据驻留在内存中，等到积累足够多之后，再使用归并排序的方式将内存内的数据合并追加到磁盘中。</p><p>LSM-tree 的主要思想是划分不同等级的树。</p><ul><li>以两级树为例，可以想象一份索引数据由两棵树组成，一棵树存在于内存，一棵树存在于磁盘。</li><li>内存中的树可以不一定是 B 树，可以是其他的树，例如 AVL 树。因为数据大小是不同的，没必要牺牲 CPU 来达到最小的树高度，而存在于磁盘的树则是一棵 B 树。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="写入过程">写入过程<a class="hash-link" href="#写入过程" title="标题的直接链接">​</a></h3><ul><li><p>在 LSM 树中，写入数据时首先会插入到内存的树中。</p></li><li><p>当内存中的树的数据超过一定阈值时，会进行合并操作。合并操作会顺序遍历内存中的树的叶子节点，并与磁盘中的树的叶子节点进行合并</p><ul><li>当被合并的数据量达到磁盘的存储页的大小时，会将数据持久化到磁盘，同时更新父亲节点对叶子节点的指针。</li></ul></li><li><p>LSM 树可以划分成很多层级的树</p><ul><li>第 0 层存储在内存，第 1 到 k 层存储在磁盘，每层的数据都是有序的。</li><li>数据首先会插入到第 0 层，然后后台逐层合并。</li><li>每一层的数据超过一定阈值时，往下一层合并。</li><li>读取叶由于不知道数据在哪一层上，可能需要遍历所有的层。</li></ul></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="level-db">Level DB<a class="hash-link" href="#level-db" title="标题的直接链接">​</a></h3><p>LevelDB 存储引擎主要包括：</p><ul><li>内存中的 MemTable 和不可变 MemTable（也称为 Frozen MemTable）</li><li>磁盘上的几种主要文件：<ul><li>当前（Current）文件</li><li>清单（Manifest）文件</li><li>操作日志（Commit Log，也称为提交日志）文件</li><li>SSTable 文件</li></ul></li></ul><p>写入过程：</p><ul><li>当应用写入一条记录时，LevelDB 会首先将修改操作写入到操作日志文件，成功后再将修改操作应用到 MemTable，这样就完成了写入操作。</li><li>当 MemTable 占用的内存达到一个上限值后，需要将内存的数据转储到外存文件中。</li><li>LevelDB 会将原先的 MemTable 冻结成为不可变 MemTable，并生成一个新 MemTable。新到来的数据被记入新的操作日志文件和新生成的 MemTable 中。</li><li>不可变 MemTable 的内容是不可更改的，只能读取不能写入或者删除。LevelDB 后台线程会将不可变 MemTable 的数据排序后转储到磁盘，形成一个新的 SSTable 文件，这个操作称为 Compaction。</li><li>SSTable 文件是内存中的数据不断进行 Compaction 操作后形成的，且 SSTable 的所有文件是一种层级结构，第 0 层为 Level 0，第 1 层为 Level 1，以此类推。</li></ul><blockquote><p>SSTable: SSTable是一个键是有序的，存储字符串形式键值对的文件。它是一个内部包含了任意长度、排好序的键值对集合的文件。SSTable文件由两部分数据组成：索引和键值对数据。所有的key和value都是紧凑地存放在一起的，如果要读取某个键对应的值，需要通过索引中的key:offset来定位。SSTable在序列化成文件之后，是不可变的，因为此时的SSTable,就类似于一个数组一样，如果插入或者删除，需要移动一大片数据，开销比较大。</p></blockquote><p>加快访问效率：</p><ul><li>LSM 树写入效率很高，但读取可能需要访问较多的磁盘文件，效率较低。为了加快读取效率，工程实现上一般使用 Bloom Filter 来加快读取效率。它使用很小的存储空间换来较大的读取效率提升。</li></ul><p>Bloom Filter 是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。</p><ul><li>Bloom Filter 的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter 不适合那些“零错误”的应用场合。</li><li>而在能容忍低错误率的应用场合下，Bloom Filter 通过极少的错误换取了存储空间的极大节省。</li></ul><blockquote><p>初始状态时，Bloom Filter 是一个包含 m 位的位数组，每一位都置为 0。为了表达 S={x1, x2,…,xn}这样一个 n 个元素的集合，Bloom Filter 使用 k 个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到{1,…,m}的范围中。对任意一个元素 x，第 i 个哈希函数映射的位置 hi(x) 就会被置为 1（1≤i≤k）。注意，如果一个位置多次被置为 1，那么只有第一次会起作用，后面几次将没有任何效果。在判断 y 是否属于这个集合时，我们对 y 应用 k 次哈希函数，如果所有 hi(y) 的位置都是 1（1≤i≤k），那么我们就认为 y 是集合中的元素，否则就认为 y 不是集合中的元素。</p></blockquote></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/resources">资源整理</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-10T10:40:08.000Z" itemprop="datePublished">2022年11月10日</time> · <!-- -->阅读需 1 分钟</div></header><div class="markdown" itemprop="articleBody"><ul><li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener noreferrer">Leaf——美团点评分布式 ID 生成系统</a></li></ul></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/site_update_log">网站更新日志</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-10T10:40:08.000Z" itemprop="datePublished">2022年11月10日</time> · <!-- -->阅读需 1 分钟</div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="v3-docusaurus">v3 Docusaurus<a class="hash-link" href="#v3-docusaurus" title="标题的直接链接">​</a></h2><p>2022.10.21 从 vuepress2 迁移到 Docusaurus</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="v2-vuepress3">v2 vuepress3<a class="hash-link" href="#v2-vuepress3" title="标题的直接链接">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="v1-vuepress1">v1 vuepress1<a class="hash-link" href="#v1-vuepress1" title="标题的直接链接">​</a></h2><p>基于 typora 处理图片</p><div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># rm -rf docs/.vuepress/dist</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd vuePressBlog</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 生成静态文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pnpm run build</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># 图片源修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rm docs/.vuepress/public/assets/img/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cp /home/trthg/.config/Typora/typora-user-images/* docs/.vuepress/public/assets/img/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># md 引用图片路径修改</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sed -i &quot;s/\/home\/trthg\/.config\/Typora\/typora-user-images/\/assets\/img/g&quot; `grep -rl &quot;/assets/img&quot; ./`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># # /* 会忽略。开头的文件   /. 不会</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rm -r ../assets</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rm -r ../java</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rm -r ../other</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rm -r ../js</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rm -r ../python</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rm -r ../rust</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rm -r ../ioclub</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rm -r ../magic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rm ../*.html</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># rm ../*.png</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># rm ../*.jpg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mv docs/.vuepress/dist/* ../</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">curDate=$(date &quot;+%Y-%m-%d&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">curTime=$(date &quot;+%H:%M:%S&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># # git init</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd ..</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git add .</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git commit -s -m &quot;commit: $curDate $curTime&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git push -u origin main</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/draft/DistributedSystem">分布式系统</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-10T10:40:08.000Z" itemprop="datePublished">2022年11月10日</time> · <!-- -->阅读需 13 分钟</div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="优势">优势<a class="hash-link" href="#优势" title="标题的直接链接">​</a></h2><ul><li><p>通过并行计算增加容量 (parallelism)</p></li><li><p>通过复制容忍故障 (fault tolerance)</p></li><li><p>匹配物理设备的分布 (physical)</p></li><li><p>通过隔离来实现安全 (security / isolated)</p><ul><li>将安全的和不安全的计算放在不同机器上运行</li><li>系统间通过网络进行交互</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="挑战">挑战<a class="hash-link" href="#挑战" title="标题的直接链接">​</a></h2><ul><li><p>分布式系统有许多部分组成，这些部分是同时运行的，会遇到各种并发编程和复杂交互带来的问题。因此需要某些机制在时间上进行控制（比如超时机制，熔断机制）。</p></li><li><p>多台计算机加网络会使故障原因也更加复杂</p></li><li><p>性能，n 台计算机并不能达到 n 倍的性能</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="主题">主题<a class="hash-link" href="#主题" title="标题的直接链接">​</a></h2><ol><li><p>一致性</p><p>通用的基础设施需要有明确的行为。例如，&quot;Get(k) 获取最近一次 Put(k,v) 的值&quot;。</p><p>实现良好的行为是很难的！ &quot;复制&quot; 的服务器很难保持一致。</p></li><li><p>性能</p><p>目标：可扩展的吞吐量</p><p>Nx 个服务器，通过并行的 CPU、磁盘、网络实现 Nx 个总吞吐量。随着 N 的增长，扩展会变得更加困难，负载不平衡。有些事情不会随着 N 的增加而加快，例如初始化、交互。</p></li><li><p>权衡</p><p>容错性、一致性和性能是敌人。实现容错性和一致性需要通信</p><ul><li><p>发送数据到备份</p></li><li><p>检查数据是否是最新的。</p></li><li><p>通信通常很慢，而且不可扩展</p></li><li><p>许多设计只提供弱的一致性，以获得速度。</p><ul><li>例如，Get() 并不*产生最新的 Put()! 对于应用程序的程序员来说，这是很痛苦的，但可能是一个很好的权衡。</li></ul></li></ul><p>我们会在一致性/性能中看到许多设计点。</p></li><li><p>实现</p><p>RPC、线程、并发控制。</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="lab">Lab<a class="hash-link" href="#lab" title="标题的直接链接">​</a></h2><ul><li><p>Map-Reduce</p></li><li><p>Raft 解决容错性</p></li><li><p>使用 Raft 构建 K/V server，它可以被复制</p></li><li><p>Sharded K/V server 将有可复制能力的主备 K/V server 克隆到多个组中，并将之前的数据分割存储到这些组中，提高运行速度（每个组只存储自己对应的数据，组合起来就是一整份数据）。同时还要实现在不同的服务期间移动数据，保证不会丢失（数据分片到各个组中，各组的服务器内也会有主从复制）。</p></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="map-reduce">Map-Reduce<a class="hash-link" href="#map-reduce" title="标题的直接链接">​</a></h2><p>以一个 word-count 为例，如果集群要对上万的文件进行计算，GFS 会先寻找到文件的所在位置，然后直接在本机的 map-reduce 程序中运行，从而节约了大量的网络传输。</p><blockquote><p>将按行存储转换为按列存储的过程，在论文中成为 shuffle</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="概述">概述<a class="hash-link" href="#概述" title="标题的直接链接">​</a></h3><p>背景：在多 TB 级数据集上进行多小时的计算，例如，建立搜索索引，或排序，或分析网络的结构，只有在有 1000 台计算机的情况下才实用。</p><p>但是应用不是由分布式系统专家编写的，它的总体目标是让非专业的程序员也能轻松使用，对于程序员来说，他只需要定义 Map 和 Reduce 函数 (通常是相当简单的同步代码). MR 管理并隐藏了分布式的所有细节！</p><p>一个 MapReduce 作业的抽象视图</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">输入 1 -&gt; Map -&gt; a,1 b,1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入 2 -&gt; Map -&gt; b,1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">输入 3 -&gt; Map -&gt; a,1 c,1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| | |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| | -&gt; Reduce -&gt; c,1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">| -----&gt; Reduce -&gt; b,2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------&gt; Reduce -&gt; a,2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>1) 输入文件（已经）被分成 M 个文件</li><li>2) MR 对每个输入文件调用 Map()，产生一组 k2, v2 的 &quot;中间&quot; 数据，每个 Map() 调用都是一个 &quot;任务&quot;</li><li>3) 当地图被 Reduce 时。MR 会收集给定 k2 的所有中间 v2。并将每个键和值传递给一个 Reduce 调用</li><li>4) 最终输出是来自 Reduce() 的&lt;k2,v3&gt;对的集合。</li></ul><p>以 wordcount 为例：</p><ul><li>Map(k, v) 将 v 分割成单词</li><li>对于每个词 w, emit(w, &quot;1&quot;)</li><li>Reduce(k, v_set)</li><li>emit(len(v_set))</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mapreduce-系统的优缺点">MapReduce 系统的优缺点<a class="hash-link" href="#mapreduce-系统的优缺点" title="标题的直接链接">​</a></h3><ol><li><p>MapReduce 的扩展性很好。</p><p>N 个 worker 计算机（可能）让你获得 Nx 的吞吐量。Maps() 和 Reduce() 可以并行运行，因为它们不相互影响。因此，更多的计算机可以带来更多的吞吐量！</p></li><li><p>MapReduce 隐藏了很多细节。</p><ul><li>发送应用代码到服务器</li><li>跟踪哪些任务已经完成</li><li>将中间数据从 Maps &quot;洗&quot; 到 Reduce 中去</li><li>平衡服务器上的负载</li><li>从故障中恢复。</li></ul></li><li><p>MapReduce 限制了应用程序可以做的事。</p><ul><li>没有互动或状态 (除了通过中间输出)</li><li>没有迭代</li><li>没有实时或流式处理</li></ul></li><li><p>MapReduce 输入和输出都存储在 GFS 集群文件系统上</p><ul><li>MR 需要巨大的并行输入和输出的吞吐量。</li><li>GFS 将文件分割到许多服务器上，以 64MB 为一个块。<ul><li>Map 并行读取</li><li>Reduce 并行写入</li></ul></li><li>GFS 还将每个文件复制到 2 或 3 个服务器上</li></ul></li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="mr-的工作细节">MR 的工作细节。<a class="hash-link" href="#mr-的工作细节" title="标题的直接链接">​</a></h3><ol><li><p>MapReduce 需要一个协调器，将任务分配给 worker 并纪录进度。</p><p>协调器将 Map 任务分配给 worker，直到所有的 Map 完成。</p><ul><li>Map 将输出（或者说中间数据）写到本地磁盘上</li><li>Map 通过哈希将输出分割到每个 Reduce 任务的一个文件中。</li></ul><p>在所有 Map 完成后，协调器将 Reduce 任务分配给 worker</p><ul><li>每个 Reduce 任务从（所有）Map worker 那里获取其中间输出。</li><li>每个 Reduce 任务在 GFS 上写入一个单独的输出文件</li></ul></li><li><p>什么可能会限制性能？</p><p>CPU、内存、磁盘、网络？在 2004 年，论文作者受到了网络容量的限制。</p><p>MR 在网络上发送什么？</p><ul><li>Map 从 GFS 读取输入。</li><li>Reduces 读取 Map 的中间输出。通常和输入一样大，例如用于排序。</li><li>Reduces 写输出文件到 GFS。</li></ul><p>在 MR 的 shuffle 过程中，一半的流量要经过根交换机。</p><p>论文的根交换机速度为 100 ~ 200 Gb/s，总共有 1800 台机器，所以每台机器可以分得 55 Gb/s。相比于磁盘或 RAM 的速度小得多。</p></li><li><p>MR 如何尽量减少网络的使用？</p><ul><li><p>协调器试图在存储其输入的 GFS 服务器上原地运行每个 Map 任务。所有的计算机都会同时运行 GFS 和 MR worker, 所以 Map 的输入都会通过 GFS 在本地磁盘读取，而不是网络。</p></li><li><p>中间数据被分割为许多文件，每个文件都存储了许多 key. 文件数量比 key 要少得多，大文件传输的效率要更高</p></li></ul></li><li><p>MR 如何处理负载均衡？</p><p>如果 N-1 个服务器必须等待 1 个慢速服务器完成，则是浪费和缓慢的。但有些任务可能确实比其他任务花的时间更长。</p><p>解决方法：比 worker 数量多得多的任务</p><ul><li>协调器将新的任务分配给完成先前任务的 worker。</li><li>因此，没有一个任务大到可以支配完成时间（希望如此）。</li><li>因此，快的服务器会比慢的服务器做更多的任务，完成的时间也差不多。</li></ul></li><li><p>MR 的容错性如何？</p><p>如果一个 worker 在 MP 任务中崩溃了怎么办？
MR 会对程序员隐藏故障。</p><p>MR 不必从头开始重新运行整个工作，它只重新运行失败的 Map 和 Reduce。假设 MR 将一个 Map 运行了两次，一个 Reduce 看到了第一次运行的输出。另一个 Reduce 看到了第二次运行的输出？</p><p>正确性要求重新执行时产生完全相同的输出。所以 Map 和 Reduce 必须是纯确定性的函数。它们只允许看它们的参数/输入。没有状态，没有文件 I/O，没有交互，没有外部通信。</p><p>如果你想允许 non-functional 的 Map 或 Reduce 呢？worker 失败将重新执行整个工作。或者是回滚到某个全局检查点。</p></li><li><p>崩溃恢复的细节</p><ul><li><p>一个 Map worker 崩溃了。</p><ul><li>协调器注意到 worker 不再响应 ping</li><li>协调器知道哪些 Map 任务在该 worker 上运行<ul><li>这些任务的中间输出现在已经丢失，必须重新运行</li><li>协调器通知其他 worker 运行这些任务</li></ul></li><li>如果所有的 Reduce 任务都获取了中间数据，可以不重新运行。</li></ul></li><li><p>一个 Reduce worker 崩溃了。</p><ul><li>完成的任务是好的 -- 已经存储在 GFS 中，并且保存有副本。</li><li>协调器在其他 worker 上重新启动未完成的任务。</li></ul></li></ul></li><li><p>其他故障/问题。</p><ul><li><p>如果协调者给两个 worker 分配了相同的 Map 任务怎么办？</p><p>  = 也许协调器错误地认为一个 worker 死了。它将只告诉 Reduce worer 其中一个。</p></li><li><p>如果协调者给了两个 worker 同样的 Reduce() 任务怎么办？</p><ul><li>他们都会试图在 GFS 上写下同一个输出文件！</li><li>GFS 的原子重命名可以防止混合；一个完整的文件将是可见的。</li></ul></li><li><p>如果一个 worker 非常慢 --&quot;散兵游勇&quot;，怎么办？</p><ul><li>也许是硬件它弱。</li><li>协调器启动最后几个任务的第二个副本。</li></ul></li><li><p>如果一个 worker 由于硬件或软件损坏而计算出不正确的输出，怎么办？</p><ul><li>太糟糕了！MR 假设 &quot;故障停止&quot; 的 CPU 和软件。</li></ul></li><li><p>如果协调器崩溃了怎么办？</p></li></ul></li><li><p>目前的状况？</p><ul><li>影响力巨大（Hadoop, Spark, &amp;c）。</li><li>可能谷歌已经不使用了。<ul><li>被Flume/FlumeJava取代（见Chambers等人的论文）。</li><li>GFS 被 Colossus（没有好的描述）和 BigTable 取代。</li></ul></li></ul></li><li><p>结论</p><p>MapReduce 使大集群计算流行起来。</p><ul><li>不是最有效或最灵活的。</li></ul><ul><li>扩展性好。</li><li>易于编程 -- 失败和数据移动被隐藏。</li></ul><p>这些在实践中是很好的权衡。现在已经有了一些更高级的继承者。</p></li></ol></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/draft/[译] pkg_mng">Let&#x27;s Dev: A Package Manager</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-10T10:40:08.000Z" itemprop="datePublished">2022年11月10日</time> · <!-- -->阅读需 1 分钟</div></header><div class="markdown" itemprop="articleBody"><p>大家好！今天，我们要写一个新的包管理器，甚至比 Yarn 还要好！好吧，也许不是，但至少我们会玩得开心，了解包管理器的工作原理，并思考 Yarn
的下一步可能会发生什么。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="title_f1Hy" itemprop="headline"><a itemprop="url" href="/blog/draft/ld">链接脚本</a></h2><div class="container_mt6G margin-vert--md"><time datetime="2022-11-10T10:40:08.000Z" itemprop="datePublished">2022年11月10日</time> · <!-- -->阅读需 1 分钟</div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="划分内存">划分内存<a class="hash-link" href="#划分内存" title="标题的直接链接">​</a></h2></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/2"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div></div>
<script src="/assets/js/runtime~main.dd3dbc08.js"></script>
<script src="/assets/js/main.916d2c7b.js"></script>
</body>
</html>