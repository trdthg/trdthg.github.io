<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>sourceread - Trdthg&#x27;s Self</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../../favicon.svg">
                        <link rel="shortcut icon" href="../../favicon.png">
                <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
                <link rel="stylesheet" href="../../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">trans</li><li class="chapter-item expanded "><a href="../../trans/2022-04-20-译-使用-Tokio-处理-CPU-密集型任务.html"><strong aria-hidden="true">1.</strong> 2022-04-20-译-使用-Tokio-处理-CPU-密集型任务</a></li><li class="chapter-item expanded "><a href="../../trans/2023-01-03-译-Rust冒险:-滥用-Serde.html"><strong aria-hidden="true">2.</strong> 2023-01-03-译-Rust冒险:-滥用-Serde</a></li><li class="chapter-item expanded "><a href="../../trans/2023-01-01-译-拓展-Rust-中的-Map.html"><strong aria-hidden="true">3.</strong> 2023-01-01-译-拓展-Rust-中的-Map</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-01-译-search_engine.html"><strong aria-hidden="true">4.</strong> 2022-04-01-译-search_engine</a></li><li class="chapter-item expanded "><a href="../../trans/2022-05-04-译-可视化-Rust-各数据类型的内存布局.html"><strong aria-hidden="true">5.</strong> 2022-05-04-译-可视化-Rust-各数据类型的内存布局</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-13-译-tail_latency.html"><strong aria-hidden="true">6.</strong> 2022-04-13-译-tail_latency</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-30-译-什么时候不应该使用-Rust-？.html"><strong aria-hidden="true">7.</strong> 2022-04-30-译-什么时候不应该使用-Rust-？</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-11-译-异步-Rust：协作与抢占式调度.html"><strong aria-hidden="true">8.</strong> 2022-04-11-译-异步-Rust：协作与抢占式调度</a></li><li class="chapter-item expanded "><a href="../../trans/2023-01-02-译-未初始化内存:-unsafe-Rust太难了.html"><strong aria-hidden="true">9.</strong> 2023-01-02-译-未初始化内存:-unsafe-Rust太难了</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/index.html"><strong aria-hidden="true">10.</strong> 2022-04-03-译-Rust-六边形架构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-4-重构.html"><strong aria-hidden="true">10.1.</strong> Rust-六边形架构-4-重构</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-2-内存存储库.html"><strong aria-hidden="true">10.2.</strong> Rust-六边形架构-2-内存存储库</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-7-长期存储库.html"><strong aria-hidden="true">10.3.</strong> Rust-六边形架构-7-长期存储库</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-1-域.html"><strong aria-hidden="true">10.4.</strong> Rust-六边形架构-1-域</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-5-其他用例.html"><strong aria-hidden="true">10.5.</strong> Rust-六边形架构-5-其他用例</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-6-CLI.html"><strong aria-hidden="true">10.6.</strong> Rust-六边形架构-6-CLI</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/Rust-六边形架构-3-HTTP-API.html"><strong aria-hidden="true">10.7.</strong> Rust-六边形架构-3-HTTP-API</a></li><li class="chapter-item expanded "><a href="../../trans/2022-04-03-译-Rust-六边形架构/index.html"><strong aria-hidden="true">10.8.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">note</li><li class="chapter-item expanded "><a href="../../note/java/index.html"><strong aria-hidden="true">11.</strong> java</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../note/java/java.html"><strong aria-hidden="true">11.1.</strong> java</a></li><li class="chapter-item expanded "><a href="../../note/java/springboot.html"><strong aria-hidden="true">11.2.</strong> springboot</a></li><li class="chapter-item expanded "><a href="../../note/java/spring.html"><strong aria-hidden="true">11.3.</strong> spring</a></li><li class="chapter-item expanded "><a href="../../note/java/sourceread.html" class="active"><strong aria-hidden="true">11.4.</strong> sourceread</a></li><li class="chapter-item expanded "><a href="../../note/java/index.html"><strong aria-hidden="true">11.5.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="../../note/frontend/index.html"><strong aria-hidden="true">12.</strong> frontend</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../note/frontend/mini_bundle.html"><strong aria-hidden="true">12.1.</strong> mini_bundle</a></li><li class="chapter-item expanded "><a href="../../note/frontend/js_advanced.html"><strong aria-hidden="true">12.2.</strong> js_advanced</a></li><li class="chapter-item expanded "><a href="../../note/frontend/mini_vue.html"><strong aria-hidden="true">12.3.</strong> mini_vue</a></li><li class="chapter-item expanded "><a href="../../note/frontend/vue.html"><strong aria-hidden="true">12.4.</strong> vue</a></li><li class="chapter-item expanded "><a href="../../note/frontend/list.html"><strong aria-hidden="true">12.5.</strong> list</a></li><li class="chapter-item expanded "><a href="../../note/frontend/http.html"><strong aria-hidden="true">12.6.</strong> http</a></li><li class="chapter-item expanded "><a href="../../note/frontend/flutter.html"><strong aria-hidden="true">12.7.</strong> flutter</a></li><li class="chapter-item expanded "><a href="../../note/frontend/css.html"><strong aria-hidden="true">12.8.</strong> css</a></li><li class="chapter-item expanded "><a href="../../note/frontend/vdom.html"><strong aria-hidden="true">12.9.</strong> vdom</a></li><li class="chapter-item expanded "><a href="../../note/frontend/index.html"><strong aria-hidden="true">12.10.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">blog</li><li class="chapter-item expanded "><a href="../../blog/index.html"><strong aria-hidden="true">13.</strong> README</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">docs</li><li class="chapter-item expanded "><a href="../../docs/log.html"><strong aria-hidden="true">14.</strong> log</a></li><li class="chapter-item expanded "><a href="../../docs/intro.html"><strong aria-hidden="true">15.</strong> intro</a></li><li class="chapter-item expanded "><a href="../../docs/magic/index.html"><strong aria-hidden="true">16.</strong> magic</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../docs/magic/riscv.html"><strong aria-hidden="true">16.1.</strong> riscv</a></li><li class="chapter-item expanded "><a href="../../docs/magic/haskell.html"><strong aria-hidden="true">16.2.</strong> haskell</a></li><li class="chapter-item expanded "><a href="../../docs/magic/bash.html"><strong aria-hidden="true">16.3.</strong> bash</a></li><li class="chapter-item expanded "><a href="../../docs/magic/memory_ordering.html"><strong aria-hidden="true">16.4.</strong> memory_ordering</a></li><li class="chapter-item expanded "><a href="../../docs/magic/linuxIO.html"><strong aria-hidden="true">16.5.</strong> linuxIO</a></li><li class="chapter-item expanded "><a href="../../docs/magic/cicd.html"><strong aria-hidden="true">16.6.</strong> cicd</a></li><li class="chapter-item expanded "><a href="../../docs/magic/fd.html"><strong aria-hidden="true">16.7.</strong> fd</a></li><li class="chapter-item expanded "><a href="../../docs/magic/hadoop.html"><strong aria-hidden="true">16.8.</strong> hadoop</a></li><li class="chapter-item expanded "><a href="../../docs/magic/go.html"><strong aria-hidden="true">16.9.</strong> go</a></li><li class="chapter-item expanded "><a href="../../docs/magic/async.html"><strong aria-hidden="true">16.10.</strong> async</a></li><li class="chapter-item expanded "><a href="../../docs/magic/index.html"><strong aria-hidden="true">16.11.</strong> README</a></li><li class="chapter-item expanded "><a href="../../docs/magic/software_arch.html"><strong aria-hidden="true">16.12.</strong> software_arch</a></li></ol></li><li class="chapter-item expanded "><a href="../../docs/riscv/index.html"><strong aria-hidden="true">17.</strong> riscv</a></li><li class="chapter-item expanded "><a href="../../docs/common/index.html"><strong aria-hidden="true">18.</strong> common</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../docs/common/pgsql.html"><strong aria-hidden="true">18.1.</strong> pgsql</a></li><li class="chapter-item expanded "><a href="../../docs/common/git.html"><strong aria-hidden="true">18.2.</strong> git</a></li><li class="chapter-item expanded "><a href="../../docs/common/linux.html"><strong aria-hidden="true">18.3.</strong> linux</a></li><li class="chapter-item expanded "><a href="../../docs/common/datastructure.html"><strong aria-hidden="true">18.4.</strong> datastructure</a></li><li class="chapter-item expanded "><a href="../../docs/common/docker.html"><strong aria-hidden="true">18.5.</strong> docker</a></li><li class="chapter-item expanded "><a href="../../docs/common/analyze.html"><strong aria-hidden="true">18.6.</strong> analyze</a></li><li class="chapter-item expanded "><a href="../../docs/common/oci.html"><strong aria-hidden="true">18.7.</strong> oci</a></li><li class="chapter-item expanded "><a href="../../docs/common/unsorted.html"><strong aria-hidden="true">18.8.</strong> unsorted</a></li><li class="chapter-item expanded "><a href="../../docs/common/oauth2.html"><strong aria-hidden="true">18.9.</strong> oauth2</a></li><li class="chapter-item expanded "><a href="../../docs/common/vim.html"><strong aria-hidden="true">18.10.</strong> vim</a></li><li class="chapter-item expanded "><a href="../../docs/common/python.html"><strong aria-hidden="true">18.11.</strong> python</a></li><li class="chapter-item expanded "><a href="../../docs/common/index.html"><strong aria-hidden="true">18.12.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="../../docs/rust/index.html"><strong aria-hidden="true">19.</strong> rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../docs/rust/mini_tokio.html"><strong aria-hidden="true">19.1.</strong> mini_tokio</a></li><li class="chapter-item expanded "><a href="../../docs/rust/wasm.html"><strong aria-hidden="true">19.2.</strong> wasm</a></li><li class="chapter-item expanded "><a href="../../docs/rust/rust_quiz.html"><strong aria-hidden="true">19.3.</strong> rust_quiz</a></li><li class="chapter-item expanded "><a href="../../docs/rust/rust.html"><strong aria-hidden="true">19.4.</strong> rust</a></li><li class="chapter-item expanded "><a href="../../docs/rust/print_into_detail.html"><strong aria-hidden="true">19.5.</strong> print_into_detail</a></li><li class="chapter-item expanded "><a href="../../docs/rust/net-piercer.html"><strong aria-hidden="true">19.6.</strong> net-piercer</a></li><li class="chapter-item expanded "><a href="../../docs/rust/rs_channel.html"><strong aria-hidden="true">19.7.</strong> rs_channel</a></li><li class="chapter-item expanded "><a href="../../docs/rust/lists.html"><strong aria-hidden="true">19.8.</strong> lists</a></li><li class="chapter-item expanded "><a href="../../docs/rust/index.html"><strong aria-hidden="true">19.9.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="../../docs/riscv/index.html"><strong aria-hidden="true">20.</strong> riscv</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../docs/riscv/index.html"><strong aria-hidden="true">20.1.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">other</li><li class="chapter-item expanded "><a href="../../other/2023-04-12-remote-usb.html"><strong aria-hidden="true">21.</strong> 2023-04-12-remote-usb</a></li><li class="chapter-item expanded "><a href="../../other/resources.html"><strong aria-hidden="true">22.</strong> resources</a></li><li class="chapter-item expanded "><a href="../../other/i3wm.html"><strong aria-hidden="true">23.</strong> i3wm</a></li><li class="chapter-item expanded "><a href="../../other/lsm.html"><strong aria-hidden="true">24.</strong> lsm</a></li><li class="chapter-item expanded "><a href="../../other/site_update_log.html"><strong aria-hidden="true">25.</strong> site_update_log</a></li><li class="chapter-item expanded "><a href="../../other/ioclub/index.html"><strong aria-hidden="true">26.</strong> ioclub</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../other/ioclub/share_1.html"><strong aria-hidden="true">26.1.</strong> share_1</a></li><li class="chapter-item expanded "><a href="../../other/ioclub/index.html"><strong aria-hidden="true">26.2.</strong> README</a></li></ol></li><li class="chapter-item expanded "><a href="../../other/2021-后端/index.html"><strong aria-hidden="true">27.</strong> 2021-后端</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_1.html"><strong aria-hidden="true">27.1.</strong> backend_1</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_2.html"><strong aria-hidden="true">27.2.</strong> backend_2</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_3.html"><strong aria-hidden="true">27.3.</strong> backend_3</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_4.html"><strong aria-hidden="true">27.4.</strong> backend_4</a></li></ol></li><li class="chapter-item expanded "><a href="../../other/2021-后端/index.html"><strong aria-hidden="true">28.</strong> 2021-后端</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_1.html"><strong aria-hidden="true">28.1.</strong> backend_1</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_2.html"><strong aria-hidden="true">28.2.</strong> backend_2</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_3.html"><strong aria-hidden="true">28.3.</strong> backend_3</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/backend_4.html"><strong aria-hidden="true">28.4.</strong> backend_4</a></li><li class="chapter-item expanded "><a href="../../other/2021-后端/index.html"><strong aria-hidden="true">28.5.</strong> README</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">draft</li><li class="chapter-item expanded "><a href="../../draft/组成原理.html"><strong aria-hidden="true">29.</strong> 组成原理</a></li><li class="chapter-item expanded "><a href="../../draft/计算机网络.html"><strong aria-hidden="true">30.</strong> 计算机网络</a></li><li class="chapter-item expanded "><a href="../../draft/译-pkg_mng.html"><strong aria-hidden="true">31.</strong> 译-pkg_mng</a></li><li class="chapter-item expanded "><a href="../../draft/DistributedSystem.html"><strong aria-hidden="true">32.</strong> DistributedSystem</a></li><li class="chapter-item expanded "><a href="../../draft/oscamp2022.html"><strong aria-hidden="true">33.</strong> oscamp2022</a></li><li class="chapter-item expanded "><a href="../../draft/compile.html"><strong aria-hidden="true">34.</strong> compile</a></li><li class="chapter-item expanded "><a href="../../draft/test.html"><strong aria-hidden="true">35.</strong> test</a></li><li class="chapter-item expanded "><a href="../../draft/ld.html"><strong aria-hidden="true">36.</strong> ld</a></li><li class="chapter-item expanded "><a href="../../draft/数据库设计.html"><strong aria-hidden="true">37.</strong> 数据库设计</a></li><li class="chapter-item expanded "><a href="../../draft/index.html"><strong aria-hidden="true">38.</strong> README</a></li><li class="chapter-item expanded "><a href="../../draft/computer_network/index.html"><strong aria-hidden="true">39.</strong> computer_network</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../draft/computer_network/index.html"><strong aria-hidden="true">39.1.</strong> README</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Trdthg&#x27;s Self</h1>

                    <div class="right-buttons">
                                                <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="集合框架"><a class="header" href="#集合框架">集合框架</a></h1>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<h4 id="arrayscopy"><a class="header" href="#arrayscopy">Arrays.copy()</a></h4>
<ol>
<li>创建一个新的集合用来储存数据
<ul>
<li>type(T) == type(U) ? 直接创建 : 通过反射机制创建</li>
</ul>
</li>
<li>调用 System.arraycopy() 拷贝到新集合上</li>
</ol>
<pre><code class="language-java">public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) {
    @SuppressWarnings(&quot;unchecked&quot;)
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    System.arraycopy(original, 0, copy, 0,
                        Math.min(original.length, newLength));
    return copy;
}
</code></pre>
<h3 id="collection"><a class="header" href="#collection">Collection</a></h3>
<ol>
<li>解释</li>
</ol>
<pre><code class="language-java">public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {
</code></pre>
<ul>
<li>继承自 Iterable，实现了 forEach &amp;&amp; iterator &amp;&amp; spliterator</li>
<li>removeIf 方法传入 Predicate(函数接口，传入比较的方法), 利用 Iterator 迭代</li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">public interface MyCollection&lt;E&gt; extends Iterable&lt;E&gt; {
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator&lt;E&gt; iterator();
    Object[] toArray();
    &lt;T&gt; T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection&lt;?&gt; c);
    boolean addAll(Collection&lt;? extends E&gt; c);
    boolean removeAll(Collection&lt;?&gt; c);
    default boolean removeIf(Predicate&lt;? super E&gt; filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator&lt;E&gt; each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }
    boolean retainAll(Collection&lt;?&gt; c);
    void clear();
    boolean equals(Object o);
    int hashCode();

    // 自从 1.8
    //default Spliterator&lt;E&gt; spliterator() {
    //    return Spliterators.spliterator(this, 0);
    //}
    //default Stream&lt;E&gt; stream() {
    //    return StreamSupport.stream(spliterator(), false);
    //}
    //default Stream&lt;E&gt; parallelStream() {
    //    return StreamSupport.stream(spliterator(), true);
    //}

}
</code></pre>
<h3 id="list-1"><a class="header" href="#list-1">List</a></h3>
<ol>
<li>解释</li>
</ol>
<ul>
<li>相比于 Collection，主要增加了</li>
<li>get</li>
<li>sort</li>
<li>index 相关</li>
<li>listIterator</li>
<li>SubList</li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">public interface MyList&lt;E&gt; extends Collection&lt;E&gt; {
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator&lt;E&gt; iterator();
    Object[] toArray();
    &lt;T&gt; T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection&lt;?&gt; c);
    boolean addAll(Collection&lt;? extends E&gt; c);
    boolean addAll(int index, Collection&lt;? extends E&gt; c);
    boolean removeAll(Collection&lt;?&gt; c);
    boolean retainAll(Collection&lt;?&gt; c);
    default void replaceAll(UnaryOperator&lt;E&gt; operator) {
        Objects.requireNonNull(operator);
        final ListIterator&lt;E&gt; li = this.listIterator();
        while (li.hasNext()) {
            li.set(operator.apply(li.next()));
        }
    }
    default void sort(Comparator&lt;? super E&gt; c) {
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator&lt;E&gt; i = this.listIterator();
        for (Object e : a) {
            i.next();
            i.set((E) e);
        }
    }
    void clear();
    boolean equals(Object o);
    int hashCode();
    E get(int index);
    E set(int index, E element);
    void add(int index, E element);
    E remove(int index);
    int indexOf(Object o);
    int lastIndexOf(Object o);
    ListIterator&lt;E&gt; listIterator();
    ListIterator&lt;E&gt; listIterator(int index);
    List&lt;E&gt; subList(int fromIndex, int toIndex);
</code></pre>
<h3 id="abstractcollection"><a class="header" href="#abstractcollection">AbstractCollection</a></h3>
<ol>
<li>解释</li>
</ol>
<ul>
<li>提供了两个抽象方法</li>
</ul>
<pre><code class="language-java">public abstract Iterator&lt;E&gt; iterator();
public abstract int size();
</code></pre>
<ul>
<li>实现了 toArray() 方法</li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">public abstract class MyAbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {
    protected MyAbstractCollection() {
    }
    public abstract Iterator&lt;E&gt; iterator();
    public abstract int size();
    public boolean isEmpty() {
        return size() == 0;
    }
    public boolean contains(Object o) {
        Iterator&lt;E&gt; it = iterator();
        if (o==null) {
            while (it.hasNext())
                if (it.next()==null)
                    return true;
        } else {
            while (it.hasNext())
                if (o.equals(it.next()))
                    return true;
        }
        return false;
    }
    public Object[] toArray() {
        // Estimate size of array; be prepared to see more or fewer elements
        Object[] r = new Object[size()];
        Iterator&lt;E&gt; it = iterator();
        for (int i = 0; i &lt; r.length; i++) {
            if (! it.hasNext()) // fewer elements than expected
                return Arrays.copyOf(r, i);
            r[i] = it.next();
        }
        return it.hasNext() ? finishToArray(r, it) : r;
    }
    public &lt;T&gt; T[] toArray(T[] a) {
        // Estimate size of array; be prepared to see more or fewer elements
        int size = size();
        T[] r = a.length &gt;= size ? a :
                (T[])java.lang.reflect.Array
                        .newInstance(a.getClass().getComponentType(), size);
        Iterator&lt;E&gt; it = iterator();

        for (int i = 0; i &lt; r.length; i++) {
            if (! it.hasNext()) { // fewer elements than expected
                if (a == r) {
                    r[i] = null; // null-terminate
                } else if (a.length &lt; i) {
                    return Arrays.copyOf(r, i);
                } else {
                    System.arraycopy(r, 0, a, 0, i);
                    if (a.length &gt; i) {
                        a[i] = null;
                    }
                }
                return a;
            }
            r[i] = (T)it.next();
        }
        // more elements than expected
        return it.hasNext() ? finishToArray(r, it) : r;
    }
    private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) {
        int len = r.length;
        int i = len;
        while (it.hasNext()) {
            if (i == len) {
                len = ArraysSupport.newLength(len,
                        1,             /* minimum growth */
                        (len &gt;&gt; 1) + 1 /* preferred growth */);
                r = Arrays.copyOf(r, len);
            }
            r[i++] = (T)it.next();
        }
        // trim if overallocated
        return (i == len) ? r : Arrays.copyOf(r, i);
    }
    public boolean add(E e) {
        throw new UnsupportedOperationException();
    }
    public boolean remove(Object o) {
        Iterator&lt;E&gt; it = iterator();
        if (o==null) {
            while (it.hasNext()) {
                if (it.next()==null) {
                    it.remove();
                    return true;
                }
            }
        } else {
            while (it.hasNext()) {
                if (o.equals(it.next())) {
                    it.remove();
                    return true;
                }
            }
        }
        return false;
    }
    public boolean containsAll(Collection&lt;?&gt; c) {
        for (Object e : c)
            if (!contains(e))
                return false;
        return true;
    }
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        boolean modified = false;
        for (E e : c)
            if (add(e))
                modified = true;
        return modified;
    }
    public boolean removeAll(Collection&lt;?&gt; c) {
        Objects.requireNonNull(c);
        boolean modified = false;
        Iterator&lt;?&gt; it = iterator();
        while (it.hasNext()) {
            if (c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }
    public boolean retainAll(Collection&lt;?&gt; c) {
        Objects.requireNonNull(c);
        boolean modified = false;
        Iterator&lt;E&gt; it = iterator();
        while (it.hasNext()) {
            if (!c.contains(it.next())) {
                it.remove();
                modified = true;
            }
        }
        return modified;
    }
    public void clear() {
        Iterator&lt;E&gt; it = iterator();
        while (it.hasNext()) {
            it.next();
            it.remove();
        }
    }
    public String toString() {
        Iterator&lt;E&gt; it = iterator();
        if (! it.hasNext())
            return &quot;[]&quot;;
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (;;) {
            E e = it.next();
            sb.append(e == this ? &quot;(this Collection)&quot; : e);
            if (! it.hasNext())
                return sb.append(']').toString();
            sb.append(',').append(' ');
        }
    }

}
</code></pre>
<ol start="2">
<li>解释</li>
</ol>
<ul>
<li>toArray 该方法没有直接返回，目的是为了应对多线程</li>
</ul>
<pre><code class="language-java">public Object[] toArray() {
    // Estimate size of array; be prepared to see more or fewer elements
    Object[] r = new Object[size()];
    Iterator&lt;E&gt; it = iterator();
    for (int i = 0; i &lt; r.length; i++) {
        if (! it.hasNext()) // fewer elements than expected
            return Arrays.copyOf(r, i);
        r[i] = it.next();
    }
    return it.hasNext() ? finishToArray(r, it) : r;
}
</code></pre>
<ul>
<li>为什么不是遍历迭代器？如果有多个线程操作该集合，其中某个线程向集合中添加了元素，此时如果在迭代器的遍历中向数组中添加元素，则会抛出数组越界异常。</li>
<li>为什么返回一个新数组？如果多线程删除了元素，新数组长度更小，节约空间 如果多线程添加了元素，调用 finishToArray</li>
</ul>
<pre><code class="language-java">private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) {
    int len = r.length;
    int i = len;
    while (it.hasNext()) {
        if (i == len) {
            len = ArraysSupport.newLength(len,
                    1,             /* minimum growth */
                    (len &gt;&gt; 1) + 1 /* preferred growth */);
            r = Arrays.copyOf(r, len);
        }
        r[i++] = (T)it.next();
    }
    // trim if overallocated
    return (i == len) ? r : Arrays.copyOf(r, i);
}
</code></pre>
<ul>
<li>该方法每次迭代都会比较当前数组长度与迭代器长度，利用 Array.copyOf 进行扩容 最后返回前再次判断，确保数组容量与实际数据长度相同</li>
</ul>
<h3 id="abstractlist"><a class="header" href="#abstractlist">AbstractList</a></h3>
<ol>
<li>概述</li>
</ol>
<ul>
<li>extend
<ul>
<li>AbstractList 继承自 AbstractCollection 抽象类，实现了 List 接口，</li>
<li>它实现了 List 的一些位置相关操作 (比如 get,set,add,remove)，是第一个实现随机访问方法的集合类，但不支持添加和替换。</li>
<li>AbstractList 内部已经提供了 Iterator, ListIterator 迭代器的实现类，分别为 Itr, ListItr</li>
<li>实现了 SubList 类</li>
</ul>
</li>
<li>super
<ul>
<li>是 ArrayList 和 AbstractSequentiaList 的父类。</li>
<li>提供了一个抽象类 <code>public abstract E get(int index);</code></li>
</ul>
</li>
</ul>
<h4 id="modcount-与-fail-fast"><a class="header" href="#modcount-与-fail-fast">modCount 与 fail-fast</a></h4>
<ul>
<li>modCount 作用是记录集合结构被改变的次数 (添加，删除等等), 目的是为了防止迭代过程中，其他线程，或者自己对集合结构修改，并不只是更改元素内容</li>
<li>fail-fast 机制在迭代器中实现，
fail-fast 机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测 bug。</li>
</ul>
<h4 id="itr-类"><a class="header" href="#itr-类">Itr 类</a></h4>
<ol>
<li>特征变量</li>
</ol>
<ul>
<li>cursor: 是指集合遍历过程中的即将遍历的元素的索引</li>
<li>lastRet: 它主要用于记录刚刚遍历过的元素的索引</li>
<li>expectedModCount: 为集合修改次数 (默认为 0) <code>int expectedModCount = modCount;</code></li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">private class Itr implements Iterator&lt;E&gt; {
        /**
         * Index of element to be returned by subsequent call to next.
         */
        int cursor = 0;

        /**
         * Index of element returned by most recent call to next or
         * previous.  Reset to -1 if this element is deleted by a call
         * to remove.
         */
        int lastRet = -1;

        /**
         * The modCount value that the iterator believes that the backing
         * List should have.  If this expectation is violated, the iterator
         * has detected concurrent modification.
         */
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size();
        }

        public E next() {
            checkForComodification();
            try {
                int i = cursor;
                E next = get(i);
                lastRet = i;
                cursor = i + 1;
                return next;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException(e);
            }
        }

        public void remove() {
            if (lastRet &lt; 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                AbstractList.this.remove(lastRet);
                if (lastRet &lt; cursor)
                    cursor--;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
</code></pre>
<ol start="3">
<li>解释</li>
</ol>
<ul>
<li>iterator 进行 next() 和 remove() 前都需要进行 checkForComodification(), 检查迭代过程中集合结构是否放生改变 ?
抛出 ConcurrentModificationException() : 正常执行</li>
<li>迭代器自身的 next, remove 不会对 modCount 进行修改，集合调用 add 等方法时会修改</li>
</ul>
<h4 id="如何避免-fail-fast"><a class="header" href="#如何避免-fail-fast">如何避免 fail-fast</a></h4>
<ol>
<li>调用 Iterator 自身的 remove() 而不是集合的
Itr.remove() 并不会修改 modCount 的值，并且不会对后面的遍历造成影响，因为该方法 remove 不能指定元素，只能 remove 当前遍历过的那个元素，所以调用该方法并不会发生 fail-fast 现象。该方法有局限性。</li>
<li>使用 java 并发包 (java.util.concurrent) 中的类来代替 ArrayList 和 hashMap。示例</li>
</ol>
<ul>
<li>CopyOnWriterArrayList
CopyOnWriter 是写时复制的容器 (COW)，在读写时是线程安全的。该容器在对 add 和 remove 等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于
CopyOnWriterArrayList 在迭代过程并不会发生 fail-fast 现象。但
CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。</li>
<li>ConcurrentHashMap
ConcurrentHashMap 采用了锁机制，是线程安全的。在迭代方面，ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而不影响原有的数据
，iterator 完成后再将头指针替换为新的数据
，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。即迭代不会发生 fail-fast，但不保证获取的是最新的数据。</li>
</ul>
<h4 id="listitr-类"><a class="header" href="#listitr-类">ListItr 类</a></h4>
<ol>
<li>概述</li>
</ol>
<ul>
<li>ListItr 继承自 Itr 实现了 ListIterator 接口</li>
<li>添加了 previous(返回前一位), add(增加), set(修改) 方法</li>
<li>与 Itr 一样，每次修改前需要检查 modCount 是否一致，修改后再次同步 modCount</li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">private class ListItr extends Itr implements ListIterator&lt;E&gt; {
        ListItr(int index) {
            cursor = index;
        }

        public boolean hasPrevious() {
            return cursor != 0;
        }

        public E previous() {
            checkForComodification();
            try {
                int i = cursor - 1;
                E previous = get(i);
                lastRet = cursor = i;
                return previous;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException(e);
            }
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor-1;
        }

        public void set(E e) {
            if (lastRet &lt; 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                AbstractList.this.set(lastRet, e);
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        public void add(E e) {
            checkForComodification();

            try {
                int i = cursor;
                AbstractList.this.add(i, e);
                lastRet = -1;
                cursor = i + 1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
    }
</code></pre>
<h4 id=""><a class="header" href="#"></a></h4>
<h3 id="arraylist"><a class="header" href="#arraylist">ArrayList</a></h3>
<p>:::warning 注意 ArrayList 不是线程安全的，如果需要，
可以选择使用 Collections.synchronizedList 方法“包装”列表。最好在创建时执行此操作，以防止意外不同步地访问列表 - from Josh
Bloch, Neal Gafter :::</p>
<h4 id="概述"><a class="header" href="#概述">概述</a></h4>
<ol>
<li>创建</li>
</ol>
<pre><code class="language-java">public class ArrayList&lt;E&gt;
    extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable
</code></pre>
<ol start="2">
<li>构造函数：</li>
</ol>
<ul>
<li>无参长度默认为 10</li>
<li>指定长度</li>
<li>从另一个 Collection 拷贝</li>
</ul>
<pre><code class="language-java">public ArrayList(Collection&lt;? extends E&gt; c) {
        Object[] a = c.toArray();
        if ((size = a.length) != 0) {
            if (c.getClass() == ArrayList.class) {
                elementData = a;
            } else {
                elementData = Arrays.copyOf(a, size, Object[].class);
            }
        } else {
            // replace with empty array.
            elementData = EMPTY_ELEMENTDATA;
        }
    }
</code></pre>
<h4 id="其他方法"><a class="header" href="#其他方法">其他方法</a></h4>
<ol>
<li>trimToSize(最小化)</li>
</ol>
<ul>
<li>用来最小化实例存储，将容器大小调整为当前元素所占用的容量大小。</li>
</ul>
<pre><code class="language-java">public void trimToSize() {
    modCount++;
    if (size &lt; elementData.length) {
        elementData = (size == 0)
            ? EMPTY_ELEMENTDATA
            : Arrays.copyOf(elementData, size);
    }
}
</code></pre>
<ol start="2">
<li>ensureCapacity(最大化)</li>
</ol>
<ul>
<li>利用 grow(minCapacity) 主动扩容，当需要扩大的容量很大时，能有效提高效率</li>
</ul>
<pre><code class="language-java">public void ensureCapacity(int minCapacity) {
    if (minCapacity &gt; elementData.length
        &amp;&amp; !(elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
                &amp;&amp; minCapacity &lt;= DEFAULT_CAPACITY)) {
        modCount++;
        grow(minCapacity);
    }
}
</code></pre>
<ol start="3">
<li>addAll</li>
</ol>
<ul>
<li>modCount++</li>
<li>拷贝新集合</li>
<li>判断是否超出原集合剩余容量</li>
<li>System.copy()</li>
</ul>
<ol start="4">
<li>shiftTailOverGap</li>
</ol>
<ul>
<li>将某段元素进行平移</li>
</ul>
<ol start="5">
<li>batchRemove retainAll , removeAll 均通过调用此方法实现</li>
<li>第一次循环，记录原数组中第一次出现的位置</li>
<li>第二次循环</li>
</ol>
<pre><code class="language-java">for (Object e; r &lt; end; r++)
    if (c.contains(e = es[r]) == complement)
        es[w++] = e;
</code></pre>
<ul>
<li>r: 记录遍历到的 index</li>
<li>w: 记录原始数组被覆盖到的 index</li>
<li>这部分的意思是，w 的目的是记录新的内容覆盖掉原有的内容，覆盖的原则是，判断 elementData[r] 是否符合需要，若符合就把他粘到 w 处</li>
<li>最后 finally 执行 shiftTailOverGap，目的是把后面的乱七八糟的后缀</li>
</ul>
<h4 id="核心方法"><a class="header" href="#核心方法">核心方法</a></h4>
<ol>
<li>grow</li>
</ol>
<ul>
<li>不传参 <code>return grow(size + 1);</code></li>
<li>传参</li>
</ul>
<pre><code class="language-java">private Object[] grow(int minCapacity) {
    int oldCapacity = elementData.length;
    if (oldCapacity &gt; 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        int newCapacity = ArraysSupport.newLength(oldCapacity,
                minCapacity - oldCapacity, /* minimum growth */
                oldCapacity &gt;&gt; 1           /* preferred growth */);
        return elementData = Arrays.copyOf(elementData, newCapacity);
    } else {
        return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
    }
}
</code></pre>
<ul>
<li>若扩容时没有元素直接阔到 max(10, minCapacity)</li>
<li>若有元素，由于右移运算符的存在，每次扩容并不一定是 minCapacity 的的大小，一般为原大小的 1.5 倍，
具体可以查看 System.newLength 和 System.hugeLength</li>
</ul>
<ol start="2">
<li>
<p>clone() 常规的浅拷贝</p>
</li>
<li>
<p>add(), set(), remove()</p>
<ol>
<li>new ArrayList()
<ul>
<li>调用构造函数创建新的空集合集合</li>
<li>通过 AbstractList 创建 modCount=0</li>
</ul>
</li>
<li>add():
<ul>
<li>modCount++</li>
<li>if elementData.length &gt;= 0 ? 扩容 50% :扩容默认 10 格</li>
<li>elementData[size] = e (size 是已经存入的数据个数)</li>
</ul>
</li>
<li>若集合满了则先调用 grow() 扩容，在赋值</li>
</ol>
</li>
<li>
<p>add(index), remove(index)</p>
</li>
</ol>
<ul>
<li>add(index) 同理，扩容采用 System.arraycopy 在原数组上扩容</li>
<li>若 index 不是最后一个，则需要先用 System.arraycopy 从 index 让后方的数据向后挪一位，空出新的位置用来插入</li>
</ul>
<pre><code class="language-java">System.arraycopy(elementData, index,
                         elementData, index + 1,
                         s - index);
</code></pre>
<ul>
<li>remove(index) 调用了 fastRemove(), 通过 System.arraycopy() 最小化容器，在将指定位置设置为 null</li>
</ul>
<pre><code class="language-java">private void fastRemove(Object[] es, int i) {
    modCount++;
    final int newSize;
    if ((newSize = size - 1) &gt; i)
        System.arraycopy(es, i + 1, es, i, newSize - i);
    es[size = newSize] = null;
}
</code></pre>
<h3 id="待续"><a class="header" href="#待续">待续...</a></h3>
<h2 id="set"><a class="header" href="#set">Set</a></h2>
<h3 id="set-1"><a class="header" href="#set-1">Set</a></h3>
<h4 id="概述-1"><a class="header" href="#概述-1">概述</a></h4>
<pre><code class="language-java">public interface Set&lt;E&gt; extends Collection&lt;E&gt; {
</code></pre>
<h3 id="abstractset"><a class="header" href="#abstractset">AbstractSet</a></h3>
<h4 id="概述-2"><a class="header" href="#概述-2">概述</a></h4>
<pre><code class="language-java">public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; {
</code></pre>
<ol>
<li>继承自 AbstractCollection，实现了 Set 接口</li>
<li>只重写了 equals(), hashcode(), removeAll() 方法，几乎没变</li>
</ol>
<h3 id="待续-1"><a class="header" href="#待续-1">待续...</a></h3>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<h3 id="接口-map"><a class="header" href="#接口-map">接口 Map</a></h3>
<h3 id="map-1"><a class="header" href="#map-1">Map</a></h3>
<h4 id="基础方法"><a class="header" href="#基础方法">基础方法</a></h4>
<pre><code class="language-java">public interface Map&lt;K, V&gt; {
    int size();
    boolean isEmpty();
    boolean containsKey(Object key);
    boolean containsValue(Object value);
    V get(Object key);
    V put(K key, V value);
    V remove(Object key);
    void putAll(Map&lt;? extends K, ? extends V&gt; m);
    void clear();

    Set&lt;K&gt; keySet();
    Collection&lt;V&gt; values();
    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();

    static &lt;K, V&gt; Map&lt;K, V&gt; of(K k1, V v1, K k2, V v2) {  // 最大支持 10 对
        return new ImmutableCollections.MapN&lt;&gt;(k1, v1, k2, v2);
    }
    default boolean remove(Object key, Object value) { // 允许 key 为 null
        Object curValue = get(key);
        if (!Objects.equals(curValue, value) ||
            (curValue == null &amp;&amp; !containsKey(key))) {
            return false;
        }
        remove(key);
        return true;
    }
</code></pre>
<h4 id="内部-entry-接口"><a class="header" href="#内部-entry-接口">内部 Entry 接口</a></h4>
<pre><code class="language-java">interface Entry&lt;K, V&gt; {
    K getKey();
    V getValue();
    V setValue(V value);
    boolean equals(Object o);
    int hashCode();
    public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey() {
        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey());
    }
    public static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue() {}
    public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? super K&gt; cmp) {
        Objects.requireNonNull(cmp);
        return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey());
    }
    public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? super V&gt; cmp) {}
}
</code></pre>
<h4 id="其他方法-1"><a class="header" href="#其他方法-1">其他方法</a></h4>
<ul>
<li>equal hashcode</li>
<li>3 个 replace 4 个 ifAbsent 1 个 merge</li>
</ul>
<pre><code class="language-java">    boolean equals(Object o);
    int hashCode();
    default V getOrDefault(Object key, V defaultValue) {  // 没有则返回
        V v;
        return (((v = get(key)) != null) || containsKey(key))
            ? v
            : defaultValue;
    }
    default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
        Objects.requireNonNull(action);
        for (Map.Entry&lt;K, V&gt; entry : entrySet()) {
            K k;
            V v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch (IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }
            action.accept(k, v);
        }
    }
    default boolean replace(K key, V oldValue, V newValue) {
        Object curValue = get(key);
        if (!Objects.equals(curValue, oldValue) ||
            (curValue == null &amp;&amp; !containsKey(key))) {
            return false;
        }
        put(key, newValue);
        return true;
    }
    default V replace(K key, V value) {}
    default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {  // function 批量处理
        Objects.requireNonNull(function);
        for (Map.Entry&lt;K, V&gt; entry : entrySet()) {
            K k;
            V v;
            try {
                k = entry.getKey();
                v = entry.getValue();
            } catch (IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }

            // ise thrown from function is not a cme.
            v = function.apply(k, v);

            try {
                entry.setValue(v);
            } catch (IllegalStateException ise) {
                // this usually means the entry is no longer in the map.
                throw new ConcurrentModificationException(ise);
            }
        }
    }
    default V putIfAbsent(K key, V value) {  // 不存在 key 则添加
        V v = get(key);
        if (v == null) {
            v = put(key, value);
        }
        return v;
    }

    // computeIfPresent 同理
    // compute 用 key 和 value 生产新的 value
    default V computeIfAbsent(K key,
            Function&lt;? super K, ? extends V&gt; mappingFunction) {  // 不存在就用方法新建
        Objects.requireNonNull(mappingFunction);
        V v;
        if ((v = get(key)) == null) {
            V newValue;
            if ((newValue = mappingFunction.apply(key)) != null) {
                put(key, newValue);
                return newValue;
            }
        }

        return v;
    }
    default V merge(K key, V value,
        BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
        Objects.requireNonNull(remappingFunction);
        Objects.requireNonNull(value);
        V oldValue = get(key);
        V newValue = (oldValue == null) ? value :
                remappingFunction.apply(oldValue, value);
        if (newValue == null) {
            remove(key);
        } else {
            put(key, newValue);
        }
        return newValue;
    }
</code></pre>
<h3 id="abstractmap"><a class="header" href="#abstractmap">AbstractMap</a></h3>
<h4 id="概述-3"><a class="header" href="#概述-3">概述</a></h4>
<ol>
<li>实现 Map 接口，没有实现 Map.Entry() 接口</li>
<li>有一个抽象方法</li>
</ol>
<pre><code class="language-java">public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();
</code></pre>
<ol start="3">
<li>默认不支持修改</li>
</ol>
<h4 id="enttryset"><a class="header" href="#enttryset">enttrySet()</a></h4>
<pre><code class="language-java">public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();
</code></pre>
<ol>
<li>当我们要实现一个不可变的 Map 时，只需要继承这个类，然后实现 entrySet() 方法，这个方法返回一个保存所有 key-value 映射的
set。通常这个 Set 不支持 add(), remove() 方法，Set 对应的迭代器也不支持 remove() 方法。</li>
<li>如果想要实现一个可变的 Map，我们需要在上述操作外，重写 put() 方法，因为 默认不支持 put 操作：</li>
</ol>
<pre><code class="language-java">public V put(K key, V value) {
    throw new UnsupportedOperationException();
}
</code></pre>
<p>而且 entrySet() 返回的 Set 的迭代器，也得实现 remove() 方法，因为 AbstractMap 中的 删除相关操作都需要调用该迭代器的
remove() 方法。</p>
<h4 id="基础方法-1"><a class="header" href="#基础方法-1">基础方法</a></h4>
<ol>
<li>put() 默认需要重写，否则直接抛异常</li>
<li>其他无非都是 Iterator 遍历</li>
</ol>
<h4 id="三个视图"><a class="header" href="#三个视图">三个视图</a></h4>
<ol>
<li>获取所有键 <code>public Set&lt;K&gt; keySet() {</code></li>
<li>获取所有值 <code>public Collection&lt;V&gt; values() {</code></li>
<li>获取所有键值对 <code>public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</code></li>
</ol>
<h3 id="sortedmap"><a class="header" href="#sortedmap">SortedMap</a></h3>
<pre><code class="language-java">public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; {
</code></pre>
<p>内置方法：</p>
<pre><code class="language-java">Comparator&lt;? super K&gt; comparator();
SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);
SortedMap&lt;K,V&gt; headMap(K toKey);
SortedMap&lt;K,V&gt; tailMap(K fromKey);
K firstKey();
K lastKey();
Set&lt;K&gt; keySet();
Collection&lt;V&gt; values();
Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();
</code></pre>
<h3 id="navigablemap"><a class="header" href="#navigablemap">NavigableMap</a></h3>
<pre><code class="language-java">public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; {
</code></pre>
<p>内置方法：</p>
<pre><code class="language-java">Map.Entry&lt;K,V&gt; lowerEntry(K key);  // 比给定的 entry 小的最大的 entry
K lowerKey(K key);
Map.Entry&lt;K,V&gt; floorEntry(K key);
K floorKey(K key); // &lt;=
Map.Entry&lt;K,V&gt; ceilingEntry(K key);
K ceilingKey(K key);
Map.Entry&lt;K,V&gt; higherEntry(K key);
K higherKey(K key);
Map.Entry&lt;K,V&gt; firstEntry();
Map.Entry&lt;K,V&gt; lastEntry();
Map.Entry&lt;K,V&gt; pollFirstEntry();
Map.Entry&lt;K,V&gt; pollLastEntry();
NavigableMap&lt;K,V&gt; descendingMap();  // reverse order view
NavigableSet&lt;K&gt; navigableKeySet();
NavigableSet&lt;K&gt; descendingKeySet();
NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
                         K toKey,   boolean toInclusive);
NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive);  // less than toKey
NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive);
SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);
SortedMap&lt;K,V&gt; headMap(K toKey);
SortedMap&lt;K,V&gt; tailMap(K fromKey);
</code></pre>
<h3 id="treemap"><a class="header" href="#treemap">TreeMap</a></h3>
<pre><code class="language-java">public class TreeMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable
{
</code></pre>
<h4 id="成员变量"><a class="header" href="#成员变量">成员变量</a></h4>
<pre><code class="language-java">    // maintain the order Or keep keys'order natural
    private final Comparator&lt;? super K&gt; comparator;
    private transient Entry&lt;K,V&gt; root;
    private transient int size = 0;
    private transient int modCount = 0;
static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        K key;
        V value;
        Entry&lt;K,V&gt; left;
        Entry&lt;K,V&gt; right;
        Entry&lt;K,V&gt; parent;
        boolean color = BLACK;
</code></pre>
<h4 id="构造器"><a class="header" href="#构造器">构造器</a></h4>
<p>是否自带 Comparator 是否从其他 Map 复制</p>
<pre><code class="language-java">public TreeMap() {
    comparator = null;
}
public TreeMap(Comparator&lt;? super K&gt; comparator) {
    this.comparator = comparator;
}
public TreeMap(Map&lt;? extends K, ? extends V&gt; m) {
    comparator = null;
    putAll(m);
}
public TreeMap(SortedMap&lt;K, ? extends V&gt; m) {
    comparator = m.comparator();
    try {
        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);
    } catch (java.io.IOException cannotHappen) {
    } catch (ClassNotFoundException cannotHappen) {
    }
}
</code></pre>
<h4 id="put"><a class="header" href="#put">Put</a></h4>
<p>put 就是普通的二叉树插入 若用户指定判断条件，就按照指定的条件判断插入坐枝还是插入右枝 否则使用默认的比较方法
重点是插入后调用了 fixAfterInsertion(e);</p>
<pre><code class="language-java">public V put(K key, V value) {
    Entry&lt;K,V&gt; t = root;
    if (t == null) {
        compare(key, key); // type (and possibly null) check
        root = new Entry&lt;&gt;(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    int cmp;
    Entry&lt;K,V&gt; parent;
    // split comparator and comparable paths
    Comparator&lt;? super K&gt; cpr = comparator;
    if (cpr != null) {
        do {
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    else {
        if (key == null)
            throw new NullPointerException();
        @SuppressWarnings(&quot;unchecked&quot;)
            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp &lt; 0)
                t = t.left;
            else if (cmp &gt; 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
    if (cmp &lt; 0)
        parent.left = e;
    else
        parent.right = e;
    fixAfterInsertion(e);
    size++;
    modCount++;
    return null;
}
</code></pre>
<h4 id="fixafterinsertione"><a class="header" href="#fixafterinsertione">fixAfterInsertion(e);</a></h4>
<h4 id="-1"><a class="header" href="#-1"></a></h4>
<h3 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h3>
<pre><code class="language-java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable {
</code></pre>
<h4 id="成员变量-1"><a class="header" href="#成员变量-1">成员变量</a></h4>
<ol>
<li><code>private static final long serialVersionUID = 362498820763181265L;</code>：序列化 ID</li>
<li><code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</code>：指定默认初始长度</li>
<li><code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>：最大长度</li>
<li><code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code>：负载因子</li>
<li><code>static final int TREEIFY_THRESHOLD = 8;</code>：由链表转为红黑树的临界值 1（链表长度&gt;8）</li>
<li><code>static final int UNTREEIFY_THRESHOLD = 6;</code>：由红黑树转为链表的临界值</li>
<li><code>static final int MIN_TREEIFY_CAPACITY = 64;</code>：：由链表转为红黑树的临界值 2（capicity&gt;64）</li>
</ol>
<ul>
<li>loadFactor 值为 0.75 加载因子的选择与 Poisson_distribution 有关
链表 8 号位有值的概率是 0.00000006（理想随机情况下），具体可以查看源码注释
更多的是为了防止用户自己实现了不好的哈希算法时导致链表过长，从而导致查询效率低，而此时转为红黑树更多的是一种保底策略，用来保证极端情况下查询的效率。</li>
<li>刚开始不使用红黑树的原因</li>
</ul>
<p>单个 TreeNode 需要占用的空间大约是普通 Node 的两倍，所以只有当包含足够多的 Nodes 时才会转成 TreeNodes，
而当桶中节点数小于 6 时又会变回普通的链表的形式，以便节省空间，</p>
<ul>
<li>链表转红黑树选择 8 红黑树平均查找长度为 log(n) 链表平均查找长度为 n/2</li>
</ul>
<h4 id="构造器-1"><a class="header" href="#构造器-1">构造器</a></h4>
<ol>
<li>HashMap 提供了 4 种构造器，可以自主选择初始长度和负载因子</li>
<li>若传入的初始长度不是二次幂，java 会自动将用户传入的 initialCapacity 转换为比它大的二进制数，目的是方便在求索引时使用位运算更快取模 :::
tip 注意 虽然创建了新的 table，但是没有将 capicity 进行赋值仍然是零，只将 loadFactor 和 threshold 进行赋值
这点需要在 resize() 中用到 :::</li>
</ol>
<pre><code class="language-java">public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);
    // 不能超过默认最大长度
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    // 负载因子不能小于零
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);
    this.loadFactor = loadFactor;
    // 这里虽然不是用`capicity * loadfactory`为扩容临界值赋值，但是还会在 put 方法里重新修正
    this.threshold = tableSizeFor(initialCapacity);
}
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    // 此时阈值和容量值大小都为 0
}

public HashMap(Map&lt;? extends K, ? extends V&gt; m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}
</code></pre>
<h4 id="初始长度修正"><a class="header" href="#初始长度修正">初始长度修正</a></h4>
<p>这里使用 5 次右移 + 或运算 一下是举例：</p>
<pre><code>0000 0000 0000 1010 0000 0011 1110 1010  n
0000 0000 0000 0101 0000 0001 1111 0101  n &gt;&gt;&gt; 1
---------------------------------------  |
0000 0000 0000 1111 0000 0011 1111 1111  n
0000 0000 0000 0011 1100 0000 1111 1111  n &gt;&gt;&gt; 2
---------------------------------------  |
0000 0000 0000 1111 1100 0011 1111 1111  n
0000 0000 0000 0000 1111 1100 0011 1111  n &gt;&gt;&gt; 4
---------------------------------------  |
0000 0000 0000 1111 1111 1111 1111 1111  n
0000 0000 0000 0000 0000 1111 1111 1111  n &gt;&gt;&gt; 8
剩下的就不用写了全部被转换成 1，最后在加上 1 就是：
&gt;Returns a power of two size for the given target capacity.
</code></pre>
<pre><code class="language-java">static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre>
<h4 id="链表转红黑树"><a class="header" href="#链表转红黑树">链表转红黑树</a></h4>
<p>若链表长度&gt;8，尝试转为红黑树</p>
<pre><code class="language-java">if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
    treeifyBin(tab, hash);
</code></pre>
<ul>
<li>若检测到 size&lt;64，扩容，不转为红黑树</li>
</ul>
<pre><code class="language-java">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
    int n, index; Node&lt;K,V&gt; e;
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
        resize();
</code></pre>
<p>resize 扩容后所有元素的索引值会重新分配，链表长度会发生变化，更加散列</p>
<ul>
<li>若检测到 size&gt;=64，转为红黑树
<ol>
<li>链表转为 LinkedHashMap（节点转为 TreeNode，加入向前的指针和左右字节点）</li>
</ol>
<pre><code class="language-java">else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
    TreeNode&lt;K,V&gt; hd = null, tl = null;
    do {
        TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
        if (tl == null)
            hd = p;
        else {
            p.prev = tl;
            tl.next = p;
        }
        tl = p;
    } while ((e = e.next) != null);
</code></pre>
<ol start="2">
<li>
<p>把根节点放入桶中，进行平衡</p>
</li>
<li>
<p>待续</p>
</li>
</ol>
</li>
</ul>
<h4 id="扩容_resize"><a class="header" href="#扩容_resize">扩容_resize</a></h4>
<ol>
<li>
<p>确定新容量的大小：</p>
<ul>
<li>若 oldCap &gt; 0(正常情况下扩容)
<pre><code class="language-java">//翻倍或者调为 MAXIMUM_CAPACITY(本身就超过最大值或者翻倍后会超过最大值)
if (oldCap &gt; 0) {
    if (oldCap &gt;= MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return oldTab;
    }
    else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
        newThr = oldThr &lt;&lt; 1; // double threshold
}
</code></pre>
</li>
<li>若 oldThr &gt; 0（初始化下需要扩容，手动选择初始容量）
<pre><code class="language-java">// 确定初始长度
else if (oldThr &gt; 0) // initial capacity was placed in threshold
    newCap = oldThr;
</code></pre>
这里需要说明，在构造器中有如下代码
<pre><code class="language-java">this.threshold = tableSizeFor(initialCapacity);
// tableSizeFor 返回的就是 Capicity，只不过赋值给了 threshold(也就是 oldThr)，在这里 newCap 才被确定
</code></pre>
</li>
<li>若 oldCap == oldThr == 0（初始化下需要扩容，没有手动选择初始容量）按照默认值进行初始化
<pre><code class="language-java">else {               // zero initial threshold signifies using defaults
    newCap = DEFAULT_INITIAL_CAPACITY;
    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>确定新的扩容边界</p>
<pre><code class="language-java">if (newThr == 0) {
    float ft = (float)newCap * loadFactor;
    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                (int)ft : Integer.MAX_VALUE);
}
threshold = newThr;
</code></pre>
</li>
<li>
<p>开辟新的空间，重新排列原来的元素</p>
<ul>
<li>开辟</li>
</ul>
<pre><code class="language-java">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
table = newTab;
</code></pre>
<p>若原数组不为空（不是刚初始化的），循环原 tab</p>
<ul>
<li>用 e 代替 oldTab</li>
</ul>
<pre><code class="language-java">if (oldTab != null) {
    for (int j = 0; j &lt; oldCap; ++j) {
        Node&lt;K,V&gt; e;
        if ((e = oldTab[j]) != null) {
</code></pre>
<ul>
<li>若原 tab 在 j 处不为空
<ol>
<li>清空原 table 在 j 处的占用
<pre><code class="language-java">oldTab[j] = null;
</code></pre>
</li>
<li>重新计算索引
<ul>
<li>若不是链表或红黑树，直接移动</li>
</ul>
<pre><code class="language-java">if (e.next == null)
    newTab[e.hash &amp; (newCap - 1)] = e;
</code></pre>
<ul>
<li>若是红黑树，待续</li>
</ul>
<pre><code class="language-java">else if (e instanceof TreeNode)
    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
</code></pre>
<ul>
<li>若是链表 这里 e.hash &amp; oldCap 直接与二次幂（不是 n-1）做&amp;运算
二次幂低位全为零，与 hash 做与运算后能够得到得到新索引的最高位为是 0 还是 1 (e.hash &amp; oldCap) == 0 =&gt;
确定新索引是原索引还是原索引 +n</li>
</ul>
<pre><code class="language-java">    else { // preserve order
        Node&lt;K,V&gt; loHead = null, loTail = null;
        Node&lt;K,V&gt; hiHead = null, hiTail = null;
        Node&lt;K,V&gt; next;
        do {
            next = e.next;
            // 判断新索引最高为
            if ((e.hash &amp; oldCap) == 0) {
                if (loTail == null)
                    loHead = e;
                else
                    //如果可能会拼接一个新链表
                    loTail.next = e;
                loTail = e;
            }
            else {
                if (hiTail == null)
                    hiHead = e;
                else
                    hiTail.next = e;
                hiTail = e;
            }
        } while ((e = next) != null);
        // 新链表的头节点装入到新桶中
        if (loTail != null) {
            loTail.next = null;
            newTab[j] = loHead;
        }
        if (hiTail != null) {
            hiTail.next = null;
            newTab[j + oldCap] = hiHead;
        }
    }
}
```java
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="扩容后的索引规律"><a class="header" href="#扩容后的索引规律">扩容后的索引规律</a></h4>
<p>假如原数组长度 n = 16</p>
<ol>
<li>hash &amp; (n-1)</li>
</ol>
<pre><code>- key1 与 15
1101 1001 0010 1100 1111 000|0 0101  key1.hashCode()
0000 0000 0000 0000 0000 000|0 1111  n - 1
----------------------------------  &amp;
0000 0000 0000 0000 0000 000|0 0101  5
- key1 与 31
1101 1001 0010 1100 1111 000|0 0101  key1.hashCode()
0000 0000 0000 0000 0000 000|1 1111  n * 2 - 1
----------------------------------  &amp;
0000 0000 0000 0000 0000 000|0 0101  5
- key2 与 15
1101 1001 0010 1100 1111 001|1 0101  key2.hashCode()
0000 0000 0000 0000 0000 000|0 1111  n - 1
----------------------------------  &amp;
0000 0000 0000 0000 0000 000|0 0101  5
- key2 与 31
1101 1001 0010 1100 1111 001|1 0101  key2.hashCode()
0000 0000 0000 0000 0000 000|1 1111  n * 2 - 1
----------------------------------  &amp;
0000 0000 0000 0000 0000 000|1 0101  5 + 16
</code></pre>
<p>由上图可见，新索引位置只能是原索引或者原索引 +n，到底是那种情况只用看新索引高位是 0 还是 1</p>
<ul>
<li>优点：不用真的重新计算新索引位置，只需要计算高位是 0 还是 1 即可确定新索引</li>
</ul>
<ol start="2">
<li>hash &amp; n</li>
</ol>
<ul>
<li>key2 与 16 1101 1001 0010 1100 1111 001|1 0101 key2.hashCode() 0000 0000 0000
0000 0000 000|0 1111 n ---------------------------------- &amp; 0000 0000 0000
0000 0000 000|0 0101 5</li>
<li>key2 与 32 1101 1001 0010 1100 1111 001|1 0101 key2.hashCode() 0000 0000 0000
0000 0000 000|1 0000 n ---------------------------------- &amp; 0000 0000 0000
0000 0000 000|1 0000 得到最高位为 1</li>
</ul>
<h4 id="hash-计算方法"><a class="header" href="#hash-计算方法">hash 计算方法</a></h4>
<p>先调用 key.hashCode()，在于自身高位异或</p>
<pre><code class="language-java">static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}
</code></pre>
<p>示例</p>
<pre><code>1101 0111 1010 1111 1000 0110 0001 1011  hash
0000 0000 0000 0000 1101 0111 1010 1111  hash &gt;&gt;&gt; 16
---------------------------------------  ^
1101 0111 1010 1111 0101 0001 1011 0100
</code></pre>
<p>原因：</p>
<ol>
<li>混合高低位信息</li>
<li>确保 hash 不会向 0 或 1 单独靠拢</li>
</ol>
<h4 id="put-1"><a class="header" href="#put-1">put</a></h4>
<ul>
<li>
<p>put 调用 putVal 实现</p>
<pre><code class="language-java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
</code></pre>
</li>
<li>
<p>方法参数</p>
<ol>
<li>boolean onlyIfAbsent：只有不存在才添加（即不修改原数据）</li>
<li>boolean evict：如果为 false 表示为创建状态</li>
</ol>
</li>
<li>
<p>具体实现</p>
</li>
</ul>
<ol>
<li>如果 table == null，resize 新建数组</li>
</ol>
<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
</code></pre>
<ol start="2">
<li>插入/或记录被修改 value 的节点 e
<ul>
<li>若索引位置为空，直接插入</li>
</ul>
<pre><code class="language-java">if ((p = tab[i = (n - 1) &amp; hash]) == null)
    tab[i] = newNode(hash, key, value, null);
else {
</code></pre>
<ul>
<li>若不为空，且 key 相同，e 就是当前节点</li>
</ul>
<pre><code class="language-java">Node&lt;K,V&gt; e; K k;
if (p.hash == hash &amp;&amp;
    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
    e = p;
</code></pre>
<ul>
<li>若不为空，但是为红黑树，按照红黑树插入</li>
</ul>
<pre><code class="language-java">else if (p instanceof TreeNode)
    e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
</code></pre>
<ul>
<li>若不为空但是为链表 找到相同节点就记录 e 没找到就尾插新结点，并判断是否转为红黑树</li>
</ul>
<pre><code class="language-java">else {
    for (int binCount = 0; ; ++binCount) {
        if ((e = p.next) == null) {
            p.next = newNode(hash, key, value, null);
            if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                treeifyBin(tab, hash);
            break;
        }
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
            break;
        p = e;
    }
}
</code></pre>
</li>
<li>如果上一步没有插入新结点而是准备覆盖 value，就在这一步覆盖</li>
</ol>
<pre><code class="language-java">    if (e != null) { // existing mapping for key
        V oldValue = e.value;
        if (!onlyIfAbsent || oldValue == null)
            e.value = value;
        afterNodeAccess(e);
        return oldValue;
    }
}
</code></pre>
<ol start="4">
<li>fastfail 检验，扩容检验</li>
</ol>
<pre><code class="language-java">    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict); // 空函数，不知道有啥用
    return null;
}
</code></pre>
<h4 id="remove"><a class="header" href="#remove">remove</a></h4>
<ol>
<li>判断 table 是否为空，table 是否存有元素，要找的索引位置是否有值</li>
</ol>
<pre><code class="language-java">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) {
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (p = tab[index = (n - 1) &amp; hash]) != null) {
</code></pre>
<ol start="2">
<li>找到待删除节点 node 记录
<ul>
<li>index 处就是所找节点
<pre><code class="language-java">Node&lt;K,V&gt; node = null, e; K k; V v;
if (p.hash == hash &amp;&amp;
    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
    node = p;
</code></pre>
</li>
<li>是红黑树，按照红黑树的方式查找
<pre><code class="language-java">else if ((e = p.next) != null) {
    if (p instanceof TreeNode)
        node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
</code></pre>
</li>
<li>是链表，按照链表方式查找
<pre><code class="language-java">    else {
        do {
            if (e.hash == hash &amp;&amp;
                ((k = e.key) == key ||
                    (key != null &amp;&amp; key.equals(k)))) {
                node = e;
                break;
            }
            p = e;
        } while ((e = e.next) != null);
    }
}
</code></pre>
</li>
</ul>
</li>
<li>删除节点，处理后事</li>
</ol>
<pre><code class="language-java">        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                                (value != null &amp;&amp; value.equals(v)))) {
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            else if (node == p)
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
</code></pre>
<h4 id="待续-2"><a class="header" href="#待续-2">待续...</a></h4>
<h3 id="待续-3"><a class="header" href="#待续-3">待续...</a></h3>
<h2 id="标记接口"><a class="header" href="#标记接口">标记接口</a></h2>
<h3 id="序列化"><a class="header" href="#序列化">序列化</a></h3>
<h4 id="serializable-接口"><a class="header" href="#serializable-接口">Serializable 接口</a></h4>
<ul>
<li>序列化就是将对象转换为字节序列的过程，反序列化就是把持久化的字节文件数据恢复为对象的过程。</li>
<li>对于 JVM 来说，要进行持久化的类必须要有一个标记，只有持有这个标记 JVM 才允许类创建的对象可以通过其 IO 系统转换为字节数据，从而实现持久化，而这个标记就是 Serializable 接口。</li>
<li>而在反序列化的过程中则需要使用 serialVersionUID 来确定由那个类来加载这个对象，所以我们在实现 Serializable 接口的时候，一般还会要去尽量显示地定义 serialVersionUID</li>
</ul>
<pre><code class="language-java">public class MySerializable {
    public static void main(String[] args) {
        write();
        read();
    }

    public static void write() {
        Student student = new Student(1, &quot;zhangsan&quot;);
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;src/resources/student.txt&quot;));
        objectOutputStream.writeObject(student);
    }

    public static void read() {
        ObjectInputStream objectInputStream = null;
        objectInputStream = new ObjectInputStream(new FileInputStream(&quot;src/resources/student.txt&quot;));
        Student student = (Student) objectInputStream.readObject();
    }
}
@Data
@AllArgsConstructor
class Student implements Serializable {
    private int id;
    private String name;
}
</code></pre>
<blockquote>
<p>如果我们在序列化中没有显示地声明 serialVersionUID，则序列化运行时将会根据该类的各个方面计算该类默认的 serialVersionUID 值。&gt;但是，Java 官方强烈建议所有要序列化的类都显示地声明 serialVersionUID 字段，因为如果高度依赖于 JVM 默认生成 serialVersionUID，可&gt;能会导致其与编译器的实现细节耦合，这样可能会导致在反序列化的过程中发生意外的 InvalidClassException 异常。因此，为了保证跨不？&gt;同 Java 编译器实现的 serialVersionUID 值的一致，实现 Serializable 接口的必须显示地声明 serialVersionUID 字段。<br/></p>
</blockquote>
<blockquote>
<p>此外 serialVersionUID 字段地声明要尽可能使用 private 关键字修饰，这是因为该字段的声明只适用于声明的类，该字段作为成员变量被子&gt;类继承是没有用处的！有个特殊的地方需要注意的是，数组类是不能显示地声明 serialVersionUID 的，因为它们始终具有默认计算的值，不过&gt;数组类反序列化过程中也是放弃了匹配 serialVersionUID 值的要求。</p>
</blockquote>
<h4 id="transient"><a class="header" href="#transient">transient</a></h4>
<ul>
<li>在实现 Serializable 接口后可以用该关键字修饰，让这个属性不序列化</li>
<li>但是用 static 修饰后，一定不会被序列化</li>
<li>若选择实现 Externalizable 接口，则属性是否进行序列化需要手动指定，与是否有 transient 关键字无关</li>
</ul>
<h3 id="randomaccess"><a class="header" href="#randomaccess">RandomAccess</a></h3>
<ol>
<li>概述 RandomAccess 是一个空的接口，它用来标识某个类是否支持
随机访问（随机访问，相对比“按顺序访问”）。一个支持随机访问的类明显可以使用更加高效的算法。</li>
</ol>
<pre><code class="language-java">public interface RandomAccess {
}
</code></pre>
<ul>
<li>List 中支持随机访问最佳的例子就是 ArrayList，它的数据结构使得 get(), set(), add() 等方法的时间复杂度都是 O(1);</li>
<li>反例就是 LinkedList，链表结构使得它不支持随机访问，只能按序访问，因此在一些操作上性能略逊一筹。</li>
</ul>
<ol start="2">
<li>例子</li>
</ol>
<ul>
<li>通常在操作一个 List 对象时，通常会判断是否支持 随机访问，也就是* 是否为 RandomAccess 的实例*，从而使用不同的算法。比如遍历，实现了
RandomAccess 的集合使用 get():</li>
</ul>
<pre><code class="language-java">for (int i=0, n=list.size(); i &amp;lt; n; i++)
          list.get(i);
</code></pre>
<p>比用迭代器更快：</p>
<pre><code class="language-java">for (Iterator i=list.iterator(); i.hasNext(); )
    i.next();
</code></pre>
<blockquote>
<p>实现了 RandomAccess 接口的类有：ArrayList, AttributeList, CopyOnWriteArrayList,
Vector, Stack 等。</p>
</blockquote>
<h3 id="cloneable"><a class="header" href="#cloneable">Cloneable</a></h3>
<h4 id="浅拷贝"><a class="header" href="#浅拷贝">浅拷贝</a></h4>
<ol>
<li>概述 实现了 Cloneable 接口的对象能进行克隆，Object 实现了先拷贝</li>
</ol>
<pre><code class="language-java">public interface Cloneable {
}
</code></pre>
<p>clon 方法再 Object 类中定义</p>
<pre><code class="language-java">protected native Object clone() throws CloneNotSupportedException;
</code></pre>
<ol start="2">
<li>引例</li>
</ol>
<ul>
<li>这里先定义一个学生</li>
</ul>
<pre><code class="language-java">@Data
@AllArgsConstructor
class Student implements Cloneable{
    String name;
    Address address;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>
<ul>
<li>student2 由 student 浅拷贝得到</li>
</ul>
<pre><code class="language-java">Student student = new Student(&quot;a&quot;, address1);
Student student2 = (Student) student.clone();
</code></pre>
<ul>
<li>student == student2 =&gt; False</li>
<li>student.address == student2.address =&gt; True 两人的地址不同，但是“地址”所指向的地址相同</li>
</ul>
<h4 id="深拷贝"><a class="header" href="#深拷贝">深拷贝</a></h4>
<ol>
<li>实现 Cloneable 接口并重写 Object 类中的 clone() 方法；</li>
</ol>
<ul>
<li>
<p>在上面的例子中想要实现 address 也不相同可以在重写 clone() 加上
<code>stu.addr = (Address)addr.clone();   //深度复制</code></p>
</li>
<li>
<p>缺点：
如果引用类型里面还包含很多引用类型，或者内层引用类型的类里面又包含引用类型，使用 clone 方法就会很麻烦。这时我们可以用序列化的方式来实现对象的深克隆。</p>
</li>
</ul>
<ol start="2">
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li>
</ol>
<ul>
<li>
<p>手动写新的 clone 方法</p>
</li>
<li>
<p>缺点：需要对象及对象所有的对象属性都实现序列化</p>
</li>
<li>
<p>示例</p>
</li>
</ul>
<pre><code class="language-java">public class DeepClone {
    public static void main(String[] args) {
        Inner inner = new Inner();
        Outer outer = new Outer(inner);
        Outer outer1 = outer.myClone();
        System.out.println(outer.inner == outer1.inner); // False
    }
}

@AllArgsConstructor
class Outer implements Serializable {
    private static final long serialVersionUID = 369285298572941L;  //最好是显式声明 ID
    public Inner inner;
    public Outer myClone() {
        Outer outer = null;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(baos);
        oos.writeObject(this);
        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        outer = (Outer) ois.readObject();
        return outer;
    }
}

class Inner implements Serializable {
    private static final long serialVersionUID = 872390113109L; //最好是显式声明 ID
}
</code></pre>
<p>::: tip 注意
注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用 Object 类的 clone 方法克隆对象。让问题在编译的时候暴露出来总是优于把问题留到运行时。
:::</p>
<h3 id="待续-4"><a class="header" href="#待续-4">待续...</a></h3>
<h2 id="函数式接口"><a class="header" href="#函数式接口">函数式接口</a></h2>
<h3 id="概述-4"><a class="header" href="#概述-4">概述</a></h3>
<p><code>@FunctionalInterface</code></p>
<ol>
<li>特征</li>
</ol>
<ul>
<li>该注解只能标记在&quot;有且仅有一个抽象方法&quot;的接口上。</li>
<li>JDK8 接口中的静态方法和默认方法，都不算是抽象方法。</li>
<li>接口默认继承 java.lang.Object，所以如果接口显示声明覆盖了 Object 中方法，那么也不算抽象方法。</li>
<li>该注解不是必须的，如果一个接口符合&quot;函数式接口&quot;定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了 @FunctionInterface，那么编译器会报错。</li>
</ul>
<ol start="2">
<li>示例</li>
</ol>
<pre><code class="language-java">// 正确的函数式接口
@FunctionalInterface
public interface TestInterface {

    // 抽象方法
    public void sub();

    // java.lang.Object 中的方法不是抽象方法
    public boolean equals(Object var1);

    // default 不是抽象方法
    public default void defaultMethod(){}

    // static 不是抽象方法
    public static void staticMethod(){}
}
</code></pre>
<h3 id="consumer"><a class="header" href="#consumer">Consumer</a></h3>
<h4 id="consumer-1"><a class="header" href="#consumer-1">Consumer</a></h4>
<ol>
<li>定义</li>
</ol>
<ul>
<li>它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定</li>
<li>泛型指定什么类型，就可以使用 accept 方法消费什么类型的数据</li>
<li>至于具体怎么消费 (使用)，需要自定义</li>
</ul>
<pre><code class="language-java">@FunctionalInterface
public interface Consumer&lt;T&gt; {

    void accept(T t);

    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&gt; { accept(t); after.accept(t); };
    }
}
</code></pre>
<h4 id="bicomsumer"><a class="header" href="#bicomsumer">BiComsumer</a></h4>
<p>与 Consumer 类似</p>
<pre><code class="language-java">@FunctionalInterface
public interface BiConsumer&lt;T, U&gt; {
    void accept(T t, U u);
default BiConsumer&lt;T, U&gt; andThen(BiConsumer&lt;? super T, ? super U&gt; after) {
    Objects.requireNonNull(after);
    return (l, r) -&gt; {
        accept(l, r);
        after.accept(l, r);
    };
}
</code></pre>
<ol start="2">
<li>示例 Iterable 接口，用法和 Thread 类似</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;1&quot;);
    list.add(&quot;1&quot;);
    Consumer consumer = new Consumer() {
        @Override
        public void accept(Object o) {
            System.out.println(o);
        }
    };
    list.forEach(consumer);
}
</code></pre>
<h3 id="predicate"><a class="header" href="#predicate">Predicate</a></h3>
<ol>
<li>特性</li>
</ol>
<ul>
<li>JDK8 提供的函数式接口</li>
<li>提供一个抽象方法 test，接受一个参数，根据这个参数进行一些判断，返回判断结果 true / false</li>
<li>提供几个默认的 default 方法，and, or, negate 用于进行组合判断</li>
<li>在流中被广泛使用</li>
</ul>
<ol start="2">
<li>定义</li>
</ol>
<pre><code class="language-java">@FunctionalInterface
public interface MyPredict&lt;T&gt; {
    // jdk 1.8

    boolean test(T t);

    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) {
        Objects.requireNonNull(other);
        return (t) -&gt; test(t) &amp;&amp; other.test(t);
    }
    default Predicate&lt;T&gt; negate() {
        return (t) -&gt; !test(t);
    }
    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) {
        Objects.requireNonNull(other);
        return (t) -&gt; test(t) || other.test(t);
    }
    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) {
        return (null == targetRef)
                ? Objects::isNull
                : object -&gt; targetRef.equals(object);
    }
    // jdk 11
    static &lt;T&gt; Predicate&lt;T&gt; not(Predicate&lt;? super T&gt; target) {
        Objects.requireNonNull(target);
        return (Predicate&lt;T&gt;)target.negate();
    }
}
</code></pre>
<ol start="3">
<li>示例</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
    Predicate predicate = &quot;Yes&quot;::equals;   // lambda 表达式
    Predicate predicate2 = o -&gt; !&quot;No&quot;.equals(o);
    System.out.println(predicate.test(&quot;Yes&quot;));
    System.out.println(predicate.and(predicate2).test(&quot;Yes&quot;));;
}
</code></pre>
<h3 id="function"><a class="header" href="#function">Function</a></h3>
<h4 id="function-1"><a class="header" href="#function-1">Function</a></h4>
<ol>
<li>特性 Function 接口的主要作用是将一个给定的对象进行加工，然后返回加工后的对象，这个加工可以是任何操作。</li>
<li>定义</li>
</ol>
<pre><code class="language-java">public interface MyFunction&lt;T, R&gt; {
    R apply(T t);

    default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) {
        Objects.requireNonNull(before);
        return (V v) -&gt; apply(before.apply(v));
    }

    default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&gt; after.apply(apply(t));
    }

    static &lt;T&gt; Function&lt;T, T&gt; identity() {
        return t -&gt; t;
    }

}
</code></pre>
<ol start="3">
<li>示例</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
    Function&lt;String, Integer&gt; f1 = (t) -&gt; Integer.valueOf(t) * 10;
    System.out.println(f1.apply(&quot;3&quot;));
    // 返回自己
    System.out.println(Function.identity().apply(&quot;3&quot;));
    // apply 后执行
    System.out.println(f1.andThen((r) -&gt; String.valueOf(r) + &quot;.....&quot;).apply(&quot;4&quot;));
    // apply 前执行
    System.out.println(f1.compose((String r) -&gt; r.substring(1)).apply(&quot;a5&quot;));
}
</code></pre>
<h4 id="bifunction"><a class="header" href="#bifunction">BiFunction</a></h4>
<pre><code class="language-java">@FunctionalInterface
public interface BiFunction&lt;T, U, R&gt; {
    R apply(T t, U u);
    default &lt;V&gt; BiFunction&lt;T, U, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) {
        Objects.requireNonNull(after);
        return (T t, U u) -&gt; after.apply(apply(t, u));
    }
</code></pre>
<h3 id="unaryoperator"><a class="header" href="#unaryoperator">UnaryOperator</a></h3>
<ol>
<li>定义</li>
</ol>
<pre><code class="language-java">@FunctionalInterface
public interface MyUnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; {
    static &lt;T&gt; UnaryOperator&lt;T&gt; identity() {
        return t -&gt; t;
    }
}
`
</code></pre>
<ol start="2">
<li>示例</li>
</ol>
<pre><code class="language-java">public static void main(String[] args) {
    UnaryOperator&lt;Integer&gt; unaryOperator = x -&gt; x + 1;
    System.out.println(unaryOperator.apply(10)); // 11
    UnaryOperator&lt;String&gt; unaryOperator1 = x -&gt; x + 1;
    System.out.println(unaryOperator1.apply(&quot;aa&quot;)); // aa1
}
</code></pre>
<h3 id="compare"><a class="header" href="#compare">Compare</a></h3>
<h4 id="comparable"><a class="header" href="#comparable">Comparable</a></h4>
<ul>
<li>Comparable 是排序接口。</li>
<li>若一个类实现了 Comparable 接口，就意味着“该类支持排序”。</li>
</ul>
<pre><code class="language-java">public interface Comparable&lt;T&gt; {
        public int compareTo(T o);
}
</code></pre>
<h4 id="comparator"><a class="header" href="#comparator">Comparator</a></h4>
<h5 id="源码"><a class="header" href="#源码">源码</a></h5>
<pre><code class="language-java">@FunctionalInterface
public interface MyComparator&lt;T&gt; {

    // jdk 1.2
    int compare(T o1, T o2);
    boolean equals(Object obj);

    // jdk 1.8
    //default Comparator&lt;T&gt; reversed() {
    //    return Collections.reverseOrder(this);
    //}

    default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) {
        Objects.requireNonNull(other);
        return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; {
            int res = compare(c1, c2);
            return (res != 0) ? res : other.compare(c1, c2);
        };
    }
    default &lt;U&gt; Comparator&lt;T&gt; thenComparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor,
            Comparator&lt;? super U&gt; keyComparator)
    {
        return thenComparing(comparing(keyExtractor, keyComparator));
    }
    default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor)
    {
        return thenComparing(comparing(keyExtractor));
    }

    default Comparator&lt;T&gt; thenComparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) {
        return thenComparing(comparingInt(keyExtractor));
    }
    default Comparator&lt;T&gt; thenComparingLong(ToLongFunction&lt;? super T&gt; keyExtractor) {
        return thenComparing(comparingLong(keyExtractor));
    }
    default Comparator&lt;T&gt; thenComparingDouble(ToDoubleFunction&lt;? super T&gt; keyExtractor) {
        return thenComparing(comparingDouble(keyExtractor));
    }

    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder() {
        return Collections.reverseOrder();
    }
    public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; naturalOrder() {
        return (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;
    }
    public static &lt;T&gt; Comparator&lt;T&gt; nullsFirst(Comparator&lt;? super T&gt; comparator) {
        return new Comparators.NullComparator&lt;&gt;(true, comparator);
    }
    public static &lt;T&gt; Comparator&lt;T&gt; nullsLast(Comparator&lt;? super T&gt; comparator) {
        return new Comparators.NullComparator&lt;&gt;(false, comparator);
    }
    public static &lt;T, U&gt; Comparator&lt;T&gt; comparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor,
            Comparator&lt;? super U&gt; keyComparator)
    {
        Objects.requireNonNull(keyExtractor);
        Objects.requireNonNull(keyComparator);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1),
                        keyExtractor.apply(c2));
    }
    public static &lt;T, U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; comparing(
            Function&lt;? super T, ? extends U&gt; keyExtractor)
    {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));
    }
    public static &lt;T&gt; Comparator&lt;T&gt; comparingInt(ToIntFunction&lt;? super T&gt; keyExtractor) {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));
    }
    public static &lt;T&gt; Comparator&lt;T&gt; comparingLong(ToLongFunction&lt;? super T&gt; keyExtractor) {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; Long.compare(keyExtractor.applyAsLong(c1), keyExtractor.applyAsLong(c2));
    }
    public static&lt;T&gt; Comparator&lt;T&gt; comparingDouble(ToDoubleFunction&lt;? super T&gt; keyExtractor) {
        Objects.requireNonNull(keyExtractor);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; Double.compare(keyExtractor.applyAsDouble(c1), keyExtractor.applyAsDouble(c2));
    }
}
</code></pre>
<h5 id="方法解释"><a class="header" href="#方法解释">方法解释</a></h5>
<ol>
<li>thenComparing</li>
</ol>
<ul>
<li>&amp;是 java8 新语法</li>
</ul>
<pre><code class="language-java">// (Comparator&lt;T&gt; &amp; Serializable) == (Comparator&lt;T&gt;) (Serializable)
default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other) {
    Objects.requireNonNull(other);
    return (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; {
        int res = compare(c1, c2);
        return (res != 0) ? res : other.compare(c1, c2);
    };
}
</code></pre>
<ul>
<li>示例</li>
</ul>
<pre><code class="language-java">public static void main(String[] args) {
    Comparator comparator = new Comparator() {
        @Override
        public int compare(Object o1, Object o2) {
            return (o1 != o2) ? 1 : 0;
        }
    };
    System.out.println(comparator.compare(&quot;111&quot;, &quot;111&quot;));
    System.out.println(comparator.thenComparing((o1, o2) -&gt; (o1 == o2) ? 1 : 0).compare(&quot;111&quot;, &quot;111&quot;));
}
</code></pre>
<ol start="2">
<li>comparing</li>
</ol>
<ul>
<li>利用 Function 先处理再比较</li>
</ul>
<pre><code class="language-java">public static &lt;T, U&gt; Comparator&lt;T&gt; comparing(   Function&lt;? super T, ? extends U&gt; keyExtractor,
                                                Comparator&lt;? super U&gt; keyComparator) {
        Objects.requireNonNull(keyExtractor);
        Objects.requireNonNull(keyComparator);
        return (Comparator&lt;T&gt; &amp; Serializable)
                (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1),
                        keyExtractor.apply(c2));
    }
</code></pre>
<ol start="3">
<li>reverseOrder</li>
</ol>
<ul>
<li>利用 Collections 实现</li>
</ul>
<pre><code class="language-java">public static &lt;T extends Comparable&lt;? super T&gt;&gt; Comparator&lt;T&gt; reverseOrder() {
    return Collections.reverseOrder();
}
</code></pre>
<h3 id="待续-5"><a class="header" href="#待续-5">待续...</a></h3>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<h3 id="object"><a class="header" href="#object">Object</a></h3>
<ol>
<li>概述</li>
</ol>
<ul>
<li>@HotSpotIntrinsicCandidate</li>
<li>自 JDK 9 引入</li>
<li>作用：
被 @HotSpotIntrinsicCandidate 标注的方法，在 HotSpot 中都有一套高效的实现，该高效实现基于 CPU 指令，运行时，HotSpot 维护的高效实现会替代 JDK 的源码实现，从而获得更高的效率。</li>
</ul>
<ol start="2">
<li>源码</li>
</ol>
<pre><code class="language-java">public class MyObject {
    //@HotSpotIntrinsicCandidate
    public Object() {}
    //@HotSpotIntrinsicCandidate
    public final native Class&lt;?&gt; getClass();
    @HotSpotIntrinsicCandidate
    public native int hashCode();
    public boolean equals(Object obj) {
        return (this == obj);
    }
    @HotSpotIntrinsicCandidate
    protected native Object clone() throws CloneNotSupportedException;
    public String toString() {
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    }
    @HotSpotIntrinsicCandidate
    public final native void notify();
    @HotSpotIntrinsicCandidate
    public final native void notifyAll();
    public final void wait() throws InterruptedException {
        wait(0L);
    }
    public final native void wait(long timeoutMillis) throws InterruptedException;
    public final void wait(long timeoutMillis, int nanos) throws InterruptedException {
        if (timeoutMillis &lt; 0) {
            throw new IllegalArgumentException(&quot;timeoutMillis value is negative&quot;);
        }
        if (nanos &lt; 0 || nanos &gt; 999999) {
            throw new IllegalArgumentException(
                    &quot;nanosecond timeout value out of range&quot;);
        }
        if (nanos &gt; 0 &amp;&amp; timeoutMillis &lt; Long.MAX_VALUE) {
            timeoutMillis++;
        }
        wait(timeoutMillis);
    }
    @Deprecated(since=&quot;9&quot;)
    protected void finalize() throws Throwable { }
}
</code></pre>
<h2 id="待续-6"><a class="header" href="#待续-6">待续...</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../../note/java/spring.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../../note/java/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../../note/java/spring.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../../note/java/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
