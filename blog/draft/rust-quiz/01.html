<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Rust Quiz#1 | Trdthg&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://trdthg.github.io//blog/draft/rust-quiz/01"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Rust Quiz#1 | Trdthg&#x27;s blog"><meta data-rh="true" name="description" content="题目"><meta data-rh="true" property="og:description" content="题目"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-10-21T08:15:00.000Z"><link data-rh="true" rel="icon" href="/img/logo_png.png"><link data-rh="true" rel="canonical" href="https://trdthg.github.io//blog/draft/rust-quiz/01"><link data-rh="true" rel="alternate" href="https://trdthg.github.io//blog/draft/rust-quiz/01" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://trdthg.github.io//blog/draft/rust-quiz/01" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Trdthg&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Trdthg&#39;s blog Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4TM86KZ83J"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-4TM86KZ83J",{anonymize_ip:!0})</script><link rel="stylesheet" href="/assets/css/styles.6b28552f.css">
<link rel="preload" href="/assets/js/runtime~main.bfa67ea9.js" as="script">
<link rel="preload" href="/assets/js/main.4ddc18dc.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo_png.png" alt="Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo_png.png" alt="Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Trdthg</b></a><a class="navbar__item navbar__link" href="/docs/intro">文档</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/trdthg" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">全部博文</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/01/03/[译] Rust冒险: 滥用 Serde">[译] Rust冒险: 滥用 Serde</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/01/02/[译] 未初始化内存: unsafe Rust太难了">[译] 未初始化内存: unsafe Rust太难了</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/01/01/[译] 拓展 Rust 中的 Map">[译] 拓展 Rust 中的 Map</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/i3wm">Linux 发行版配置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/resources">资源整理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/site_update_log">网站更新日志</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/DistributedSystem">分布式系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/[译] pkg_mng">Let&#x27;s Dev: A Package Manager</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/test">垃圾软件</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/数据库设计">数据库设计</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/组成原理">计算机组成原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/draft/计算机网络">计算机网络</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/draft/rust-quiz/01">Rust Quiz#1</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/05/04/[译] 可视化 Rust 各数据类型的内存布局">[译] 可视化 Rust 各数据类型的内存布局</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/30/[译] 什么时候不应该使用 Rust ？">[译] 什么时候不应该使用 Rust ？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/20/[译] 使用 Tokio 处理 CPU 密集型任务">[译] 使用 Tokio 处理 CPU 密集型任务</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/13/[译] tail_latency">对重请求 - 应对尾部延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/11/[译] 异步 Rust：协作与抢占式调度">[译] 异步 Rust：协作与抢占式调度</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/README">Rust 六边形架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 1 域">[译] Rust 六边形架构/Rust 六边形架构 1 域</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 2 内存存储库">[译] Rust 六边形架构/Rust 六边形架构 2 内存存储库</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 3 HTTP API">[译] Rust 六边形架构/Rust 六边形架构 3 HTTP API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 4 重构">[译] Rust 六边形架构/Rust 六边形架构 4 重构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 5 其他用例">[译] Rust 六边形架构/Rust 六边形架构 5 其他用例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 6 CLI">[译] Rust 六边形架构/Rust 六边形架构 6 CLI</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/03/[译] Rust 六边形架构/Rust 六边形架构 7 长期存储库">[译] Rust 六边形架构/Rust 六边形架构 7 长期存储库</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2022/04/01/[译] search_engine">查询引擎：推送与拉取</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Rust Quiz#1</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-10-21T08:15:00.000Z" itemprop="datePublished">2022年10月21日</time> · <!-- -->阅读需 7 分钟</div></header><div id="post-content" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="题目">题目<a class="hash-link" href="#题目" title="标题的直接链接">​</a></h2><p>下面的 1 输出是什么？</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">macro_rules! m {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ($( $s:stmt )*) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        $(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            { stringify!($s); 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )&lt;&lt;*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    print!(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;{}{}{}&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m! { return || true },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m! { (return) || true },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m! { {return} || true },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>The program exhibits undefined behavior</li><li>The program does not compile</li><li>The program is guaranteed to output: <!-- -->[ ]</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="解答">解答<a class="hash-link" href="#解答" title="标题的直接链接">​</a></h2><p>122</p><p>这个问题围绕着 Rust 的语法边界设计。</p><blockquote><p>This question revolves around where the Rust grammar places statement
boundaries.</p></blockquote><p>宏的输入规则是 <code>$( $s:stmt )*</code>, 它能够匹配到 0 或多个 Rust 语句。该规则内部的 <code>$s: stmt</code>
是一个片段分类符，它能够匹配到一个符合 Rust 语法规范的表达式。被匹配到的语句可以在展开后的代码中作为 <code>$s</code> 。而外部的 <code>$(...)*</code>
部分表示一个重复，它可以重复匹配 0 或多次内容。</p><blockquote><p>The input rule of the macro m! is $($s:stmt)<em> which matches zero or more Rust
statements. The $(...)</em> part of the rule is a repetition which matches the
contents of the repetition zero or more times, and the $s:stmt is a fragment
specifier that matches a Rust statement (stmt) conforming to the rules of the
Rust grammar. The matched statements are available within the expanded code as
the fragment variable $s.</p></blockquote><p>语句是函数体中允许的最高级别的语法单位。下面所有的内容都是语句的例子。</p><blockquote><p>A statement is the top-level unit of syntax permitted within a function body.
All of the following are examples of statements.</p></blockquote><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Items are statements.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct S { x: u64 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Let-bindings are statements.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let mut s = S { x: 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Expressions are statements.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">s.x + 1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>函数体的语法要求某些类型的语句后面有一个分号，但对于宏的语法而言，分号并不是语句的一部分。</p><blockquote><p>The grammar of function bodies requires that some types of statements are
followed by a semicolon, but the semicolon is not part of the statement for
the purpose of macro syntax.</p></blockquote><p>m! 将会展开为 0 或多个由 <code>&lt;&lt;</code> 分割的 <code>{ stringify!($s); 1 }</code>。<code>$(...)&lt;&lt;*</code> 部分表示重复语句之间使用 <code>&lt;&lt;</code>
作为分隔符</p><blockquote><p>The macro m! expands to zero or more copies of <code>{ stringify!($s); 1 }</code>
separated by the <code>&lt;&lt;</code> token. The <code>$(...)&lt;&lt;*</code> part of the rule is a repetition
using <code>&lt;&lt;</code> as the separator.</p></blockquote><p>在宏中使用 <code>&lt;&lt;</code> 作为分隔符非常不常见。最常用的分隔符是逗号，<code>$(...),*</code>，其他的单一符号也是允许的。重要的是，<code>macro_rules!</code> 把所有的 Rust 内置操作符都当成单 token</p><blockquote><p>Using <code>&lt;&lt;</code> as a separator in a repetition in a macro is highly unusual. The
most commmonly used separator is the comma, written as <code>$(...),*</code>, but any
other single token is allowed here. Crucially, macro_rules! treats all
built-in Rust operators as single tokens, even those that consist of multiple
characters like &lt;&lt;.</p></blockquote><p>The <code>{ stringify!($s); 1 }</code> is an expression whose value is always 1. The value
of <code>stringify!($s)</code> is discarded, so this is equivalent to the expression
<code>{ 1 }</code>. The reason for having <code>stringify!($s)</code> in there is to control the
number of times the repetition is repeated, which is determined by which
fragment variables are used within the repetition. Writing a repetition without
using any fragment variables inside of it would not be legal.</p><p>Suppose we call this macro with three of the statements shown above as input.</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">m! {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct S { x: u64 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let mut s = S { x: 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    s.x + 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The macro expands to:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{ stringify!(struct S { x: u64 }); 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { stringify!(let mut s = S { x: 1 }); 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { stringify!(s.x + 1); 1 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Each of the stringifys expands to a string literal:
2</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">{ &quot;struct S { x: u64 }&quot;; 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { &quot;let mut s = S { x: 1 }&quot;; 1 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;&lt; { &quot;s.x + 1&quot;; 1 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The values of the string literals are not used. In this case the expression is
equivalent to <code>{ 1 } &lt;&lt; { 1 } &lt;&lt; { 1 }</code>, which is equivalent to <code>1 &lt;&lt; 1 &lt;&lt; 1</code>.
The <code>&lt;&lt;</code> operator is left-associative; the numeric value of this expression
is 4.</p><p>Altogether, the relevant behavior of this macro is that it evaluates to
<code>1 &lt;&lt; 1 &lt;&lt; 1 &lt;&lt; ...</code> where the number of ones is equal to the number of Rust
statements in the input of the macro. In closed form, the numeric value is
<code>1 &lt;&lt; (n - 1)</code> where n is the number of statements, except in the case that n is
zero where the macro expands to nothing and we get a syntax error at the call
site.</p><p>It remains to determine how many statements are in the three invocations of m!
in the quiz code.</p><ol><li><code>return || true</code></li></ol><p>This is a return-expression that would return the closure <code>|| true</code>. It is
equivalent to return <code>(|| true)</code>. It is parsed as a single statement so the m!
invocation evaluates to</p><ol start="2"><li><code>(return) || true</code></li></ol><p>This is a logical-OR expression. The <code>||</code> is a binary operator, where the
left-hand side is the expression <code>(return)</code> (of diverging type <code>!</code>) and the
right-hand side is the expression <code>true</code>. This expression is a single statement
so m! again evaluates to 1.</p><ol start="3"><li><code>{return} || true</code></li></ol><p>This one is two statements! A block-statement <code>{return}</code> followed by a closure
expression <code>|| true</code>.</p><p>The Rust grammar distinguishes between expressions that require a semicolon in
order to stand alone as a statement, and expressions that can be statements even
without a semicolon. Consider two examples:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// No trailing semicolon required.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for t in vec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* ... */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Trailing semicolon required.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">self.skip_whitespace()?;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The list of expression types that stand alone without a semicolon is defined
here in libsyntax. The distinction informs a few different early bail-out cases
where the parser decides to finish parsing the current expression.</p><p>Relevant to our case is that block expressions <code>{ /* ... */ }</code> terminate an
expression if doing so would be syntactically sensible. The parser does not
eagerly consume binary operators after a block expression. Thus one might write:</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn f() -&gt; &amp;&#x27;static &amp;&#x27;static bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Block expression.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        println!(&quot;What a silly function.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Reference to reference to true.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &amp;&amp;true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In order to parse a block followed by a binary operator, we would need to make
it syntactically insensible for the parser to terminate an expression at the
close curly brace. This would usually be done by wrapping in parentheses.</p><div class="language-rs codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-rs codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fn f() -&gt; bool {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ({ true } &amp;&amp; true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Anyhow, the output of the program is 112.</p><p>You have answered 2 of 33 questions correctly.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/draft/计算机网络"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">计算机网络</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/2022/05/04/[译] 可视化 Rust 各数据类型的内存布局"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">[译] 可视化 Rust 各数据类型的内存布局</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#题目" class="table-of-contents__link toc-highlight">题目</a></li><li><a href="#解答" class="table-of-contents__link toc-highlight">解答</a></li></ul></div></div></div></div></div></div>
<script src="/assets/js/runtime~main.bfa67ea9.js"></script>
<script src="/assets/js/main.4ddc18dc.js"></script>
</body>
</html>